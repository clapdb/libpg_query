// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: pg_query.fbe
// Version: 1.7.0.0

#include "pg_query_ptr_models.h"

namespace FBE {

FieldModel<::pg_query::Node>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FieldModel<::pg_query::Node>::fbe_body() const noexcept
{
    // variant type's fbe_size not included
    size_t fbe_result = 4;
    return fbe_result;
}

size_t FieldModel<::pg_query::Node>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body();

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::pg_query::Node>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))
        return false;

    uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);
    if (fbe_variant_type < 0 || fbe_variant_type >= 228)
        return false;

    _buffer.shift(fbe_variant_offset);
    switch(fbe_variant_type) {
        case 0: {
            FieldModelPtr_pg_query_Alias fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 1: {
            FieldModelPtr_pg_query_RangeVar fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 2: {
            FieldModelPtr_pg_query_TableFunc fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 3: {
            FieldModelPtr_pg_query_Expr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 4: {
            FieldModelPtr_pg_query_Var fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 5: {
            FieldModelPtr_pg_query_Param fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 6: {
            FieldModelPtr_pg_query_Aggref fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 7: {
            FieldModelPtr_pg_query_GroupingFunc fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 8: {
            FieldModelPtr_pg_query_WindowFunc fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 9: {
            FieldModelPtr_pg_query_SubscriptingRef fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 10: {
            FieldModelPtr_pg_query_FuncExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 11: {
            FieldModelPtr_pg_query_NamedArgExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 12: {
            FieldModelPtr_pg_query_OpExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 13: {
            FieldModelPtr_pg_query_DistinctExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 14: {
            FieldModelPtr_pg_query_NullIfExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 15: {
            FieldModelPtr_pg_query_ScalarArrayOpExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 16: {
            FieldModelPtr_pg_query_BoolExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 17: {
            FieldModelPtr_pg_query_SubLink fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 18: {
            FieldModelPtr_pg_query_SubPlan fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 19: {
            FieldModelPtr_pg_query_AlternativeSubPlan fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 20: {
            FieldModelPtr_pg_query_FieldSelect fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 21: {
            FieldModelPtr_pg_query_FieldStore fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 22: {
            FieldModelPtr_pg_query_RelabelType fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 23: {
            FieldModelPtr_pg_query_CoerceViaIO fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 24: {
            FieldModelPtr_pg_query_ArrayCoerceExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 25: {
            FieldModelPtr_pg_query_ConvertRowtypeExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 26: {
            FieldModelPtr_pg_query_CollateExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 27: {
            FieldModelPtr_pg_query_CaseExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 28: {
            FieldModelPtr_pg_query_CaseWhen fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 29: {
            FieldModelPtr_pg_query_CaseTestExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 30: {
            FieldModelPtr_pg_query_ArrayExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 31: {
            FieldModelPtr_pg_query_RowExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 32: {
            FieldModelPtr_pg_query_RowCompareExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 33: {
            FieldModelPtr_pg_query_CoalesceExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 34: {
            FieldModelPtr_pg_query_MinMaxExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 35: {
            FieldModelPtr_pg_query_SQLValueFunction fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 36: {
            FieldModelPtr_pg_query_XmlExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 37: {
            FieldModelPtr_pg_query_NullTest fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 38: {
            FieldModelPtr_pg_query_BooleanTest fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 39: {
            FieldModelPtr_pg_query_CoerceToDomain fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 40: {
            FieldModelPtr_pg_query_CoerceToDomainValue fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 41: {
            FieldModelPtr_pg_query_SetToDefault fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 42: {
            FieldModelPtr_pg_query_CurrentOfExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 43: {
            FieldModelPtr_pg_query_NextValueExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 44: {
            FieldModelPtr_pg_query_InferenceElem fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 45: {
            FieldModelPtr_pg_query_TargetEntry fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 46: {
            FieldModelPtr_pg_query_RangeTblRef fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 47: {
            FieldModelPtr_pg_query_JoinExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 48: {
            FieldModelPtr_pg_query_FromExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 49: {
            FieldModelPtr_pg_query_OnConflictExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 50: {
            FieldModelPtr_pg_query_IntoClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 51: {
            FieldModelPtr_pg_query_RawStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 52: {
            FieldModelPtr_pg_query_Query fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 53: {
            FieldModelPtr_pg_query_InsertStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 54: {
            FieldModelPtr_pg_query_DeleteStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 55: {
            FieldModelPtr_pg_query_UpdateStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 56: {
            FieldModelPtr_pg_query_SelectStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 57: {
            FieldModelPtr_pg_query_AlterTableStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 58: {
            FieldModelPtr_pg_query_AlterTableCmd fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 59: {
            FieldModelPtr_pg_query_AlterDomainStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 60: {
            FieldModelPtr_pg_query_SetOperationStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 61: {
            FieldModelPtr_pg_query_GrantStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 62: {
            FieldModelPtr_pg_query_GrantRoleStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 63: {
            FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 64: {
            FieldModelPtr_pg_query_ClosePortalStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 65: {
            FieldModelPtr_pg_query_ClusterStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 66: {
            FieldModelPtr_pg_query_CopyStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 67: {
            FieldModelPtr_pg_query_CreateStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 68: {
            FieldModelPtr_pg_query_DefineStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 69: {
            FieldModelPtr_pg_query_DropStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 70: {
            FieldModelPtr_pg_query_TruncateStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 71: {
            FieldModelPtr_pg_query_CommentStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 72: {
            FieldModelPtr_pg_query_FetchStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 73: {
            FieldModelPtr_pg_query_IndexStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 74: {
            FieldModelPtr_pg_query_CreateFunctionStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 75: {
            FieldModelPtr_pg_query_AlterFunctionStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 76: {
            FieldModelPtr_pg_query_DoStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 77: {
            FieldModelPtr_pg_query_RenameStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 78: {
            FieldModelPtr_pg_query_RuleStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 79: {
            FieldModelPtr_pg_query_NotifyStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 80: {
            FieldModelPtr_pg_query_ListenStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 81: {
            FieldModelPtr_pg_query_UnlistenStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 82: {
            FieldModelPtr_pg_query_TransactionStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 83: {
            FieldModelPtr_pg_query_ViewStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 84: {
            FieldModelPtr_pg_query_LoadStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 85: {
            FieldModelPtr_pg_query_CreateDomainStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 86: {
            FieldModelPtr_pg_query_CreatedbStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 87: {
            FieldModelPtr_pg_query_DropdbStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 88: {
            FieldModelPtr_pg_query_VacuumStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 89: {
            FieldModelPtr_pg_query_ExplainStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 90: {
            FieldModelPtr_pg_query_CreateTableAsStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 91: {
            FieldModelPtr_pg_query_CreateSeqStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 92: {
            FieldModelPtr_pg_query_AlterSeqStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 93: {
            FieldModelPtr_pg_query_VariableSetStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 94: {
            FieldModelPtr_pg_query_VariableShowStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 95: {
            FieldModelPtr_pg_query_DiscardStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 96: {
            FieldModelPtr_pg_query_CreateTrigStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 97: {
            FieldModelPtr_pg_query_CreatePLangStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 98: {
            FieldModelPtr_pg_query_CreateRoleStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 99: {
            FieldModelPtr_pg_query_AlterRoleStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 100: {
            FieldModelPtr_pg_query_DropRoleStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 101: {
            FieldModelPtr_pg_query_LockStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 102: {
            FieldModelPtr_pg_query_ConstraintsSetStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 103: {
            FieldModelPtr_pg_query_ReindexStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 104: {
            FieldModelPtr_pg_query_CheckPointStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 105: {
            FieldModelPtr_pg_query_CreateSchemaStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 106: {
            FieldModelPtr_pg_query_AlterDatabaseStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 107: {
            FieldModelPtr_pg_query_AlterDatabaseSetStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 108: {
            FieldModelPtr_pg_query_AlterRoleSetStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 109: {
            FieldModelPtr_pg_query_CreateConversionStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 110: {
            FieldModelPtr_pg_query_CreateCastStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 111: {
            FieldModelPtr_pg_query_CreateOpClassStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 112: {
            FieldModelPtr_pg_query_CreateOpFamilyStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 113: {
            FieldModelPtr_pg_query_AlterOpFamilyStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 114: {
            FieldModelPtr_pg_query_PrepareStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 115: {
            FieldModelPtr_pg_query_ExecuteStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 116: {
            FieldModelPtr_pg_query_DeallocateStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 117: {
            FieldModelPtr_pg_query_DeclareCursorStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 118: {
            FieldModelPtr_pg_query_CreateTableSpaceStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 119: {
            FieldModelPtr_pg_query_DropTableSpaceStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 120: {
            FieldModelPtr_pg_query_AlterObjectDependsStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 121: {
            FieldModelPtr_pg_query_AlterObjectSchemaStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 122: {
            FieldModelPtr_pg_query_AlterOwnerStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 123: {
            FieldModelPtr_pg_query_AlterOperatorStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 124: {
            FieldModelPtr_pg_query_AlterTypeStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 125: {
            FieldModelPtr_pg_query_DropOwnedStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 126: {
            FieldModelPtr_pg_query_ReassignOwnedStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 127: {
            FieldModelPtr_pg_query_CompositeTypeStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 128: {
            FieldModelPtr_pg_query_CreateEnumStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 129: {
            FieldModelPtr_pg_query_CreateRangeStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 130: {
            FieldModelPtr_pg_query_AlterEnumStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 131: {
            FieldModelPtr_pg_query_AlterTSDictionaryStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 132: {
            FieldModelPtr_pg_query_AlterTSConfigurationStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 133: {
            FieldModelPtr_pg_query_CreateFdwStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 134: {
            FieldModelPtr_pg_query_AlterFdwStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 135: {
            FieldModelPtr_pg_query_CreateForeignServerStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 136: {
            FieldModelPtr_pg_query_AlterForeignServerStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 137: {
            FieldModelPtr_pg_query_CreateUserMappingStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 138: {
            FieldModelPtr_pg_query_AlterUserMappingStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 139: {
            FieldModelPtr_pg_query_DropUserMappingStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 140: {
            FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 141: {
            FieldModelPtr_pg_query_AlterTableMoveAllStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 142: {
            FieldModelPtr_pg_query_SecLabelStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 143: {
            FieldModelPtr_pg_query_CreateForeignTableStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 144: {
            FieldModelPtr_pg_query_ImportForeignSchemaStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 145: {
            FieldModelPtr_pg_query_CreateExtensionStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 146: {
            FieldModelPtr_pg_query_AlterExtensionStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 147: {
            FieldModelPtr_pg_query_AlterExtensionContentsStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 148: {
            FieldModelPtr_pg_query_CreateEventTrigStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 149: {
            FieldModelPtr_pg_query_AlterEventTrigStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 150: {
            FieldModelPtr_pg_query_RefreshMatViewStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 151: {
            FieldModelPtr_pg_query_ReplicaIdentityStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 152: {
            FieldModelPtr_pg_query_AlterSystemStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 153: {
            FieldModelPtr_pg_query_CreatePolicyStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 154: {
            FieldModelPtr_pg_query_AlterPolicyStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 155: {
            FieldModelPtr_pg_query_CreateTransformStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 156: {
            FieldModelPtr_pg_query_CreateAmStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 157: {
            FieldModelPtr_pg_query_CreatePublicationStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 158: {
            FieldModelPtr_pg_query_AlterPublicationStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 159: {
            FieldModelPtr_pg_query_CreateSubscriptionStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 160: {
            FieldModelPtr_pg_query_AlterSubscriptionStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 161: {
            FieldModelPtr_pg_query_DropSubscriptionStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 162: {
            FieldModelPtr_pg_query_CreateStatsStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 163: {
            FieldModelPtr_pg_query_AlterCollationStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 164: {
            FieldModelPtr_pg_query_CallStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 165: {
            FieldModelPtr_pg_query_AlterStatsStmt fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 166: {
            FieldModelPtr_pg_query_A_Expr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 167: {
            FieldModelPtr_pg_query_ColumnRef fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 168: {
            FieldModelPtr_pg_query_ParamRef fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 169: {
            FieldModelPtr_pg_query_A_Const fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 170: {
            FieldModelPtr_pg_query_FuncCall fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 171: {
            FieldModelPtr_pg_query_A_Star fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 172: {
            FieldModelPtr_pg_query_A_Indices fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 173: {
            FieldModelPtr_pg_query_A_Indirection fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 174: {
            FieldModelPtr_pg_query_A_ArrayExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 175: {
            FieldModelPtr_pg_query_ResTarget fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 176: {
            FieldModelPtr_pg_query_MultiAssignRef fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 177: {
            FieldModelPtr_pg_query_TypeCast fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 178: {
            FieldModelPtr_pg_query_CollateClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 179: {
            FieldModelPtr_pg_query_SortBy fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 180: {
            FieldModelPtr_pg_query_WindowDef fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 181: {
            FieldModelPtr_pg_query_RangeSubselect fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 182: {
            FieldModelPtr_pg_query_RangeFunction fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 183: {
            FieldModelPtr_pg_query_RangeTableSample fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 184: {
            FieldModelPtr_pg_query_RangeTableFunc fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 185: {
            FieldModelPtr_pg_query_RangeTableFuncCol fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 186: {
            FieldModelPtr_pg_query_TypeName fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 187: {
            FieldModelPtr_pg_query_ColumnDef fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 188: {
            FieldModelPtr_pg_query_IndexElem fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 189: {
            FieldModelPtr_pg_query_Constraint fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 190: {
            FieldModelPtr_pg_query_DefElem fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 191: {
            FieldModelPtr_pg_query_RangeTblEntry fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 192: {
            FieldModelPtr_pg_query_RangeTblFunction fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 193: {
            FieldModelPtr_pg_query_TableSampleClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 194: {
            FieldModelPtr_pg_query_WithCheckOption fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 195: {
            FieldModelPtr_pg_query_SortGroupClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 196: {
            FieldModelPtr_pg_query_GroupingSet fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 197: {
            FieldModelPtr_pg_query_WindowClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 198: {
            FieldModelPtr_pg_query_ObjectWithArgs fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 199: {
            FieldModelPtr_pg_query_AccessPriv fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 200: {
            FieldModelPtr_pg_query_CreateOpClassItem fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 201: {
            FieldModelPtr_pg_query_TableLikeClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 202: {
            FieldModelPtr_pg_query_FunctionParameter fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 203: {
            FieldModelPtr_pg_query_LockingClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 204: {
            FieldModelPtr_pg_query_RowMarkClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 205: {
            FieldModelPtr_pg_query_XmlSerialize fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 206: {
            FieldModelPtr_pg_query_WithClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 207: {
            FieldModelPtr_pg_query_InferClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 208: {
            FieldModelPtr_pg_query_OnConflictClause fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 209: {
            FieldModelPtr_pg_query_CommonTableExpr fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 210: {
            FieldModelPtr_pg_query_RoleSpec fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 211: {
            FieldModelPtr_pg_query_TriggerTransition fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 212: {
            FieldModelPtr_pg_query_PartitionElem fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 213: {
            FieldModelPtr_pg_query_PartitionSpec fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 214: {
            FieldModelPtr_pg_query_PartitionBoundSpec fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 215: {
            FieldModelPtr_pg_query_PartitionRangeDatum fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 216: {
            FieldModelPtr_pg_query_PartitionCmd fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 217: {
            FieldModelPtr_pg_query_VacuumRelation fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 218: {
            FieldModelPtr_pg_query_InlineCodeBlock fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 219: {
            FieldModelPtr_pg_query_CallContext fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 220: {
            FieldModelPtr_pg_query_Integer fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 221: {
            FieldModelPtr_pg_query_Float fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 222: {
            FieldModelPtr_pg_query_String fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 223: {
            FieldModelPtr_pg_query_BitString fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 224: {
            FieldModelPtr_pg_query_Null fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 225: {
            FieldModelPtr_pg_query_List fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 226: {
            FieldModelPtr_pg_query_IntList fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 227: {
            FieldModelPtr_pg_query_OidList fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
    }

    _buffer.unshift(fbe_variant_offset);
    return true;
}

void FieldModel<::pg_query::Node>::get(::pg_query::Node& fbe_value) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))
        return;
    uint32_t vairant_type_index = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);
    assert(vairant_type_index >= 0 && vairant_type_index < 228 && "Model is broken!");

    _buffer.shift(fbe_variant_offset);

    switch(vairant_type_index) {
        case 0: {
            FieldModelPtr_pg_query_Alias fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Alias*>();
            auto& value = std::get<0>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 1: {
            FieldModelPtr_pg_query_RangeVar fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RangeVar*>();
            auto& value = std::get<1>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 2: {
            FieldModelPtr_pg_query_TableFunc fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::TableFunc*>();
            auto& value = std::get<2>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 3: {
            FieldModelPtr_pg_query_Expr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Expr*>();
            auto& value = std::get<3>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 4: {
            FieldModelPtr_pg_query_Var fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Var*>();
            auto& value = std::get<4>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 5: {
            FieldModelPtr_pg_query_Param fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Param*>();
            auto& value = std::get<5>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 6: {
            FieldModelPtr_pg_query_Aggref fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Aggref*>();
            auto& value = std::get<6>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 7: {
            FieldModelPtr_pg_query_GroupingFunc fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::GroupingFunc*>();
            auto& value = std::get<7>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 8: {
            FieldModelPtr_pg_query_WindowFunc fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::WindowFunc*>();
            auto& value = std::get<8>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 9: {
            FieldModelPtr_pg_query_SubscriptingRef fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SubscriptingRef*>();
            auto& value = std::get<9>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 10: {
            FieldModelPtr_pg_query_FuncExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::FuncExpr*>();
            auto& value = std::get<10>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 11: {
            FieldModelPtr_pg_query_NamedArgExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::NamedArgExpr*>();
            auto& value = std::get<11>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 12: {
            FieldModelPtr_pg_query_OpExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::OpExpr*>();
            auto& value = std::get<12>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 13: {
            FieldModelPtr_pg_query_DistinctExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DistinctExpr*>();
            auto& value = std::get<13>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 14: {
            FieldModelPtr_pg_query_NullIfExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::NullIfExpr*>();
            auto& value = std::get<14>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 15: {
            FieldModelPtr_pg_query_ScalarArrayOpExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ScalarArrayOpExpr*>();
            auto& value = std::get<15>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 16: {
            FieldModelPtr_pg_query_BoolExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::BoolExpr*>();
            auto& value = std::get<16>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 17: {
            FieldModelPtr_pg_query_SubLink fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SubLink*>();
            auto& value = std::get<17>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 18: {
            FieldModelPtr_pg_query_SubPlan fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SubPlan*>();
            auto& value = std::get<18>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 19: {
            FieldModelPtr_pg_query_AlternativeSubPlan fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlternativeSubPlan*>();
            auto& value = std::get<19>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 20: {
            FieldModelPtr_pg_query_FieldSelect fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::FieldSelect*>();
            auto& value = std::get<20>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 21: {
            FieldModelPtr_pg_query_FieldStore fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::FieldStore*>();
            auto& value = std::get<21>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 22: {
            FieldModelPtr_pg_query_RelabelType fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RelabelType*>();
            auto& value = std::get<22>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 23: {
            FieldModelPtr_pg_query_CoerceViaIO fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CoerceViaIO*>();
            auto& value = std::get<23>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 24: {
            FieldModelPtr_pg_query_ArrayCoerceExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ArrayCoerceExpr*>();
            auto& value = std::get<24>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 25: {
            FieldModelPtr_pg_query_ConvertRowtypeExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ConvertRowtypeExpr*>();
            auto& value = std::get<25>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 26: {
            FieldModelPtr_pg_query_CollateExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CollateExpr*>();
            auto& value = std::get<26>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 27: {
            FieldModelPtr_pg_query_CaseExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CaseExpr*>();
            auto& value = std::get<27>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 28: {
            FieldModelPtr_pg_query_CaseWhen fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CaseWhen*>();
            auto& value = std::get<28>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 29: {
            FieldModelPtr_pg_query_CaseTestExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CaseTestExpr*>();
            auto& value = std::get<29>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 30: {
            FieldModelPtr_pg_query_ArrayExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ArrayExpr*>();
            auto& value = std::get<30>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 31: {
            FieldModelPtr_pg_query_RowExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RowExpr*>();
            auto& value = std::get<31>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 32: {
            FieldModelPtr_pg_query_RowCompareExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RowCompareExpr*>();
            auto& value = std::get<32>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 33: {
            FieldModelPtr_pg_query_CoalesceExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CoalesceExpr*>();
            auto& value = std::get<33>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 34: {
            FieldModelPtr_pg_query_MinMaxExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::MinMaxExpr*>();
            auto& value = std::get<34>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 35: {
            FieldModelPtr_pg_query_SQLValueFunction fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SQLValueFunction*>();
            auto& value = std::get<35>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 36: {
            FieldModelPtr_pg_query_XmlExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::XmlExpr*>();
            auto& value = std::get<36>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 37: {
            FieldModelPtr_pg_query_NullTest fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::NullTest*>();
            auto& value = std::get<37>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 38: {
            FieldModelPtr_pg_query_BooleanTest fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::BooleanTest*>();
            auto& value = std::get<38>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 39: {
            FieldModelPtr_pg_query_CoerceToDomain fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CoerceToDomain*>();
            auto& value = std::get<39>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 40: {
            FieldModelPtr_pg_query_CoerceToDomainValue fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CoerceToDomainValue*>();
            auto& value = std::get<40>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 41: {
            FieldModelPtr_pg_query_SetToDefault fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SetToDefault*>();
            auto& value = std::get<41>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 42: {
            FieldModelPtr_pg_query_CurrentOfExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CurrentOfExpr*>();
            auto& value = std::get<42>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 43: {
            FieldModelPtr_pg_query_NextValueExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::NextValueExpr*>();
            auto& value = std::get<43>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 44: {
            FieldModelPtr_pg_query_InferenceElem fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::InferenceElem*>();
            auto& value = std::get<44>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 45: {
            FieldModelPtr_pg_query_TargetEntry fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::TargetEntry*>();
            auto& value = std::get<45>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 46: {
            FieldModelPtr_pg_query_RangeTblRef fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RangeTblRef*>();
            auto& value = std::get<46>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 47: {
            FieldModelPtr_pg_query_JoinExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::JoinExpr*>();
            auto& value = std::get<47>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 48: {
            FieldModelPtr_pg_query_FromExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::FromExpr*>();
            auto& value = std::get<48>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 49: {
            FieldModelPtr_pg_query_OnConflictExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::OnConflictExpr*>();
            auto& value = std::get<49>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 50: {
            FieldModelPtr_pg_query_IntoClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::IntoClause*>();
            auto& value = std::get<50>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 51: {
            FieldModelPtr_pg_query_RawStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RawStmt*>();
            auto& value = std::get<51>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 52: {
            FieldModelPtr_pg_query_Query fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Query*>();
            auto& value = std::get<52>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 53: {
            FieldModelPtr_pg_query_InsertStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::InsertStmt*>();
            auto& value = std::get<53>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 54: {
            FieldModelPtr_pg_query_DeleteStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DeleteStmt*>();
            auto& value = std::get<54>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 55: {
            FieldModelPtr_pg_query_UpdateStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::UpdateStmt*>();
            auto& value = std::get<55>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 56: {
            FieldModelPtr_pg_query_SelectStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SelectStmt*>();
            auto& value = std::get<56>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 57: {
            FieldModelPtr_pg_query_AlterTableStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterTableStmt*>();
            auto& value = std::get<57>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 58: {
            FieldModelPtr_pg_query_AlterTableCmd fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterTableCmd*>();
            auto& value = std::get<58>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 59: {
            FieldModelPtr_pg_query_AlterDomainStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterDomainStmt*>();
            auto& value = std::get<59>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 60: {
            FieldModelPtr_pg_query_SetOperationStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SetOperationStmt*>();
            auto& value = std::get<60>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 61: {
            FieldModelPtr_pg_query_GrantStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::GrantStmt*>();
            auto& value = std::get<61>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 62: {
            FieldModelPtr_pg_query_GrantRoleStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::GrantRoleStmt*>();
            auto& value = std::get<62>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 63: {
            FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterDefaultPrivilegesStmt*>();
            auto& value = std::get<63>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 64: {
            FieldModelPtr_pg_query_ClosePortalStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ClosePortalStmt*>();
            auto& value = std::get<64>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 65: {
            FieldModelPtr_pg_query_ClusterStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ClusterStmt*>();
            auto& value = std::get<65>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 66: {
            FieldModelPtr_pg_query_CopyStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CopyStmt*>();
            auto& value = std::get<66>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 67: {
            FieldModelPtr_pg_query_CreateStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateStmt*>();
            auto& value = std::get<67>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 68: {
            FieldModelPtr_pg_query_DefineStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DefineStmt*>();
            auto& value = std::get<68>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 69: {
            FieldModelPtr_pg_query_DropStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DropStmt*>();
            auto& value = std::get<69>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 70: {
            FieldModelPtr_pg_query_TruncateStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::TruncateStmt*>();
            auto& value = std::get<70>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 71: {
            FieldModelPtr_pg_query_CommentStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CommentStmt*>();
            auto& value = std::get<71>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 72: {
            FieldModelPtr_pg_query_FetchStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::FetchStmt*>();
            auto& value = std::get<72>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 73: {
            FieldModelPtr_pg_query_IndexStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::IndexStmt*>();
            auto& value = std::get<73>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 74: {
            FieldModelPtr_pg_query_CreateFunctionStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateFunctionStmt*>();
            auto& value = std::get<74>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 75: {
            FieldModelPtr_pg_query_AlterFunctionStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterFunctionStmt*>();
            auto& value = std::get<75>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 76: {
            FieldModelPtr_pg_query_DoStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DoStmt*>();
            auto& value = std::get<76>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 77: {
            FieldModelPtr_pg_query_RenameStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RenameStmt*>();
            auto& value = std::get<77>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 78: {
            FieldModelPtr_pg_query_RuleStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RuleStmt*>();
            auto& value = std::get<78>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 79: {
            FieldModelPtr_pg_query_NotifyStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::NotifyStmt*>();
            auto& value = std::get<79>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 80: {
            FieldModelPtr_pg_query_ListenStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ListenStmt*>();
            auto& value = std::get<80>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 81: {
            FieldModelPtr_pg_query_UnlistenStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::UnlistenStmt*>();
            auto& value = std::get<81>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 82: {
            FieldModelPtr_pg_query_TransactionStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::TransactionStmt*>();
            auto& value = std::get<82>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 83: {
            FieldModelPtr_pg_query_ViewStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ViewStmt*>();
            auto& value = std::get<83>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 84: {
            FieldModelPtr_pg_query_LoadStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::LoadStmt*>();
            auto& value = std::get<84>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 85: {
            FieldModelPtr_pg_query_CreateDomainStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateDomainStmt*>();
            auto& value = std::get<85>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 86: {
            FieldModelPtr_pg_query_CreatedbStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreatedbStmt*>();
            auto& value = std::get<86>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 87: {
            FieldModelPtr_pg_query_DropdbStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DropdbStmt*>();
            auto& value = std::get<87>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 88: {
            FieldModelPtr_pg_query_VacuumStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::VacuumStmt*>();
            auto& value = std::get<88>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 89: {
            FieldModelPtr_pg_query_ExplainStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ExplainStmt*>();
            auto& value = std::get<89>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 90: {
            FieldModelPtr_pg_query_CreateTableAsStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateTableAsStmt*>();
            auto& value = std::get<90>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 91: {
            FieldModelPtr_pg_query_CreateSeqStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateSeqStmt*>();
            auto& value = std::get<91>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 92: {
            FieldModelPtr_pg_query_AlterSeqStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterSeqStmt*>();
            auto& value = std::get<92>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 93: {
            FieldModelPtr_pg_query_VariableSetStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::VariableSetStmt*>();
            auto& value = std::get<93>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 94: {
            FieldModelPtr_pg_query_VariableShowStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::VariableShowStmt*>();
            auto& value = std::get<94>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 95: {
            FieldModelPtr_pg_query_DiscardStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DiscardStmt*>();
            auto& value = std::get<95>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 96: {
            FieldModelPtr_pg_query_CreateTrigStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateTrigStmt*>();
            auto& value = std::get<96>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 97: {
            FieldModelPtr_pg_query_CreatePLangStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreatePLangStmt*>();
            auto& value = std::get<97>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 98: {
            FieldModelPtr_pg_query_CreateRoleStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateRoleStmt*>();
            auto& value = std::get<98>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 99: {
            FieldModelPtr_pg_query_AlterRoleStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterRoleStmt*>();
            auto& value = std::get<99>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 100: {
            FieldModelPtr_pg_query_DropRoleStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DropRoleStmt*>();
            auto& value = std::get<100>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 101: {
            FieldModelPtr_pg_query_LockStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::LockStmt*>();
            auto& value = std::get<101>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 102: {
            FieldModelPtr_pg_query_ConstraintsSetStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ConstraintsSetStmt*>();
            auto& value = std::get<102>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 103: {
            FieldModelPtr_pg_query_ReindexStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ReindexStmt*>();
            auto& value = std::get<103>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 104: {
            FieldModelPtr_pg_query_CheckPointStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CheckPointStmt*>();
            auto& value = std::get<104>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 105: {
            FieldModelPtr_pg_query_CreateSchemaStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateSchemaStmt*>();
            auto& value = std::get<105>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 106: {
            FieldModelPtr_pg_query_AlterDatabaseStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterDatabaseStmt*>();
            auto& value = std::get<106>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 107: {
            FieldModelPtr_pg_query_AlterDatabaseSetStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterDatabaseSetStmt*>();
            auto& value = std::get<107>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 108: {
            FieldModelPtr_pg_query_AlterRoleSetStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterRoleSetStmt*>();
            auto& value = std::get<108>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 109: {
            FieldModelPtr_pg_query_CreateConversionStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateConversionStmt*>();
            auto& value = std::get<109>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 110: {
            FieldModelPtr_pg_query_CreateCastStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateCastStmt*>();
            auto& value = std::get<110>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 111: {
            FieldModelPtr_pg_query_CreateOpClassStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateOpClassStmt*>();
            auto& value = std::get<111>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 112: {
            FieldModelPtr_pg_query_CreateOpFamilyStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateOpFamilyStmt*>();
            auto& value = std::get<112>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 113: {
            FieldModelPtr_pg_query_AlterOpFamilyStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterOpFamilyStmt*>();
            auto& value = std::get<113>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 114: {
            FieldModelPtr_pg_query_PrepareStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::PrepareStmt*>();
            auto& value = std::get<114>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 115: {
            FieldModelPtr_pg_query_ExecuteStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ExecuteStmt*>();
            auto& value = std::get<115>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 116: {
            FieldModelPtr_pg_query_DeallocateStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DeallocateStmt*>();
            auto& value = std::get<116>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 117: {
            FieldModelPtr_pg_query_DeclareCursorStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DeclareCursorStmt*>();
            auto& value = std::get<117>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 118: {
            FieldModelPtr_pg_query_CreateTableSpaceStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateTableSpaceStmt*>();
            auto& value = std::get<118>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 119: {
            FieldModelPtr_pg_query_DropTableSpaceStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DropTableSpaceStmt*>();
            auto& value = std::get<119>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 120: {
            FieldModelPtr_pg_query_AlterObjectDependsStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterObjectDependsStmt*>();
            auto& value = std::get<120>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 121: {
            FieldModelPtr_pg_query_AlterObjectSchemaStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterObjectSchemaStmt*>();
            auto& value = std::get<121>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 122: {
            FieldModelPtr_pg_query_AlterOwnerStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterOwnerStmt*>();
            auto& value = std::get<122>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 123: {
            FieldModelPtr_pg_query_AlterOperatorStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterOperatorStmt*>();
            auto& value = std::get<123>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 124: {
            FieldModelPtr_pg_query_AlterTypeStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterTypeStmt*>();
            auto& value = std::get<124>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 125: {
            FieldModelPtr_pg_query_DropOwnedStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DropOwnedStmt*>();
            auto& value = std::get<125>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 126: {
            FieldModelPtr_pg_query_ReassignOwnedStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ReassignOwnedStmt*>();
            auto& value = std::get<126>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 127: {
            FieldModelPtr_pg_query_CompositeTypeStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CompositeTypeStmt*>();
            auto& value = std::get<127>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 128: {
            FieldModelPtr_pg_query_CreateEnumStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateEnumStmt*>();
            auto& value = std::get<128>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 129: {
            FieldModelPtr_pg_query_CreateRangeStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateRangeStmt*>();
            auto& value = std::get<129>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 130: {
            FieldModelPtr_pg_query_AlterEnumStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterEnumStmt*>();
            auto& value = std::get<130>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 131: {
            FieldModelPtr_pg_query_AlterTSDictionaryStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterTSDictionaryStmt*>();
            auto& value = std::get<131>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 132: {
            FieldModelPtr_pg_query_AlterTSConfigurationStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterTSConfigurationStmt*>();
            auto& value = std::get<132>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 133: {
            FieldModelPtr_pg_query_CreateFdwStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateFdwStmt*>();
            auto& value = std::get<133>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 134: {
            FieldModelPtr_pg_query_AlterFdwStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterFdwStmt*>();
            auto& value = std::get<134>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 135: {
            FieldModelPtr_pg_query_CreateForeignServerStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateForeignServerStmt*>();
            auto& value = std::get<135>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 136: {
            FieldModelPtr_pg_query_AlterForeignServerStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterForeignServerStmt*>();
            auto& value = std::get<136>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 137: {
            FieldModelPtr_pg_query_CreateUserMappingStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateUserMappingStmt*>();
            auto& value = std::get<137>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 138: {
            FieldModelPtr_pg_query_AlterUserMappingStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterUserMappingStmt*>();
            auto& value = std::get<138>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 139: {
            FieldModelPtr_pg_query_DropUserMappingStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DropUserMappingStmt*>();
            auto& value = std::get<139>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 140: {
            FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterTableSpaceOptionsStmt*>();
            auto& value = std::get<140>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 141: {
            FieldModelPtr_pg_query_AlterTableMoveAllStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterTableMoveAllStmt*>();
            auto& value = std::get<141>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 142: {
            FieldModelPtr_pg_query_SecLabelStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SecLabelStmt*>();
            auto& value = std::get<142>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 143: {
            FieldModelPtr_pg_query_CreateForeignTableStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateForeignTableStmt*>();
            auto& value = std::get<143>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 144: {
            FieldModelPtr_pg_query_ImportForeignSchemaStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ImportForeignSchemaStmt*>();
            auto& value = std::get<144>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 145: {
            FieldModelPtr_pg_query_CreateExtensionStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateExtensionStmt*>();
            auto& value = std::get<145>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 146: {
            FieldModelPtr_pg_query_AlterExtensionStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterExtensionStmt*>();
            auto& value = std::get<146>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 147: {
            FieldModelPtr_pg_query_AlterExtensionContentsStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterExtensionContentsStmt*>();
            auto& value = std::get<147>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 148: {
            FieldModelPtr_pg_query_CreateEventTrigStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateEventTrigStmt*>();
            auto& value = std::get<148>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 149: {
            FieldModelPtr_pg_query_AlterEventTrigStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterEventTrigStmt*>();
            auto& value = std::get<149>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 150: {
            FieldModelPtr_pg_query_RefreshMatViewStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RefreshMatViewStmt*>();
            auto& value = std::get<150>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 151: {
            FieldModelPtr_pg_query_ReplicaIdentityStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ReplicaIdentityStmt*>();
            auto& value = std::get<151>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 152: {
            FieldModelPtr_pg_query_AlterSystemStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterSystemStmt*>();
            auto& value = std::get<152>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 153: {
            FieldModelPtr_pg_query_CreatePolicyStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreatePolicyStmt*>();
            auto& value = std::get<153>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 154: {
            FieldModelPtr_pg_query_AlterPolicyStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterPolicyStmt*>();
            auto& value = std::get<154>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 155: {
            FieldModelPtr_pg_query_CreateTransformStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateTransformStmt*>();
            auto& value = std::get<155>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 156: {
            FieldModelPtr_pg_query_CreateAmStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateAmStmt*>();
            auto& value = std::get<156>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 157: {
            FieldModelPtr_pg_query_CreatePublicationStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreatePublicationStmt*>();
            auto& value = std::get<157>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 158: {
            FieldModelPtr_pg_query_AlterPublicationStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterPublicationStmt*>();
            auto& value = std::get<158>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 159: {
            FieldModelPtr_pg_query_CreateSubscriptionStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateSubscriptionStmt*>();
            auto& value = std::get<159>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 160: {
            FieldModelPtr_pg_query_AlterSubscriptionStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterSubscriptionStmt*>();
            auto& value = std::get<160>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 161: {
            FieldModelPtr_pg_query_DropSubscriptionStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DropSubscriptionStmt*>();
            auto& value = std::get<161>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 162: {
            FieldModelPtr_pg_query_CreateStatsStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateStatsStmt*>();
            auto& value = std::get<162>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 163: {
            FieldModelPtr_pg_query_AlterCollationStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterCollationStmt*>();
            auto& value = std::get<163>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 164: {
            FieldModelPtr_pg_query_CallStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CallStmt*>();
            auto& value = std::get<164>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 165: {
            FieldModelPtr_pg_query_AlterStatsStmt fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AlterStatsStmt*>();
            auto& value = std::get<165>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 166: {
            FieldModelPtr_pg_query_A_Expr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::A_Expr*>();
            auto& value = std::get<166>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 167: {
            FieldModelPtr_pg_query_ColumnRef fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ColumnRef*>();
            auto& value = std::get<167>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 168: {
            FieldModelPtr_pg_query_ParamRef fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ParamRef*>();
            auto& value = std::get<168>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 169: {
            FieldModelPtr_pg_query_A_Const fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::A_Const*>();
            auto& value = std::get<169>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 170: {
            FieldModelPtr_pg_query_FuncCall fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::FuncCall*>();
            auto& value = std::get<170>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 171: {
            FieldModelPtr_pg_query_A_Star fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::A_Star*>();
            auto& value = std::get<171>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 172: {
            FieldModelPtr_pg_query_A_Indices fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::A_Indices*>();
            auto& value = std::get<172>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 173: {
            FieldModelPtr_pg_query_A_Indirection fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::A_Indirection*>();
            auto& value = std::get<173>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 174: {
            FieldModelPtr_pg_query_A_ArrayExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::A_ArrayExpr*>();
            auto& value = std::get<174>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 175: {
            FieldModelPtr_pg_query_ResTarget fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ResTarget*>();
            auto& value = std::get<175>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 176: {
            FieldModelPtr_pg_query_MultiAssignRef fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::MultiAssignRef*>();
            auto& value = std::get<176>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 177: {
            FieldModelPtr_pg_query_TypeCast fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::TypeCast*>();
            auto& value = std::get<177>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 178: {
            FieldModelPtr_pg_query_CollateClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CollateClause*>();
            auto& value = std::get<178>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 179: {
            FieldModelPtr_pg_query_SortBy fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SortBy*>();
            auto& value = std::get<179>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 180: {
            FieldModelPtr_pg_query_WindowDef fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::WindowDef*>();
            auto& value = std::get<180>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 181: {
            FieldModelPtr_pg_query_RangeSubselect fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RangeSubselect*>();
            auto& value = std::get<181>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 182: {
            FieldModelPtr_pg_query_RangeFunction fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RangeFunction*>();
            auto& value = std::get<182>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 183: {
            FieldModelPtr_pg_query_RangeTableSample fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RangeTableSample*>();
            auto& value = std::get<183>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 184: {
            FieldModelPtr_pg_query_RangeTableFunc fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RangeTableFunc*>();
            auto& value = std::get<184>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 185: {
            FieldModelPtr_pg_query_RangeTableFuncCol fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RangeTableFuncCol*>();
            auto& value = std::get<185>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 186: {
            FieldModelPtr_pg_query_TypeName fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::TypeName*>();
            auto& value = std::get<186>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 187: {
            FieldModelPtr_pg_query_ColumnDef fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ColumnDef*>();
            auto& value = std::get<187>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 188: {
            FieldModelPtr_pg_query_IndexElem fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::IndexElem*>();
            auto& value = std::get<188>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 189: {
            FieldModelPtr_pg_query_Constraint fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Constraint*>();
            auto& value = std::get<189>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 190: {
            FieldModelPtr_pg_query_DefElem fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::DefElem*>();
            auto& value = std::get<190>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 191: {
            FieldModelPtr_pg_query_RangeTblEntry fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RangeTblEntry*>();
            auto& value = std::get<191>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 192: {
            FieldModelPtr_pg_query_RangeTblFunction fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RangeTblFunction*>();
            auto& value = std::get<192>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 193: {
            FieldModelPtr_pg_query_TableSampleClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::TableSampleClause*>();
            auto& value = std::get<193>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 194: {
            FieldModelPtr_pg_query_WithCheckOption fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::WithCheckOption*>();
            auto& value = std::get<194>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 195: {
            FieldModelPtr_pg_query_SortGroupClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::SortGroupClause*>();
            auto& value = std::get<195>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 196: {
            FieldModelPtr_pg_query_GroupingSet fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::GroupingSet*>();
            auto& value = std::get<196>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 197: {
            FieldModelPtr_pg_query_WindowClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::WindowClause*>();
            auto& value = std::get<197>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 198: {
            FieldModelPtr_pg_query_ObjectWithArgs fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::ObjectWithArgs*>();
            auto& value = std::get<198>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 199: {
            FieldModelPtr_pg_query_AccessPriv fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::AccessPriv*>();
            auto& value = std::get<199>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 200: {
            FieldModelPtr_pg_query_CreateOpClassItem fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CreateOpClassItem*>();
            auto& value = std::get<200>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 201: {
            FieldModelPtr_pg_query_TableLikeClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::TableLikeClause*>();
            auto& value = std::get<201>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 202: {
            FieldModelPtr_pg_query_FunctionParameter fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::FunctionParameter*>();
            auto& value = std::get<202>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 203: {
            FieldModelPtr_pg_query_LockingClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::LockingClause*>();
            auto& value = std::get<203>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 204: {
            FieldModelPtr_pg_query_RowMarkClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RowMarkClause*>();
            auto& value = std::get<204>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 205: {
            FieldModelPtr_pg_query_XmlSerialize fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::XmlSerialize*>();
            auto& value = std::get<205>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 206: {
            FieldModelPtr_pg_query_WithClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::WithClause*>();
            auto& value = std::get<206>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 207: {
            FieldModelPtr_pg_query_InferClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::InferClause*>();
            auto& value = std::get<207>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 208: {
            FieldModelPtr_pg_query_OnConflictClause fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::OnConflictClause*>();
            auto& value = std::get<208>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 209: {
            FieldModelPtr_pg_query_CommonTableExpr fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CommonTableExpr*>();
            auto& value = std::get<209>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 210: {
            FieldModelPtr_pg_query_RoleSpec fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::RoleSpec*>();
            auto& value = std::get<210>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 211: {
            FieldModelPtr_pg_query_TriggerTransition fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::TriggerTransition*>();
            auto& value = std::get<211>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 212: {
            FieldModelPtr_pg_query_PartitionElem fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::PartitionElem*>();
            auto& value = std::get<212>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 213: {
            FieldModelPtr_pg_query_PartitionSpec fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::PartitionSpec*>();
            auto& value = std::get<213>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 214: {
            FieldModelPtr_pg_query_PartitionBoundSpec fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::PartitionBoundSpec*>();
            auto& value = std::get<214>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 215: {
            FieldModelPtr_pg_query_PartitionRangeDatum fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::PartitionRangeDatum*>();
            auto& value = std::get<215>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 216: {
            FieldModelPtr_pg_query_PartitionCmd fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::PartitionCmd*>();
            auto& value = std::get<216>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 217: {
            FieldModelPtr_pg_query_VacuumRelation fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::VacuumRelation*>();
            auto& value = std::get<217>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 218: {
            FieldModelPtr_pg_query_InlineCodeBlock fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::InlineCodeBlock*>();
            auto& value = std::get<218>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 219: {
            FieldModelPtr_pg_query_CallContext fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::CallContext*>();
            auto& value = std::get<219>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 220: {
            FieldModelPtr_pg_query_Integer fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Integer*>();
            auto& value = std::get<220>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 221: {
            FieldModelPtr_pg_query_Float fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Float*>();
            auto& value = std::get<221>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 222: {
            FieldModelPtr_pg_query_String fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::String*>();
            auto& value = std::get<222>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 223: {
            FieldModelPtr_pg_query_BitString fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::BitString*>();
            auto& value = std::get<223>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 224: {
            FieldModelPtr_pg_query_Null fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::Null*>();
            auto& value = std::get<224>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 225: {
            FieldModelPtr_pg_query_List fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::List*>();
            auto& value = std::get<225>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 226: {
            FieldModelPtr_pg_query_IntList fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::IntList*>();
            auto& value = std::get<226>(fbe_value);
            fbe_model.get(&value);
            break;
        }
        case 227: {
            FieldModelPtr_pg_query_OidList fbe_model(_buffer, 4);
            fbe_value.emplace<::pg_query::OidList*>();
            auto& value = std::get<227>(fbe_value);
            fbe_model.get(&value);
            break;
        }
    }

    _buffer.unshift(fbe_variant_offset);
}

size_t FieldModel<::pg_query::Node>::set_begin(size_t variant_type_fbe_size, size_t variant_type_index)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_variant_size = (uint32_t)(fbe_body() + variant_type_fbe_size);
    uint32_t fbe_variant_offset = (uint32_t)(_buffer.allocate(fbe_variant_size) - _buffer.offset());
    assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_variant_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset, variant_type_index);

    _buffer.shift(fbe_variant_offset);
    return fbe_variant_offset;
}

void FieldModel<::pg_query::Node>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

// Set the variant value
void FieldModel<::pg_query::Node>::set(const ::pg_query::Node& fbe_value) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    std::visit(
        overloaded
        {
            [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Alias* v) {
                FieldModelPtr_pg_query_Alias fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RangeVar* v) {
                FieldModelPtr_pg_query_RangeVar fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::TableFunc* v) {
                FieldModelPtr_pg_query_TableFunc fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Expr* v) {
                FieldModelPtr_pg_query_Expr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Var* v) {
                FieldModelPtr_pg_query_Var fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Param* v) {
                FieldModelPtr_pg_query_Param fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Aggref* v) {
                FieldModelPtr_pg_query_Aggref fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::GroupingFunc* v) {
                FieldModelPtr_pg_query_GroupingFunc fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::WindowFunc* v) {
                FieldModelPtr_pg_query_WindowFunc fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SubscriptingRef* v) {
                FieldModelPtr_pg_query_SubscriptingRef fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::FuncExpr* v) {
                FieldModelPtr_pg_query_FuncExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::NamedArgExpr* v) {
                FieldModelPtr_pg_query_NamedArgExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::OpExpr* v) {
                FieldModelPtr_pg_query_OpExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DistinctExpr* v) {
                FieldModelPtr_pg_query_DistinctExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::NullIfExpr* v) {
                FieldModelPtr_pg_query_NullIfExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ScalarArrayOpExpr* v) {
                FieldModelPtr_pg_query_ScalarArrayOpExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::BoolExpr* v) {
                FieldModelPtr_pg_query_BoolExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SubLink* v) {
                FieldModelPtr_pg_query_SubLink fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SubPlan* v) {
                FieldModelPtr_pg_query_SubPlan fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlternativeSubPlan* v) {
                FieldModelPtr_pg_query_AlternativeSubPlan fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::FieldSelect* v) {
                FieldModelPtr_pg_query_FieldSelect fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::FieldStore* v) {
                FieldModelPtr_pg_query_FieldStore fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RelabelType* v) {
                FieldModelPtr_pg_query_RelabelType fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CoerceViaIO* v) {
                FieldModelPtr_pg_query_CoerceViaIO fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ArrayCoerceExpr* v) {
                FieldModelPtr_pg_query_ArrayCoerceExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ConvertRowtypeExpr* v) {
                FieldModelPtr_pg_query_ConvertRowtypeExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CollateExpr* v) {
                FieldModelPtr_pg_query_CollateExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CaseExpr* v) {
                FieldModelPtr_pg_query_CaseExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CaseWhen* v) {
                FieldModelPtr_pg_query_CaseWhen fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CaseTestExpr* v) {
                FieldModelPtr_pg_query_CaseTestExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ArrayExpr* v) {
                FieldModelPtr_pg_query_ArrayExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RowExpr* v) {
                FieldModelPtr_pg_query_RowExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RowCompareExpr* v) {
                FieldModelPtr_pg_query_RowCompareExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CoalesceExpr* v) {
                FieldModelPtr_pg_query_CoalesceExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::MinMaxExpr* v) {
                FieldModelPtr_pg_query_MinMaxExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SQLValueFunction* v) {
                FieldModelPtr_pg_query_SQLValueFunction fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::XmlExpr* v) {
                FieldModelPtr_pg_query_XmlExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::NullTest* v) {
                FieldModelPtr_pg_query_NullTest fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::BooleanTest* v) {
                FieldModelPtr_pg_query_BooleanTest fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CoerceToDomain* v) {
                FieldModelPtr_pg_query_CoerceToDomain fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CoerceToDomainValue* v) {
                FieldModelPtr_pg_query_CoerceToDomainValue fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SetToDefault* v) {
                FieldModelPtr_pg_query_SetToDefault fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CurrentOfExpr* v) {
                FieldModelPtr_pg_query_CurrentOfExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::NextValueExpr* v) {
                FieldModelPtr_pg_query_NextValueExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::InferenceElem* v) {
                FieldModelPtr_pg_query_InferenceElem fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::TargetEntry* v) {
                FieldModelPtr_pg_query_TargetEntry fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RangeTblRef* v) {
                FieldModelPtr_pg_query_RangeTblRef fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::JoinExpr* v) {
                FieldModelPtr_pg_query_JoinExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::FromExpr* v) {
                FieldModelPtr_pg_query_FromExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::OnConflictExpr* v) {
                FieldModelPtr_pg_query_OnConflictExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::IntoClause* v) {
                FieldModelPtr_pg_query_IntoClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RawStmt* v) {
                FieldModelPtr_pg_query_RawStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Query* v) {
                FieldModelPtr_pg_query_Query fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::InsertStmt* v) {
                FieldModelPtr_pg_query_InsertStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DeleteStmt* v) {
                FieldModelPtr_pg_query_DeleteStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::UpdateStmt* v) {
                FieldModelPtr_pg_query_UpdateStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SelectStmt* v) {
                FieldModelPtr_pg_query_SelectStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterTableStmt* v) {
                FieldModelPtr_pg_query_AlterTableStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterTableCmd* v) {
                FieldModelPtr_pg_query_AlterTableCmd fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterDomainStmt* v) {
                FieldModelPtr_pg_query_AlterDomainStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SetOperationStmt* v) {
                FieldModelPtr_pg_query_SetOperationStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::GrantStmt* v) {
                FieldModelPtr_pg_query_GrantStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::GrantRoleStmt* v) {
                FieldModelPtr_pg_query_GrantRoleStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterDefaultPrivilegesStmt* v) {
                FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ClosePortalStmt* v) {
                FieldModelPtr_pg_query_ClosePortalStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ClusterStmt* v) {
                FieldModelPtr_pg_query_ClusterStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CopyStmt* v) {
                FieldModelPtr_pg_query_CopyStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateStmt* v) {
                FieldModelPtr_pg_query_CreateStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DefineStmt* v) {
                FieldModelPtr_pg_query_DefineStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DropStmt* v) {
                FieldModelPtr_pg_query_DropStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::TruncateStmt* v) {
                FieldModelPtr_pg_query_TruncateStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CommentStmt* v) {
                FieldModelPtr_pg_query_CommentStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::FetchStmt* v) {
                FieldModelPtr_pg_query_FetchStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::IndexStmt* v) {
                FieldModelPtr_pg_query_IndexStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateFunctionStmt* v) {
                FieldModelPtr_pg_query_CreateFunctionStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterFunctionStmt* v) {
                FieldModelPtr_pg_query_AlterFunctionStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DoStmt* v) {
                FieldModelPtr_pg_query_DoStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RenameStmt* v) {
                FieldModelPtr_pg_query_RenameStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RuleStmt* v) {
                FieldModelPtr_pg_query_RuleStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::NotifyStmt* v) {
                FieldModelPtr_pg_query_NotifyStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ListenStmt* v) {
                FieldModelPtr_pg_query_ListenStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::UnlistenStmt* v) {
                FieldModelPtr_pg_query_UnlistenStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::TransactionStmt* v) {
                FieldModelPtr_pg_query_TransactionStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ViewStmt* v) {
                FieldModelPtr_pg_query_ViewStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::LoadStmt* v) {
                FieldModelPtr_pg_query_LoadStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateDomainStmt* v) {
                FieldModelPtr_pg_query_CreateDomainStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreatedbStmt* v) {
                FieldModelPtr_pg_query_CreatedbStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DropdbStmt* v) {
                FieldModelPtr_pg_query_DropdbStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::VacuumStmt* v) {
                FieldModelPtr_pg_query_VacuumStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ExplainStmt* v) {
                FieldModelPtr_pg_query_ExplainStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateTableAsStmt* v) {
                FieldModelPtr_pg_query_CreateTableAsStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateSeqStmt* v) {
                FieldModelPtr_pg_query_CreateSeqStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterSeqStmt* v) {
                FieldModelPtr_pg_query_AlterSeqStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::VariableSetStmt* v) {
                FieldModelPtr_pg_query_VariableSetStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::VariableShowStmt* v) {
                FieldModelPtr_pg_query_VariableShowStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DiscardStmt* v) {
                FieldModelPtr_pg_query_DiscardStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateTrigStmt* v) {
                FieldModelPtr_pg_query_CreateTrigStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreatePLangStmt* v) {
                FieldModelPtr_pg_query_CreatePLangStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateRoleStmt* v) {
                FieldModelPtr_pg_query_CreateRoleStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterRoleStmt* v) {
                FieldModelPtr_pg_query_AlterRoleStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DropRoleStmt* v) {
                FieldModelPtr_pg_query_DropRoleStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::LockStmt* v) {
                FieldModelPtr_pg_query_LockStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ConstraintsSetStmt* v) {
                FieldModelPtr_pg_query_ConstraintsSetStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ReindexStmt* v) {
                FieldModelPtr_pg_query_ReindexStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CheckPointStmt* v) {
                FieldModelPtr_pg_query_CheckPointStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateSchemaStmt* v) {
                FieldModelPtr_pg_query_CreateSchemaStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterDatabaseStmt* v) {
                FieldModelPtr_pg_query_AlterDatabaseStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterDatabaseSetStmt* v) {
                FieldModelPtr_pg_query_AlterDatabaseSetStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterRoleSetStmt* v) {
                FieldModelPtr_pg_query_AlterRoleSetStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateConversionStmt* v) {
                FieldModelPtr_pg_query_CreateConversionStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateCastStmt* v) {
                FieldModelPtr_pg_query_CreateCastStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateOpClassStmt* v) {
                FieldModelPtr_pg_query_CreateOpClassStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateOpFamilyStmt* v) {
                FieldModelPtr_pg_query_CreateOpFamilyStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterOpFamilyStmt* v) {
                FieldModelPtr_pg_query_AlterOpFamilyStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::PrepareStmt* v) {
                FieldModelPtr_pg_query_PrepareStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ExecuteStmt* v) {
                FieldModelPtr_pg_query_ExecuteStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DeallocateStmt* v) {
                FieldModelPtr_pg_query_DeallocateStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DeclareCursorStmt* v) {
                FieldModelPtr_pg_query_DeclareCursorStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateTableSpaceStmt* v) {
                FieldModelPtr_pg_query_CreateTableSpaceStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DropTableSpaceStmt* v) {
                FieldModelPtr_pg_query_DropTableSpaceStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterObjectDependsStmt* v) {
                FieldModelPtr_pg_query_AlterObjectDependsStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterObjectSchemaStmt* v) {
                FieldModelPtr_pg_query_AlterObjectSchemaStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterOwnerStmt* v) {
                FieldModelPtr_pg_query_AlterOwnerStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterOperatorStmt* v) {
                FieldModelPtr_pg_query_AlterOperatorStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterTypeStmt* v) {
                FieldModelPtr_pg_query_AlterTypeStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DropOwnedStmt* v) {
                FieldModelPtr_pg_query_DropOwnedStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ReassignOwnedStmt* v) {
                FieldModelPtr_pg_query_ReassignOwnedStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CompositeTypeStmt* v) {
                FieldModelPtr_pg_query_CompositeTypeStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateEnumStmt* v) {
                FieldModelPtr_pg_query_CreateEnumStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateRangeStmt* v) {
                FieldModelPtr_pg_query_CreateRangeStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterEnumStmt* v) {
                FieldModelPtr_pg_query_AlterEnumStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterTSDictionaryStmt* v) {
                FieldModelPtr_pg_query_AlterTSDictionaryStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterTSConfigurationStmt* v) {
                FieldModelPtr_pg_query_AlterTSConfigurationStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateFdwStmt* v) {
                FieldModelPtr_pg_query_CreateFdwStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterFdwStmt* v) {
                FieldModelPtr_pg_query_AlterFdwStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateForeignServerStmt* v) {
                FieldModelPtr_pg_query_CreateForeignServerStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterForeignServerStmt* v) {
                FieldModelPtr_pg_query_AlterForeignServerStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateUserMappingStmt* v) {
                FieldModelPtr_pg_query_CreateUserMappingStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterUserMappingStmt* v) {
                FieldModelPtr_pg_query_AlterUserMappingStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DropUserMappingStmt* v) {
                FieldModelPtr_pg_query_DropUserMappingStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterTableSpaceOptionsStmt* v) {
                FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterTableMoveAllStmt* v) {
                FieldModelPtr_pg_query_AlterTableMoveAllStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SecLabelStmt* v) {
                FieldModelPtr_pg_query_SecLabelStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateForeignTableStmt* v) {
                FieldModelPtr_pg_query_CreateForeignTableStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ImportForeignSchemaStmt* v) {
                FieldModelPtr_pg_query_ImportForeignSchemaStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateExtensionStmt* v) {
                FieldModelPtr_pg_query_CreateExtensionStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterExtensionStmt* v) {
                FieldModelPtr_pg_query_AlterExtensionStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterExtensionContentsStmt* v) {
                FieldModelPtr_pg_query_AlterExtensionContentsStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateEventTrigStmt* v) {
                FieldModelPtr_pg_query_CreateEventTrigStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterEventTrigStmt* v) {
                FieldModelPtr_pg_query_AlterEventTrigStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RefreshMatViewStmt* v) {
                FieldModelPtr_pg_query_RefreshMatViewStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ReplicaIdentityStmt* v) {
                FieldModelPtr_pg_query_ReplicaIdentityStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterSystemStmt* v) {
                FieldModelPtr_pg_query_AlterSystemStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreatePolicyStmt* v) {
                FieldModelPtr_pg_query_CreatePolicyStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterPolicyStmt* v) {
                FieldModelPtr_pg_query_AlterPolicyStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateTransformStmt* v) {
                FieldModelPtr_pg_query_CreateTransformStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateAmStmt* v) {
                FieldModelPtr_pg_query_CreateAmStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreatePublicationStmt* v) {
                FieldModelPtr_pg_query_CreatePublicationStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterPublicationStmt* v) {
                FieldModelPtr_pg_query_AlterPublicationStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateSubscriptionStmt* v) {
                FieldModelPtr_pg_query_CreateSubscriptionStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterSubscriptionStmt* v) {
                FieldModelPtr_pg_query_AlterSubscriptionStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DropSubscriptionStmt* v) {
                FieldModelPtr_pg_query_DropSubscriptionStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateStatsStmt* v) {
                FieldModelPtr_pg_query_CreateStatsStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterCollationStmt* v) {
                FieldModelPtr_pg_query_AlterCollationStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CallStmt* v) {
                FieldModelPtr_pg_query_CallStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AlterStatsStmt* v) {
                FieldModelPtr_pg_query_AlterStatsStmt fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::A_Expr* v) {
                FieldModelPtr_pg_query_A_Expr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ColumnRef* v) {
                FieldModelPtr_pg_query_ColumnRef fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ParamRef* v) {
                FieldModelPtr_pg_query_ParamRef fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::A_Const* v) {
                FieldModelPtr_pg_query_A_Const fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::FuncCall* v) {
                FieldModelPtr_pg_query_FuncCall fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::A_Star* v) {
                FieldModelPtr_pg_query_A_Star fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::A_Indices* v) {
                FieldModelPtr_pg_query_A_Indices fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::A_Indirection* v) {
                FieldModelPtr_pg_query_A_Indirection fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::A_ArrayExpr* v) {
                FieldModelPtr_pg_query_A_ArrayExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ResTarget* v) {
                FieldModelPtr_pg_query_ResTarget fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::MultiAssignRef* v) {
                FieldModelPtr_pg_query_MultiAssignRef fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::TypeCast* v) {
                FieldModelPtr_pg_query_TypeCast fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CollateClause* v) {
                FieldModelPtr_pg_query_CollateClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SortBy* v) {
                FieldModelPtr_pg_query_SortBy fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::WindowDef* v) {
                FieldModelPtr_pg_query_WindowDef fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RangeSubselect* v) {
                FieldModelPtr_pg_query_RangeSubselect fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RangeFunction* v) {
                FieldModelPtr_pg_query_RangeFunction fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RangeTableSample* v) {
                FieldModelPtr_pg_query_RangeTableSample fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RangeTableFunc* v) {
                FieldModelPtr_pg_query_RangeTableFunc fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RangeTableFuncCol* v) {
                FieldModelPtr_pg_query_RangeTableFuncCol fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::TypeName* v) {
                FieldModelPtr_pg_query_TypeName fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ColumnDef* v) {
                FieldModelPtr_pg_query_ColumnDef fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::IndexElem* v) {
                FieldModelPtr_pg_query_IndexElem fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Constraint* v) {
                FieldModelPtr_pg_query_Constraint fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::DefElem* v) {
                FieldModelPtr_pg_query_DefElem fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RangeTblEntry* v) {
                FieldModelPtr_pg_query_RangeTblEntry fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RangeTblFunction* v) {
                FieldModelPtr_pg_query_RangeTblFunction fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::TableSampleClause* v) {
                FieldModelPtr_pg_query_TableSampleClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::WithCheckOption* v) {
                FieldModelPtr_pg_query_WithCheckOption fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::SortGroupClause* v) {
                FieldModelPtr_pg_query_SortGroupClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::GroupingSet* v) {
                FieldModelPtr_pg_query_GroupingSet fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::WindowClause* v) {
                FieldModelPtr_pg_query_WindowClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::ObjectWithArgs* v) {
                FieldModelPtr_pg_query_ObjectWithArgs fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::AccessPriv* v) {
                FieldModelPtr_pg_query_AccessPriv fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CreateOpClassItem* v) {
                FieldModelPtr_pg_query_CreateOpClassItem fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::TableLikeClause* v) {
                FieldModelPtr_pg_query_TableLikeClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::FunctionParameter* v) {
                FieldModelPtr_pg_query_FunctionParameter fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::LockingClause* v) {
                FieldModelPtr_pg_query_LockingClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RowMarkClause* v) {
                FieldModelPtr_pg_query_RowMarkClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::XmlSerialize* v) {
                FieldModelPtr_pg_query_XmlSerialize fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::WithClause* v) {
                FieldModelPtr_pg_query_WithClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::InferClause* v) {
                FieldModelPtr_pg_query_InferClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::OnConflictClause* v) {
                FieldModelPtr_pg_query_OnConflictClause fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CommonTableExpr* v) {
                FieldModelPtr_pg_query_CommonTableExpr fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::RoleSpec* v) {
                FieldModelPtr_pg_query_RoleSpec fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::TriggerTransition* v) {
                FieldModelPtr_pg_query_TriggerTransition fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::PartitionElem* v) {
                FieldModelPtr_pg_query_PartitionElem fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::PartitionSpec* v) {
                FieldModelPtr_pg_query_PartitionSpec fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::PartitionBoundSpec* v) {
                FieldModelPtr_pg_query_PartitionBoundSpec fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::PartitionRangeDatum* v) {
                FieldModelPtr_pg_query_PartitionRangeDatum fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::PartitionCmd* v) {
                FieldModelPtr_pg_query_PartitionCmd fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::VacuumRelation* v) {
                FieldModelPtr_pg_query_VacuumRelation fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::InlineCodeBlock* v) {
                FieldModelPtr_pg_query_InlineCodeBlock fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::CallContext* v) {
                FieldModelPtr_pg_query_CallContext fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Integer* v) {
                FieldModelPtr_pg_query_Integer fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Float* v) {
                FieldModelPtr_pg_query_Float fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::String* v) {
                FieldModelPtr_pg_query_String fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::BitString* v) {
                FieldModelPtr_pg_query_BitString fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::Null* v) {
                FieldModelPtr_pg_query_Null fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::List* v) {
                FieldModelPtr_pg_query_List fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::IntList* v) {
                FieldModelPtr_pg_query_IntList fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index()](const ::pg_query::OidList* v) {
                FieldModelPtr_pg_query_OidList fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v);
                set_end(fbe_begin);
            }
        },
        fbe_value
    );
}


FieldModelPtr_pg_query_Integer::FieldModelPtr_pg_query_Integer(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Integer::~FieldModelPtr_pg_query_Integer()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Integer::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Integer::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Integer::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Integer::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Integer::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Integer::get(::pg_query::Integer** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Integer(_buffer, 0);

    ::pg_query::Integer *tempModel = new ::pg_query::Integer();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Integer::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Integer::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Integer::set(const ::pg_query::Integer* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Integer(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Integer::FieldModel_pg_query_Integer(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , ival(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_Integer::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + ival.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Integer::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + ival.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Integer::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Integer::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + ival.fbe_size()) > fbe_struct_size)
        return true;
    if (!ival.verify())
        return false;
    fbe_current_size += ival.fbe_size();

    return true;
}

size_t FieldModel_pg_query_Integer::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Integer::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Integer::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Integer::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::Integer& fbe_value = static_cast<::pg_query::Integer&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + ival.fbe_size()) <= fbe_struct_size)
        {
            ival.get(fbe_value.ival);
        }
    else
        fbe_value.ival = (int32_t)0ll;
    fbe_current_size += ival.fbe_size();
}

size_t FieldModel_pg_query_Integer::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Integer::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Integer::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Integer::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Integer& fbe_value = static_cast<const ::pg_query::Integer&>(base_fbe_value);
    ival.set(fbe_value.ival);
}

namespace pg_query {

bool IntegerModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t IntegerModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t IntegerModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t IntegerModel::serialize(const ::pg_query::Integer& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t IntegerModel::deserialize(::pg_query::Integer& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_Float::FieldModelPtr_pg_query_Float(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Float::~FieldModelPtr_pg_query_Float()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Float::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Float::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Float::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Float::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Float::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Float::get(::pg_query::Float** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Float(_buffer, 0);

    ::pg_query::Float *tempModel = new ::pg_query::Float();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Float::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Float::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Float::set(const ::pg_query::Float* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Float(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Float::FieldModel_pg_query_Float(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , str(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_Float::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + str.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Float::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + str.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Float::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Float::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + str.fbe_size()) > fbe_struct_size)
        return true;
    if (!str.verify())
        return false;
    fbe_current_size += str.fbe_size();

    return true;
}

size_t FieldModel_pg_query_Float::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Float::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Float::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Float::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::Float& fbe_value = static_cast<::pg_query::Float&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + str.fbe_size()) <= fbe_struct_size)
        {
            str.get(fbe_value.str);
        }
    else
        fbe_value.str = "";
    fbe_current_size += str.fbe_size();
}

size_t FieldModel_pg_query_Float::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Float::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Float::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Float::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Float& fbe_value = static_cast<const ::pg_query::Float&>(base_fbe_value);
    str.set(fbe_value.str);
}

namespace pg_query {

bool FloatModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t FloatModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t FloatModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t FloatModel::serialize(const ::pg_query::Float& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t FloatModel::deserialize(::pg_query::Float& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_String::FieldModelPtr_pg_query_String(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_String::~FieldModelPtr_pg_query_String()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_String::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_String::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_String::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_String::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_String::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_String::get(::pg_query::String** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_String(_buffer, 0);

    ::pg_query::String *tempModel = new ::pg_query::String();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_String::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_String::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_String::set(const ::pg_query::String* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_String(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_String::FieldModel_pg_query_String(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , str(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_String::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + str.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_String::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + str.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_String::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_String::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + str.fbe_size()) > fbe_struct_size)
        return true;
    if (!str.verify())
        return false;
    fbe_current_size += str.fbe_size();

    return true;
}

size_t FieldModel_pg_query_String::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_String::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_String::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_String::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::String& fbe_value = static_cast<::pg_query::String&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + str.fbe_size()) <= fbe_struct_size)
        {
            str.get(fbe_value.str);
        }
    else
        fbe_value.str = "";
    fbe_current_size += str.fbe_size();
}

size_t FieldModel_pg_query_String::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_String::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_String::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_String::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::String& fbe_value = static_cast<const ::pg_query::String&>(base_fbe_value);
    str.set(fbe_value.str);
}

namespace pg_query {

bool StringModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StringModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StringModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StringModel::serialize(const ::pg_query::String& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StringModel::deserialize(::pg_query::String& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_BitString::FieldModelPtr_pg_query_BitString(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_BitString::~FieldModelPtr_pg_query_BitString()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_BitString::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_BitString::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_BitString::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_BitString::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_BitString::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_BitString::get(::pg_query::BitString** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_BitString(_buffer, 0);

    ::pg_query::BitString *tempModel = new ::pg_query::BitString();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_BitString::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_BitString::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_BitString::set(const ::pg_query::BitString* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_BitString(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_BitString::FieldModel_pg_query_BitString(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , str(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_BitString::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + str.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_BitString::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + str.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_BitString::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_BitString::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + str.fbe_size()) > fbe_struct_size)
        return true;
    if (!str.verify())
        return false;
    fbe_current_size += str.fbe_size();

    return true;
}

size_t FieldModel_pg_query_BitString::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_BitString::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_BitString::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_BitString::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::BitString& fbe_value = static_cast<::pg_query::BitString&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + str.fbe_size()) <= fbe_struct_size)
        {
            str.get(fbe_value.str);
        }
    else
        fbe_value.str = "";
    fbe_current_size += str.fbe_size();
}

size_t FieldModel_pg_query_BitString::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_BitString::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_BitString::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_BitString::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::BitString& fbe_value = static_cast<const ::pg_query::BitString&>(base_fbe_value);
    str.set(fbe_value.str);
}

namespace pg_query {

bool BitStringModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t BitStringModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t BitStringModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t BitStringModel::serialize(const ::pg_query::BitString& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t BitStringModel::deserialize(::pg_query::BitString& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_Null::FieldModelPtr_pg_query_Null(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Null::~FieldModelPtr_pg_query_Null()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Null::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Null::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Null::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Null::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Null::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Null::get(::pg_query::Null** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Null(_buffer, 0);

    ::pg_query::Null *tempModel = new ::pg_query::Null();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Null::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Null::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Null::set(const ::pg_query::Null* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Null(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Null::FieldModel_pg_query_Null(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FieldModel_pg_query_Null::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Null::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Null::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Null::verify_fields(size_t fbe_struct_size) const noexcept
{
    return true;
}

size_t FieldModel_pg_query_Null::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Null::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Null::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Null::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
}

size_t FieldModel_pg_query_Null::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Null::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Null::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Null::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Null& fbe_value = static_cast<const ::pg_query::Null&>(base_fbe_value);
}

namespace pg_query {

bool NullModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t NullModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t NullModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t NullModel::serialize(const ::pg_query::Null& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t NullModel::deserialize(::pg_query::Null& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_List::FieldModelPtr_pg_query_List(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_List::~FieldModelPtr_pg_query_List()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_List::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_List::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_List::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_List::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_List::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_List::get(::pg_query::List** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_List(_buffer, 0);

    ::pg_query::List *tempModel = new ::pg_query::List();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_List::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_List::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_List::set(const ::pg_query::List* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_List(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_List::FieldModel_pg_query_List(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , items(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_List::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + items.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_List::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + items.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_List::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_List::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + items.fbe_size()) > fbe_struct_size)
        return true;
    if (!items.verify())
        return false;
    fbe_current_size += items.fbe_size();

    return true;
}

size_t FieldModel_pg_query_List::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_List::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_List::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_List::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::List& fbe_value = static_cast<::pg_query::List&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + items.fbe_size()) <= fbe_struct_size)
        {
            items.get(fbe_value.items);
        }
    else
        fbe_value.items.clear();
    fbe_current_size += items.fbe_size();
}

size_t FieldModel_pg_query_List::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_List::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_List::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_List::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::List& fbe_value = static_cast<const ::pg_query::List&>(base_fbe_value);
    items.set(fbe_value.items);
}

namespace pg_query {

bool ListModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ListModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ListModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ListModel::serialize(const ::pg_query::List& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ListModel::deserialize(::pg_query::List& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_OidList::FieldModelPtr_pg_query_OidList(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_OidList::~FieldModelPtr_pg_query_OidList()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_OidList::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_OidList::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_OidList::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_OidList::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_OidList::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_OidList::get(::pg_query::OidList** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_OidList(_buffer, 0);

    ::pg_query::OidList *tempModel = new ::pg_query::OidList();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_OidList::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_OidList::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_OidList::set(const ::pg_query::OidList* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_OidList(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_OidList::FieldModel_pg_query_OidList(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , items(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_OidList::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + items.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_OidList::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + items.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_OidList::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_OidList::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + items.fbe_size()) > fbe_struct_size)
        return true;
    if (!items.verify())
        return false;
    fbe_current_size += items.fbe_size();

    return true;
}

size_t FieldModel_pg_query_OidList::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_OidList::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_OidList::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_OidList::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::OidList& fbe_value = static_cast<::pg_query::OidList&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + items.fbe_size()) <= fbe_struct_size)
        {
            items.get(fbe_value.items);
        }
    else
        fbe_value.items.clear();
    fbe_current_size += items.fbe_size();
}

size_t FieldModel_pg_query_OidList::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_OidList::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_OidList::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_OidList::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::OidList& fbe_value = static_cast<const ::pg_query::OidList&>(base_fbe_value);
    items.set(fbe_value.items);
}

namespace pg_query {

bool OidListModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t OidListModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t OidListModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t OidListModel::serialize(const ::pg_query::OidList& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t OidListModel::deserialize(::pg_query::OidList& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_IntList::FieldModelPtr_pg_query_IntList(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_IntList::~FieldModelPtr_pg_query_IntList()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_IntList::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_IntList::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_IntList::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_IntList::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_IntList::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_IntList::get(::pg_query::IntList** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_IntList(_buffer, 0);

    ::pg_query::IntList *tempModel = new ::pg_query::IntList();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_IntList::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_IntList::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_IntList::set(const ::pg_query::IntList* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_IntList(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_IntList::FieldModel_pg_query_IntList(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , items(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_IntList::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + items.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_IntList::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + items.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_IntList::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_IntList::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + items.fbe_size()) > fbe_struct_size)
        return true;
    if (!items.verify())
        return false;
    fbe_current_size += items.fbe_size();

    return true;
}

size_t FieldModel_pg_query_IntList::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_IntList::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_IntList::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_IntList::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::IntList& fbe_value = static_cast<::pg_query::IntList&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + items.fbe_size()) <= fbe_struct_size)
        {
            items.get(fbe_value.items);
        }
    else
        fbe_value.items.clear();
    fbe_current_size += items.fbe_size();
}

size_t FieldModel_pg_query_IntList::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_IntList::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_IntList::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_IntList::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::IntList& fbe_value = static_cast<const ::pg_query::IntList&>(base_fbe_value);
    items.set(fbe_value.items);
}

namespace pg_query {

bool IntListModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t IntListModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t IntListModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t IntListModel::serialize(const ::pg_query::IntList& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t IntListModel::deserialize(::pg_query::IntList& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_Alias::FieldModelPtr_pg_query_Alias(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Alias::~FieldModelPtr_pg_query_Alias()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Alias::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Alias::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Alias::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Alias::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Alias::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Alias::get(::pg_query::Alias** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Alias(_buffer, 0);

    ::pg_query::Alias *tempModel = new ::pg_query::Alias();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Alias::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Alias::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Alias::set(const ::pg_query::Alias* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Alias(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Alias::FieldModel_pg_query_Alias(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , aliasname(buffer, 4 + 4)
    , colnames(buffer, aliasname.fbe_offset() + aliasname.fbe_size())
{}

size_t FieldModel_pg_query_Alias::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + aliasname.fbe_size()
        + colnames.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Alias::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + aliasname.fbe_extra()
        + colnames.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Alias::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Alias::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + aliasname.fbe_size()) > fbe_struct_size)
        return true;
    if (!aliasname.verify())
        return false;
    fbe_current_size += aliasname.fbe_size();

    if ((fbe_current_size + colnames.fbe_size()) > fbe_struct_size)
        return true;
    if (!colnames.verify())
        return false;
    fbe_current_size += colnames.fbe_size();

    return true;
}

size_t FieldModel_pg_query_Alias::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Alias::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Alias::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Alias::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::Alias& fbe_value = static_cast<::pg_query::Alias&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + aliasname.fbe_size()) <= fbe_struct_size)
        {
            aliasname.get(fbe_value.aliasname);
        }
    else
        fbe_value.aliasname = "";
    fbe_current_size += aliasname.fbe_size();

    if ((fbe_current_size + colnames.fbe_size()) <= fbe_struct_size)
        {
            colnames.get(fbe_value.colnames);
        }
    else
        fbe_value.colnames.clear();
    fbe_current_size += colnames.fbe_size();
}

size_t FieldModel_pg_query_Alias::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Alias::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Alias::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Alias::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Alias& fbe_value = static_cast<const ::pg_query::Alias&>(base_fbe_value);
    aliasname.set(fbe_value.aliasname);
    colnames.set(fbe_value.colnames);
}

namespace pg_query {

bool AliasModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AliasModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AliasModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AliasModel::serialize(const ::pg_query::Alias& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AliasModel::deserialize(::pg_query::Alias& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RangeVar::FieldModelPtr_pg_query_RangeVar(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RangeVar::~FieldModelPtr_pg_query_RangeVar()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RangeVar::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeVar::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeVar::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RangeVar::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeVar::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeVar::get(::pg_query::RangeVar** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RangeVar(_buffer, 0);

    ::pg_query::RangeVar *tempModel = new ::pg_query::RangeVar();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RangeVar::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeVar::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeVar::set(const ::pg_query::RangeVar* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RangeVar(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RangeVar::FieldModel_pg_query_RangeVar(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , catalogname(buffer, 4 + 4)
    , schemaname(buffer, catalogname.fbe_offset() + catalogname.fbe_size())
    , relname(buffer, schemaname.fbe_offset() + schemaname.fbe_size())
    , inh(buffer, relname.fbe_offset() + relname.fbe_size())
    , relpersistence(buffer, inh.fbe_offset() + inh.fbe_size())
    , alias(buffer, relpersistence.fbe_offset() + relpersistence.fbe_size())
    , location(buffer, alias.fbe_offset() + alias.fbe_size())
{}

size_t FieldModel_pg_query_RangeVar::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + catalogname.fbe_size()
        + schemaname.fbe_size()
        + relname.fbe_size()
        + inh.fbe_size()
        + relpersistence.fbe_size()
        + alias.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RangeVar::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + catalogname.fbe_extra()
        + schemaname.fbe_extra()
        + relname.fbe_extra()
        + inh.fbe_extra()
        + relpersistence.fbe_extra()
        + alias.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RangeVar::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RangeVar::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + catalogname.fbe_size()) > fbe_struct_size)
        return true;
    if (!catalogname.verify())
        return false;
    fbe_current_size += catalogname.fbe_size();

    if ((fbe_current_size + schemaname.fbe_size()) > fbe_struct_size)
        return true;
    if (!schemaname.verify())
        return false;
    fbe_current_size += schemaname.fbe_size();

    if ((fbe_current_size + relname.fbe_size()) > fbe_struct_size)
        return true;
    if (!relname.verify())
        return false;
    fbe_current_size += relname.fbe_size();

    if ((fbe_current_size + inh.fbe_size()) > fbe_struct_size)
        return true;
    if (!inh.verify())
        return false;
    fbe_current_size += inh.fbe_size();

    if ((fbe_current_size + relpersistence.fbe_size()) > fbe_struct_size)
        return true;
    if (!relpersistence.verify())
        return false;
    fbe_current_size += relpersistence.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) > fbe_struct_size)
        return true;
    if (!alias.verify())
        return false;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RangeVar::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeVar::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeVar::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RangeVar::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RangeVar& fbe_value = static_cast<::pg_query::RangeVar&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + catalogname.fbe_size()) <= fbe_struct_size)
        {
            catalogname.get(fbe_value.catalogname);
        }
    else
        fbe_value.catalogname = "";
    fbe_current_size += catalogname.fbe_size();

    if ((fbe_current_size + schemaname.fbe_size()) <= fbe_struct_size)
        {
            schemaname.get(fbe_value.schemaname);
        }
    else
        fbe_value.schemaname = "";
    fbe_current_size += schemaname.fbe_size();

    if ((fbe_current_size + relname.fbe_size()) <= fbe_struct_size)
        {
            relname.get(fbe_value.relname);
        }
    else
        fbe_value.relname = "";
    fbe_current_size += relname.fbe_size();

    if ((fbe_current_size + inh.fbe_size()) <= fbe_struct_size)
        {
            inh.get(fbe_value.inh);
        }
    else
        fbe_value.inh = false;
    fbe_current_size += inh.fbe_size();

    if ((fbe_current_size + relpersistence.fbe_size()) <= fbe_struct_size)
        {
            relpersistence.get(fbe_value.relpersistence);
        }
    else
        fbe_value.relpersistence = "";
    fbe_current_size += relpersistence.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) <= fbe_struct_size)
        {
            alias.get(&fbe_value.alias);
        }
    else
        fbe_value.alias = nullptr;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_RangeVar::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeVar::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeVar::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RangeVar::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RangeVar& fbe_value = static_cast<const ::pg_query::RangeVar&>(base_fbe_value);
    catalogname.set(fbe_value.catalogname);
    schemaname.set(fbe_value.schemaname);
    relname.set(fbe_value.relname);
    inh.set(fbe_value.inh);
    relpersistence.set(fbe_value.relpersistence);
    alias.set(fbe_value.alias);
    location.set(fbe_value.location);
}

namespace pg_query {

bool RangeVarModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RangeVarModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RangeVarModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RangeVarModel::serialize(const ::pg_query::RangeVar& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RangeVarModel::deserialize(::pg_query::RangeVar& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_TableFunc::FieldModelPtr_pg_query_TableFunc(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_TableFunc::~FieldModelPtr_pg_query_TableFunc()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_TableFunc::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_TableFunc::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_TableFunc::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_TableFunc::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TableFunc::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TableFunc::get(::pg_query::TableFunc** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_TableFunc(_buffer, 0);

    ::pg_query::TableFunc *tempModel = new ::pg_query::TableFunc();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_TableFunc::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TableFunc::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TableFunc::set(const ::pg_query::TableFunc* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_TableFunc(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_TableFunc::FieldModel_pg_query_TableFunc(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , ns_uris(buffer, 4 + 4)
    , ns_names(buffer, ns_uris.fbe_offset() + ns_uris.fbe_size())
    , docexpr(buffer, ns_names.fbe_offset() + ns_names.fbe_size())
    , rowexpr(buffer, docexpr.fbe_offset() + docexpr.fbe_size())
    , colnames(buffer, rowexpr.fbe_offset() + rowexpr.fbe_size())
    , coltypes(buffer, colnames.fbe_offset() + colnames.fbe_size())
    , coltypmods(buffer, coltypes.fbe_offset() + coltypes.fbe_size())
    , colcollations(buffer, coltypmods.fbe_offset() + coltypmods.fbe_size())
    , colexprs(buffer, colcollations.fbe_offset() + colcollations.fbe_size())
    , coldefexprs(buffer, colexprs.fbe_offset() + colexprs.fbe_size())
    , notnulls(buffer, coldefexprs.fbe_offset() + coldefexprs.fbe_size())
    , ordinalitycol(buffer, notnulls.fbe_offset() + notnulls.fbe_size())
    , location(buffer, ordinalitycol.fbe_offset() + ordinalitycol.fbe_size())
{}

size_t FieldModel_pg_query_TableFunc::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + ns_uris.fbe_size()
        + ns_names.fbe_size()
        + docexpr.fbe_size()
        + rowexpr.fbe_size()
        + colnames.fbe_size()
        + coltypes.fbe_size()
        + coltypmods.fbe_size()
        + colcollations.fbe_size()
        + colexprs.fbe_size()
        + coldefexprs.fbe_size()
        + notnulls.fbe_size()
        + ordinalitycol.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_TableFunc::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + ns_uris.fbe_extra()
        + ns_names.fbe_extra()
        + docexpr.fbe_extra()
        + rowexpr.fbe_extra()
        + colnames.fbe_extra()
        + coltypes.fbe_extra()
        + coltypmods.fbe_extra()
        + colcollations.fbe_extra()
        + colexprs.fbe_extra()
        + coldefexprs.fbe_extra()
        + notnulls.fbe_extra()
        + ordinalitycol.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_TableFunc::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_TableFunc::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + ns_uris.fbe_size()) > fbe_struct_size)
        return true;
    if (!ns_uris.verify())
        return false;
    fbe_current_size += ns_uris.fbe_size();

    if ((fbe_current_size + ns_names.fbe_size()) > fbe_struct_size)
        return true;
    if (!ns_names.verify())
        return false;
    fbe_current_size += ns_names.fbe_size();

    if ((fbe_current_size + docexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!docexpr.verify())
        return false;
    fbe_current_size += docexpr.fbe_size();

    if ((fbe_current_size + rowexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!rowexpr.verify())
        return false;
    fbe_current_size += rowexpr.fbe_size();

    if ((fbe_current_size + colnames.fbe_size()) > fbe_struct_size)
        return true;
    if (!colnames.verify())
        return false;
    fbe_current_size += colnames.fbe_size();

    if ((fbe_current_size + coltypes.fbe_size()) > fbe_struct_size)
        return true;
    if (!coltypes.verify())
        return false;
    fbe_current_size += coltypes.fbe_size();

    if ((fbe_current_size + coltypmods.fbe_size()) > fbe_struct_size)
        return true;
    if (!coltypmods.verify())
        return false;
    fbe_current_size += coltypmods.fbe_size();

    if ((fbe_current_size + colcollations.fbe_size()) > fbe_struct_size)
        return true;
    if (!colcollations.verify())
        return false;
    fbe_current_size += colcollations.fbe_size();

    if ((fbe_current_size + colexprs.fbe_size()) > fbe_struct_size)
        return true;
    if (!colexprs.verify())
        return false;
    fbe_current_size += colexprs.fbe_size();

    if ((fbe_current_size + coldefexprs.fbe_size()) > fbe_struct_size)
        return true;
    if (!coldefexprs.verify())
        return false;
    fbe_current_size += coldefexprs.fbe_size();

    if ((fbe_current_size + notnulls.fbe_size()) > fbe_struct_size)
        return true;
    if (!notnulls.verify())
        return false;
    fbe_current_size += notnulls.fbe_size();

    if ((fbe_current_size + ordinalitycol.fbe_size()) > fbe_struct_size)
        return true;
    if (!ordinalitycol.verify())
        return false;
    fbe_current_size += ordinalitycol.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_TableFunc::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TableFunc::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TableFunc::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_TableFunc::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::TableFunc& fbe_value = static_cast<::pg_query::TableFunc&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + ns_uris.fbe_size()) <= fbe_struct_size)
        {
            ns_uris.get(fbe_value.ns_uris);
        }
    else
        fbe_value.ns_uris.clear();
    fbe_current_size += ns_uris.fbe_size();

    if ((fbe_current_size + ns_names.fbe_size()) <= fbe_struct_size)
        {
            ns_names.get(fbe_value.ns_names);
        }
    else
        fbe_value.ns_names.clear();
    fbe_current_size += ns_names.fbe_size();

    if ((fbe_current_size + docexpr.fbe_size()) <= fbe_struct_size)
        {
            docexpr.get(fbe_value.docexpr);
        }
    else
        fbe_value.docexpr = ::pg_query::Node();
    fbe_current_size += docexpr.fbe_size();

    if ((fbe_current_size + rowexpr.fbe_size()) <= fbe_struct_size)
        {
            rowexpr.get(fbe_value.rowexpr);
        }
    else
        fbe_value.rowexpr = ::pg_query::Node();
    fbe_current_size += rowexpr.fbe_size();

    if ((fbe_current_size + colnames.fbe_size()) <= fbe_struct_size)
        {
            colnames.get(fbe_value.colnames);
        }
    else
        fbe_value.colnames.clear();
    fbe_current_size += colnames.fbe_size();

    if ((fbe_current_size + coltypes.fbe_size()) <= fbe_struct_size)
        {
            coltypes.get(fbe_value.coltypes);
        }
    else
        fbe_value.coltypes.clear();
    fbe_current_size += coltypes.fbe_size();

    if ((fbe_current_size + coltypmods.fbe_size()) <= fbe_struct_size)
        {
            coltypmods.get(fbe_value.coltypmods);
        }
    else
        fbe_value.coltypmods.clear();
    fbe_current_size += coltypmods.fbe_size();

    if ((fbe_current_size + colcollations.fbe_size()) <= fbe_struct_size)
        {
            colcollations.get(fbe_value.colcollations);
        }
    else
        fbe_value.colcollations.clear();
    fbe_current_size += colcollations.fbe_size();

    if ((fbe_current_size + colexprs.fbe_size()) <= fbe_struct_size)
        {
            colexprs.get(fbe_value.colexprs);
        }
    else
        fbe_value.colexprs.clear();
    fbe_current_size += colexprs.fbe_size();

    if ((fbe_current_size + coldefexprs.fbe_size()) <= fbe_struct_size)
        {
            coldefexprs.get(fbe_value.coldefexprs);
        }
    else
        fbe_value.coldefexprs.clear();
    fbe_current_size += coldefexprs.fbe_size();

    if ((fbe_current_size + notnulls.fbe_size()) <= fbe_struct_size)
        {
            notnulls.get(fbe_value.notnulls);
        }
    else
        fbe_value.notnulls.clear();
    fbe_current_size += notnulls.fbe_size();

    if ((fbe_current_size + ordinalitycol.fbe_size()) <= fbe_struct_size)
        {
            ordinalitycol.get(fbe_value.ordinalitycol);
        }
    else
        fbe_value.ordinalitycol = (int32_t)0ll;
    fbe_current_size += ordinalitycol.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_TableFunc::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TableFunc::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TableFunc::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_TableFunc::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::TableFunc& fbe_value = static_cast<const ::pg_query::TableFunc&>(base_fbe_value);
    ns_uris.set(fbe_value.ns_uris);
    ns_names.set(fbe_value.ns_names);
    docexpr.set(fbe_value.docexpr);
    rowexpr.set(fbe_value.rowexpr);
    colnames.set(fbe_value.colnames);
    coltypes.set(fbe_value.coltypes);
    coltypmods.set(fbe_value.coltypmods);
    colcollations.set(fbe_value.colcollations);
    colexprs.set(fbe_value.colexprs);
    coldefexprs.set(fbe_value.coldefexprs);
    notnulls.set(fbe_value.notnulls);
    ordinalitycol.set(fbe_value.ordinalitycol);
    location.set(fbe_value.location);
}

namespace pg_query {

bool TableFuncModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TableFuncModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TableFuncModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TableFuncModel::serialize(const ::pg_query::TableFunc& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TableFuncModel::deserialize(::pg_query::TableFunc& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_Expr::FieldModelPtr_pg_query_Expr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Expr::~FieldModelPtr_pg_query_Expr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Expr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Expr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Expr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Expr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Expr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Expr::get(::pg_query::Expr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Expr(_buffer, 0);

    ::pg_query::Expr *tempModel = new ::pg_query::Expr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Expr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Expr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Expr::set(const ::pg_query::Expr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Expr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Expr::FieldModel_pg_query_Expr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FieldModel_pg_query_Expr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Expr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Expr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Expr::verify_fields(size_t fbe_struct_size) const noexcept
{
    return true;
}

size_t FieldModel_pg_query_Expr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Expr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Expr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Expr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
}

size_t FieldModel_pg_query_Expr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Expr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Expr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Expr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Expr& fbe_value = static_cast<const ::pg_query::Expr&>(base_fbe_value);
}

namespace pg_query {

bool ExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ExprModel::serialize(const ::pg_query::Expr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ExprModel::deserialize(::pg_query::Expr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_Var::FieldModelPtr_pg_query_Var(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Var::~FieldModelPtr_pg_query_Var()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Var::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Var::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Var::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Var::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Var::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Var::get(::pg_query::Var** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Var(_buffer, 0);

    ::pg_query::Var *tempModel = new ::pg_query::Var();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Var::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Var::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Var::set(const ::pg_query::Var* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Var(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Var::FieldModel_pg_query_Var(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , varno(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , varattno(buffer, varno.fbe_offset() + varno.fbe_size())
    , vartype(buffer, varattno.fbe_offset() + varattno.fbe_size())
    , vartypmod(buffer, vartype.fbe_offset() + vartype.fbe_size())
    , varcollid(buffer, vartypmod.fbe_offset() + vartypmod.fbe_size())
    , varlevelsup(buffer, varcollid.fbe_offset() + varcollid.fbe_size())
    , varnosyn(buffer, varlevelsup.fbe_offset() + varlevelsup.fbe_size())
    , varattnosyn(buffer, varnosyn.fbe_offset() + varnosyn.fbe_size())
    , location(buffer, varattnosyn.fbe_offset() + varattnosyn.fbe_size())
{}

size_t FieldModel_pg_query_Var::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + varno.fbe_size()
        + varattno.fbe_size()
        + vartype.fbe_size()
        + vartypmod.fbe_size()
        + varcollid.fbe_size()
        + varlevelsup.fbe_size()
        + varnosyn.fbe_size()
        + varattnosyn.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Var::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + varno.fbe_extra()
        + varattno.fbe_extra()
        + vartype.fbe_extra()
        + vartypmod.fbe_extra()
        + varcollid.fbe_extra()
        + varlevelsup.fbe_extra()
        + varnosyn.fbe_extra()
        + varattnosyn.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Var::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Var::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + varno.fbe_size()) > fbe_struct_size)
        return true;
    if (!varno.verify())
        return false;
    fbe_current_size += varno.fbe_size();

    if ((fbe_current_size + varattno.fbe_size()) > fbe_struct_size)
        return true;
    if (!varattno.verify())
        return false;
    fbe_current_size += varattno.fbe_size();

    if ((fbe_current_size + vartype.fbe_size()) > fbe_struct_size)
        return true;
    if (!vartype.verify())
        return false;
    fbe_current_size += vartype.fbe_size();

    if ((fbe_current_size + vartypmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!vartypmod.verify())
        return false;
    fbe_current_size += vartypmod.fbe_size();

    if ((fbe_current_size + varcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!varcollid.verify())
        return false;
    fbe_current_size += varcollid.fbe_size();

    if ((fbe_current_size + varlevelsup.fbe_size()) > fbe_struct_size)
        return true;
    if (!varlevelsup.verify())
        return false;
    fbe_current_size += varlevelsup.fbe_size();

    if ((fbe_current_size + varnosyn.fbe_size()) > fbe_struct_size)
        return true;
    if (!varnosyn.verify())
        return false;
    fbe_current_size += varnosyn.fbe_size();

    if ((fbe_current_size + varattnosyn.fbe_size()) > fbe_struct_size)
        return true;
    if (!varattnosyn.verify())
        return false;
    fbe_current_size += varattnosyn.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_Var::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Var::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Var::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Var::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::Var& fbe_value = static_cast<::pg_query::Var&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + varno.fbe_size()) <= fbe_struct_size)
        {
            varno.get(fbe_value.varno);
        }
    else
        fbe_value.varno = (uint32_t)0ull;
    fbe_current_size += varno.fbe_size();

    if ((fbe_current_size + varattno.fbe_size()) <= fbe_struct_size)
        {
            varattno.get(fbe_value.varattno);
        }
    else
        fbe_value.varattno = (int32_t)0ll;
    fbe_current_size += varattno.fbe_size();

    if ((fbe_current_size + vartype.fbe_size()) <= fbe_struct_size)
        {
            vartype.get(fbe_value.vartype);
        }
    else
        fbe_value.vartype = (uint32_t)0ull;
    fbe_current_size += vartype.fbe_size();

    if ((fbe_current_size + vartypmod.fbe_size()) <= fbe_struct_size)
        {
            vartypmod.get(fbe_value.vartypmod);
        }
    else
        fbe_value.vartypmod = (int32_t)0ll;
    fbe_current_size += vartypmod.fbe_size();

    if ((fbe_current_size + varcollid.fbe_size()) <= fbe_struct_size)
        {
            varcollid.get(fbe_value.varcollid);
        }
    else
        fbe_value.varcollid = (uint32_t)0ull;
    fbe_current_size += varcollid.fbe_size();

    if ((fbe_current_size + varlevelsup.fbe_size()) <= fbe_struct_size)
        {
            varlevelsup.get(fbe_value.varlevelsup);
        }
    else
        fbe_value.varlevelsup = (uint32_t)0ull;
    fbe_current_size += varlevelsup.fbe_size();

    if ((fbe_current_size + varnosyn.fbe_size()) <= fbe_struct_size)
        {
            varnosyn.get(fbe_value.varnosyn);
        }
    else
        fbe_value.varnosyn = (uint32_t)0ull;
    fbe_current_size += varnosyn.fbe_size();

    if ((fbe_current_size + varattnosyn.fbe_size()) <= fbe_struct_size)
        {
            varattnosyn.get(fbe_value.varattnosyn);
        }
    else
        fbe_value.varattnosyn = (int32_t)0ll;
    fbe_current_size += varattnosyn.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_Var::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Var::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Var::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Var::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Var& fbe_value = static_cast<const ::pg_query::Var&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    varno.set(fbe_value.varno);
    varattno.set(fbe_value.varattno);
    vartype.set(fbe_value.vartype);
    vartypmod.set(fbe_value.vartypmod);
    varcollid.set(fbe_value.varcollid);
    varlevelsup.set(fbe_value.varlevelsup);
    varnosyn.set(fbe_value.varnosyn);
    varattnosyn.set(fbe_value.varattnosyn);
    location.set(fbe_value.location);
}

namespace pg_query {

bool VarModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t VarModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t VarModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t VarModel::serialize(const ::pg_query::Var& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t VarModel::deserialize(::pg_query::Var& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_Param::FieldModelPtr_pg_query_Param(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Param::~FieldModelPtr_pg_query_Param()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Param::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Param::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Param::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Param::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Param::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Param::get(::pg_query::Param** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Param(_buffer, 0);

    ::pg_query::Param *tempModel = new ::pg_query::Param();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Param::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Param::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Param::set(const ::pg_query::Param* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Param(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Param::FieldModel_pg_query_Param(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , paramkind(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , paramid(buffer, paramkind.fbe_offset() + paramkind.fbe_size())
    , paramtype(buffer, paramid.fbe_offset() + paramid.fbe_size())
    , paramtypmod(buffer, paramtype.fbe_offset() + paramtype.fbe_size())
    , paramcollid(buffer, paramtypmod.fbe_offset() + paramtypmod.fbe_size())
    , location(buffer, paramcollid.fbe_offset() + paramcollid.fbe_size())
{}

size_t FieldModel_pg_query_Param::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + paramkind.fbe_size()
        + paramid.fbe_size()
        + paramtype.fbe_size()
        + paramtypmod.fbe_size()
        + paramcollid.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Param::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + paramkind.fbe_extra()
        + paramid.fbe_extra()
        + paramtype.fbe_extra()
        + paramtypmod.fbe_extra()
        + paramcollid.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Param::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Param::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + paramkind.fbe_size()) > fbe_struct_size)
        return true;
    if (!paramkind.verify())
        return false;
    fbe_current_size += paramkind.fbe_size();

    if ((fbe_current_size + paramid.fbe_size()) > fbe_struct_size)
        return true;
    if (!paramid.verify())
        return false;
    fbe_current_size += paramid.fbe_size();

    if ((fbe_current_size + paramtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!paramtype.verify())
        return false;
    fbe_current_size += paramtype.fbe_size();

    if ((fbe_current_size + paramtypmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!paramtypmod.verify())
        return false;
    fbe_current_size += paramtypmod.fbe_size();

    if ((fbe_current_size + paramcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!paramcollid.verify())
        return false;
    fbe_current_size += paramcollid.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_Param::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Param::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Param::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Param::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::Param& fbe_value = static_cast<::pg_query::Param&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + paramkind.fbe_size()) <= fbe_struct_size)
        {
            paramkind.get(fbe_value.paramkind);
        }
    else
        fbe_value.paramkind = ::pg_query::ParamKind();
    fbe_current_size += paramkind.fbe_size();

    if ((fbe_current_size + paramid.fbe_size()) <= fbe_struct_size)
        {
            paramid.get(fbe_value.paramid);
        }
    else
        fbe_value.paramid = (int32_t)0ll;
    fbe_current_size += paramid.fbe_size();

    if ((fbe_current_size + paramtype.fbe_size()) <= fbe_struct_size)
        {
            paramtype.get(fbe_value.paramtype);
        }
    else
        fbe_value.paramtype = (uint32_t)0ull;
    fbe_current_size += paramtype.fbe_size();

    if ((fbe_current_size + paramtypmod.fbe_size()) <= fbe_struct_size)
        {
            paramtypmod.get(fbe_value.paramtypmod);
        }
    else
        fbe_value.paramtypmod = (int32_t)0ll;
    fbe_current_size += paramtypmod.fbe_size();

    if ((fbe_current_size + paramcollid.fbe_size()) <= fbe_struct_size)
        {
            paramcollid.get(fbe_value.paramcollid);
        }
    else
        fbe_value.paramcollid = (uint32_t)0ull;
    fbe_current_size += paramcollid.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_Param::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Param::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Param::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Param::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Param& fbe_value = static_cast<const ::pg_query::Param&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    paramkind.set(fbe_value.paramkind);
    paramid.set(fbe_value.paramid);
    paramtype.set(fbe_value.paramtype);
    paramtypmod.set(fbe_value.paramtypmod);
    paramcollid.set(fbe_value.paramcollid);
    location.set(fbe_value.location);
}

namespace pg_query {

bool ParamModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ParamModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ParamModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ParamModel::serialize(const ::pg_query::Param& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ParamModel::deserialize(::pg_query::Param& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_Aggref::FieldModelPtr_pg_query_Aggref(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Aggref::~FieldModelPtr_pg_query_Aggref()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Aggref::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Aggref::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Aggref::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Aggref::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Aggref::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Aggref::get(::pg_query::Aggref** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Aggref(_buffer, 0);

    ::pg_query::Aggref *tempModel = new ::pg_query::Aggref();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Aggref::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Aggref::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Aggref::set(const ::pg_query::Aggref* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Aggref(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Aggref::FieldModel_pg_query_Aggref(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , aggfnoid(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , aggtype(buffer, aggfnoid.fbe_offset() + aggfnoid.fbe_size())
    , aggcollid(buffer, aggtype.fbe_offset() + aggtype.fbe_size())
    , inputcollid(buffer, aggcollid.fbe_offset() + aggcollid.fbe_size())
    , aggtranstype(buffer, inputcollid.fbe_offset() + inputcollid.fbe_size())
    , aggargtypes(buffer, aggtranstype.fbe_offset() + aggtranstype.fbe_size())
    , aggdirectargs(buffer, aggargtypes.fbe_offset() + aggargtypes.fbe_size())
    , args(buffer, aggdirectargs.fbe_offset() + aggdirectargs.fbe_size())
    , aggorder(buffer, args.fbe_offset() + args.fbe_size())
    , aggdistinct(buffer, aggorder.fbe_offset() + aggorder.fbe_size())
    , aggfilter(buffer, aggdistinct.fbe_offset() + aggdistinct.fbe_size())
    , aggstar(buffer, aggfilter.fbe_offset() + aggfilter.fbe_size())
    , aggvariadic(buffer, aggstar.fbe_offset() + aggstar.fbe_size())
    , aggkind(buffer, aggvariadic.fbe_offset() + aggvariadic.fbe_size())
    , agglevelsup(buffer, aggkind.fbe_offset() + aggkind.fbe_size())
    , aggsplit(buffer, agglevelsup.fbe_offset() + agglevelsup.fbe_size())
    , location(buffer, aggsplit.fbe_offset() + aggsplit.fbe_size())
{}

size_t FieldModel_pg_query_Aggref::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + aggfnoid.fbe_size()
        + aggtype.fbe_size()
        + aggcollid.fbe_size()
        + inputcollid.fbe_size()
        + aggtranstype.fbe_size()
        + aggargtypes.fbe_size()
        + aggdirectargs.fbe_size()
        + args.fbe_size()
        + aggorder.fbe_size()
        + aggdistinct.fbe_size()
        + aggfilter.fbe_size()
        + aggstar.fbe_size()
        + aggvariadic.fbe_size()
        + aggkind.fbe_size()
        + agglevelsup.fbe_size()
        + aggsplit.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Aggref::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + aggfnoid.fbe_extra()
        + aggtype.fbe_extra()
        + aggcollid.fbe_extra()
        + inputcollid.fbe_extra()
        + aggtranstype.fbe_extra()
        + aggargtypes.fbe_extra()
        + aggdirectargs.fbe_extra()
        + args.fbe_extra()
        + aggorder.fbe_extra()
        + aggdistinct.fbe_extra()
        + aggfilter.fbe_extra()
        + aggstar.fbe_extra()
        + aggvariadic.fbe_extra()
        + aggkind.fbe_extra()
        + agglevelsup.fbe_extra()
        + aggsplit.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Aggref::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Aggref::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + aggfnoid.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggfnoid.verify())
        return false;
    fbe_current_size += aggfnoid.fbe_size();

    if ((fbe_current_size + aggtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggtype.verify())
        return false;
    fbe_current_size += aggtype.fbe_size();

    if ((fbe_current_size + aggcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggcollid.verify())
        return false;
    fbe_current_size += aggcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!inputcollid.verify())
        return false;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + aggtranstype.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggtranstype.verify())
        return false;
    fbe_current_size += aggtranstype.fbe_size();

    if ((fbe_current_size + aggargtypes.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggargtypes.verify())
        return false;
    fbe_current_size += aggargtypes.fbe_size();

    if ((fbe_current_size + aggdirectargs.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggdirectargs.verify())
        return false;
    fbe_current_size += aggdirectargs.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + aggorder.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggorder.verify())
        return false;
    fbe_current_size += aggorder.fbe_size();

    if ((fbe_current_size + aggdistinct.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggdistinct.verify())
        return false;
    fbe_current_size += aggdistinct.fbe_size();

    if ((fbe_current_size + aggfilter.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggfilter.verify())
        return false;
    fbe_current_size += aggfilter.fbe_size();

    if ((fbe_current_size + aggstar.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggstar.verify())
        return false;
    fbe_current_size += aggstar.fbe_size();

    if ((fbe_current_size + aggvariadic.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggvariadic.verify())
        return false;
    fbe_current_size += aggvariadic.fbe_size();

    if ((fbe_current_size + aggkind.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggkind.verify())
        return false;
    fbe_current_size += aggkind.fbe_size();

    if ((fbe_current_size + agglevelsup.fbe_size()) > fbe_struct_size)
        return true;
    if (!agglevelsup.verify())
        return false;
    fbe_current_size += agglevelsup.fbe_size();

    if ((fbe_current_size + aggsplit.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggsplit.verify())
        return false;
    fbe_current_size += aggsplit.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_Aggref::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Aggref::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Aggref::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Aggref::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::Aggref& fbe_value = static_cast<::pg_query::Aggref&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + aggfnoid.fbe_size()) <= fbe_struct_size)
        {
            aggfnoid.get(fbe_value.aggfnoid);
        }
    else
        fbe_value.aggfnoid = (uint32_t)0ull;
    fbe_current_size += aggfnoid.fbe_size();

    if ((fbe_current_size + aggtype.fbe_size()) <= fbe_struct_size)
        {
            aggtype.get(fbe_value.aggtype);
        }
    else
        fbe_value.aggtype = (uint32_t)0ull;
    fbe_current_size += aggtype.fbe_size();

    if ((fbe_current_size + aggcollid.fbe_size()) <= fbe_struct_size)
        {
            aggcollid.get(fbe_value.aggcollid);
        }
    else
        fbe_value.aggcollid = (uint32_t)0ull;
    fbe_current_size += aggcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) <= fbe_struct_size)
        {
            inputcollid.get(fbe_value.inputcollid);
        }
    else
        fbe_value.inputcollid = (uint32_t)0ull;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + aggtranstype.fbe_size()) <= fbe_struct_size)
        {
            aggtranstype.get(fbe_value.aggtranstype);
        }
    else
        fbe_value.aggtranstype = (uint32_t)0ull;
    fbe_current_size += aggtranstype.fbe_size();

    if ((fbe_current_size + aggargtypes.fbe_size()) <= fbe_struct_size)
        {
            aggargtypes.get(fbe_value.aggargtypes);
        }
    else
        fbe_value.aggargtypes.clear();
    fbe_current_size += aggargtypes.fbe_size();

    if ((fbe_current_size + aggdirectargs.fbe_size()) <= fbe_struct_size)
        {
            aggdirectargs.get(fbe_value.aggdirectargs);
        }
    else
        fbe_value.aggdirectargs.clear();
    fbe_current_size += aggdirectargs.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + aggorder.fbe_size()) <= fbe_struct_size)
        {
            aggorder.get(fbe_value.aggorder);
        }
    else
        fbe_value.aggorder.clear();
    fbe_current_size += aggorder.fbe_size();

    if ((fbe_current_size + aggdistinct.fbe_size()) <= fbe_struct_size)
        {
            aggdistinct.get(fbe_value.aggdistinct);
        }
    else
        fbe_value.aggdistinct.clear();
    fbe_current_size += aggdistinct.fbe_size();

    if ((fbe_current_size + aggfilter.fbe_size()) <= fbe_struct_size)
        {
            aggfilter.get(fbe_value.aggfilter);
        }
    else
        fbe_value.aggfilter = ::pg_query::Node();
    fbe_current_size += aggfilter.fbe_size();

    if ((fbe_current_size + aggstar.fbe_size()) <= fbe_struct_size)
        {
            aggstar.get(fbe_value.aggstar);
        }
    else
        fbe_value.aggstar = false;
    fbe_current_size += aggstar.fbe_size();

    if ((fbe_current_size + aggvariadic.fbe_size()) <= fbe_struct_size)
        {
            aggvariadic.get(fbe_value.aggvariadic);
        }
    else
        fbe_value.aggvariadic = false;
    fbe_current_size += aggvariadic.fbe_size();

    if ((fbe_current_size + aggkind.fbe_size()) <= fbe_struct_size)
        {
            aggkind.get(fbe_value.aggkind);
        }
    else
        fbe_value.aggkind = "";
    fbe_current_size += aggkind.fbe_size();

    if ((fbe_current_size + agglevelsup.fbe_size()) <= fbe_struct_size)
        {
            agglevelsup.get(fbe_value.agglevelsup);
        }
    else
        fbe_value.agglevelsup = (uint32_t)0ull;
    fbe_current_size += agglevelsup.fbe_size();

    if ((fbe_current_size + aggsplit.fbe_size()) <= fbe_struct_size)
        {
            aggsplit.get(fbe_value.aggsplit);
        }
    else
        fbe_value.aggsplit = ::pg_query::AggSplit();
    fbe_current_size += aggsplit.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_Aggref::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Aggref::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Aggref::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Aggref::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Aggref& fbe_value = static_cast<const ::pg_query::Aggref&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    aggfnoid.set(fbe_value.aggfnoid);
    aggtype.set(fbe_value.aggtype);
    aggcollid.set(fbe_value.aggcollid);
    inputcollid.set(fbe_value.inputcollid);
    aggtranstype.set(fbe_value.aggtranstype);
    aggargtypes.set(fbe_value.aggargtypes);
    aggdirectargs.set(fbe_value.aggdirectargs);
    args.set(fbe_value.args);
    aggorder.set(fbe_value.aggorder);
    aggdistinct.set(fbe_value.aggdistinct);
    aggfilter.set(fbe_value.aggfilter);
    aggstar.set(fbe_value.aggstar);
    aggvariadic.set(fbe_value.aggvariadic);
    aggkind.set(fbe_value.aggkind);
    agglevelsup.set(fbe_value.agglevelsup);
    aggsplit.set(fbe_value.aggsplit);
    location.set(fbe_value.location);
}

namespace pg_query {

bool AggrefModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AggrefModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AggrefModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AggrefModel::serialize(const ::pg_query::Aggref& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AggrefModel::deserialize(::pg_query::Aggref& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_GroupingFunc::FieldModelPtr_pg_query_GroupingFunc(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_GroupingFunc::~FieldModelPtr_pg_query_GroupingFunc()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_GroupingFunc::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_GroupingFunc::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_GroupingFunc::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_GroupingFunc::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_GroupingFunc::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_GroupingFunc::get(::pg_query::GroupingFunc** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_GroupingFunc(_buffer, 0);

    ::pg_query::GroupingFunc *tempModel = new ::pg_query::GroupingFunc();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_GroupingFunc::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_GroupingFunc::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_GroupingFunc::set(const ::pg_query::GroupingFunc* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_GroupingFunc(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_GroupingFunc::FieldModel_pg_query_GroupingFunc(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , args(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , refs(buffer, args.fbe_offset() + args.fbe_size())
    , cols(buffer, refs.fbe_offset() + refs.fbe_size())
    , agglevelsup(buffer, cols.fbe_offset() + cols.fbe_size())
    , location(buffer, agglevelsup.fbe_offset() + agglevelsup.fbe_size())
{}

size_t FieldModel_pg_query_GroupingFunc::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + args.fbe_size()
        + refs.fbe_size()
        + cols.fbe_size()
        + agglevelsup.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_GroupingFunc::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + args.fbe_extra()
        + refs.fbe_extra()
        + cols.fbe_extra()
        + agglevelsup.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_GroupingFunc::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_GroupingFunc::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + refs.fbe_size()) > fbe_struct_size)
        return true;
    if (!refs.verify())
        return false;
    fbe_current_size += refs.fbe_size();

    if ((fbe_current_size + cols.fbe_size()) > fbe_struct_size)
        return true;
    if (!cols.verify())
        return false;
    fbe_current_size += cols.fbe_size();

    if ((fbe_current_size + agglevelsup.fbe_size()) > fbe_struct_size)
        return true;
    if (!agglevelsup.verify())
        return false;
    fbe_current_size += agglevelsup.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_GroupingFunc::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_GroupingFunc::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_GroupingFunc::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_GroupingFunc::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::GroupingFunc& fbe_value = static_cast<::pg_query::GroupingFunc&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + refs.fbe_size()) <= fbe_struct_size)
        {
            refs.get(fbe_value.refs);
        }
    else
        fbe_value.refs.clear();
    fbe_current_size += refs.fbe_size();

    if ((fbe_current_size + cols.fbe_size()) <= fbe_struct_size)
        {
            cols.get(fbe_value.cols);
        }
    else
        fbe_value.cols.clear();
    fbe_current_size += cols.fbe_size();

    if ((fbe_current_size + agglevelsup.fbe_size()) <= fbe_struct_size)
        {
            agglevelsup.get(fbe_value.agglevelsup);
        }
    else
        fbe_value.agglevelsup = (uint32_t)0ull;
    fbe_current_size += agglevelsup.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_GroupingFunc::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_GroupingFunc::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_GroupingFunc::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_GroupingFunc::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::GroupingFunc& fbe_value = static_cast<const ::pg_query::GroupingFunc&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    args.set(fbe_value.args);
    refs.set(fbe_value.refs);
    cols.set(fbe_value.cols);
    agglevelsup.set(fbe_value.agglevelsup);
    location.set(fbe_value.location);
}

namespace pg_query {

bool GroupingFuncModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t GroupingFuncModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t GroupingFuncModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t GroupingFuncModel::serialize(const ::pg_query::GroupingFunc& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t GroupingFuncModel::deserialize(::pg_query::GroupingFunc& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_WindowFunc::FieldModelPtr_pg_query_WindowFunc(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_WindowFunc::~FieldModelPtr_pg_query_WindowFunc()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_WindowFunc::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_WindowFunc::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_WindowFunc::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_WindowFunc::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WindowFunc::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WindowFunc::get(::pg_query::WindowFunc** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_WindowFunc(_buffer, 0);

    ::pg_query::WindowFunc *tempModel = new ::pg_query::WindowFunc();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_WindowFunc::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WindowFunc::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WindowFunc::set(const ::pg_query::WindowFunc* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_WindowFunc(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_WindowFunc::FieldModel_pg_query_WindowFunc(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , winfnoid(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , wintype(buffer, winfnoid.fbe_offset() + winfnoid.fbe_size())
    , wincollid(buffer, wintype.fbe_offset() + wintype.fbe_size())
    , inputcollid(buffer, wincollid.fbe_offset() + wincollid.fbe_size())
    , args(buffer, inputcollid.fbe_offset() + inputcollid.fbe_size())
    , aggfilter(buffer, args.fbe_offset() + args.fbe_size())
    , winref(buffer, aggfilter.fbe_offset() + aggfilter.fbe_size())
    , winstar(buffer, winref.fbe_offset() + winref.fbe_size())
    , winagg(buffer, winstar.fbe_offset() + winstar.fbe_size())
    , location(buffer, winagg.fbe_offset() + winagg.fbe_size())
{}

size_t FieldModel_pg_query_WindowFunc::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + winfnoid.fbe_size()
        + wintype.fbe_size()
        + wincollid.fbe_size()
        + inputcollid.fbe_size()
        + args.fbe_size()
        + aggfilter.fbe_size()
        + winref.fbe_size()
        + winstar.fbe_size()
        + winagg.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_WindowFunc::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + winfnoid.fbe_extra()
        + wintype.fbe_extra()
        + wincollid.fbe_extra()
        + inputcollid.fbe_extra()
        + args.fbe_extra()
        + aggfilter.fbe_extra()
        + winref.fbe_extra()
        + winstar.fbe_extra()
        + winagg.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_WindowFunc::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_WindowFunc::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + winfnoid.fbe_size()) > fbe_struct_size)
        return true;
    if (!winfnoid.verify())
        return false;
    fbe_current_size += winfnoid.fbe_size();

    if ((fbe_current_size + wintype.fbe_size()) > fbe_struct_size)
        return true;
    if (!wintype.verify())
        return false;
    fbe_current_size += wintype.fbe_size();

    if ((fbe_current_size + wincollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!wincollid.verify())
        return false;
    fbe_current_size += wincollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!inputcollid.verify())
        return false;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + aggfilter.fbe_size()) > fbe_struct_size)
        return true;
    if (!aggfilter.verify())
        return false;
    fbe_current_size += aggfilter.fbe_size();

    if ((fbe_current_size + winref.fbe_size()) > fbe_struct_size)
        return true;
    if (!winref.verify())
        return false;
    fbe_current_size += winref.fbe_size();

    if ((fbe_current_size + winstar.fbe_size()) > fbe_struct_size)
        return true;
    if (!winstar.verify())
        return false;
    fbe_current_size += winstar.fbe_size();

    if ((fbe_current_size + winagg.fbe_size()) > fbe_struct_size)
        return true;
    if (!winagg.verify())
        return false;
    fbe_current_size += winagg.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_WindowFunc::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WindowFunc::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WindowFunc::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_WindowFunc::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::WindowFunc& fbe_value = static_cast<::pg_query::WindowFunc&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + winfnoid.fbe_size()) <= fbe_struct_size)
        {
            winfnoid.get(fbe_value.winfnoid);
        }
    else
        fbe_value.winfnoid = (uint32_t)0ull;
    fbe_current_size += winfnoid.fbe_size();

    if ((fbe_current_size + wintype.fbe_size()) <= fbe_struct_size)
        {
            wintype.get(fbe_value.wintype);
        }
    else
        fbe_value.wintype = (uint32_t)0ull;
    fbe_current_size += wintype.fbe_size();

    if ((fbe_current_size + wincollid.fbe_size()) <= fbe_struct_size)
        {
            wincollid.get(fbe_value.wincollid);
        }
    else
        fbe_value.wincollid = (uint32_t)0ull;
    fbe_current_size += wincollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) <= fbe_struct_size)
        {
            inputcollid.get(fbe_value.inputcollid);
        }
    else
        fbe_value.inputcollid = (uint32_t)0ull;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + aggfilter.fbe_size()) <= fbe_struct_size)
        {
            aggfilter.get(fbe_value.aggfilter);
        }
    else
        fbe_value.aggfilter = ::pg_query::Node();
    fbe_current_size += aggfilter.fbe_size();

    if ((fbe_current_size + winref.fbe_size()) <= fbe_struct_size)
        {
            winref.get(fbe_value.winref);
        }
    else
        fbe_value.winref = (uint32_t)0ull;
    fbe_current_size += winref.fbe_size();

    if ((fbe_current_size + winstar.fbe_size()) <= fbe_struct_size)
        {
            winstar.get(fbe_value.winstar);
        }
    else
        fbe_value.winstar = false;
    fbe_current_size += winstar.fbe_size();

    if ((fbe_current_size + winagg.fbe_size()) <= fbe_struct_size)
        {
            winagg.get(fbe_value.winagg);
        }
    else
        fbe_value.winagg = false;
    fbe_current_size += winagg.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_WindowFunc::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WindowFunc::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WindowFunc::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_WindowFunc::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::WindowFunc& fbe_value = static_cast<const ::pg_query::WindowFunc&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    winfnoid.set(fbe_value.winfnoid);
    wintype.set(fbe_value.wintype);
    wincollid.set(fbe_value.wincollid);
    inputcollid.set(fbe_value.inputcollid);
    args.set(fbe_value.args);
    aggfilter.set(fbe_value.aggfilter);
    winref.set(fbe_value.winref);
    winstar.set(fbe_value.winstar);
    winagg.set(fbe_value.winagg);
    location.set(fbe_value.location);
}

namespace pg_query {

bool WindowFuncModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t WindowFuncModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t WindowFuncModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t WindowFuncModel::serialize(const ::pg_query::WindowFunc& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t WindowFuncModel::deserialize(::pg_query::WindowFunc& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SubscriptingRef::FieldModelPtr_pg_query_SubscriptingRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SubscriptingRef::~FieldModelPtr_pg_query_SubscriptingRef()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SubscriptingRef::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SubscriptingRef::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SubscriptingRef::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SubscriptingRef::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SubscriptingRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SubscriptingRef::get(::pg_query::SubscriptingRef** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SubscriptingRef(_buffer, 0);

    ::pg_query::SubscriptingRef *tempModel = new ::pg_query::SubscriptingRef();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SubscriptingRef::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SubscriptingRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SubscriptingRef::set(const ::pg_query::SubscriptingRef* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SubscriptingRef(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SubscriptingRef::FieldModel_pg_query_SubscriptingRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , refcontainertype(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , refelemtype(buffer, refcontainertype.fbe_offset() + refcontainertype.fbe_size())
    , reftypmod(buffer, refelemtype.fbe_offset() + refelemtype.fbe_size())
    , refcollid(buffer, reftypmod.fbe_offset() + reftypmod.fbe_size())
    , refupperindexpr(buffer, refcollid.fbe_offset() + refcollid.fbe_size())
    , reflowerindexpr(buffer, refupperindexpr.fbe_offset() + refupperindexpr.fbe_size())
    , refexpr(buffer, reflowerindexpr.fbe_offset() + reflowerindexpr.fbe_size())
    , refassgnexpr(buffer, refexpr.fbe_offset() + refexpr.fbe_size())
{}

size_t FieldModel_pg_query_SubscriptingRef::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + refcontainertype.fbe_size()
        + refelemtype.fbe_size()
        + reftypmod.fbe_size()
        + refcollid.fbe_size()
        + refupperindexpr.fbe_size()
        + reflowerindexpr.fbe_size()
        + refexpr.fbe_size()
        + refassgnexpr.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SubscriptingRef::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + refcontainertype.fbe_extra()
        + refelemtype.fbe_extra()
        + reftypmod.fbe_extra()
        + refcollid.fbe_extra()
        + refupperindexpr.fbe_extra()
        + reflowerindexpr.fbe_extra()
        + refexpr.fbe_extra()
        + refassgnexpr.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SubscriptingRef::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SubscriptingRef::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + refcontainertype.fbe_size()) > fbe_struct_size)
        return true;
    if (!refcontainertype.verify())
        return false;
    fbe_current_size += refcontainertype.fbe_size();

    if ((fbe_current_size + refelemtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!refelemtype.verify())
        return false;
    fbe_current_size += refelemtype.fbe_size();

    if ((fbe_current_size + reftypmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!reftypmod.verify())
        return false;
    fbe_current_size += reftypmod.fbe_size();

    if ((fbe_current_size + refcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!refcollid.verify())
        return false;
    fbe_current_size += refcollid.fbe_size();

    if ((fbe_current_size + refupperindexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!refupperindexpr.verify())
        return false;
    fbe_current_size += refupperindexpr.fbe_size();

    if ((fbe_current_size + reflowerindexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!reflowerindexpr.verify())
        return false;
    fbe_current_size += reflowerindexpr.fbe_size();

    if ((fbe_current_size + refexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!refexpr.verify())
        return false;
    fbe_current_size += refexpr.fbe_size();

    if ((fbe_current_size + refassgnexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!refassgnexpr.verify())
        return false;
    fbe_current_size += refassgnexpr.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SubscriptingRef::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SubscriptingRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SubscriptingRef::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SubscriptingRef::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SubscriptingRef& fbe_value = static_cast<::pg_query::SubscriptingRef&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + refcontainertype.fbe_size()) <= fbe_struct_size)
        {
            refcontainertype.get(fbe_value.refcontainertype);
        }
    else
        fbe_value.refcontainertype = (uint32_t)0ull;
    fbe_current_size += refcontainertype.fbe_size();

    if ((fbe_current_size + refelemtype.fbe_size()) <= fbe_struct_size)
        {
            refelemtype.get(fbe_value.refelemtype);
        }
    else
        fbe_value.refelemtype = (uint32_t)0ull;
    fbe_current_size += refelemtype.fbe_size();

    if ((fbe_current_size + reftypmod.fbe_size()) <= fbe_struct_size)
        {
            reftypmod.get(fbe_value.reftypmod);
        }
    else
        fbe_value.reftypmod = (int32_t)0ll;
    fbe_current_size += reftypmod.fbe_size();

    if ((fbe_current_size + refcollid.fbe_size()) <= fbe_struct_size)
        {
            refcollid.get(fbe_value.refcollid);
        }
    else
        fbe_value.refcollid = (uint32_t)0ull;
    fbe_current_size += refcollid.fbe_size();

    if ((fbe_current_size + refupperindexpr.fbe_size()) <= fbe_struct_size)
        {
            refupperindexpr.get(fbe_value.refupperindexpr);
        }
    else
        fbe_value.refupperindexpr.clear();
    fbe_current_size += refupperindexpr.fbe_size();

    if ((fbe_current_size + reflowerindexpr.fbe_size()) <= fbe_struct_size)
        {
            reflowerindexpr.get(fbe_value.reflowerindexpr);
        }
    else
        fbe_value.reflowerindexpr.clear();
    fbe_current_size += reflowerindexpr.fbe_size();

    if ((fbe_current_size + refexpr.fbe_size()) <= fbe_struct_size)
        {
            refexpr.get(fbe_value.refexpr);
        }
    else
        fbe_value.refexpr = ::pg_query::Node();
    fbe_current_size += refexpr.fbe_size();

    if ((fbe_current_size + refassgnexpr.fbe_size()) <= fbe_struct_size)
        {
            refassgnexpr.get(fbe_value.refassgnexpr);
        }
    else
        fbe_value.refassgnexpr = ::pg_query::Node();
    fbe_current_size += refassgnexpr.fbe_size();
}

size_t FieldModel_pg_query_SubscriptingRef::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SubscriptingRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SubscriptingRef::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SubscriptingRef::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SubscriptingRef& fbe_value = static_cast<const ::pg_query::SubscriptingRef&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    refcontainertype.set(fbe_value.refcontainertype);
    refelemtype.set(fbe_value.refelemtype);
    reftypmod.set(fbe_value.reftypmod);
    refcollid.set(fbe_value.refcollid);
    refupperindexpr.set(fbe_value.refupperindexpr);
    reflowerindexpr.set(fbe_value.reflowerindexpr);
    refexpr.set(fbe_value.refexpr);
    refassgnexpr.set(fbe_value.refassgnexpr);
}

namespace pg_query {

bool SubscriptingRefModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SubscriptingRefModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SubscriptingRefModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SubscriptingRefModel::serialize(const ::pg_query::SubscriptingRef& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SubscriptingRefModel::deserialize(::pg_query::SubscriptingRef& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_FuncExpr::FieldModelPtr_pg_query_FuncExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_FuncExpr::~FieldModelPtr_pg_query_FuncExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_FuncExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_FuncExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_FuncExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_FuncExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FuncExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FuncExpr::get(::pg_query::FuncExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_FuncExpr(_buffer, 0);

    ::pg_query::FuncExpr *tempModel = new ::pg_query::FuncExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_FuncExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FuncExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FuncExpr::set(const ::pg_query::FuncExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_FuncExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_FuncExpr::FieldModel_pg_query_FuncExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , funcid(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , funcresulttype(buffer, funcid.fbe_offset() + funcid.fbe_size())
    , funcretset(buffer, funcresulttype.fbe_offset() + funcresulttype.fbe_size())
    , funcvariadic(buffer, funcretset.fbe_offset() + funcretset.fbe_size())
    , funcformat(buffer, funcvariadic.fbe_offset() + funcvariadic.fbe_size())
    , funccollid(buffer, funcformat.fbe_offset() + funcformat.fbe_size())
    , inputcollid(buffer, funccollid.fbe_offset() + funccollid.fbe_size())
    , args(buffer, inputcollid.fbe_offset() + inputcollid.fbe_size())
    , location(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_FuncExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + funcid.fbe_size()
        + funcresulttype.fbe_size()
        + funcretset.fbe_size()
        + funcvariadic.fbe_size()
        + funcformat.fbe_size()
        + funccollid.fbe_size()
        + inputcollid.fbe_size()
        + args.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_FuncExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + funcid.fbe_extra()
        + funcresulttype.fbe_extra()
        + funcretset.fbe_extra()
        + funcvariadic.fbe_extra()
        + funcformat.fbe_extra()
        + funccollid.fbe_extra()
        + inputcollid.fbe_extra()
        + args.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_FuncExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_FuncExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + funcid.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcid.verify())
        return false;
    fbe_current_size += funcid.fbe_size();

    if ((fbe_current_size + funcresulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcresulttype.verify())
        return false;
    fbe_current_size += funcresulttype.fbe_size();

    if ((fbe_current_size + funcretset.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcretset.verify())
        return false;
    fbe_current_size += funcretset.fbe_size();

    if ((fbe_current_size + funcvariadic.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcvariadic.verify())
        return false;
    fbe_current_size += funcvariadic.fbe_size();

    if ((fbe_current_size + funcformat.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcformat.verify())
        return false;
    fbe_current_size += funcformat.fbe_size();

    if ((fbe_current_size + funccollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!funccollid.verify())
        return false;
    fbe_current_size += funccollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!inputcollid.verify())
        return false;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_FuncExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FuncExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FuncExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_FuncExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::FuncExpr& fbe_value = static_cast<::pg_query::FuncExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + funcid.fbe_size()) <= fbe_struct_size)
        {
            funcid.get(fbe_value.funcid);
        }
    else
        fbe_value.funcid = (uint32_t)0ull;
    fbe_current_size += funcid.fbe_size();

    if ((fbe_current_size + funcresulttype.fbe_size()) <= fbe_struct_size)
        {
            funcresulttype.get(fbe_value.funcresulttype);
        }
    else
        fbe_value.funcresulttype = (uint32_t)0ull;
    fbe_current_size += funcresulttype.fbe_size();

    if ((fbe_current_size + funcretset.fbe_size()) <= fbe_struct_size)
        {
            funcretset.get(fbe_value.funcretset);
        }
    else
        fbe_value.funcretset = false;
    fbe_current_size += funcretset.fbe_size();

    if ((fbe_current_size + funcvariadic.fbe_size()) <= fbe_struct_size)
        {
            funcvariadic.get(fbe_value.funcvariadic);
        }
    else
        fbe_value.funcvariadic = false;
    fbe_current_size += funcvariadic.fbe_size();

    if ((fbe_current_size + funcformat.fbe_size()) <= fbe_struct_size)
        {
            funcformat.get(fbe_value.funcformat);
        }
    else
        fbe_value.funcformat = ::pg_query::CoercionForm();
    fbe_current_size += funcformat.fbe_size();

    if ((fbe_current_size + funccollid.fbe_size()) <= fbe_struct_size)
        {
            funccollid.get(fbe_value.funccollid);
        }
    else
        fbe_value.funccollid = (uint32_t)0ull;
    fbe_current_size += funccollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) <= fbe_struct_size)
        {
            inputcollid.get(fbe_value.inputcollid);
        }
    else
        fbe_value.inputcollid = (uint32_t)0ull;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_FuncExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FuncExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FuncExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_FuncExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::FuncExpr& fbe_value = static_cast<const ::pg_query::FuncExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    funcid.set(fbe_value.funcid);
    funcresulttype.set(fbe_value.funcresulttype);
    funcretset.set(fbe_value.funcretset);
    funcvariadic.set(fbe_value.funcvariadic);
    funcformat.set(fbe_value.funcformat);
    funccollid.set(fbe_value.funccollid);
    inputcollid.set(fbe_value.inputcollid);
    args.set(fbe_value.args);
    location.set(fbe_value.location);
}

namespace pg_query {

bool FuncExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t FuncExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t FuncExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t FuncExprModel::serialize(const ::pg_query::FuncExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t FuncExprModel::deserialize(::pg_query::FuncExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_NamedArgExpr::FieldModelPtr_pg_query_NamedArgExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_NamedArgExpr::~FieldModelPtr_pg_query_NamedArgExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_NamedArgExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_NamedArgExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_NamedArgExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_NamedArgExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NamedArgExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NamedArgExpr::get(::pg_query::NamedArgExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_NamedArgExpr(_buffer, 0);

    ::pg_query::NamedArgExpr *tempModel = new ::pg_query::NamedArgExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_NamedArgExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NamedArgExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NamedArgExpr::set(const ::pg_query::NamedArgExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_NamedArgExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_NamedArgExpr::FieldModel_pg_query_NamedArgExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , name(buffer, arg.fbe_offset() + arg.fbe_size())
    , argnumber(buffer, name.fbe_offset() + name.fbe_size())
    , location(buffer, argnumber.fbe_offset() + argnumber.fbe_size())
{}

size_t FieldModel_pg_query_NamedArgExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + name.fbe_size()
        + argnumber.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_NamedArgExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + name.fbe_extra()
        + argnumber.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_NamedArgExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_NamedArgExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + argnumber.fbe_size()) > fbe_struct_size)
        return true;
    if (!argnumber.verify())
        return false;
    fbe_current_size += argnumber.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_NamedArgExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NamedArgExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NamedArgExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_NamedArgExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::NamedArgExpr& fbe_value = static_cast<::pg_query::NamedArgExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + argnumber.fbe_size()) <= fbe_struct_size)
        {
            argnumber.get(fbe_value.argnumber);
        }
    else
        fbe_value.argnumber = (int32_t)0ll;
    fbe_current_size += argnumber.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_NamedArgExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NamedArgExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NamedArgExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_NamedArgExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::NamedArgExpr& fbe_value = static_cast<const ::pg_query::NamedArgExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    name.set(fbe_value.name);
    argnumber.set(fbe_value.argnumber);
    location.set(fbe_value.location);
}

namespace pg_query {

bool NamedArgExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t NamedArgExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t NamedArgExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t NamedArgExprModel::serialize(const ::pg_query::NamedArgExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t NamedArgExprModel::deserialize(::pg_query::NamedArgExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_OpExpr::FieldModelPtr_pg_query_OpExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_OpExpr::~FieldModelPtr_pg_query_OpExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_OpExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_OpExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_OpExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_OpExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_OpExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_OpExpr::get(::pg_query::OpExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_OpExpr(_buffer, 0);

    ::pg_query::OpExpr *tempModel = new ::pg_query::OpExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_OpExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_OpExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_OpExpr::set(const ::pg_query::OpExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_OpExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_OpExpr::FieldModel_pg_query_OpExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , opno(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , opfuncid(buffer, opno.fbe_offset() + opno.fbe_size())
    , opresulttype(buffer, opfuncid.fbe_offset() + opfuncid.fbe_size())
    , opretset(buffer, opresulttype.fbe_offset() + opresulttype.fbe_size())
    , opcollid(buffer, opretset.fbe_offset() + opretset.fbe_size())
    , inputcollid(buffer, opcollid.fbe_offset() + opcollid.fbe_size())
    , args(buffer, inputcollid.fbe_offset() + inputcollid.fbe_size())
    , location(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_OpExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + opno.fbe_size()
        + opfuncid.fbe_size()
        + opresulttype.fbe_size()
        + opretset.fbe_size()
        + opcollid.fbe_size()
        + inputcollid.fbe_size()
        + args.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_OpExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + opno.fbe_extra()
        + opfuncid.fbe_extra()
        + opresulttype.fbe_extra()
        + opretset.fbe_extra()
        + opcollid.fbe_extra()
        + inputcollid.fbe_extra()
        + args.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_OpExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_OpExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + opno.fbe_size()) > fbe_struct_size)
        return true;
    if (!opno.verify())
        return false;
    fbe_current_size += opno.fbe_size();

    if ((fbe_current_size + opfuncid.fbe_size()) > fbe_struct_size)
        return true;
    if (!opfuncid.verify())
        return false;
    fbe_current_size += opfuncid.fbe_size();

    if ((fbe_current_size + opresulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!opresulttype.verify())
        return false;
    fbe_current_size += opresulttype.fbe_size();

    if ((fbe_current_size + opretset.fbe_size()) > fbe_struct_size)
        return true;
    if (!opretset.verify())
        return false;
    fbe_current_size += opretset.fbe_size();

    if ((fbe_current_size + opcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!opcollid.verify())
        return false;
    fbe_current_size += opcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!inputcollid.verify())
        return false;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_OpExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_OpExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_OpExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_OpExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::OpExpr& fbe_value = static_cast<::pg_query::OpExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + opno.fbe_size()) <= fbe_struct_size)
        {
            opno.get(fbe_value.opno);
        }
    else
        fbe_value.opno = (uint32_t)0ull;
    fbe_current_size += opno.fbe_size();

    if ((fbe_current_size + opfuncid.fbe_size()) <= fbe_struct_size)
        {
            opfuncid.get(fbe_value.opfuncid);
        }
    else
        fbe_value.opfuncid = (uint32_t)0ull;
    fbe_current_size += opfuncid.fbe_size();

    if ((fbe_current_size + opresulttype.fbe_size()) <= fbe_struct_size)
        {
            opresulttype.get(fbe_value.opresulttype);
        }
    else
        fbe_value.opresulttype = (uint32_t)0ull;
    fbe_current_size += opresulttype.fbe_size();

    if ((fbe_current_size + opretset.fbe_size()) <= fbe_struct_size)
        {
            opretset.get(fbe_value.opretset);
        }
    else
        fbe_value.opretset = false;
    fbe_current_size += opretset.fbe_size();

    if ((fbe_current_size + opcollid.fbe_size()) <= fbe_struct_size)
        {
            opcollid.get(fbe_value.opcollid);
        }
    else
        fbe_value.opcollid = (uint32_t)0ull;
    fbe_current_size += opcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) <= fbe_struct_size)
        {
            inputcollid.get(fbe_value.inputcollid);
        }
    else
        fbe_value.inputcollid = (uint32_t)0ull;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_OpExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_OpExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_OpExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_OpExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::OpExpr& fbe_value = static_cast<const ::pg_query::OpExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    opno.set(fbe_value.opno);
    opfuncid.set(fbe_value.opfuncid);
    opresulttype.set(fbe_value.opresulttype);
    opretset.set(fbe_value.opretset);
    opcollid.set(fbe_value.opcollid);
    inputcollid.set(fbe_value.inputcollid);
    args.set(fbe_value.args);
    location.set(fbe_value.location);
}

namespace pg_query {

bool OpExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t OpExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t OpExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t OpExprModel::serialize(const ::pg_query::OpExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t OpExprModel::deserialize(::pg_query::OpExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DistinctExpr::FieldModelPtr_pg_query_DistinctExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DistinctExpr::~FieldModelPtr_pg_query_DistinctExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DistinctExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DistinctExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DistinctExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DistinctExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DistinctExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DistinctExpr::get(::pg_query::DistinctExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DistinctExpr(_buffer, 0);

    ::pg_query::DistinctExpr *tempModel = new ::pg_query::DistinctExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DistinctExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DistinctExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DistinctExpr::set(const ::pg_query::DistinctExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DistinctExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DistinctExpr::FieldModel_pg_query_DistinctExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , opno(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , opfuncid(buffer, opno.fbe_offset() + opno.fbe_size())
    , opresulttype(buffer, opfuncid.fbe_offset() + opfuncid.fbe_size())
    , opretset(buffer, opresulttype.fbe_offset() + opresulttype.fbe_size())
    , opcollid(buffer, opretset.fbe_offset() + opretset.fbe_size())
    , inputcollid(buffer, opcollid.fbe_offset() + opcollid.fbe_size())
    , args(buffer, inputcollid.fbe_offset() + inputcollid.fbe_size())
    , location(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_DistinctExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + opno.fbe_size()
        + opfuncid.fbe_size()
        + opresulttype.fbe_size()
        + opretset.fbe_size()
        + opcollid.fbe_size()
        + inputcollid.fbe_size()
        + args.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DistinctExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + opno.fbe_extra()
        + opfuncid.fbe_extra()
        + opresulttype.fbe_extra()
        + opretset.fbe_extra()
        + opcollid.fbe_extra()
        + inputcollid.fbe_extra()
        + args.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DistinctExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DistinctExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + opno.fbe_size()) > fbe_struct_size)
        return true;
    if (!opno.verify())
        return false;
    fbe_current_size += opno.fbe_size();

    if ((fbe_current_size + opfuncid.fbe_size()) > fbe_struct_size)
        return true;
    if (!opfuncid.verify())
        return false;
    fbe_current_size += opfuncid.fbe_size();

    if ((fbe_current_size + opresulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!opresulttype.verify())
        return false;
    fbe_current_size += opresulttype.fbe_size();

    if ((fbe_current_size + opretset.fbe_size()) > fbe_struct_size)
        return true;
    if (!opretset.verify())
        return false;
    fbe_current_size += opretset.fbe_size();

    if ((fbe_current_size + opcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!opcollid.verify())
        return false;
    fbe_current_size += opcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!inputcollid.verify())
        return false;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DistinctExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DistinctExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DistinctExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DistinctExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DistinctExpr& fbe_value = static_cast<::pg_query::DistinctExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + opno.fbe_size()) <= fbe_struct_size)
        {
            opno.get(fbe_value.opno);
        }
    else
        fbe_value.opno = (uint32_t)0ull;
    fbe_current_size += opno.fbe_size();

    if ((fbe_current_size + opfuncid.fbe_size()) <= fbe_struct_size)
        {
            opfuncid.get(fbe_value.opfuncid);
        }
    else
        fbe_value.opfuncid = (uint32_t)0ull;
    fbe_current_size += opfuncid.fbe_size();

    if ((fbe_current_size + opresulttype.fbe_size()) <= fbe_struct_size)
        {
            opresulttype.get(fbe_value.opresulttype);
        }
    else
        fbe_value.opresulttype = (uint32_t)0ull;
    fbe_current_size += opresulttype.fbe_size();

    if ((fbe_current_size + opretset.fbe_size()) <= fbe_struct_size)
        {
            opretset.get(fbe_value.opretset);
        }
    else
        fbe_value.opretset = false;
    fbe_current_size += opretset.fbe_size();

    if ((fbe_current_size + opcollid.fbe_size()) <= fbe_struct_size)
        {
            opcollid.get(fbe_value.opcollid);
        }
    else
        fbe_value.opcollid = (uint32_t)0ull;
    fbe_current_size += opcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) <= fbe_struct_size)
        {
            inputcollid.get(fbe_value.inputcollid);
        }
    else
        fbe_value.inputcollid = (uint32_t)0ull;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_DistinctExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DistinctExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DistinctExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DistinctExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DistinctExpr& fbe_value = static_cast<const ::pg_query::DistinctExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    opno.set(fbe_value.opno);
    opfuncid.set(fbe_value.opfuncid);
    opresulttype.set(fbe_value.opresulttype);
    opretset.set(fbe_value.opretset);
    opcollid.set(fbe_value.opcollid);
    inputcollid.set(fbe_value.inputcollid);
    args.set(fbe_value.args);
    location.set(fbe_value.location);
}

namespace pg_query {

bool DistinctExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DistinctExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DistinctExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DistinctExprModel::serialize(const ::pg_query::DistinctExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DistinctExprModel::deserialize(::pg_query::DistinctExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_NullIfExpr::FieldModelPtr_pg_query_NullIfExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_NullIfExpr::~FieldModelPtr_pg_query_NullIfExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_NullIfExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_NullIfExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_NullIfExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_NullIfExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NullIfExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NullIfExpr::get(::pg_query::NullIfExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_NullIfExpr(_buffer, 0);

    ::pg_query::NullIfExpr *tempModel = new ::pg_query::NullIfExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_NullIfExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NullIfExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NullIfExpr::set(const ::pg_query::NullIfExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_NullIfExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_NullIfExpr::FieldModel_pg_query_NullIfExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , opno(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , opfuncid(buffer, opno.fbe_offset() + opno.fbe_size())
    , opresulttype(buffer, opfuncid.fbe_offset() + opfuncid.fbe_size())
    , opretset(buffer, opresulttype.fbe_offset() + opresulttype.fbe_size())
    , opcollid(buffer, opretset.fbe_offset() + opretset.fbe_size())
    , inputcollid(buffer, opcollid.fbe_offset() + opcollid.fbe_size())
    , args(buffer, inputcollid.fbe_offset() + inputcollid.fbe_size())
    , location(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_NullIfExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + opno.fbe_size()
        + opfuncid.fbe_size()
        + opresulttype.fbe_size()
        + opretset.fbe_size()
        + opcollid.fbe_size()
        + inputcollid.fbe_size()
        + args.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_NullIfExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + opno.fbe_extra()
        + opfuncid.fbe_extra()
        + opresulttype.fbe_extra()
        + opretset.fbe_extra()
        + opcollid.fbe_extra()
        + inputcollid.fbe_extra()
        + args.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_NullIfExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_NullIfExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + opno.fbe_size()) > fbe_struct_size)
        return true;
    if (!opno.verify())
        return false;
    fbe_current_size += opno.fbe_size();

    if ((fbe_current_size + opfuncid.fbe_size()) > fbe_struct_size)
        return true;
    if (!opfuncid.verify())
        return false;
    fbe_current_size += opfuncid.fbe_size();

    if ((fbe_current_size + opresulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!opresulttype.verify())
        return false;
    fbe_current_size += opresulttype.fbe_size();

    if ((fbe_current_size + opretset.fbe_size()) > fbe_struct_size)
        return true;
    if (!opretset.verify())
        return false;
    fbe_current_size += opretset.fbe_size();

    if ((fbe_current_size + opcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!opcollid.verify())
        return false;
    fbe_current_size += opcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!inputcollid.verify())
        return false;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_NullIfExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NullIfExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NullIfExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_NullIfExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::NullIfExpr& fbe_value = static_cast<::pg_query::NullIfExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + opno.fbe_size()) <= fbe_struct_size)
        {
            opno.get(fbe_value.opno);
        }
    else
        fbe_value.opno = (uint32_t)0ull;
    fbe_current_size += opno.fbe_size();

    if ((fbe_current_size + opfuncid.fbe_size()) <= fbe_struct_size)
        {
            opfuncid.get(fbe_value.opfuncid);
        }
    else
        fbe_value.opfuncid = (uint32_t)0ull;
    fbe_current_size += opfuncid.fbe_size();

    if ((fbe_current_size + opresulttype.fbe_size()) <= fbe_struct_size)
        {
            opresulttype.get(fbe_value.opresulttype);
        }
    else
        fbe_value.opresulttype = (uint32_t)0ull;
    fbe_current_size += opresulttype.fbe_size();

    if ((fbe_current_size + opretset.fbe_size()) <= fbe_struct_size)
        {
            opretset.get(fbe_value.opretset);
        }
    else
        fbe_value.opretset = false;
    fbe_current_size += opretset.fbe_size();

    if ((fbe_current_size + opcollid.fbe_size()) <= fbe_struct_size)
        {
            opcollid.get(fbe_value.opcollid);
        }
    else
        fbe_value.opcollid = (uint32_t)0ull;
    fbe_current_size += opcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) <= fbe_struct_size)
        {
            inputcollid.get(fbe_value.inputcollid);
        }
    else
        fbe_value.inputcollid = (uint32_t)0ull;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_NullIfExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NullIfExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NullIfExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_NullIfExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::NullIfExpr& fbe_value = static_cast<const ::pg_query::NullIfExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    opno.set(fbe_value.opno);
    opfuncid.set(fbe_value.opfuncid);
    opresulttype.set(fbe_value.opresulttype);
    opretset.set(fbe_value.opretset);
    opcollid.set(fbe_value.opcollid);
    inputcollid.set(fbe_value.inputcollid);
    args.set(fbe_value.args);
    location.set(fbe_value.location);
}

namespace pg_query {

bool NullIfExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t NullIfExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t NullIfExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t NullIfExprModel::serialize(const ::pg_query::NullIfExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t NullIfExprModel::deserialize(::pg_query::NullIfExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ScalarArrayOpExpr::FieldModelPtr_pg_query_ScalarArrayOpExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ScalarArrayOpExpr::~FieldModelPtr_pg_query_ScalarArrayOpExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ScalarArrayOpExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ScalarArrayOpExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ScalarArrayOpExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ScalarArrayOpExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ScalarArrayOpExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ScalarArrayOpExpr::get(::pg_query::ScalarArrayOpExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ScalarArrayOpExpr(_buffer, 0);

    ::pg_query::ScalarArrayOpExpr *tempModel = new ::pg_query::ScalarArrayOpExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ScalarArrayOpExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ScalarArrayOpExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ScalarArrayOpExpr::set(const ::pg_query::ScalarArrayOpExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ScalarArrayOpExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ScalarArrayOpExpr::FieldModel_pg_query_ScalarArrayOpExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , opno(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , opfuncid(buffer, opno.fbe_offset() + opno.fbe_size())
    , use_or(buffer, opfuncid.fbe_offset() + opfuncid.fbe_size())
    , inputcollid(buffer, use_or.fbe_offset() + use_or.fbe_size())
    , args(buffer, inputcollid.fbe_offset() + inputcollid.fbe_size())
    , location(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_ScalarArrayOpExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + opno.fbe_size()
        + opfuncid.fbe_size()
        + use_or.fbe_size()
        + inputcollid.fbe_size()
        + args.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ScalarArrayOpExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + opno.fbe_extra()
        + opfuncid.fbe_extra()
        + use_or.fbe_extra()
        + inputcollid.fbe_extra()
        + args.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ScalarArrayOpExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ScalarArrayOpExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + opno.fbe_size()) > fbe_struct_size)
        return true;
    if (!opno.verify())
        return false;
    fbe_current_size += opno.fbe_size();

    if ((fbe_current_size + opfuncid.fbe_size()) > fbe_struct_size)
        return true;
    if (!opfuncid.verify())
        return false;
    fbe_current_size += opfuncid.fbe_size();

    if ((fbe_current_size + use_or.fbe_size()) > fbe_struct_size)
        return true;
    if (!use_or.verify())
        return false;
    fbe_current_size += use_or.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!inputcollid.verify())
        return false;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ScalarArrayOpExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ScalarArrayOpExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ScalarArrayOpExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ScalarArrayOpExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ScalarArrayOpExpr& fbe_value = static_cast<::pg_query::ScalarArrayOpExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + opno.fbe_size()) <= fbe_struct_size)
        {
            opno.get(fbe_value.opno);
        }
    else
        fbe_value.opno = (uint32_t)0ull;
    fbe_current_size += opno.fbe_size();

    if ((fbe_current_size + opfuncid.fbe_size()) <= fbe_struct_size)
        {
            opfuncid.get(fbe_value.opfuncid);
        }
    else
        fbe_value.opfuncid = (uint32_t)0ull;
    fbe_current_size += opfuncid.fbe_size();

    if ((fbe_current_size + use_or.fbe_size()) <= fbe_struct_size)
        {
            use_or.get(fbe_value.use_or);
        }
    else
        fbe_value.use_or = false;
    fbe_current_size += use_or.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) <= fbe_struct_size)
        {
            inputcollid.get(fbe_value.inputcollid);
        }
    else
        fbe_value.inputcollid = (uint32_t)0ull;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_ScalarArrayOpExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ScalarArrayOpExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ScalarArrayOpExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ScalarArrayOpExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ScalarArrayOpExpr& fbe_value = static_cast<const ::pg_query::ScalarArrayOpExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    opno.set(fbe_value.opno);
    opfuncid.set(fbe_value.opfuncid);
    use_or.set(fbe_value.use_or);
    inputcollid.set(fbe_value.inputcollid);
    args.set(fbe_value.args);
    location.set(fbe_value.location);
}

namespace pg_query {

bool ScalarArrayOpExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ScalarArrayOpExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ScalarArrayOpExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ScalarArrayOpExprModel::serialize(const ::pg_query::ScalarArrayOpExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ScalarArrayOpExprModel::deserialize(::pg_query::ScalarArrayOpExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_BoolExpr::FieldModelPtr_pg_query_BoolExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_BoolExpr::~FieldModelPtr_pg_query_BoolExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_BoolExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_BoolExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_BoolExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_BoolExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_BoolExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_BoolExpr::get(::pg_query::BoolExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_BoolExpr(_buffer, 0);

    ::pg_query::BoolExpr *tempModel = new ::pg_query::BoolExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_BoolExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_BoolExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_BoolExpr::set(const ::pg_query::BoolExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_BoolExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_BoolExpr::FieldModel_pg_query_BoolExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , boolop(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , args(buffer, boolop.fbe_offset() + boolop.fbe_size())
    , location(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_BoolExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + boolop.fbe_size()
        + args.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_BoolExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + boolop.fbe_extra()
        + args.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_BoolExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_BoolExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + boolop.fbe_size()) > fbe_struct_size)
        return true;
    if (!boolop.verify())
        return false;
    fbe_current_size += boolop.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_BoolExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_BoolExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_BoolExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_BoolExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::BoolExpr& fbe_value = static_cast<::pg_query::BoolExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + boolop.fbe_size()) <= fbe_struct_size)
        {
            boolop.get(fbe_value.boolop);
        }
    else
        fbe_value.boolop = ::pg_query::BoolExprType();
    fbe_current_size += boolop.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_BoolExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_BoolExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_BoolExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_BoolExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::BoolExpr& fbe_value = static_cast<const ::pg_query::BoolExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    boolop.set(fbe_value.boolop);
    args.set(fbe_value.args);
    location.set(fbe_value.location);
}

namespace pg_query {

bool BoolExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t BoolExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t BoolExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t BoolExprModel::serialize(const ::pg_query::BoolExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t BoolExprModel::deserialize(::pg_query::BoolExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SubLink::FieldModelPtr_pg_query_SubLink(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SubLink::~FieldModelPtr_pg_query_SubLink()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SubLink::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SubLink::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SubLink::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SubLink::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SubLink::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SubLink::get(::pg_query::SubLink** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SubLink(_buffer, 0);

    ::pg_query::SubLink *tempModel = new ::pg_query::SubLink();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SubLink::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SubLink::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SubLink::set(const ::pg_query::SubLink* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SubLink(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SubLink::FieldModel_pg_query_SubLink(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , sub_link_type(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , sub_link_id(buffer, sub_link_type.fbe_offset() + sub_link_type.fbe_size())
    , testexpr(buffer, sub_link_id.fbe_offset() + sub_link_id.fbe_size())
    , oper_name(buffer, testexpr.fbe_offset() + testexpr.fbe_size())
    , subselect(buffer, oper_name.fbe_offset() + oper_name.fbe_size())
    , location(buffer, subselect.fbe_offset() + subselect.fbe_size())
{}

size_t FieldModel_pg_query_SubLink::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + sub_link_type.fbe_size()
        + sub_link_id.fbe_size()
        + testexpr.fbe_size()
        + oper_name.fbe_size()
        + subselect.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SubLink::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + sub_link_type.fbe_extra()
        + sub_link_id.fbe_extra()
        + testexpr.fbe_extra()
        + oper_name.fbe_extra()
        + subselect.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SubLink::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SubLink::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + sub_link_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!sub_link_type.verify())
        return false;
    fbe_current_size += sub_link_type.fbe_size();

    if ((fbe_current_size + sub_link_id.fbe_size()) > fbe_struct_size)
        return true;
    if (!sub_link_id.verify())
        return false;
    fbe_current_size += sub_link_id.fbe_size();

    if ((fbe_current_size + testexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!testexpr.verify())
        return false;
    fbe_current_size += testexpr.fbe_size();

    if ((fbe_current_size + oper_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!oper_name.verify())
        return false;
    fbe_current_size += oper_name.fbe_size();

    if ((fbe_current_size + subselect.fbe_size()) > fbe_struct_size)
        return true;
    if (!subselect.verify())
        return false;
    fbe_current_size += subselect.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SubLink::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SubLink::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SubLink::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SubLink::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SubLink& fbe_value = static_cast<::pg_query::SubLink&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + sub_link_type.fbe_size()) <= fbe_struct_size)
        {
            sub_link_type.get(fbe_value.sub_link_type);
        }
    else
        fbe_value.sub_link_type = ::pg_query::SubLinkType();
    fbe_current_size += sub_link_type.fbe_size();

    if ((fbe_current_size + sub_link_id.fbe_size()) <= fbe_struct_size)
        {
            sub_link_id.get(fbe_value.sub_link_id);
        }
    else
        fbe_value.sub_link_id = (int32_t)0ll;
    fbe_current_size += sub_link_id.fbe_size();

    if ((fbe_current_size + testexpr.fbe_size()) <= fbe_struct_size)
        {
            testexpr.get(fbe_value.testexpr);
        }
    else
        fbe_value.testexpr = ::pg_query::Node();
    fbe_current_size += testexpr.fbe_size();

    if ((fbe_current_size + oper_name.fbe_size()) <= fbe_struct_size)
        {
            oper_name.get(fbe_value.oper_name);
        }
    else
        fbe_value.oper_name.clear();
    fbe_current_size += oper_name.fbe_size();

    if ((fbe_current_size + subselect.fbe_size()) <= fbe_struct_size)
        {
            subselect.get(fbe_value.subselect);
        }
    else
        fbe_value.subselect = ::pg_query::Node();
    fbe_current_size += subselect.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_SubLink::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SubLink::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SubLink::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SubLink::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SubLink& fbe_value = static_cast<const ::pg_query::SubLink&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    sub_link_type.set(fbe_value.sub_link_type);
    sub_link_id.set(fbe_value.sub_link_id);
    testexpr.set(fbe_value.testexpr);
    oper_name.set(fbe_value.oper_name);
    subselect.set(fbe_value.subselect);
    location.set(fbe_value.location);
}

namespace pg_query {

bool SubLinkModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SubLinkModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SubLinkModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SubLinkModel::serialize(const ::pg_query::SubLink& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SubLinkModel::deserialize(::pg_query::SubLink& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SubPlan::FieldModelPtr_pg_query_SubPlan(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SubPlan::~FieldModelPtr_pg_query_SubPlan()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SubPlan::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SubPlan::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SubPlan::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SubPlan::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SubPlan::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SubPlan::get(::pg_query::SubPlan** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SubPlan(_buffer, 0);

    ::pg_query::SubPlan *tempModel = new ::pg_query::SubPlan();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SubPlan::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SubPlan::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SubPlan::set(const ::pg_query::SubPlan* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SubPlan(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SubPlan::FieldModel_pg_query_SubPlan(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , sub_link_type(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , testexpr(buffer, sub_link_type.fbe_offset() + sub_link_type.fbe_size())
    , param_ids(buffer, testexpr.fbe_offset() + testexpr.fbe_size())
    , plan_id(buffer, param_ids.fbe_offset() + param_ids.fbe_size())
    , plan_name(buffer, plan_id.fbe_offset() + plan_id.fbe_size())
    , first_col_type(buffer, plan_name.fbe_offset() + plan_name.fbe_size())
    , first_col_typmod(buffer, first_col_type.fbe_offset() + first_col_type.fbe_size())
    , first_col_collation(buffer, first_col_typmod.fbe_offset() + first_col_typmod.fbe_size())
    , use_hash_table(buffer, first_col_collation.fbe_offset() + first_col_collation.fbe_size())
    , unknown_eq_false(buffer, use_hash_table.fbe_offset() + use_hash_table.fbe_size())
    , parallel_safe(buffer, unknown_eq_false.fbe_offset() + unknown_eq_false.fbe_size())
    , set_param(buffer, parallel_safe.fbe_offset() + parallel_safe.fbe_size())
    , par_param(buffer, set_param.fbe_offset() + set_param.fbe_size())
    , args(buffer, par_param.fbe_offset() + par_param.fbe_size())
    , startup_cost(buffer, args.fbe_offset() + args.fbe_size())
    , per_call_cost(buffer, startup_cost.fbe_offset() + startup_cost.fbe_size())
{}

size_t FieldModel_pg_query_SubPlan::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + sub_link_type.fbe_size()
        + testexpr.fbe_size()
        + param_ids.fbe_size()
        + plan_id.fbe_size()
        + plan_name.fbe_size()
        + first_col_type.fbe_size()
        + first_col_typmod.fbe_size()
        + first_col_collation.fbe_size()
        + use_hash_table.fbe_size()
        + unknown_eq_false.fbe_size()
        + parallel_safe.fbe_size()
        + set_param.fbe_size()
        + par_param.fbe_size()
        + args.fbe_size()
        + startup_cost.fbe_size()
        + per_call_cost.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SubPlan::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + sub_link_type.fbe_extra()
        + testexpr.fbe_extra()
        + param_ids.fbe_extra()
        + plan_id.fbe_extra()
        + plan_name.fbe_extra()
        + first_col_type.fbe_extra()
        + first_col_typmod.fbe_extra()
        + first_col_collation.fbe_extra()
        + use_hash_table.fbe_extra()
        + unknown_eq_false.fbe_extra()
        + parallel_safe.fbe_extra()
        + set_param.fbe_extra()
        + par_param.fbe_extra()
        + args.fbe_extra()
        + startup_cost.fbe_extra()
        + per_call_cost.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SubPlan::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SubPlan::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + sub_link_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!sub_link_type.verify())
        return false;
    fbe_current_size += sub_link_type.fbe_size();

    if ((fbe_current_size + testexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!testexpr.verify())
        return false;
    fbe_current_size += testexpr.fbe_size();

    if ((fbe_current_size + param_ids.fbe_size()) > fbe_struct_size)
        return true;
    if (!param_ids.verify())
        return false;
    fbe_current_size += param_ids.fbe_size();

    if ((fbe_current_size + plan_id.fbe_size()) > fbe_struct_size)
        return true;
    if (!plan_id.verify())
        return false;
    fbe_current_size += plan_id.fbe_size();

    if ((fbe_current_size + plan_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!plan_name.verify())
        return false;
    fbe_current_size += plan_name.fbe_size();

    if ((fbe_current_size + first_col_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!first_col_type.verify())
        return false;
    fbe_current_size += first_col_type.fbe_size();

    if ((fbe_current_size + first_col_typmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!first_col_typmod.verify())
        return false;
    fbe_current_size += first_col_typmod.fbe_size();

    if ((fbe_current_size + first_col_collation.fbe_size()) > fbe_struct_size)
        return true;
    if (!first_col_collation.verify())
        return false;
    fbe_current_size += first_col_collation.fbe_size();

    if ((fbe_current_size + use_hash_table.fbe_size()) > fbe_struct_size)
        return true;
    if (!use_hash_table.verify())
        return false;
    fbe_current_size += use_hash_table.fbe_size();

    if ((fbe_current_size + unknown_eq_false.fbe_size()) > fbe_struct_size)
        return true;
    if (!unknown_eq_false.verify())
        return false;
    fbe_current_size += unknown_eq_false.fbe_size();

    if ((fbe_current_size + parallel_safe.fbe_size()) > fbe_struct_size)
        return true;
    if (!parallel_safe.verify())
        return false;
    fbe_current_size += parallel_safe.fbe_size();

    if ((fbe_current_size + set_param.fbe_size()) > fbe_struct_size)
        return true;
    if (!set_param.verify())
        return false;
    fbe_current_size += set_param.fbe_size();

    if ((fbe_current_size + par_param.fbe_size()) > fbe_struct_size)
        return true;
    if (!par_param.verify())
        return false;
    fbe_current_size += par_param.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + startup_cost.fbe_size()) > fbe_struct_size)
        return true;
    if (!startup_cost.verify())
        return false;
    fbe_current_size += startup_cost.fbe_size();

    if ((fbe_current_size + per_call_cost.fbe_size()) > fbe_struct_size)
        return true;
    if (!per_call_cost.verify())
        return false;
    fbe_current_size += per_call_cost.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SubPlan::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SubPlan::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SubPlan::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SubPlan::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SubPlan& fbe_value = static_cast<::pg_query::SubPlan&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + sub_link_type.fbe_size()) <= fbe_struct_size)
        {
            sub_link_type.get(fbe_value.sub_link_type);
        }
    else
        fbe_value.sub_link_type = ::pg_query::SubLinkType();
    fbe_current_size += sub_link_type.fbe_size();

    if ((fbe_current_size + testexpr.fbe_size()) <= fbe_struct_size)
        {
            testexpr.get(fbe_value.testexpr);
        }
    else
        fbe_value.testexpr = ::pg_query::Node();
    fbe_current_size += testexpr.fbe_size();

    if ((fbe_current_size + param_ids.fbe_size()) <= fbe_struct_size)
        {
            param_ids.get(fbe_value.param_ids);
        }
    else
        fbe_value.param_ids.clear();
    fbe_current_size += param_ids.fbe_size();

    if ((fbe_current_size + plan_id.fbe_size()) <= fbe_struct_size)
        {
            plan_id.get(fbe_value.plan_id);
        }
    else
        fbe_value.plan_id = (int32_t)0ll;
    fbe_current_size += plan_id.fbe_size();

    if ((fbe_current_size + plan_name.fbe_size()) <= fbe_struct_size)
        {
            plan_name.get(fbe_value.plan_name);
        }
    else
        fbe_value.plan_name = "";
    fbe_current_size += plan_name.fbe_size();

    if ((fbe_current_size + first_col_type.fbe_size()) <= fbe_struct_size)
        {
            first_col_type.get(fbe_value.first_col_type);
        }
    else
        fbe_value.first_col_type = (uint32_t)0ull;
    fbe_current_size += first_col_type.fbe_size();

    if ((fbe_current_size + first_col_typmod.fbe_size()) <= fbe_struct_size)
        {
            first_col_typmod.get(fbe_value.first_col_typmod);
        }
    else
        fbe_value.first_col_typmod = (int32_t)0ll;
    fbe_current_size += first_col_typmod.fbe_size();

    if ((fbe_current_size + first_col_collation.fbe_size()) <= fbe_struct_size)
        {
            first_col_collation.get(fbe_value.first_col_collation);
        }
    else
        fbe_value.first_col_collation = (uint32_t)0ull;
    fbe_current_size += first_col_collation.fbe_size();

    if ((fbe_current_size + use_hash_table.fbe_size()) <= fbe_struct_size)
        {
            use_hash_table.get(fbe_value.use_hash_table);
        }
    else
        fbe_value.use_hash_table = false;
    fbe_current_size += use_hash_table.fbe_size();

    if ((fbe_current_size + unknown_eq_false.fbe_size()) <= fbe_struct_size)
        {
            unknown_eq_false.get(fbe_value.unknown_eq_false);
        }
    else
        fbe_value.unknown_eq_false = false;
    fbe_current_size += unknown_eq_false.fbe_size();

    if ((fbe_current_size + parallel_safe.fbe_size()) <= fbe_struct_size)
        {
            parallel_safe.get(fbe_value.parallel_safe);
        }
    else
        fbe_value.parallel_safe = false;
    fbe_current_size += parallel_safe.fbe_size();

    if ((fbe_current_size + set_param.fbe_size()) <= fbe_struct_size)
        {
            set_param.get(fbe_value.set_param);
        }
    else
        fbe_value.set_param.clear();
    fbe_current_size += set_param.fbe_size();

    if ((fbe_current_size + par_param.fbe_size()) <= fbe_struct_size)
        {
            par_param.get(fbe_value.par_param);
        }
    else
        fbe_value.par_param.clear();
    fbe_current_size += par_param.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + startup_cost.fbe_size()) <= fbe_struct_size)
        {
            startup_cost.get(fbe_value.startup_cost);
        }
    else
        fbe_value.startup_cost = 0.0;
    fbe_current_size += startup_cost.fbe_size();

    if ((fbe_current_size + per_call_cost.fbe_size()) <= fbe_struct_size)
        {
            per_call_cost.get(fbe_value.per_call_cost);
        }
    else
        fbe_value.per_call_cost = 0.0;
    fbe_current_size += per_call_cost.fbe_size();
}

size_t FieldModel_pg_query_SubPlan::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SubPlan::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SubPlan::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SubPlan::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SubPlan& fbe_value = static_cast<const ::pg_query::SubPlan&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    sub_link_type.set(fbe_value.sub_link_type);
    testexpr.set(fbe_value.testexpr);
    param_ids.set(fbe_value.param_ids);
    plan_id.set(fbe_value.plan_id);
    plan_name.set(fbe_value.plan_name);
    first_col_type.set(fbe_value.first_col_type);
    first_col_typmod.set(fbe_value.first_col_typmod);
    first_col_collation.set(fbe_value.first_col_collation);
    use_hash_table.set(fbe_value.use_hash_table);
    unknown_eq_false.set(fbe_value.unknown_eq_false);
    parallel_safe.set(fbe_value.parallel_safe);
    set_param.set(fbe_value.set_param);
    par_param.set(fbe_value.par_param);
    args.set(fbe_value.args);
    startup_cost.set(fbe_value.startup_cost);
    per_call_cost.set(fbe_value.per_call_cost);
}

namespace pg_query {

bool SubPlanModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SubPlanModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SubPlanModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SubPlanModel::serialize(const ::pg_query::SubPlan& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SubPlanModel::deserialize(::pg_query::SubPlan& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlternativeSubPlan::FieldModelPtr_pg_query_AlternativeSubPlan(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlternativeSubPlan::~FieldModelPtr_pg_query_AlternativeSubPlan()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlternativeSubPlan::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlternativeSubPlan::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlternativeSubPlan::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlternativeSubPlan::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlternativeSubPlan::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlternativeSubPlan::get(::pg_query::AlternativeSubPlan** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlternativeSubPlan(_buffer, 0);

    ::pg_query::AlternativeSubPlan *tempModel = new ::pg_query::AlternativeSubPlan();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlternativeSubPlan::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlternativeSubPlan::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlternativeSubPlan::set(const ::pg_query::AlternativeSubPlan* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlternativeSubPlan(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlternativeSubPlan::FieldModel_pg_query_AlternativeSubPlan(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , subplans(buffer, xpr.fbe_offset() + xpr.fbe_size())
{}

size_t FieldModel_pg_query_AlternativeSubPlan::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + subplans.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlternativeSubPlan::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + subplans.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlternativeSubPlan::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlternativeSubPlan::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + subplans.fbe_size()) > fbe_struct_size)
        return true;
    if (!subplans.verify())
        return false;
    fbe_current_size += subplans.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlternativeSubPlan::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlternativeSubPlan::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlternativeSubPlan::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlternativeSubPlan::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlternativeSubPlan& fbe_value = static_cast<::pg_query::AlternativeSubPlan&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + subplans.fbe_size()) <= fbe_struct_size)
        {
            subplans.get(fbe_value.subplans);
        }
    else
        fbe_value.subplans.clear();
    fbe_current_size += subplans.fbe_size();
}

size_t FieldModel_pg_query_AlternativeSubPlan::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlternativeSubPlan::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlternativeSubPlan::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlternativeSubPlan::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlternativeSubPlan& fbe_value = static_cast<const ::pg_query::AlternativeSubPlan&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    subplans.set(fbe_value.subplans);
}

namespace pg_query {

bool AlternativeSubPlanModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlternativeSubPlanModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlternativeSubPlanModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlternativeSubPlanModel::serialize(const ::pg_query::AlternativeSubPlan& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlternativeSubPlanModel::deserialize(::pg_query::AlternativeSubPlan& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_FieldSelect::FieldModelPtr_pg_query_FieldSelect(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_FieldSelect::~FieldModelPtr_pg_query_FieldSelect()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_FieldSelect::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_FieldSelect::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_FieldSelect::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_FieldSelect::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FieldSelect::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FieldSelect::get(::pg_query::FieldSelect** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_FieldSelect(_buffer, 0);

    ::pg_query::FieldSelect *tempModel = new ::pg_query::FieldSelect();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_FieldSelect::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FieldSelect::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FieldSelect::set(const ::pg_query::FieldSelect* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_FieldSelect(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_FieldSelect::FieldModel_pg_query_FieldSelect(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , fieldnum(buffer, arg.fbe_offset() + arg.fbe_size())
    , resulttype(buffer, fieldnum.fbe_offset() + fieldnum.fbe_size())
    , resulttypmod(buffer, resulttype.fbe_offset() + resulttype.fbe_size())
    , resultcollid(buffer, resulttypmod.fbe_offset() + resulttypmod.fbe_size())
{}

size_t FieldModel_pg_query_FieldSelect::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + fieldnum.fbe_size()
        + resulttype.fbe_size()
        + resulttypmod.fbe_size()
        + resultcollid.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_FieldSelect::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + fieldnum.fbe_extra()
        + resulttype.fbe_extra()
        + resulttypmod.fbe_extra()
        + resultcollid.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_FieldSelect::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_FieldSelect::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + fieldnum.fbe_size()) > fbe_struct_size)
        return true;
    if (!fieldnum.verify())
        return false;
    fbe_current_size += fieldnum.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttype.verify())
        return false;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resulttypmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttypmod.verify())
        return false;
    fbe_current_size += resulttypmod.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!resultcollid.verify())
        return false;
    fbe_current_size += resultcollid.fbe_size();

    return true;
}

size_t FieldModel_pg_query_FieldSelect::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FieldSelect::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FieldSelect::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_FieldSelect::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::FieldSelect& fbe_value = static_cast<::pg_query::FieldSelect&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + fieldnum.fbe_size()) <= fbe_struct_size)
        {
            fieldnum.get(fbe_value.fieldnum);
        }
    else
        fbe_value.fieldnum = (int32_t)0ll;
    fbe_current_size += fieldnum.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) <= fbe_struct_size)
        {
            resulttype.get(fbe_value.resulttype);
        }
    else
        fbe_value.resulttype = (uint32_t)0ull;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resulttypmod.fbe_size()) <= fbe_struct_size)
        {
            resulttypmod.get(fbe_value.resulttypmod);
        }
    else
        fbe_value.resulttypmod = (int32_t)0ll;
    fbe_current_size += resulttypmod.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) <= fbe_struct_size)
        {
            resultcollid.get(fbe_value.resultcollid);
        }
    else
        fbe_value.resultcollid = (uint32_t)0ull;
    fbe_current_size += resultcollid.fbe_size();
}

size_t FieldModel_pg_query_FieldSelect::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FieldSelect::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FieldSelect::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_FieldSelect::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::FieldSelect& fbe_value = static_cast<const ::pg_query::FieldSelect&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    fieldnum.set(fbe_value.fieldnum);
    resulttype.set(fbe_value.resulttype);
    resulttypmod.set(fbe_value.resulttypmod);
    resultcollid.set(fbe_value.resultcollid);
}

namespace pg_query {

bool FieldSelectModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t FieldSelectModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t FieldSelectModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t FieldSelectModel::serialize(const ::pg_query::FieldSelect& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t FieldSelectModel::deserialize(::pg_query::FieldSelect& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_FieldStore::FieldModelPtr_pg_query_FieldStore(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_FieldStore::~FieldModelPtr_pg_query_FieldStore()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_FieldStore::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_FieldStore::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_FieldStore::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_FieldStore::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FieldStore::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FieldStore::get(::pg_query::FieldStore** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_FieldStore(_buffer, 0);

    ::pg_query::FieldStore *tempModel = new ::pg_query::FieldStore();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_FieldStore::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FieldStore::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FieldStore::set(const ::pg_query::FieldStore* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_FieldStore(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_FieldStore::FieldModel_pg_query_FieldStore(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , newvals(buffer, arg.fbe_offset() + arg.fbe_size())
    , fieldnums(buffer, newvals.fbe_offset() + newvals.fbe_size())
    , resulttype(buffer, fieldnums.fbe_offset() + fieldnums.fbe_size())
{}

size_t FieldModel_pg_query_FieldStore::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + newvals.fbe_size()
        + fieldnums.fbe_size()
        + resulttype.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_FieldStore::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + newvals.fbe_extra()
        + fieldnums.fbe_extra()
        + resulttype.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_FieldStore::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_FieldStore::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + newvals.fbe_size()) > fbe_struct_size)
        return true;
    if (!newvals.verify())
        return false;
    fbe_current_size += newvals.fbe_size();

    if ((fbe_current_size + fieldnums.fbe_size()) > fbe_struct_size)
        return true;
    if (!fieldnums.verify())
        return false;
    fbe_current_size += fieldnums.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttype.verify())
        return false;
    fbe_current_size += resulttype.fbe_size();

    return true;
}

size_t FieldModel_pg_query_FieldStore::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FieldStore::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FieldStore::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_FieldStore::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::FieldStore& fbe_value = static_cast<::pg_query::FieldStore&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + newvals.fbe_size()) <= fbe_struct_size)
        {
            newvals.get(fbe_value.newvals);
        }
    else
        fbe_value.newvals.clear();
    fbe_current_size += newvals.fbe_size();

    if ((fbe_current_size + fieldnums.fbe_size()) <= fbe_struct_size)
        {
            fieldnums.get(fbe_value.fieldnums);
        }
    else
        fbe_value.fieldnums.clear();
    fbe_current_size += fieldnums.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) <= fbe_struct_size)
        {
            resulttype.get(fbe_value.resulttype);
        }
    else
        fbe_value.resulttype = (uint32_t)0ull;
    fbe_current_size += resulttype.fbe_size();
}

size_t FieldModel_pg_query_FieldStore::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FieldStore::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FieldStore::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_FieldStore::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::FieldStore& fbe_value = static_cast<const ::pg_query::FieldStore&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    newvals.set(fbe_value.newvals);
    fieldnums.set(fbe_value.fieldnums);
    resulttype.set(fbe_value.resulttype);
}

namespace pg_query {

bool FieldStoreModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t FieldStoreModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t FieldStoreModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t FieldStoreModel::serialize(const ::pg_query::FieldStore& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t FieldStoreModel::deserialize(::pg_query::FieldStore& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RelabelType::FieldModelPtr_pg_query_RelabelType(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RelabelType::~FieldModelPtr_pg_query_RelabelType()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RelabelType::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RelabelType::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RelabelType::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RelabelType::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RelabelType::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RelabelType::get(::pg_query::RelabelType** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RelabelType(_buffer, 0);

    ::pg_query::RelabelType *tempModel = new ::pg_query::RelabelType();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RelabelType::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RelabelType::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RelabelType::set(const ::pg_query::RelabelType* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RelabelType(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RelabelType::FieldModel_pg_query_RelabelType(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , resulttype(buffer, arg.fbe_offset() + arg.fbe_size())
    , resulttypmod(buffer, resulttype.fbe_offset() + resulttype.fbe_size())
    , resultcollid(buffer, resulttypmod.fbe_offset() + resulttypmod.fbe_size())
    , relabelformat(buffer, resultcollid.fbe_offset() + resultcollid.fbe_size())
    , location(buffer, relabelformat.fbe_offset() + relabelformat.fbe_size())
{}

size_t FieldModel_pg_query_RelabelType::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + resulttype.fbe_size()
        + resulttypmod.fbe_size()
        + resultcollid.fbe_size()
        + relabelformat.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RelabelType::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + resulttype.fbe_extra()
        + resulttypmod.fbe_extra()
        + resultcollid.fbe_extra()
        + relabelformat.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RelabelType::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RelabelType::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttype.verify())
        return false;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resulttypmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttypmod.verify())
        return false;
    fbe_current_size += resulttypmod.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!resultcollid.verify())
        return false;
    fbe_current_size += resultcollid.fbe_size();

    if ((fbe_current_size + relabelformat.fbe_size()) > fbe_struct_size)
        return true;
    if (!relabelformat.verify())
        return false;
    fbe_current_size += relabelformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RelabelType::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RelabelType::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RelabelType::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RelabelType::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RelabelType& fbe_value = static_cast<::pg_query::RelabelType&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) <= fbe_struct_size)
        {
            resulttype.get(fbe_value.resulttype);
        }
    else
        fbe_value.resulttype = (uint32_t)0ull;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resulttypmod.fbe_size()) <= fbe_struct_size)
        {
            resulttypmod.get(fbe_value.resulttypmod);
        }
    else
        fbe_value.resulttypmod = (int32_t)0ll;
    fbe_current_size += resulttypmod.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) <= fbe_struct_size)
        {
            resultcollid.get(fbe_value.resultcollid);
        }
    else
        fbe_value.resultcollid = (uint32_t)0ull;
    fbe_current_size += resultcollid.fbe_size();

    if ((fbe_current_size + relabelformat.fbe_size()) <= fbe_struct_size)
        {
            relabelformat.get(fbe_value.relabelformat);
        }
    else
        fbe_value.relabelformat = ::pg_query::CoercionForm();
    fbe_current_size += relabelformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_RelabelType::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RelabelType::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RelabelType::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RelabelType::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RelabelType& fbe_value = static_cast<const ::pg_query::RelabelType&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    resulttype.set(fbe_value.resulttype);
    resulttypmod.set(fbe_value.resulttypmod);
    resultcollid.set(fbe_value.resultcollid);
    relabelformat.set(fbe_value.relabelformat);
    location.set(fbe_value.location);
}

namespace pg_query {

bool RelabelTypeModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RelabelTypeModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RelabelTypeModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RelabelTypeModel::serialize(const ::pg_query::RelabelType& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RelabelTypeModel::deserialize(::pg_query::RelabelType& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CoerceViaIO::FieldModelPtr_pg_query_CoerceViaIO(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CoerceViaIO::~FieldModelPtr_pg_query_CoerceViaIO()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CoerceViaIO::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CoerceViaIO::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CoerceViaIO::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CoerceViaIO::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CoerceViaIO::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CoerceViaIO::get(::pg_query::CoerceViaIO** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CoerceViaIO(_buffer, 0);

    ::pg_query::CoerceViaIO *tempModel = new ::pg_query::CoerceViaIO();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CoerceViaIO::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CoerceViaIO::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CoerceViaIO::set(const ::pg_query::CoerceViaIO* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CoerceViaIO(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CoerceViaIO::FieldModel_pg_query_CoerceViaIO(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , resulttype(buffer, arg.fbe_offset() + arg.fbe_size())
    , resultcollid(buffer, resulttype.fbe_offset() + resulttype.fbe_size())
    , coerceformat(buffer, resultcollid.fbe_offset() + resultcollid.fbe_size())
    , location(buffer, coerceformat.fbe_offset() + coerceformat.fbe_size())
{}

size_t FieldModel_pg_query_CoerceViaIO::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + resulttype.fbe_size()
        + resultcollid.fbe_size()
        + coerceformat.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CoerceViaIO::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + resulttype.fbe_extra()
        + resultcollid.fbe_extra()
        + coerceformat.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CoerceViaIO::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CoerceViaIO::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttype.verify())
        return false;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!resultcollid.verify())
        return false;
    fbe_current_size += resultcollid.fbe_size();

    if ((fbe_current_size + coerceformat.fbe_size()) > fbe_struct_size)
        return true;
    if (!coerceformat.verify())
        return false;
    fbe_current_size += coerceformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CoerceViaIO::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CoerceViaIO::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CoerceViaIO::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CoerceViaIO::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CoerceViaIO& fbe_value = static_cast<::pg_query::CoerceViaIO&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) <= fbe_struct_size)
        {
            resulttype.get(fbe_value.resulttype);
        }
    else
        fbe_value.resulttype = (uint32_t)0ull;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) <= fbe_struct_size)
        {
            resultcollid.get(fbe_value.resultcollid);
        }
    else
        fbe_value.resultcollid = (uint32_t)0ull;
    fbe_current_size += resultcollid.fbe_size();

    if ((fbe_current_size + coerceformat.fbe_size()) <= fbe_struct_size)
        {
            coerceformat.get(fbe_value.coerceformat);
        }
    else
        fbe_value.coerceformat = ::pg_query::CoercionForm();
    fbe_current_size += coerceformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_CoerceViaIO::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CoerceViaIO::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CoerceViaIO::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CoerceViaIO::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CoerceViaIO& fbe_value = static_cast<const ::pg_query::CoerceViaIO&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    resulttype.set(fbe_value.resulttype);
    resultcollid.set(fbe_value.resultcollid);
    coerceformat.set(fbe_value.coerceformat);
    location.set(fbe_value.location);
}

namespace pg_query {

bool CoerceViaIOModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CoerceViaIOModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CoerceViaIOModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CoerceViaIOModel::serialize(const ::pg_query::CoerceViaIO& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CoerceViaIOModel::deserialize(::pg_query::CoerceViaIO& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ArrayCoerceExpr::FieldModelPtr_pg_query_ArrayCoerceExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ArrayCoerceExpr::~FieldModelPtr_pg_query_ArrayCoerceExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ArrayCoerceExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ArrayCoerceExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ArrayCoerceExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ArrayCoerceExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ArrayCoerceExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ArrayCoerceExpr::get(::pg_query::ArrayCoerceExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ArrayCoerceExpr(_buffer, 0);

    ::pg_query::ArrayCoerceExpr *tempModel = new ::pg_query::ArrayCoerceExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ArrayCoerceExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ArrayCoerceExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ArrayCoerceExpr::set(const ::pg_query::ArrayCoerceExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ArrayCoerceExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ArrayCoerceExpr::FieldModel_pg_query_ArrayCoerceExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , elemexpr(buffer, arg.fbe_offset() + arg.fbe_size())
    , resulttype(buffer, elemexpr.fbe_offset() + elemexpr.fbe_size())
    , resulttypmod(buffer, resulttype.fbe_offset() + resulttype.fbe_size())
    , resultcollid(buffer, resulttypmod.fbe_offset() + resulttypmod.fbe_size())
    , coerceformat(buffer, resultcollid.fbe_offset() + resultcollid.fbe_size())
    , location(buffer, coerceformat.fbe_offset() + coerceformat.fbe_size())
{}

size_t FieldModel_pg_query_ArrayCoerceExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + elemexpr.fbe_size()
        + resulttype.fbe_size()
        + resulttypmod.fbe_size()
        + resultcollid.fbe_size()
        + coerceformat.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ArrayCoerceExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + elemexpr.fbe_extra()
        + resulttype.fbe_extra()
        + resulttypmod.fbe_extra()
        + resultcollid.fbe_extra()
        + coerceformat.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ArrayCoerceExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ArrayCoerceExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + elemexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!elemexpr.verify())
        return false;
    fbe_current_size += elemexpr.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttype.verify())
        return false;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resulttypmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttypmod.verify())
        return false;
    fbe_current_size += resulttypmod.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!resultcollid.verify())
        return false;
    fbe_current_size += resultcollid.fbe_size();

    if ((fbe_current_size + coerceformat.fbe_size()) > fbe_struct_size)
        return true;
    if (!coerceformat.verify())
        return false;
    fbe_current_size += coerceformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ArrayCoerceExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ArrayCoerceExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ArrayCoerceExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ArrayCoerceExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ArrayCoerceExpr& fbe_value = static_cast<::pg_query::ArrayCoerceExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + elemexpr.fbe_size()) <= fbe_struct_size)
        {
            elemexpr.get(fbe_value.elemexpr);
        }
    else
        fbe_value.elemexpr = ::pg_query::Node();
    fbe_current_size += elemexpr.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) <= fbe_struct_size)
        {
            resulttype.get(fbe_value.resulttype);
        }
    else
        fbe_value.resulttype = (uint32_t)0ull;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resulttypmod.fbe_size()) <= fbe_struct_size)
        {
            resulttypmod.get(fbe_value.resulttypmod);
        }
    else
        fbe_value.resulttypmod = (int32_t)0ll;
    fbe_current_size += resulttypmod.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) <= fbe_struct_size)
        {
            resultcollid.get(fbe_value.resultcollid);
        }
    else
        fbe_value.resultcollid = (uint32_t)0ull;
    fbe_current_size += resultcollid.fbe_size();

    if ((fbe_current_size + coerceformat.fbe_size()) <= fbe_struct_size)
        {
            coerceformat.get(fbe_value.coerceformat);
        }
    else
        fbe_value.coerceformat = ::pg_query::CoercionForm();
    fbe_current_size += coerceformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_ArrayCoerceExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ArrayCoerceExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ArrayCoerceExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ArrayCoerceExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ArrayCoerceExpr& fbe_value = static_cast<const ::pg_query::ArrayCoerceExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    elemexpr.set(fbe_value.elemexpr);
    resulttype.set(fbe_value.resulttype);
    resulttypmod.set(fbe_value.resulttypmod);
    resultcollid.set(fbe_value.resultcollid);
    coerceformat.set(fbe_value.coerceformat);
    location.set(fbe_value.location);
}

namespace pg_query {

bool ArrayCoerceExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ArrayCoerceExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ArrayCoerceExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ArrayCoerceExprModel::serialize(const ::pg_query::ArrayCoerceExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ArrayCoerceExprModel::deserialize(::pg_query::ArrayCoerceExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ConvertRowtypeExpr::FieldModelPtr_pg_query_ConvertRowtypeExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ConvertRowtypeExpr::~FieldModelPtr_pg_query_ConvertRowtypeExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ConvertRowtypeExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ConvertRowtypeExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ConvertRowtypeExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ConvertRowtypeExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ConvertRowtypeExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ConvertRowtypeExpr::get(::pg_query::ConvertRowtypeExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ConvertRowtypeExpr(_buffer, 0);

    ::pg_query::ConvertRowtypeExpr *tempModel = new ::pg_query::ConvertRowtypeExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ConvertRowtypeExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ConvertRowtypeExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ConvertRowtypeExpr::set(const ::pg_query::ConvertRowtypeExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ConvertRowtypeExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ConvertRowtypeExpr::FieldModel_pg_query_ConvertRowtypeExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , resulttype(buffer, arg.fbe_offset() + arg.fbe_size())
    , convertformat(buffer, resulttype.fbe_offset() + resulttype.fbe_size())
    , location(buffer, convertformat.fbe_offset() + convertformat.fbe_size())
{}

size_t FieldModel_pg_query_ConvertRowtypeExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + resulttype.fbe_size()
        + convertformat.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ConvertRowtypeExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + resulttype.fbe_extra()
        + convertformat.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ConvertRowtypeExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ConvertRowtypeExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttype.verify())
        return false;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + convertformat.fbe_size()) > fbe_struct_size)
        return true;
    if (!convertformat.verify())
        return false;
    fbe_current_size += convertformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ConvertRowtypeExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ConvertRowtypeExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ConvertRowtypeExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ConvertRowtypeExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ConvertRowtypeExpr& fbe_value = static_cast<::pg_query::ConvertRowtypeExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) <= fbe_struct_size)
        {
            resulttype.get(fbe_value.resulttype);
        }
    else
        fbe_value.resulttype = (uint32_t)0ull;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + convertformat.fbe_size()) <= fbe_struct_size)
        {
            convertformat.get(fbe_value.convertformat);
        }
    else
        fbe_value.convertformat = ::pg_query::CoercionForm();
    fbe_current_size += convertformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_ConvertRowtypeExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ConvertRowtypeExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ConvertRowtypeExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ConvertRowtypeExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ConvertRowtypeExpr& fbe_value = static_cast<const ::pg_query::ConvertRowtypeExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    resulttype.set(fbe_value.resulttype);
    convertformat.set(fbe_value.convertformat);
    location.set(fbe_value.location);
}

namespace pg_query {

bool ConvertRowtypeExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ConvertRowtypeExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ConvertRowtypeExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ConvertRowtypeExprModel::serialize(const ::pg_query::ConvertRowtypeExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ConvertRowtypeExprModel::deserialize(::pg_query::ConvertRowtypeExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CollateExpr::FieldModelPtr_pg_query_CollateExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CollateExpr::~FieldModelPtr_pg_query_CollateExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CollateExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CollateExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CollateExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CollateExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CollateExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CollateExpr::get(::pg_query::CollateExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CollateExpr(_buffer, 0);

    ::pg_query::CollateExpr *tempModel = new ::pg_query::CollateExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CollateExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CollateExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CollateExpr::set(const ::pg_query::CollateExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CollateExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CollateExpr::FieldModel_pg_query_CollateExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , coll_oid(buffer, arg.fbe_offset() + arg.fbe_size())
    , location(buffer, coll_oid.fbe_offset() + coll_oid.fbe_size())
{}

size_t FieldModel_pg_query_CollateExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + coll_oid.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CollateExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + coll_oid.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CollateExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CollateExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + coll_oid.fbe_size()) > fbe_struct_size)
        return true;
    if (!coll_oid.verify())
        return false;
    fbe_current_size += coll_oid.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CollateExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CollateExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CollateExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CollateExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CollateExpr& fbe_value = static_cast<::pg_query::CollateExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + coll_oid.fbe_size()) <= fbe_struct_size)
        {
            coll_oid.get(fbe_value.coll_oid);
        }
    else
        fbe_value.coll_oid = (uint32_t)0ull;
    fbe_current_size += coll_oid.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_CollateExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CollateExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CollateExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CollateExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CollateExpr& fbe_value = static_cast<const ::pg_query::CollateExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    coll_oid.set(fbe_value.coll_oid);
    location.set(fbe_value.location);
}

namespace pg_query {

bool CollateExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CollateExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CollateExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CollateExprModel::serialize(const ::pg_query::CollateExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CollateExprModel::deserialize(::pg_query::CollateExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CaseExpr::FieldModelPtr_pg_query_CaseExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CaseExpr::~FieldModelPtr_pg_query_CaseExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CaseExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CaseExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CaseExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CaseExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CaseExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CaseExpr::get(::pg_query::CaseExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CaseExpr(_buffer, 0);

    ::pg_query::CaseExpr *tempModel = new ::pg_query::CaseExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CaseExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CaseExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CaseExpr::set(const ::pg_query::CaseExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CaseExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CaseExpr::FieldModel_pg_query_CaseExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , casetype(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , casecollid(buffer, casetype.fbe_offset() + casetype.fbe_size())
    , arg(buffer, casecollid.fbe_offset() + casecollid.fbe_size())
    , args(buffer, arg.fbe_offset() + arg.fbe_size())
    , defresult(buffer, args.fbe_offset() + args.fbe_size())
    , location(buffer, defresult.fbe_offset() + defresult.fbe_size())
{}

size_t FieldModel_pg_query_CaseExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + casetype.fbe_size()
        + casecollid.fbe_size()
        + arg.fbe_size()
        + args.fbe_size()
        + defresult.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CaseExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + casetype.fbe_extra()
        + casecollid.fbe_extra()
        + arg.fbe_extra()
        + args.fbe_extra()
        + defresult.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CaseExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CaseExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + casetype.fbe_size()) > fbe_struct_size)
        return true;
    if (!casetype.verify())
        return false;
    fbe_current_size += casetype.fbe_size();

    if ((fbe_current_size + casecollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!casecollid.verify())
        return false;
    fbe_current_size += casecollid.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + defresult.fbe_size()) > fbe_struct_size)
        return true;
    if (!defresult.verify())
        return false;
    fbe_current_size += defresult.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CaseExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CaseExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CaseExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CaseExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CaseExpr& fbe_value = static_cast<::pg_query::CaseExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + casetype.fbe_size()) <= fbe_struct_size)
        {
            casetype.get(fbe_value.casetype);
        }
    else
        fbe_value.casetype = (uint32_t)0ull;
    fbe_current_size += casetype.fbe_size();

    if ((fbe_current_size + casecollid.fbe_size()) <= fbe_struct_size)
        {
            casecollid.get(fbe_value.casecollid);
        }
    else
        fbe_value.casecollid = (uint32_t)0ull;
    fbe_current_size += casecollid.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + defresult.fbe_size()) <= fbe_struct_size)
        {
            defresult.get(fbe_value.defresult);
        }
    else
        fbe_value.defresult = ::pg_query::Node();
    fbe_current_size += defresult.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_CaseExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CaseExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CaseExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CaseExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CaseExpr& fbe_value = static_cast<const ::pg_query::CaseExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    casetype.set(fbe_value.casetype);
    casecollid.set(fbe_value.casecollid);
    arg.set(fbe_value.arg);
    args.set(fbe_value.args);
    defresult.set(fbe_value.defresult);
    location.set(fbe_value.location);
}

namespace pg_query {

bool CaseExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CaseExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CaseExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CaseExprModel::serialize(const ::pg_query::CaseExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CaseExprModel::deserialize(::pg_query::CaseExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CaseWhen::FieldModelPtr_pg_query_CaseWhen(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CaseWhen::~FieldModelPtr_pg_query_CaseWhen()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CaseWhen::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CaseWhen::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CaseWhen::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CaseWhen::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CaseWhen::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CaseWhen::get(::pg_query::CaseWhen** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CaseWhen(_buffer, 0);

    ::pg_query::CaseWhen *tempModel = new ::pg_query::CaseWhen();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CaseWhen::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CaseWhen::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CaseWhen::set(const ::pg_query::CaseWhen* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CaseWhen(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CaseWhen::FieldModel_pg_query_CaseWhen(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , expr(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , result(buffer, expr.fbe_offset() + expr.fbe_size())
    , location(buffer, result.fbe_offset() + result.fbe_size())
{}

size_t FieldModel_pg_query_CaseWhen::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + expr.fbe_size()
        + result.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CaseWhen::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + expr.fbe_extra()
        + result.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CaseWhen::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CaseWhen::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) > fbe_struct_size)
        return true;
    if (!expr.verify())
        return false;
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + result.fbe_size()) > fbe_struct_size)
        return true;
    if (!result.verify())
        return false;
    fbe_current_size += result.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CaseWhen::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CaseWhen::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CaseWhen::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CaseWhen::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CaseWhen& fbe_value = static_cast<::pg_query::CaseWhen&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) <= fbe_struct_size)
        {
            expr.get(fbe_value.expr);
        }
    else
        fbe_value.expr = ::pg_query::Node();
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + result.fbe_size()) <= fbe_struct_size)
        {
            result.get(fbe_value.result);
        }
    else
        fbe_value.result = ::pg_query::Node();
    fbe_current_size += result.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_CaseWhen::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CaseWhen::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CaseWhen::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CaseWhen::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CaseWhen& fbe_value = static_cast<const ::pg_query::CaseWhen&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    expr.set(fbe_value.expr);
    result.set(fbe_value.result);
    location.set(fbe_value.location);
}

namespace pg_query {

bool CaseWhenModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CaseWhenModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CaseWhenModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CaseWhenModel::serialize(const ::pg_query::CaseWhen& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CaseWhenModel::deserialize(::pg_query::CaseWhen& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CaseTestExpr::FieldModelPtr_pg_query_CaseTestExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CaseTestExpr::~FieldModelPtr_pg_query_CaseTestExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CaseTestExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CaseTestExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CaseTestExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CaseTestExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CaseTestExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CaseTestExpr::get(::pg_query::CaseTestExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CaseTestExpr(_buffer, 0);

    ::pg_query::CaseTestExpr *tempModel = new ::pg_query::CaseTestExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CaseTestExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CaseTestExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CaseTestExpr::set(const ::pg_query::CaseTestExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CaseTestExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CaseTestExpr::FieldModel_pg_query_CaseTestExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , type_id(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , type_mod(buffer, type_id.fbe_offset() + type_id.fbe_size())
    , collation(buffer, type_mod.fbe_offset() + type_mod.fbe_size())
{}

size_t FieldModel_pg_query_CaseTestExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + type_id.fbe_size()
        + type_mod.fbe_size()
        + collation.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CaseTestExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + type_id.fbe_extra()
        + type_mod.fbe_extra()
        + collation.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CaseTestExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CaseTestExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + type_id.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_id.verify())
        return false;
    fbe_current_size += type_id.fbe_size();

    if ((fbe_current_size + type_mod.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_mod.verify())
        return false;
    fbe_current_size += type_mod.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) > fbe_struct_size)
        return true;
    if (!collation.verify())
        return false;
    fbe_current_size += collation.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CaseTestExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CaseTestExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CaseTestExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CaseTestExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CaseTestExpr& fbe_value = static_cast<::pg_query::CaseTestExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + type_id.fbe_size()) <= fbe_struct_size)
        {
            type_id.get(fbe_value.type_id);
        }
    else
        fbe_value.type_id = (uint32_t)0ull;
    fbe_current_size += type_id.fbe_size();

    if ((fbe_current_size + type_mod.fbe_size()) <= fbe_struct_size)
        {
            type_mod.get(fbe_value.type_mod);
        }
    else
        fbe_value.type_mod = (int32_t)0ll;
    fbe_current_size += type_mod.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) <= fbe_struct_size)
        {
            collation.get(fbe_value.collation);
        }
    else
        fbe_value.collation = (uint32_t)0ull;
    fbe_current_size += collation.fbe_size();
}

size_t FieldModel_pg_query_CaseTestExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CaseTestExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CaseTestExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CaseTestExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CaseTestExpr& fbe_value = static_cast<const ::pg_query::CaseTestExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    type_id.set(fbe_value.type_id);
    type_mod.set(fbe_value.type_mod);
    collation.set(fbe_value.collation);
}

namespace pg_query {

bool CaseTestExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CaseTestExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CaseTestExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CaseTestExprModel::serialize(const ::pg_query::CaseTestExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CaseTestExprModel::deserialize(::pg_query::CaseTestExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ArrayExpr::FieldModelPtr_pg_query_ArrayExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ArrayExpr::~FieldModelPtr_pg_query_ArrayExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ArrayExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ArrayExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ArrayExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ArrayExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ArrayExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ArrayExpr::get(::pg_query::ArrayExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ArrayExpr(_buffer, 0);

    ::pg_query::ArrayExpr *tempModel = new ::pg_query::ArrayExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ArrayExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ArrayExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ArrayExpr::set(const ::pg_query::ArrayExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ArrayExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ArrayExpr::FieldModel_pg_query_ArrayExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , array_typeid(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , array_collid(buffer, array_typeid.fbe_offset() + array_typeid.fbe_size())
    , element_typeid(buffer, array_collid.fbe_offset() + array_collid.fbe_size())
    , elements(buffer, element_typeid.fbe_offset() + element_typeid.fbe_size())
    , multidims(buffer, elements.fbe_offset() + elements.fbe_size())
    , location(buffer, multidims.fbe_offset() + multidims.fbe_size())
{}

size_t FieldModel_pg_query_ArrayExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + array_typeid.fbe_size()
        + array_collid.fbe_size()
        + element_typeid.fbe_size()
        + elements.fbe_size()
        + multidims.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ArrayExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + array_typeid.fbe_extra()
        + array_collid.fbe_extra()
        + element_typeid.fbe_extra()
        + elements.fbe_extra()
        + multidims.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ArrayExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ArrayExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + array_typeid.fbe_size()) > fbe_struct_size)
        return true;
    if (!array_typeid.verify())
        return false;
    fbe_current_size += array_typeid.fbe_size();

    if ((fbe_current_size + array_collid.fbe_size()) > fbe_struct_size)
        return true;
    if (!array_collid.verify())
        return false;
    fbe_current_size += array_collid.fbe_size();

    if ((fbe_current_size + element_typeid.fbe_size()) > fbe_struct_size)
        return true;
    if (!element_typeid.verify())
        return false;
    fbe_current_size += element_typeid.fbe_size();

    if ((fbe_current_size + elements.fbe_size()) > fbe_struct_size)
        return true;
    if (!elements.verify())
        return false;
    fbe_current_size += elements.fbe_size();

    if ((fbe_current_size + multidims.fbe_size()) > fbe_struct_size)
        return true;
    if (!multidims.verify())
        return false;
    fbe_current_size += multidims.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ArrayExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ArrayExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ArrayExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ArrayExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ArrayExpr& fbe_value = static_cast<::pg_query::ArrayExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + array_typeid.fbe_size()) <= fbe_struct_size)
        {
            array_typeid.get(fbe_value.array_typeid);
        }
    else
        fbe_value.array_typeid = (uint32_t)0ull;
    fbe_current_size += array_typeid.fbe_size();

    if ((fbe_current_size + array_collid.fbe_size()) <= fbe_struct_size)
        {
            array_collid.get(fbe_value.array_collid);
        }
    else
        fbe_value.array_collid = (uint32_t)0ull;
    fbe_current_size += array_collid.fbe_size();

    if ((fbe_current_size + element_typeid.fbe_size()) <= fbe_struct_size)
        {
            element_typeid.get(fbe_value.element_typeid);
        }
    else
        fbe_value.element_typeid = (uint32_t)0ull;
    fbe_current_size += element_typeid.fbe_size();

    if ((fbe_current_size + elements.fbe_size()) <= fbe_struct_size)
        {
            elements.get(fbe_value.elements);
        }
    else
        fbe_value.elements.clear();
    fbe_current_size += elements.fbe_size();

    if ((fbe_current_size + multidims.fbe_size()) <= fbe_struct_size)
        {
            multidims.get(fbe_value.multidims);
        }
    else
        fbe_value.multidims = false;
    fbe_current_size += multidims.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_ArrayExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ArrayExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ArrayExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ArrayExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ArrayExpr& fbe_value = static_cast<const ::pg_query::ArrayExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    array_typeid.set(fbe_value.array_typeid);
    array_collid.set(fbe_value.array_collid);
    element_typeid.set(fbe_value.element_typeid);
    elements.set(fbe_value.elements);
    multidims.set(fbe_value.multidims);
    location.set(fbe_value.location);
}

namespace pg_query {

bool ArrayExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ArrayExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ArrayExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ArrayExprModel::serialize(const ::pg_query::ArrayExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ArrayExprModel::deserialize(::pg_query::ArrayExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RowExpr::FieldModelPtr_pg_query_RowExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RowExpr::~FieldModelPtr_pg_query_RowExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RowExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RowExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RowExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RowExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RowExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RowExpr::get(::pg_query::RowExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RowExpr(_buffer, 0);

    ::pg_query::RowExpr *tempModel = new ::pg_query::RowExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RowExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RowExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RowExpr::set(const ::pg_query::RowExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RowExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RowExpr::FieldModel_pg_query_RowExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , args(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , row_typeid(buffer, args.fbe_offset() + args.fbe_size())
    , row_format(buffer, row_typeid.fbe_offset() + row_typeid.fbe_size())
    , colnames(buffer, row_format.fbe_offset() + row_format.fbe_size())
    , location(buffer, colnames.fbe_offset() + colnames.fbe_size())
{}

size_t FieldModel_pg_query_RowExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + args.fbe_size()
        + row_typeid.fbe_size()
        + row_format.fbe_size()
        + colnames.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RowExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + args.fbe_extra()
        + row_typeid.fbe_extra()
        + row_format.fbe_extra()
        + colnames.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RowExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RowExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + row_typeid.fbe_size()) > fbe_struct_size)
        return true;
    if (!row_typeid.verify())
        return false;
    fbe_current_size += row_typeid.fbe_size();

    if ((fbe_current_size + row_format.fbe_size()) > fbe_struct_size)
        return true;
    if (!row_format.verify())
        return false;
    fbe_current_size += row_format.fbe_size();

    if ((fbe_current_size + colnames.fbe_size()) > fbe_struct_size)
        return true;
    if (!colnames.verify())
        return false;
    fbe_current_size += colnames.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RowExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RowExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RowExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RowExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RowExpr& fbe_value = static_cast<::pg_query::RowExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + row_typeid.fbe_size()) <= fbe_struct_size)
        {
            row_typeid.get(fbe_value.row_typeid);
        }
    else
        fbe_value.row_typeid = (uint32_t)0ull;
    fbe_current_size += row_typeid.fbe_size();

    if ((fbe_current_size + row_format.fbe_size()) <= fbe_struct_size)
        {
            row_format.get(fbe_value.row_format);
        }
    else
        fbe_value.row_format = ::pg_query::CoercionForm();
    fbe_current_size += row_format.fbe_size();

    if ((fbe_current_size + colnames.fbe_size()) <= fbe_struct_size)
        {
            colnames.get(fbe_value.colnames);
        }
    else
        fbe_value.colnames.clear();
    fbe_current_size += colnames.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_RowExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RowExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RowExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RowExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RowExpr& fbe_value = static_cast<const ::pg_query::RowExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    args.set(fbe_value.args);
    row_typeid.set(fbe_value.row_typeid);
    row_format.set(fbe_value.row_format);
    colnames.set(fbe_value.colnames);
    location.set(fbe_value.location);
}

namespace pg_query {

bool RowExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RowExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RowExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RowExprModel::serialize(const ::pg_query::RowExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RowExprModel::deserialize(::pg_query::RowExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RowCompareExpr::FieldModelPtr_pg_query_RowCompareExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RowCompareExpr::~FieldModelPtr_pg_query_RowCompareExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RowCompareExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RowCompareExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RowCompareExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RowCompareExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RowCompareExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RowCompareExpr::get(::pg_query::RowCompareExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RowCompareExpr(_buffer, 0);

    ::pg_query::RowCompareExpr *tempModel = new ::pg_query::RowCompareExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RowCompareExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RowCompareExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RowCompareExpr::set(const ::pg_query::RowCompareExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RowCompareExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RowCompareExpr::FieldModel_pg_query_RowCompareExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , rctype(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , opnos(buffer, rctype.fbe_offset() + rctype.fbe_size())
    , opfamilies(buffer, opnos.fbe_offset() + opnos.fbe_size())
    , inputcollids(buffer, opfamilies.fbe_offset() + opfamilies.fbe_size())
    , largs(buffer, inputcollids.fbe_offset() + inputcollids.fbe_size())
    , rargs(buffer, largs.fbe_offset() + largs.fbe_size())
{}

size_t FieldModel_pg_query_RowCompareExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + rctype.fbe_size()
        + opnos.fbe_size()
        + opfamilies.fbe_size()
        + inputcollids.fbe_size()
        + largs.fbe_size()
        + rargs.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RowCompareExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + rctype.fbe_extra()
        + opnos.fbe_extra()
        + opfamilies.fbe_extra()
        + inputcollids.fbe_extra()
        + largs.fbe_extra()
        + rargs.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RowCompareExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RowCompareExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + rctype.fbe_size()) > fbe_struct_size)
        return true;
    if (!rctype.verify())
        return false;
    fbe_current_size += rctype.fbe_size();

    if ((fbe_current_size + opnos.fbe_size()) > fbe_struct_size)
        return true;
    if (!opnos.verify())
        return false;
    fbe_current_size += opnos.fbe_size();

    if ((fbe_current_size + opfamilies.fbe_size()) > fbe_struct_size)
        return true;
    if (!opfamilies.verify())
        return false;
    fbe_current_size += opfamilies.fbe_size();

    if ((fbe_current_size + inputcollids.fbe_size()) > fbe_struct_size)
        return true;
    if (!inputcollids.verify())
        return false;
    fbe_current_size += inputcollids.fbe_size();

    if ((fbe_current_size + largs.fbe_size()) > fbe_struct_size)
        return true;
    if (!largs.verify())
        return false;
    fbe_current_size += largs.fbe_size();

    if ((fbe_current_size + rargs.fbe_size()) > fbe_struct_size)
        return true;
    if (!rargs.verify())
        return false;
    fbe_current_size += rargs.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RowCompareExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RowCompareExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RowCompareExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RowCompareExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RowCompareExpr& fbe_value = static_cast<::pg_query::RowCompareExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + rctype.fbe_size()) <= fbe_struct_size)
        {
            rctype.get(fbe_value.rctype);
        }
    else
        fbe_value.rctype = ::pg_query::RowCompareType();
    fbe_current_size += rctype.fbe_size();

    if ((fbe_current_size + opnos.fbe_size()) <= fbe_struct_size)
        {
            opnos.get(fbe_value.opnos);
        }
    else
        fbe_value.opnos.clear();
    fbe_current_size += opnos.fbe_size();

    if ((fbe_current_size + opfamilies.fbe_size()) <= fbe_struct_size)
        {
            opfamilies.get(fbe_value.opfamilies);
        }
    else
        fbe_value.opfamilies.clear();
    fbe_current_size += opfamilies.fbe_size();

    if ((fbe_current_size + inputcollids.fbe_size()) <= fbe_struct_size)
        {
            inputcollids.get(fbe_value.inputcollids);
        }
    else
        fbe_value.inputcollids.clear();
    fbe_current_size += inputcollids.fbe_size();

    if ((fbe_current_size + largs.fbe_size()) <= fbe_struct_size)
        {
            largs.get(fbe_value.largs);
        }
    else
        fbe_value.largs.clear();
    fbe_current_size += largs.fbe_size();

    if ((fbe_current_size + rargs.fbe_size()) <= fbe_struct_size)
        {
            rargs.get(fbe_value.rargs);
        }
    else
        fbe_value.rargs.clear();
    fbe_current_size += rargs.fbe_size();
}

size_t FieldModel_pg_query_RowCompareExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RowCompareExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RowCompareExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RowCompareExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RowCompareExpr& fbe_value = static_cast<const ::pg_query::RowCompareExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    rctype.set(fbe_value.rctype);
    opnos.set(fbe_value.opnos);
    opfamilies.set(fbe_value.opfamilies);
    inputcollids.set(fbe_value.inputcollids);
    largs.set(fbe_value.largs);
    rargs.set(fbe_value.rargs);
}

namespace pg_query {

bool RowCompareExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RowCompareExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RowCompareExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RowCompareExprModel::serialize(const ::pg_query::RowCompareExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RowCompareExprModel::deserialize(::pg_query::RowCompareExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CoalesceExpr::FieldModelPtr_pg_query_CoalesceExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CoalesceExpr::~FieldModelPtr_pg_query_CoalesceExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CoalesceExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CoalesceExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CoalesceExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CoalesceExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CoalesceExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CoalesceExpr::get(::pg_query::CoalesceExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CoalesceExpr(_buffer, 0);

    ::pg_query::CoalesceExpr *tempModel = new ::pg_query::CoalesceExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CoalesceExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CoalesceExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CoalesceExpr::set(const ::pg_query::CoalesceExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CoalesceExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CoalesceExpr::FieldModel_pg_query_CoalesceExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , coalescetype(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , coalescecollid(buffer, coalescetype.fbe_offset() + coalescetype.fbe_size())
    , args(buffer, coalescecollid.fbe_offset() + coalescecollid.fbe_size())
    , location(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_CoalesceExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + coalescetype.fbe_size()
        + coalescecollid.fbe_size()
        + args.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CoalesceExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + coalescetype.fbe_extra()
        + coalescecollid.fbe_extra()
        + args.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CoalesceExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CoalesceExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + coalescetype.fbe_size()) > fbe_struct_size)
        return true;
    if (!coalescetype.verify())
        return false;
    fbe_current_size += coalescetype.fbe_size();

    if ((fbe_current_size + coalescecollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!coalescecollid.verify())
        return false;
    fbe_current_size += coalescecollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CoalesceExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CoalesceExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CoalesceExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CoalesceExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CoalesceExpr& fbe_value = static_cast<::pg_query::CoalesceExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + coalescetype.fbe_size()) <= fbe_struct_size)
        {
            coalescetype.get(fbe_value.coalescetype);
        }
    else
        fbe_value.coalescetype = (uint32_t)0ull;
    fbe_current_size += coalescetype.fbe_size();

    if ((fbe_current_size + coalescecollid.fbe_size()) <= fbe_struct_size)
        {
            coalescecollid.get(fbe_value.coalescecollid);
        }
    else
        fbe_value.coalescecollid = (uint32_t)0ull;
    fbe_current_size += coalescecollid.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_CoalesceExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CoalesceExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CoalesceExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CoalesceExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CoalesceExpr& fbe_value = static_cast<const ::pg_query::CoalesceExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    coalescetype.set(fbe_value.coalescetype);
    coalescecollid.set(fbe_value.coalescecollid);
    args.set(fbe_value.args);
    location.set(fbe_value.location);
}

namespace pg_query {

bool CoalesceExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CoalesceExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CoalesceExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CoalesceExprModel::serialize(const ::pg_query::CoalesceExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CoalesceExprModel::deserialize(::pg_query::CoalesceExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_MinMaxExpr::FieldModelPtr_pg_query_MinMaxExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_MinMaxExpr::~FieldModelPtr_pg_query_MinMaxExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_MinMaxExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_MinMaxExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_MinMaxExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_MinMaxExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_MinMaxExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_MinMaxExpr::get(::pg_query::MinMaxExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_MinMaxExpr(_buffer, 0);

    ::pg_query::MinMaxExpr *tempModel = new ::pg_query::MinMaxExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_MinMaxExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_MinMaxExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_MinMaxExpr::set(const ::pg_query::MinMaxExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_MinMaxExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_MinMaxExpr::FieldModel_pg_query_MinMaxExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , minmaxtype(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , minmaxcollid(buffer, minmaxtype.fbe_offset() + minmaxtype.fbe_size())
    , inputcollid(buffer, minmaxcollid.fbe_offset() + minmaxcollid.fbe_size())
    , op(buffer, inputcollid.fbe_offset() + inputcollid.fbe_size())
    , args(buffer, op.fbe_offset() + op.fbe_size())
    , location(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_MinMaxExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + minmaxtype.fbe_size()
        + minmaxcollid.fbe_size()
        + inputcollid.fbe_size()
        + op.fbe_size()
        + args.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_MinMaxExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + minmaxtype.fbe_extra()
        + minmaxcollid.fbe_extra()
        + inputcollid.fbe_extra()
        + op.fbe_extra()
        + args.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_MinMaxExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_MinMaxExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + minmaxtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!minmaxtype.verify())
        return false;
    fbe_current_size += minmaxtype.fbe_size();

    if ((fbe_current_size + minmaxcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!minmaxcollid.verify())
        return false;
    fbe_current_size += minmaxcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!inputcollid.verify())
        return false;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + op.fbe_size()) > fbe_struct_size)
        return true;
    if (!op.verify())
        return false;
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_MinMaxExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_MinMaxExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_MinMaxExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_MinMaxExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::MinMaxExpr& fbe_value = static_cast<::pg_query::MinMaxExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + minmaxtype.fbe_size()) <= fbe_struct_size)
        {
            minmaxtype.get(fbe_value.minmaxtype);
        }
    else
        fbe_value.minmaxtype = (uint32_t)0ull;
    fbe_current_size += minmaxtype.fbe_size();

    if ((fbe_current_size + minmaxcollid.fbe_size()) <= fbe_struct_size)
        {
            minmaxcollid.get(fbe_value.minmaxcollid);
        }
    else
        fbe_value.minmaxcollid = (uint32_t)0ull;
    fbe_current_size += minmaxcollid.fbe_size();

    if ((fbe_current_size + inputcollid.fbe_size()) <= fbe_struct_size)
        {
            inputcollid.get(fbe_value.inputcollid);
        }
    else
        fbe_value.inputcollid = (uint32_t)0ull;
    fbe_current_size += inputcollid.fbe_size();

    if ((fbe_current_size + op.fbe_size()) <= fbe_struct_size)
        {
            op.get(fbe_value.op);
        }
    else
        fbe_value.op = ::pg_query::MinMaxOp();
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_MinMaxExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_MinMaxExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_MinMaxExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_MinMaxExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::MinMaxExpr& fbe_value = static_cast<const ::pg_query::MinMaxExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    minmaxtype.set(fbe_value.minmaxtype);
    minmaxcollid.set(fbe_value.minmaxcollid);
    inputcollid.set(fbe_value.inputcollid);
    op.set(fbe_value.op);
    args.set(fbe_value.args);
    location.set(fbe_value.location);
}

namespace pg_query {

bool MinMaxExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t MinMaxExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t MinMaxExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t MinMaxExprModel::serialize(const ::pg_query::MinMaxExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t MinMaxExprModel::deserialize(::pg_query::MinMaxExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SQLValueFunction::FieldModelPtr_pg_query_SQLValueFunction(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SQLValueFunction::~FieldModelPtr_pg_query_SQLValueFunction()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SQLValueFunction::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SQLValueFunction::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SQLValueFunction::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SQLValueFunction::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SQLValueFunction::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SQLValueFunction::get(::pg_query::SQLValueFunction** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SQLValueFunction(_buffer, 0);

    ::pg_query::SQLValueFunction *tempModel = new ::pg_query::SQLValueFunction();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SQLValueFunction::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SQLValueFunction::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SQLValueFunction::set(const ::pg_query::SQLValueFunction* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SQLValueFunction(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SQLValueFunction::FieldModel_pg_query_SQLValueFunction(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , op(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , type(buffer, op.fbe_offset() + op.fbe_size())
    , typmod(buffer, type.fbe_offset() + type.fbe_size())
    , location(buffer, typmod.fbe_offset() + typmod.fbe_size())
{}

size_t FieldModel_pg_query_SQLValueFunction::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + op.fbe_size()
        + type.fbe_size()
        + typmod.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SQLValueFunction::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + op.fbe_extra()
        + type.fbe_extra()
        + typmod.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SQLValueFunction::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SQLValueFunction::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + op.fbe_size()) > fbe_struct_size)
        return true;
    if (!op.verify())
        return false;
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + type.fbe_size()) > fbe_struct_size)
        return true;
    if (!type.verify())
        return false;
    fbe_current_size += type.fbe_size();

    if ((fbe_current_size + typmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!typmod.verify())
        return false;
    fbe_current_size += typmod.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SQLValueFunction::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SQLValueFunction::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SQLValueFunction::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SQLValueFunction::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SQLValueFunction& fbe_value = static_cast<::pg_query::SQLValueFunction&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + op.fbe_size()) <= fbe_struct_size)
        {
            op.get(fbe_value.op);
        }
    else
        fbe_value.op = ::pg_query::SQLValueFunctionOp();
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + type.fbe_size()) <= fbe_struct_size)
        {
            type.get(fbe_value.type);
        }
    else
        fbe_value.type = (uint32_t)0ull;
    fbe_current_size += type.fbe_size();

    if ((fbe_current_size + typmod.fbe_size()) <= fbe_struct_size)
        {
            typmod.get(fbe_value.typmod);
        }
    else
        fbe_value.typmod = (int32_t)0ll;
    fbe_current_size += typmod.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_SQLValueFunction::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SQLValueFunction::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SQLValueFunction::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SQLValueFunction::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SQLValueFunction& fbe_value = static_cast<const ::pg_query::SQLValueFunction&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    op.set(fbe_value.op);
    type.set(fbe_value.type);
    typmod.set(fbe_value.typmod);
    location.set(fbe_value.location);
}

namespace pg_query {

bool SQLValueFunctionModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SQLValueFunctionModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SQLValueFunctionModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SQLValueFunctionModel::serialize(const ::pg_query::SQLValueFunction& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SQLValueFunctionModel::deserialize(::pg_query::SQLValueFunction& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_XmlExpr::FieldModelPtr_pg_query_XmlExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_XmlExpr::~FieldModelPtr_pg_query_XmlExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_XmlExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_XmlExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_XmlExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_XmlExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_XmlExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_XmlExpr::get(::pg_query::XmlExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_XmlExpr(_buffer, 0);

    ::pg_query::XmlExpr *tempModel = new ::pg_query::XmlExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_XmlExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_XmlExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_XmlExpr::set(const ::pg_query::XmlExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_XmlExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_XmlExpr::FieldModel_pg_query_XmlExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , op(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , name(buffer, op.fbe_offset() + op.fbe_size())
    , named_args(buffer, name.fbe_offset() + name.fbe_size())
    , arg_names(buffer, named_args.fbe_offset() + named_args.fbe_size())
    , args(buffer, arg_names.fbe_offset() + arg_names.fbe_size())
    , xmloption(buffer, args.fbe_offset() + args.fbe_size())
    , type(buffer, xmloption.fbe_offset() + xmloption.fbe_size())
    , typmod(buffer, type.fbe_offset() + type.fbe_size())
    , location(buffer, typmod.fbe_offset() + typmod.fbe_size())
{}

size_t FieldModel_pg_query_XmlExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + op.fbe_size()
        + name.fbe_size()
        + named_args.fbe_size()
        + arg_names.fbe_size()
        + args.fbe_size()
        + xmloption.fbe_size()
        + type.fbe_size()
        + typmod.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_XmlExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + op.fbe_extra()
        + name.fbe_extra()
        + named_args.fbe_extra()
        + arg_names.fbe_extra()
        + args.fbe_extra()
        + xmloption.fbe_extra()
        + type.fbe_extra()
        + typmod.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_XmlExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_XmlExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + op.fbe_size()) > fbe_struct_size)
        return true;
    if (!op.verify())
        return false;
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + named_args.fbe_size()) > fbe_struct_size)
        return true;
    if (!named_args.verify())
        return false;
    fbe_current_size += named_args.fbe_size();

    if ((fbe_current_size + arg_names.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg_names.verify())
        return false;
    fbe_current_size += arg_names.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + xmloption.fbe_size()) > fbe_struct_size)
        return true;
    if (!xmloption.verify())
        return false;
    fbe_current_size += xmloption.fbe_size();

    if ((fbe_current_size + type.fbe_size()) > fbe_struct_size)
        return true;
    if (!type.verify())
        return false;
    fbe_current_size += type.fbe_size();

    if ((fbe_current_size + typmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!typmod.verify())
        return false;
    fbe_current_size += typmod.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_XmlExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_XmlExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_XmlExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_XmlExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::XmlExpr& fbe_value = static_cast<::pg_query::XmlExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + op.fbe_size()) <= fbe_struct_size)
        {
            op.get(fbe_value.op);
        }
    else
        fbe_value.op = ::pg_query::XmlExprOp();
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + named_args.fbe_size()) <= fbe_struct_size)
        {
            named_args.get(fbe_value.named_args);
        }
    else
        fbe_value.named_args.clear();
    fbe_current_size += named_args.fbe_size();

    if ((fbe_current_size + arg_names.fbe_size()) <= fbe_struct_size)
        {
            arg_names.get(fbe_value.arg_names);
        }
    else
        fbe_value.arg_names.clear();
    fbe_current_size += arg_names.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + xmloption.fbe_size()) <= fbe_struct_size)
        {
            xmloption.get(fbe_value.xmloption);
        }
    else
        fbe_value.xmloption = ::pg_query::XmlOptionType();
    fbe_current_size += xmloption.fbe_size();

    if ((fbe_current_size + type.fbe_size()) <= fbe_struct_size)
        {
            type.get(fbe_value.type);
        }
    else
        fbe_value.type = (uint32_t)0ull;
    fbe_current_size += type.fbe_size();

    if ((fbe_current_size + typmod.fbe_size()) <= fbe_struct_size)
        {
            typmod.get(fbe_value.typmod);
        }
    else
        fbe_value.typmod = (int32_t)0ll;
    fbe_current_size += typmod.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_XmlExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_XmlExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_XmlExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_XmlExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::XmlExpr& fbe_value = static_cast<const ::pg_query::XmlExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    op.set(fbe_value.op);
    name.set(fbe_value.name);
    named_args.set(fbe_value.named_args);
    arg_names.set(fbe_value.arg_names);
    args.set(fbe_value.args);
    xmloption.set(fbe_value.xmloption);
    type.set(fbe_value.type);
    typmod.set(fbe_value.typmod);
    location.set(fbe_value.location);
}

namespace pg_query {

bool XmlExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t XmlExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t XmlExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t XmlExprModel::serialize(const ::pg_query::XmlExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t XmlExprModel::deserialize(::pg_query::XmlExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_NullTest::FieldModelPtr_pg_query_NullTest(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_NullTest::~FieldModelPtr_pg_query_NullTest()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_NullTest::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_NullTest::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_NullTest::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_NullTest::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NullTest::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NullTest::get(::pg_query::NullTest** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_NullTest(_buffer, 0);

    ::pg_query::NullTest *tempModel = new ::pg_query::NullTest();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_NullTest::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NullTest::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NullTest::set(const ::pg_query::NullTest* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_NullTest(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_NullTest::FieldModel_pg_query_NullTest(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , nulltesttype(buffer, arg.fbe_offset() + arg.fbe_size())
    , argisrow(buffer, nulltesttype.fbe_offset() + nulltesttype.fbe_size())
    , location(buffer, argisrow.fbe_offset() + argisrow.fbe_size())
{}

size_t FieldModel_pg_query_NullTest::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + nulltesttype.fbe_size()
        + argisrow.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_NullTest::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + nulltesttype.fbe_extra()
        + argisrow.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_NullTest::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_NullTest::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + nulltesttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!nulltesttype.verify())
        return false;
    fbe_current_size += nulltesttype.fbe_size();

    if ((fbe_current_size + argisrow.fbe_size()) > fbe_struct_size)
        return true;
    if (!argisrow.verify())
        return false;
    fbe_current_size += argisrow.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_NullTest::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NullTest::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NullTest::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_NullTest::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::NullTest& fbe_value = static_cast<::pg_query::NullTest&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + nulltesttype.fbe_size()) <= fbe_struct_size)
        {
            nulltesttype.get(fbe_value.nulltesttype);
        }
    else
        fbe_value.nulltesttype = ::pg_query::NullTestType();
    fbe_current_size += nulltesttype.fbe_size();

    if ((fbe_current_size + argisrow.fbe_size()) <= fbe_struct_size)
        {
            argisrow.get(fbe_value.argisrow);
        }
    else
        fbe_value.argisrow = false;
    fbe_current_size += argisrow.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_NullTest::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NullTest::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NullTest::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_NullTest::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::NullTest& fbe_value = static_cast<const ::pg_query::NullTest&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    nulltesttype.set(fbe_value.nulltesttype);
    argisrow.set(fbe_value.argisrow);
    location.set(fbe_value.location);
}

namespace pg_query {

bool NullTestModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t NullTestModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t NullTestModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t NullTestModel::serialize(const ::pg_query::NullTest& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t NullTestModel::deserialize(::pg_query::NullTest& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_BooleanTest::FieldModelPtr_pg_query_BooleanTest(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_BooleanTest::~FieldModelPtr_pg_query_BooleanTest()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_BooleanTest::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_BooleanTest::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_BooleanTest::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_BooleanTest::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_BooleanTest::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_BooleanTest::get(::pg_query::BooleanTest** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_BooleanTest(_buffer, 0);

    ::pg_query::BooleanTest *tempModel = new ::pg_query::BooleanTest();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_BooleanTest::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_BooleanTest::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_BooleanTest::set(const ::pg_query::BooleanTest* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_BooleanTest(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_BooleanTest::FieldModel_pg_query_BooleanTest(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , booltesttype(buffer, arg.fbe_offset() + arg.fbe_size())
    , location(buffer, booltesttype.fbe_offset() + booltesttype.fbe_size())
{}

size_t FieldModel_pg_query_BooleanTest::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + booltesttype.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_BooleanTest::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + booltesttype.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_BooleanTest::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_BooleanTest::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + booltesttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!booltesttype.verify())
        return false;
    fbe_current_size += booltesttype.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_BooleanTest::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_BooleanTest::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_BooleanTest::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_BooleanTest::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::BooleanTest& fbe_value = static_cast<::pg_query::BooleanTest&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + booltesttype.fbe_size()) <= fbe_struct_size)
        {
            booltesttype.get(fbe_value.booltesttype);
        }
    else
        fbe_value.booltesttype = ::pg_query::BoolTestType();
    fbe_current_size += booltesttype.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_BooleanTest::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_BooleanTest::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_BooleanTest::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_BooleanTest::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::BooleanTest& fbe_value = static_cast<const ::pg_query::BooleanTest&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    booltesttype.set(fbe_value.booltesttype);
    location.set(fbe_value.location);
}

namespace pg_query {

bool BooleanTestModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t BooleanTestModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t BooleanTestModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t BooleanTestModel::serialize(const ::pg_query::BooleanTest& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t BooleanTestModel::deserialize(::pg_query::BooleanTest& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CoerceToDomain::FieldModelPtr_pg_query_CoerceToDomain(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CoerceToDomain::~FieldModelPtr_pg_query_CoerceToDomain()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CoerceToDomain::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CoerceToDomain::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CoerceToDomain::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CoerceToDomain::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CoerceToDomain::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CoerceToDomain::get(::pg_query::CoerceToDomain** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CoerceToDomain(_buffer, 0);

    ::pg_query::CoerceToDomain *tempModel = new ::pg_query::CoerceToDomain();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CoerceToDomain::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CoerceToDomain::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CoerceToDomain::set(const ::pg_query::CoerceToDomain* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CoerceToDomain(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CoerceToDomain::FieldModel_pg_query_CoerceToDomain(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , arg(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , resulttype(buffer, arg.fbe_offset() + arg.fbe_size())
    , resulttypmod(buffer, resulttype.fbe_offset() + resulttype.fbe_size())
    , resultcollid(buffer, resulttypmod.fbe_offset() + resulttypmod.fbe_size())
    , coercionformat(buffer, resultcollid.fbe_offset() + resultcollid.fbe_size())
    , location(buffer, coercionformat.fbe_offset() + coercionformat.fbe_size())
{}

size_t FieldModel_pg_query_CoerceToDomain::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + arg.fbe_size()
        + resulttype.fbe_size()
        + resulttypmod.fbe_size()
        + resultcollid.fbe_size()
        + coercionformat.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CoerceToDomain::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + arg.fbe_extra()
        + resulttype.fbe_extra()
        + resulttypmod.fbe_extra()
        + resultcollid.fbe_extra()
        + coercionformat.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CoerceToDomain::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CoerceToDomain::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttype.verify())
        return false;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resulttypmod.fbe_size()) > fbe_struct_size)
        return true;
    if (!resulttypmod.verify())
        return false;
    fbe_current_size += resulttypmod.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!resultcollid.verify())
        return false;
    fbe_current_size += resultcollid.fbe_size();

    if ((fbe_current_size + coercionformat.fbe_size()) > fbe_struct_size)
        return true;
    if (!coercionformat.verify())
        return false;
    fbe_current_size += coercionformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CoerceToDomain::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CoerceToDomain::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CoerceToDomain::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CoerceToDomain::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CoerceToDomain& fbe_value = static_cast<::pg_query::CoerceToDomain&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + resulttype.fbe_size()) <= fbe_struct_size)
        {
            resulttype.get(fbe_value.resulttype);
        }
    else
        fbe_value.resulttype = (uint32_t)0ull;
    fbe_current_size += resulttype.fbe_size();

    if ((fbe_current_size + resulttypmod.fbe_size()) <= fbe_struct_size)
        {
            resulttypmod.get(fbe_value.resulttypmod);
        }
    else
        fbe_value.resulttypmod = (int32_t)0ll;
    fbe_current_size += resulttypmod.fbe_size();

    if ((fbe_current_size + resultcollid.fbe_size()) <= fbe_struct_size)
        {
            resultcollid.get(fbe_value.resultcollid);
        }
    else
        fbe_value.resultcollid = (uint32_t)0ull;
    fbe_current_size += resultcollid.fbe_size();

    if ((fbe_current_size + coercionformat.fbe_size()) <= fbe_struct_size)
        {
            coercionformat.get(fbe_value.coercionformat);
        }
    else
        fbe_value.coercionformat = ::pg_query::CoercionForm();
    fbe_current_size += coercionformat.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_CoerceToDomain::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CoerceToDomain::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CoerceToDomain::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CoerceToDomain::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CoerceToDomain& fbe_value = static_cast<const ::pg_query::CoerceToDomain&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    arg.set(fbe_value.arg);
    resulttype.set(fbe_value.resulttype);
    resulttypmod.set(fbe_value.resulttypmod);
    resultcollid.set(fbe_value.resultcollid);
    coercionformat.set(fbe_value.coercionformat);
    location.set(fbe_value.location);
}

namespace pg_query {

bool CoerceToDomainModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CoerceToDomainModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CoerceToDomainModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CoerceToDomainModel::serialize(const ::pg_query::CoerceToDomain& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CoerceToDomainModel::deserialize(::pg_query::CoerceToDomain& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CoerceToDomainValue::FieldModelPtr_pg_query_CoerceToDomainValue(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CoerceToDomainValue::~FieldModelPtr_pg_query_CoerceToDomainValue()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CoerceToDomainValue::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CoerceToDomainValue::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CoerceToDomainValue::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CoerceToDomainValue::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CoerceToDomainValue::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CoerceToDomainValue::get(::pg_query::CoerceToDomainValue** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CoerceToDomainValue(_buffer, 0);

    ::pg_query::CoerceToDomainValue *tempModel = new ::pg_query::CoerceToDomainValue();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CoerceToDomainValue::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CoerceToDomainValue::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CoerceToDomainValue::set(const ::pg_query::CoerceToDomainValue* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CoerceToDomainValue(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CoerceToDomainValue::FieldModel_pg_query_CoerceToDomainValue(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , type_id(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , type_mod(buffer, type_id.fbe_offset() + type_id.fbe_size())
    , collation(buffer, type_mod.fbe_offset() + type_mod.fbe_size())
    , location(buffer, collation.fbe_offset() + collation.fbe_size())
{}

size_t FieldModel_pg_query_CoerceToDomainValue::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + type_id.fbe_size()
        + type_mod.fbe_size()
        + collation.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CoerceToDomainValue::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + type_id.fbe_extra()
        + type_mod.fbe_extra()
        + collation.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CoerceToDomainValue::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CoerceToDomainValue::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + type_id.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_id.verify())
        return false;
    fbe_current_size += type_id.fbe_size();

    if ((fbe_current_size + type_mod.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_mod.verify())
        return false;
    fbe_current_size += type_mod.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) > fbe_struct_size)
        return true;
    if (!collation.verify())
        return false;
    fbe_current_size += collation.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CoerceToDomainValue::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CoerceToDomainValue::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CoerceToDomainValue::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CoerceToDomainValue::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CoerceToDomainValue& fbe_value = static_cast<::pg_query::CoerceToDomainValue&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + type_id.fbe_size()) <= fbe_struct_size)
        {
            type_id.get(fbe_value.type_id);
        }
    else
        fbe_value.type_id = (uint32_t)0ull;
    fbe_current_size += type_id.fbe_size();

    if ((fbe_current_size + type_mod.fbe_size()) <= fbe_struct_size)
        {
            type_mod.get(fbe_value.type_mod);
        }
    else
        fbe_value.type_mod = (int32_t)0ll;
    fbe_current_size += type_mod.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) <= fbe_struct_size)
        {
            collation.get(fbe_value.collation);
        }
    else
        fbe_value.collation = (uint32_t)0ull;
    fbe_current_size += collation.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_CoerceToDomainValue::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CoerceToDomainValue::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CoerceToDomainValue::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CoerceToDomainValue::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CoerceToDomainValue& fbe_value = static_cast<const ::pg_query::CoerceToDomainValue&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    type_id.set(fbe_value.type_id);
    type_mod.set(fbe_value.type_mod);
    collation.set(fbe_value.collation);
    location.set(fbe_value.location);
}

namespace pg_query {

bool CoerceToDomainValueModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CoerceToDomainValueModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CoerceToDomainValueModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CoerceToDomainValueModel::serialize(const ::pg_query::CoerceToDomainValue& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CoerceToDomainValueModel::deserialize(::pg_query::CoerceToDomainValue& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SetToDefault::FieldModelPtr_pg_query_SetToDefault(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SetToDefault::~FieldModelPtr_pg_query_SetToDefault()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SetToDefault::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SetToDefault::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SetToDefault::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SetToDefault::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SetToDefault::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SetToDefault::get(::pg_query::SetToDefault** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SetToDefault(_buffer, 0);

    ::pg_query::SetToDefault *tempModel = new ::pg_query::SetToDefault();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SetToDefault::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SetToDefault::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SetToDefault::set(const ::pg_query::SetToDefault* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SetToDefault(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SetToDefault::FieldModel_pg_query_SetToDefault(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , type_id(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , type_mod(buffer, type_id.fbe_offset() + type_id.fbe_size())
    , collation(buffer, type_mod.fbe_offset() + type_mod.fbe_size())
    , location(buffer, collation.fbe_offset() + collation.fbe_size())
{}

size_t FieldModel_pg_query_SetToDefault::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + type_id.fbe_size()
        + type_mod.fbe_size()
        + collation.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SetToDefault::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + type_id.fbe_extra()
        + type_mod.fbe_extra()
        + collation.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SetToDefault::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SetToDefault::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + type_id.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_id.verify())
        return false;
    fbe_current_size += type_id.fbe_size();

    if ((fbe_current_size + type_mod.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_mod.verify())
        return false;
    fbe_current_size += type_mod.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) > fbe_struct_size)
        return true;
    if (!collation.verify())
        return false;
    fbe_current_size += collation.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SetToDefault::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SetToDefault::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SetToDefault::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SetToDefault::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SetToDefault& fbe_value = static_cast<::pg_query::SetToDefault&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + type_id.fbe_size()) <= fbe_struct_size)
        {
            type_id.get(fbe_value.type_id);
        }
    else
        fbe_value.type_id = (uint32_t)0ull;
    fbe_current_size += type_id.fbe_size();

    if ((fbe_current_size + type_mod.fbe_size()) <= fbe_struct_size)
        {
            type_mod.get(fbe_value.type_mod);
        }
    else
        fbe_value.type_mod = (int32_t)0ll;
    fbe_current_size += type_mod.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) <= fbe_struct_size)
        {
            collation.get(fbe_value.collation);
        }
    else
        fbe_value.collation = (uint32_t)0ull;
    fbe_current_size += collation.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_SetToDefault::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SetToDefault::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SetToDefault::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SetToDefault::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SetToDefault& fbe_value = static_cast<const ::pg_query::SetToDefault&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    type_id.set(fbe_value.type_id);
    type_mod.set(fbe_value.type_mod);
    collation.set(fbe_value.collation);
    location.set(fbe_value.location);
}

namespace pg_query {

bool SetToDefaultModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SetToDefaultModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SetToDefaultModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SetToDefaultModel::serialize(const ::pg_query::SetToDefault& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SetToDefaultModel::deserialize(::pg_query::SetToDefault& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CurrentOfExpr::FieldModelPtr_pg_query_CurrentOfExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CurrentOfExpr::~FieldModelPtr_pg_query_CurrentOfExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CurrentOfExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CurrentOfExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CurrentOfExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CurrentOfExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CurrentOfExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CurrentOfExpr::get(::pg_query::CurrentOfExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CurrentOfExpr(_buffer, 0);

    ::pg_query::CurrentOfExpr *tempModel = new ::pg_query::CurrentOfExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CurrentOfExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CurrentOfExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CurrentOfExpr::set(const ::pg_query::CurrentOfExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CurrentOfExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CurrentOfExpr::FieldModel_pg_query_CurrentOfExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , cvarno(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , cursor_name(buffer, cvarno.fbe_offset() + cvarno.fbe_size())
    , cursor_param(buffer, cursor_name.fbe_offset() + cursor_name.fbe_size())
{}

size_t FieldModel_pg_query_CurrentOfExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + cvarno.fbe_size()
        + cursor_name.fbe_size()
        + cursor_param.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CurrentOfExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + cvarno.fbe_extra()
        + cursor_name.fbe_extra()
        + cursor_param.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CurrentOfExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CurrentOfExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + cvarno.fbe_size()) > fbe_struct_size)
        return true;
    if (!cvarno.verify())
        return false;
    fbe_current_size += cvarno.fbe_size();

    if ((fbe_current_size + cursor_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!cursor_name.verify())
        return false;
    fbe_current_size += cursor_name.fbe_size();

    if ((fbe_current_size + cursor_param.fbe_size()) > fbe_struct_size)
        return true;
    if (!cursor_param.verify())
        return false;
    fbe_current_size += cursor_param.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CurrentOfExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CurrentOfExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CurrentOfExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CurrentOfExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CurrentOfExpr& fbe_value = static_cast<::pg_query::CurrentOfExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + cvarno.fbe_size()) <= fbe_struct_size)
        {
            cvarno.get(fbe_value.cvarno);
        }
    else
        fbe_value.cvarno = (uint32_t)0ull;
    fbe_current_size += cvarno.fbe_size();

    if ((fbe_current_size + cursor_name.fbe_size()) <= fbe_struct_size)
        {
            cursor_name.get(fbe_value.cursor_name);
        }
    else
        fbe_value.cursor_name = "";
    fbe_current_size += cursor_name.fbe_size();

    if ((fbe_current_size + cursor_param.fbe_size()) <= fbe_struct_size)
        {
            cursor_param.get(fbe_value.cursor_param);
        }
    else
        fbe_value.cursor_param = (int32_t)0ll;
    fbe_current_size += cursor_param.fbe_size();
}

size_t FieldModel_pg_query_CurrentOfExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CurrentOfExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CurrentOfExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CurrentOfExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CurrentOfExpr& fbe_value = static_cast<const ::pg_query::CurrentOfExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    cvarno.set(fbe_value.cvarno);
    cursor_name.set(fbe_value.cursor_name);
    cursor_param.set(fbe_value.cursor_param);
}

namespace pg_query {

bool CurrentOfExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CurrentOfExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CurrentOfExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CurrentOfExprModel::serialize(const ::pg_query::CurrentOfExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CurrentOfExprModel::deserialize(::pg_query::CurrentOfExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_NextValueExpr::FieldModelPtr_pg_query_NextValueExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_NextValueExpr::~FieldModelPtr_pg_query_NextValueExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_NextValueExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_NextValueExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_NextValueExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_NextValueExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NextValueExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NextValueExpr::get(::pg_query::NextValueExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_NextValueExpr(_buffer, 0);

    ::pg_query::NextValueExpr *tempModel = new ::pg_query::NextValueExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_NextValueExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NextValueExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NextValueExpr::set(const ::pg_query::NextValueExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_NextValueExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_NextValueExpr::FieldModel_pg_query_NextValueExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , seqid(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , type_id(buffer, seqid.fbe_offset() + seqid.fbe_size())
{}

size_t FieldModel_pg_query_NextValueExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + seqid.fbe_size()
        + type_id.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_NextValueExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + seqid.fbe_extra()
        + type_id.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_NextValueExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_NextValueExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + seqid.fbe_size()) > fbe_struct_size)
        return true;
    if (!seqid.verify())
        return false;
    fbe_current_size += seqid.fbe_size();

    if ((fbe_current_size + type_id.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_id.verify())
        return false;
    fbe_current_size += type_id.fbe_size();

    return true;
}

size_t FieldModel_pg_query_NextValueExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NextValueExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NextValueExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_NextValueExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::NextValueExpr& fbe_value = static_cast<::pg_query::NextValueExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + seqid.fbe_size()) <= fbe_struct_size)
        {
            seqid.get(fbe_value.seqid);
        }
    else
        fbe_value.seqid = (uint32_t)0ull;
    fbe_current_size += seqid.fbe_size();

    if ((fbe_current_size + type_id.fbe_size()) <= fbe_struct_size)
        {
            type_id.get(fbe_value.type_id);
        }
    else
        fbe_value.type_id = (uint32_t)0ull;
    fbe_current_size += type_id.fbe_size();
}

size_t FieldModel_pg_query_NextValueExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NextValueExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NextValueExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_NextValueExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::NextValueExpr& fbe_value = static_cast<const ::pg_query::NextValueExpr&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    seqid.set(fbe_value.seqid);
    type_id.set(fbe_value.type_id);
}

namespace pg_query {

bool NextValueExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t NextValueExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t NextValueExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t NextValueExprModel::serialize(const ::pg_query::NextValueExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t NextValueExprModel::deserialize(::pg_query::NextValueExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_InferenceElem::FieldModelPtr_pg_query_InferenceElem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_InferenceElem::~FieldModelPtr_pg_query_InferenceElem()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_InferenceElem::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_InferenceElem::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_InferenceElem::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_InferenceElem::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_InferenceElem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_InferenceElem::get(::pg_query::InferenceElem** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_InferenceElem(_buffer, 0);

    ::pg_query::InferenceElem *tempModel = new ::pg_query::InferenceElem();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_InferenceElem::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_InferenceElem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_InferenceElem::set(const ::pg_query::InferenceElem* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_InferenceElem(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_InferenceElem::FieldModel_pg_query_InferenceElem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , expr(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , infercollid(buffer, expr.fbe_offset() + expr.fbe_size())
    , inferopclass(buffer, infercollid.fbe_offset() + infercollid.fbe_size())
{}

size_t FieldModel_pg_query_InferenceElem::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + expr.fbe_size()
        + infercollid.fbe_size()
        + inferopclass.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_InferenceElem::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + expr.fbe_extra()
        + infercollid.fbe_extra()
        + inferopclass.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_InferenceElem::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_InferenceElem::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) > fbe_struct_size)
        return true;
    if (!expr.verify())
        return false;
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + infercollid.fbe_size()) > fbe_struct_size)
        return true;
    if (!infercollid.verify())
        return false;
    fbe_current_size += infercollid.fbe_size();

    if ((fbe_current_size + inferopclass.fbe_size()) > fbe_struct_size)
        return true;
    if (!inferopclass.verify())
        return false;
    fbe_current_size += inferopclass.fbe_size();

    return true;
}

size_t FieldModel_pg_query_InferenceElem::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_InferenceElem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_InferenceElem::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_InferenceElem::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::InferenceElem& fbe_value = static_cast<::pg_query::InferenceElem&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) <= fbe_struct_size)
        {
            expr.get(fbe_value.expr);
        }
    else
        fbe_value.expr = ::pg_query::Node();
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + infercollid.fbe_size()) <= fbe_struct_size)
        {
            infercollid.get(fbe_value.infercollid);
        }
    else
        fbe_value.infercollid = (uint32_t)0ull;
    fbe_current_size += infercollid.fbe_size();

    if ((fbe_current_size + inferopclass.fbe_size()) <= fbe_struct_size)
        {
            inferopclass.get(fbe_value.inferopclass);
        }
    else
        fbe_value.inferopclass = (uint32_t)0ull;
    fbe_current_size += inferopclass.fbe_size();
}

size_t FieldModel_pg_query_InferenceElem::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_InferenceElem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_InferenceElem::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_InferenceElem::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::InferenceElem& fbe_value = static_cast<const ::pg_query::InferenceElem&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    expr.set(fbe_value.expr);
    infercollid.set(fbe_value.infercollid);
    inferopclass.set(fbe_value.inferopclass);
}

namespace pg_query {

bool InferenceElemModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t InferenceElemModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t InferenceElemModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t InferenceElemModel::serialize(const ::pg_query::InferenceElem& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t InferenceElemModel::deserialize(::pg_query::InferenceElem& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_TargetEntry::FieldModelPtr_pg_query_TargetEntry(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_TargetEntry::~FieldModelPtr_pg_query_TargetEntry()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_TargetEntry::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_TargetEntry::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_TargetEntry::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_TargetEntry::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TargetEntry::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TargetEntry::get(::pg_query::TargetEntry** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_TargetEntry(_buffer, 0);

    ::pg_query::TargetEntry *tempModel = new ::pg_query::TargetEntry();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_TargetEntry::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TargetEntry::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TargetEntry::set(const ::pg_query::TargetEntry* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_TargetEntry(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_TargetEntry::FieldModel_pg_query_TargetEntry(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xpr(buffer, 4 + 4)
    , expr(buffer, xpr.fbe_offset() + xpr.fbe_size())
    , resno(buffer, expr.fbe_offset() + expr.fbe_size())
    , resname(buffer, resno.fbe_offset() + resno.fbe_size())
    , ressortgroupref(buffer, resname.fbe_offset() + resname.fbe_size())
    , resorigtbl(buffer, ressortgroupref.fbe_offset() + ressortgroupref.fbe_size())
    , resorigcol(buffer, resorigtbl.fbe_offset() + resorigtbl.fbe_size())
    , resjunk(buffer, resorigcol.fbe_offset() + resorigcol.fbe_size())
{}

size_t FieldModel_pg_query_TargetEntry::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xpr.fbe_size()
        + expr.fbe_size()
        + resno.fbe_size()
        + resname.fbe_size()
        + ressortgroupref.fbe_size()
        + resorigtbl.fbe_size()
        + resorigcol.fbe_size()
        + resjunk.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_TargetEntry::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xpr.fbe_extra()
        + expr.fbe_extra()
        + resno.fbe_extra()
        + resname.fbe_extra()
        + ressortgroupref.fbe_extra()
        + resorigtbl.fbe_extra()
        + resorigcol.fbe_extra()
        + resjunk.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_TargetEntry::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_TargetEntry::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!xpr.verify())
        return false;
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) > fbe_struct_size)
        return true;
    if (!expr.verify())
        return false;
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + resno.fbe_size()) > fbe_struct_size)
        return true;
    if (!resno.verify())
        return false;
    fbe_current_size += resno.fbe_size();

    if ((fbe_current_size + resname.fbe_size()) > fbe_struct_size)
        return true;
    if (!resname.verify())
        return false;
    fbe_current_size += resname.fbe_size();

    if ((fbe_current_size + ressortgroupref.fbe_size()) > fbe_struct_size)
        return true;
    if (!ressortgroupref.verify())
        return false;
    fbe_current_size += ressortgroupref.fbe_size();

    if ((fbe_current_size + resorigtbl.fbe_size()) > fbe_struct_size)
        return true;
    if (!resorigtbl.verify())
        return false;
    fbe_current_size += resorigtbl.fbe_size();

    if ((fbe_current_size + resorigcol.fbe_size()) > fbe_struct_size)
        return true;
    if (!resorigcol.verify())
        return false;
    fbe_current_size += resorigcol.fbe_size();

    if ((fbe_current_size + resjunk.fbe_size()) > fbe_struct_size)
        return true;
    if (!resjunk.verify())
        return false;
    fbe_current_size += resjunk.fbe_size();

    return true;
}

size_t FieldModel_pg_query_TargetEntry::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TargetEntry::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TargetEntry::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_TargetEntry::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::TargetEntry& fbe_value = static_cast<::pg_query::TargetEntry&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xpr.fbe_size()) <= fbe_struct_size)
        {
            xpr.get(fbe_value.xpr);
        }
    else
        fbe_value.xpr = ::pg_query::Node();
    fbe_current_size += xpr.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) <= fbe_struct_size)
        {
            expr.get(fbe_value.expr);
        }
    else
        fbe_value.expr = ::pg_query::Node();
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + resno.fbe_size()) <= fbe_struct_size)
        {
            resno.get(fbe_value.resno);
        }
    else
        fbe_value.resno = (int32_t)0ll;
    fbe_current_size += resno.fbe_size();

    if ((fbe_current_size + resname.fbe_size()) <= fbe_struct_size)
        {
            resname.get(fbe_value.resname);
        }
    else
        fbe_value.resname = "";
    fbe_current_size += resname.fbe_size();

    if ((fbe_current_size + ressortgroupref.fbe_size()) <= fbe_struct_size)
        {
            ressortgroupref.get(fbe_value.ressortgroupref);
        }
    else
        fbe_value.ressortgroupref = (uint32_t)0ull;
    fbe_current_size += ressortgroupref.fbe_size();

    if ((fbe_current_size + resorigtbl.fbe_size()) <= fbe_struct_size)
        {
            resorigtbl.get(fbe_value.resorigtbl);
        }
    else
        fbe_value.resorigtbl = (uint32_t)0ull;
    fbe_current_size += resorigtbl.fbe_size();

    if ((fbe_current_size + resorigcol.fbe_size()) <= fbe_struct_size)
        {
            resorigcol.get(fbe_value.resorigcol);
        }
    else
        fbe_value.resorigcol = (int32_t)0ll;
    fbe_current_size += resorigcol.fbe_size();

    if ((fbe_current_size + resjunk.fbe_size()) <= fbe_struct_size)
        {
            resjunk.get(fbe_value.resjunk);
        }
    else
        fbe_value.resjunk = false;
    fbe_current_size += resjunk.fbe_size();
}

size_t FieldModel_pg_query_TargetEntry::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TargetEntry::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TargetEntry::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_TargetEntry::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::TargetEntry& fbe_value = static_cast<const ::pg_query::TargetEntry&>(base_fbe_value);
    xpr.set(fbe_value.xpr);
    expr.set(fbe_value.expr);
    resno.set(fbe_value.resno);
    resname.set(fbe_value.resname);
    ressortgroupref.set(fbe_value.ressortgroupref);
    resorigtbl.set(fbe_value.resorigtbl);
    resorigcol.set(fbe_value.resorigcol);
    resjunk.set(fbe_value.resjunk);
}

namespace pg_query {

bool TargetEntryModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TargetEntryModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TargetEntryModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TargetEntryModel::serialize(const ::pg_query::TargetEntry& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TargetEntryModel::deserialize(::pg_query::TargetEntry& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RangeTblRef::FieldModelPtr_pg_query_RangeTblRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RangeTblRef::~FieldModelPtr_pg_query_RangeTblRef()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RangeTblRef::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTblRef::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTblRef::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RangeTblRef::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTblRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTblRef::get(::pg_query::RangeTblRef** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RangeTblRef(_buffer, 0);

    ::pg_query::RangeTblRef *tempModel = new ::pg_query::RangeTblRef();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RangeTblRef::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTblRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTblRef::set(const ::pg_query::RangeTblRef* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RangeTblRef(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RangeTblRef::FieldModel_pg_query_RangeTblRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , rtindex(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_RangeTblRef::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + rtindex.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RangeTblRef::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + rtindex.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RangeTblRef::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RangeTblRef::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rtindex.fbe_size()) > fbe_struct_size)
        return true;
    if (!rtindex.verify())
        return false;
    fbe_current_size += rtindex.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RangeTblRef::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTblRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTblRef::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RangeTblRef::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RangeTblRef& fbe_value = static_cast<::pg_query::RangeTblRef&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rtindex.fbe_size()) <= fbe_struct_size)
        {
            rtindex.get(fbe_value.rtindex);
        }
    else
        fbe_value.rtindex = (int32_t)0ll;
    fbe_current_size += rtindex.fbe_size();
}

size_t FieldModel_pg_query_RangeTblRef::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTblRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTblRef::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RangeTblRef::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RangeTblRef& fbe_value = static_cast<const ::pg_query::RangeTblRef&>(base_fbe_value);
    rtindex.set(fbe_value.rtindex);
}

namespace pg_query {

bool RangeTblRefModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RangeTblRefModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RangeTblRefModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RangeTblRefModel::serialize(const ::pg_query::RangeTblRef& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RangeTblRefModel::deserialize(::pg_query::RangeTblRef& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_JoinExpr::FieldModelPtr_pg_query_JoinExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_JoinExpr::~FieldModelPtr_pg_query_JoinExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_JoinExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_JoinExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_JoinExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_JoinExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_JoinExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_JoinExpr::get(::pg_query::JoinExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_JoinExpr(_buffer, 0);

    ::pg_query::JoinExpr *tempModel = new ::pg_query::JoinExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_JoinExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_JoinExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_JoinExpr::set(const ::pg_query::JoinExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_JoinExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_JoinExpr::FieldModel_pg_query_JoinExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , jointype(buffer, 4 + 4)
    , is_natural(buffer, jointype.fbe_offset() + jointype.fbe_size())
    , larg(buffer, is_natural.fbe_offset() + is_natural.fbe_size())
    , rarg(buffer, larg.fbe_offset() + larg.fbe_size())
    , using_clause(buffer, rarg.fbe_offset() + rarg.fbe_size())
    , quals(buffer, using_clause.fbe_offset() + using_clause.fbe_size())
    , alias(buffer, quals.fbe_offset() + quals.fbe_size())
    , rtindex(buffer, alias.fbe_offset() + alias.fbe_size())
{}

size_t FieldModel_pg_query_JoinExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + jointype.fbe_size()
        + is_natural.fbe_size()
        + larg.fbe_size()
        + rarg.fbe_size()
        + using_clause.fbe_size()
        + quals.fbe_size()
        + alias.fbe_size()
        + rtindex.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_JoinExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + jointype.fbe_extra()
        + is_natural.fbe_extra()
        + larg.fbe_extra()
        + rarg.fbe_extra()
        + using_clause.fbe_extra()
        + quals.fbe_extra()
        + alias.fbe_extra()
        + rtindex.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_JoinExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_JoinExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + jointype.fbe_size()) > fbe_struct_size)
        return true;
    if (!jointype.verify())
        return false;
    fbe_current_size += jointype.fbe_size();

    if ((fbe_current_size + is_natural.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_natural.verify())
        return false;
    fbe_current_size += is_natural.fbe_size();

    if ((fbe_current_size + larg.fbe_size()) > fbe_struct_size)
        return true;
    if (!larg.verify())
        return false;
    fbe_current_size += larg.fbe_size();

    if ((fbe_current_size + rarg.fbe_size()) > fbe_struct_size)
        return true;
    if (!rarg.verify())
        return false;
    fbe_current_size += rarg.fbe_size();

    if ((fbe_current_size + using_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!using_clause.verify())
        return false;
    fbe_current_size += using_clause.fbe_size();

    if ((fbe_current_size + quals.fbe_size()) > fbe_struct_size)
        return true;
    if (!quals.verify())
        return false;
    fbe_current_size += quals.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) > fbe_struct_size)
        return true;
    if (!alias.verify())
        return false;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + rtindex.fbe_size()) > fbe_struct_size)
        return true;
    if (!rtindex.verify())
        return false;
    fbe_current_size += rtindex.fbe_size();

    return true;
}

size_t FieldModel_pg_query_JoinExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_JoinExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_JoinExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_JoinExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::JoinExpr& fbe_value = static_cast<::pg_query::JoinExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + jointype.fbe_size()) <= fbe_struct_size)
        {
            jointype.get(fbe_value.jointype);
        }
    else
        fbe_value.jointype = ::pg_query::JoinType();
    fbe_current_size += jointype.fbe_size();

    if ((fbe_current_size + is_natural.fbe_size()) <= fbe_struct_size)
        {
            is_natural.get(fbe_value.is_natural);
        }
    else
        fbe_value.is_natural = false;
    fbe_current_size += is_natural.fbe_size();

    if ((fbe_current_size + larg.fbe_size()) <= fbe_struct_size)
        {
            larg.get(fbe_value.larg);
        }
    else
        fbe_value.larg = ::pg_query::Node();
    fbe_current_size += larg.fbe_size();

    if ((fbe_current_size + rarg.fbe_size()) <= fbe_struct_size)
        {
            rarg.get(fbe_value.rarg);
        }
    else
        fbe_value.rarg = ::pg_query::Node();
    fbe_current_size += rarg.fbe_size();

    if ((fbe_current_size + using_clause.fbe_size()) <= fbe_struct_size)
        {
            using_clause.get(fbe_value.using_clause);
        }
    else
        fbe_value.using_clause.clear();
    fbe_current_size += using_clause.fbe_size();

    if ((fbe_current_size + quals.fbe_size()) <= fbe_struct_size)
        {
            quals.get(fbe_value.quals);
        }
    else
        fbe_value.quals = ::pg_query::Node();
    fbe_current_size += quals.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) <= fbe_struct_size)
        {
            alias.get(&fbe_value.alias);
        }
    else
        fbe_value.alias = nullptr;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + rtindex.fbe_size()) <= fbe_struct_size)
        {
            rtindex.get(fbe_value.rtindex);
        }
    else
        fbe_value.rtindex = (int32_t)0ll;
    fbe_current_size += rtindex.fbe_size();
}

size_t FieldModel_pg_query_JoinExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_JoinExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_JoinExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_JoinExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::JoinExpr& fbe_value = static_cast<const ::pg_query::JoinExpr&>(base_fbe_value);
    jointype.set(fbe_value.jointype);
    is_natural.set(fbe_value.is_natural);
    larg.set(fbe_value.larg);
    rarg.set(fbe_value.rarg);
    using_clause.set(fbe_value.using_clause);
    quals.set(fbe_value.quals);
    alias.set(fbe_value.alias);
    rtindex.set(fbe_value.rtindex);
}

namespace pg_query {

bool JoinExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t JoinExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t JoinExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t JoinExprModel::serialize(const ::pg_query::JoinExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t JoinExprModel::deserialize(::pg_query::JoinExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_FromExpr::FieldModelPtr_pg_query_FromExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_FromExpr::~FieldModelPtr_pg_query_FromExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_FromExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_FromExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_FromExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_FromExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FromExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FromExpr::get(::pg_query::FromExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_FromExpr(_buffer, 0);

    ::pg_query::FromExpr *tempModel = new ::pg_query::FromExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_FromExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FromExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FromExpr::set(const ::pg_query::FromExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_FromExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_FromExpr::FieldModel_pg_query_FromExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , fromlist(buffer, 4 + 4)
    , quals(buffer, fromlist.fbe_offset() + fromlist.fbe_size())
{}

size_t FieldModel_pg_query_FromExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + fromlist.fbe_size()
        + quals.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_FromExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + fromlist.fbe_extra()
        + quals.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_FromExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_FromExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + fromlist.fbe_size()) > fbe_struct_size)
        return true;
    if (!fromlist.verify())
        return false;
    fbe_current_size += fromlist.fbe_size();

    if ((fbe_current_size + quals.fbe_size()) > fbe_struct_size)
        return true;
    if (!quals.verify())
        return false;
    fbe_current_size += quals.fbe_size();

    return true;
}

size_t FieldModel_pg_query_FromExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FromExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FromExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_FromExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::FromExpr& fbe_value = static_cast<::pg_query::FromExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + fromlist.fbe_size()) <= fbe_struct_size)
        {
            fromlist.get(fbe_value.fromlist);
        }
    else
        fbe_value.fromlist.clear();
    fbe_current_size += fromlist.fbe_size();

    if ((fbe_current_size + quals.fbe_size()) <= fbe_struct_size)
        {
            quals.get(fbe_value.quals);
        }
    else
        fbe_value.quals = ::pg_query::Node();
    fbe_current_size += quals.fbe_size();
}

size_t FieldModel_pg_query_FromExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FromExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FromExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_FromExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::FromExpr& fbe_value = static_cast<const ::pg_query::FromExpr&>(base_fbe_value);
    fromlist.set(fbe_value.fromlist);
    quals.set(fbe_value.quals);
}

namespace pg_query {

bool FromExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t FromExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t FromExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t FromExprModel::serialize(const ::pg_query::FromExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t FromExprModel::deserialize(::pg_query::FromExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_OnConflictExpr::FieldModelPtr_pg_query_OnConflictExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_OnConflictExpr::~FieldModelPtr_pg_query_OnConflictExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_OnConflictExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_OnConflictExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_OnConflictExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_OnConflictExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_OnConflictExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_OnConflictExpr::get(::pg_query::OnConflictExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_OnConflictExpr(_buffer, 0);

    ::pg_query::OnConflictExpr *tempModel = new ::pg_query::OnConflictExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_OnConflictExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_OnConflictExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_OnConflictExpr::set(const ::pg_query::OnConflictExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_OnConflictExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_OnConflictExpr::FieldModel_pg_query_OnConflictExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , action(buffer, 4 + 4)
    , arbiter_elems(buffer, action.fbe_offset() + action.fbe_size())
    , arbiter_where(buffer, arbiter_elems.fbe_offset() + arbiter_elems.fbe_size())
    , constraint(buffer, arbiter_where.fbe_offset() + arbiter_where.fbe_size())
    , on_conflict_set(buffer, constraint.fbe_offset() + constraint.fbe_size())
    , on_conflict_where(buffer, on_conflict_set.fbe_offset() + on_conflict_set.fbe_size())
    , excl_rel_index(buffer, on_conflict_where.fbe_offset() + on_conflict_where.fbe_size())
    , excl_rel_tlist(buffer, excl_rel_index.fbe_offset() + excl_rel_index.fbe_size())
{}

size_t FieldModel_pg_query_OnConflictExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + action.fbe_size()
        + arbiter_elems.fbe_size()
        + arbiter_where.fbe_size()
        + constraint.fbe_size()
        + on_conflict_set.fbe_size()
        + on_conflict_where.fbe_size()
        + excl_rel_index.fbe_size()
        + excl_rel_tlist.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_OnConflictExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + action.fbe_extra()
        + arbiter_elems.fbe_extra()
        + arbiter_where.fbe_extra()
        + constraint.fbe_extra()
        + on_conflict_set.fbe_extra()
        + on_conflict_where.fbe_extra()
        + excl_rel_index.fbe_extra()
        + excl_rel_tlist.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_OnConflictExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_OnConflictExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + action.fbe_size()) > fbe_struct_size)
        return true;
    if (!action.verify())
        return false;
    fbe_current_size += action.fbe_size();

    if ((fbe_current_size + arbiter_elems.fbe_size()) > fbe_struct_size)
        return true;
    if (!arbiter_elems.verify())
        return false;
    fbe_current_size += arbiter_elems.fbe_size();

    if ((fbe_current_size + arbiter_where.fbe_size()) > fbe_struct_size)
        return true;
    if (!arbiter_where.verify())
        return false;
    fbe_current_size += arbiter_where.fbe_size();

    if ((fbe_current_size + constraint.fbe_size()) > fbe_struct_size)
        return true;
    if (!constraint.verify())
        return false;
    fbe_current_size += constraint.fbe_size();

    if ((fbe_current_size + on_conflict_set.fbe_size()) > fbe_struct_size)
        return true;
    if (!on_conflict_set.verify())
        return false;
    fbe_current_size += on_conflict_set.fbe_size();

    if ((fbe_current_size + on_conflict_where.fbe_size()) > fbe_struct_size)
        return true;
    if (!on_conflict_where.verify())
        return false;
    fbe_current_size += on_conflict_where.fbe_size();

    if ((fbe_current_size + excl_rel_index.fbe_size()) > fbe_struct_size)
        return true;
    if (!excl_rel_index.verify())
        return false;
    fbe_current_size += excl_rel_index.fbe_size();

    if ((fbe_current_size + excl_rel_tlist.fbe_size()) > fbe_struct_size)
        return true;
    if (!excl_rel_tlist.verify())
        return false;
    fbe_current_size += excl_rel_tlist.fbe_size();

    return true;
}

size_t FieldModel_pg_query_OnConflictExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_OnConflictExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_OnConflictExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_OnConflictExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::OnConflictExpr& fbe_value = static_cast<::pg_query::OnConflictExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + action.fbe_size()) <= fbe_struct_size)
        {
            action.get(fbe_value.action);
        }
    else
        fbe_value.action = ::pg_query::OnConflictAction();
    fbe_current_size += action.fbe_size();

    if ((fbe_current_size + arbiter_elems.fbe_size()) <= fbe_struct_size)
        {
            arbiter_elems.get(fbe_value.arbiter_elems);
        }
    else
        fbe_value.arbiter_elems.clear();
    fbe_current_size += arbiter_elems.fbe_size();

    if ((fbe_current_size + arbiter_where.fbe_size()) <= fbe_struct_size)
        {
            arbiter_where.get(fbe_value.arbiter_where);
        }
    else
        fbe_value.arbiter_where = ::pg_query::Node();
    fbe_current_size += arbiter_where.fbe_size();

    if ((fbe_current_size + constraint.fbe_size()) <= fbe_struct_size)
        {
            constraint.get(fbe_value.constraint);
        }
    else
        fbe_value.constraint = (uint32_t)0ull;
    fbe_current_size += constraint.fbe_size();

    if ((fbe_current_size + on_conflict_set.fbe_size()) <= fbe_struct_size)
        {
            on_conflict_set.get(fbe_value.on_conflict_set);
        }
    else
        fbe_value.on_conflict_set.clear();
    fbe_current_size += on_conflict_set.fbe_size();

    if ((fbe_current_size + on_conflict_where.fbe_size()) <= fbe_struct_size)
        {
            on_conflict_where.get(fbe_value.on_conflict_where);
        }
    else
        fbe_value.on_conflict_where = ::pg_query::Node();
    fbe_current_size += on_conflict_where.fbe_size();

    if ((fbe_current_size + excl_rel_index.fbe_size()) <= fbe_struct_size)
        {
            excl_rel_index.get(fbe_value.excl_rel_index);
        }
    else
        fbe_value.excl_rel_index = (int32_t)0ll;
    fbe_current_size += excl_rel_index.fbe_size();

    if ((fbe_current_size + excl_rel_tlist.fbe_size()) <= fbe_struct_size)
        {
            excl_rel_tlist.get(fbe_value.excl_rel_tlist);
        }
    else
        fbe_value.excl_rel_tlist.clear();
    fbe_current_size += excl_rel_tlist.fbe_size();
}

size_t FieldModel_pg_query_OnConflictExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_OnConflictExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_OnConflictExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_OnConflictExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::OnConflictExpr& fbe_value = static_cast<const ::pg_query::OnConflictExpr&>(base_fbe_value);
    action.set(fbe_value.action);
    arbiter_elems.set(fbe_value.arbiter_elems);
    arbiter_where.set(fbe_value.arbiter_where);
    constraint.set(fbe_value.constraint);
    on_conflict_set.set(fbe_value.on_conflict_set);
    on_conflict_where.set(fbe_value.on_conflict_where);
    excl_rel_index.set(fbe_value.excl_rel_index);
    excl_rel_tlist.set(fbe_value.excl_rel_tlist);
}

namespace pg_query {

bool OnConflictExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t OnConflictExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t OnConflictExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t OnConflictExprModel::serialize(const ::pg_query::OnConflictExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t OnConflictExprModel::deserialize(::pg_query::OnConflictExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_IntoClause::FieldModelPtr_pg_query_IntoClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_IntoClause::~FieldModelPtr_pg_query_IntoClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_IntoClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_IntoClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_IntoClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_IntoClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_IntoClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_IntoClause::get(::pg_query::IntoClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_IntoClause(_buffer, 0);

    ::pg_query::IntoClause *tempModel = new ::pg_query::IntoClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_IntoClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_IntoClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_IntoClause::set(const ::pg_query::IntoClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_IntoClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_IntoClause::FieldModel_pg_query_IntoClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , rel(buffer, 4 + 4)
    , col_names(buffer, rel.fbe_offset() + rel.fbe_size())
    , access_method(buffer, col_names.fbe_offset() + col_names.fbe_size())
    , options(buffer, access_method.fbe_offset() + access_method.fbe_size())
    , on_commit(buffer, options.fbe_offset() + options.fbe_size())
    , table_space_name(buffer, on_commit.fbe_offset() + on_commit.fbe_size())
    , view_query(buffer, table_space_name.fbe_offset() + table_space_name.fbe_size())
    , skip_data(buffer, view_query.fbe_offset() + view_query.fbe_size())
{}

size_t FieldModel_pg_query_IntoClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + rel.fbe_size()
        + col_names.fbe_size()
        + access_method.fbe_size()
        + options.fbe_size()
        + on_commit.fbe_size()
        + table_space_name.fbe_size()
        + view_query.fbe_size()
        + skip_data.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_IntoClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + rel.fbe_extra()
        + col_names.fbe_extra()
        + access_method.fbe_extra()
        + options.fbe_extra()
        + on_commit.fbe_extra()
        + table_space_name.fbe_extra()
        + view_query.fbe_extra()
        + skip_data.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_IntoClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_IntoClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rel.fbe_size()) > fbe_struct_size)
        return true;
    if (!rel.verify())
        return false;
    fbe_current_size += rel.fbe_size();

    if ((fbe_current_size + col_names.fbe_size()) > fbe_struct_size)
        return true;
    if (!col_names.verify())
        return false;
    fbe_current_size += col_names.fbe_size();

    if ((fbe_current_size + access_method.fbe_size()) > fbe_struct_size)
        return true;
    if (!access_method.verify())
        return false;
    fbe_current_size += access_method.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + on_commit.fbe_size()) > fbe_struct_size)
        return true;
    if (!on_commit.verify())
        return false;
    fbe_current_size += on_commit.fbe_size();

    if ((fbe_current_size + table_space_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!table_space_name.verify())
        return false;
    fbe_current_size += table_space_name.fbe_size();

    if ((fbe_current_size + view_query.fbe_size()) > fbe_struct_size)
        return true;
    if (!view_query.verify())
        return false;
    fbe_current_size += view_query.fbe_size();

    if ((fbe_current_size + skip_data.fbe_size()) > fbe_struct_size)
        return true;
    if (!skip_data.verify())
        return false;
    fbe_current_size += skip_data.fbe_size();

    return true;
}

size_t FieldModel_pg_query_IntoClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_IntoClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_IntoClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_IntoClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::IntoClause& fbe_value = static_cast<::pg_query::IntoClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rel.fbe_size()) <= fbe_struct_size)
        {
            rel.get(&fbe_value.rel);
        }
    else
        fbe_value.rel = nullptr;
    fbe_current_size += rel.fbe_size();

    if ((fbe_current_size + col_names.fbe_size()) <= fbe_struct_size)
        {
            col_names.get(fbe_value.col_names);
        }
    else
        fbe_value.col_names.clear();
    fbe_current_size += col_names.fbe_size();

    if ((fbe_current_size + access_method.fbe_size()) <= fbe_struct_size)
        {
            access_method.get(fbe_value.access_method);
        }
    else
        fbe_value.access_method = "";
    fbe_current_size += access_method.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + on_commit.fbe_size()) <= fbe_struct_size)
        {
            on_commit.get(fbe_value.on_commit);
        }
    else
        fbe_value.on_commit = ::pg_query::OnCommitAction();
    fbe_current_size += on_commit.fbe_size();

    if ((fbe_current_size + table_space_name.fbe_size()) <= fbe_struct_size)
        {
            table_space_name.get(fbe_value.table_space_name);
        }
    else
        fbe_value.table_space_name = "";
    fbe_current_size += table_space_name.fbe_size();

    if ((fbe_current_size + view_query.fbe_size()) <= fbe_struct_size)
        {
            view_query.get(fbe_value.view_query);
        }
    else
        fbe_value.view_query = ::pg_query::Node();
    fbe_current_size += view_query.fbe_size();

    if ((fbe_current_size + skip_data.fbe_size()) <= fbe_struct_size)
        {
            skip_data.get(fbe_value.skip_data);
        }
    else
        fbe_value.skip_data = false;
    fbe_current_size += skip_data.fbe_size();
}

size_t FieldModel_pg_query_IntoClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_IntoClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_IntoClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_IntoClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::IntoClause& fbe_value = static_cast<const ::pg_query::IntoClause&>(base_fbe_value);
    rel.set(fbe_value.rel);
    col_names.set(fbe_value.col_names);
    access_method.set(fbe_value.access_method);
    options.set(fbe_value.options);
    on_commit.set(fbe_value.on_commit);
    table_space_name.set(fbe_value.table_space_name);
    view_query.set(fbe_value.view_query);
    skip_data.set(fbe_value.skip_data);
}

namespace pg_query {

bool IntoClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t IntoClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t IntoClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t IntoClauseModel::serialize(const ::pg_query::IntoClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t IntoClauseModel::deserialize(::pg_query::IntoClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RawStmt::FieldModelPtr_pg_query_RawStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RawStmt::~FieldModelPtr_pg_query_RawStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RawStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RawStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RawStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RawStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RawStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RawStmt::get(::pg_query::RawStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RawStmt(_buffer, 0);

    ::pg_query::RawStmt *tempModel = new ::pg_query::RawStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RawStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RawStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RawStmt::set(const ::pg_query::RawStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RawStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RawStmt::FieldModel_pg_query_RawStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , stmt(buffer, 4 + 4)
    , stmt_location(buffer, stmt.fbe_offset() + stmt.fbe_size())
    , stmt_len(buffer, stmt_location.fbe_offset() + stmt_location.fbe_size())
{}

size_t FieldModel_pg_query_RawStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + stmt.fbe_size()
        + stmt_location.fbe_size()
        + stmt_len.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RawStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + stmt.fbe_extra()
        + stmt_location.fbe_extra()
        + stmt_len.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RawStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RawStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + stmt.fbe_size()) > fbe_struct_size)
        return true;
    if (!stmt.verify())
        return false;
    fbe_current_size += stmt.fbe_size();

    if ((fbe_current_size + stmt_location.fbe_size()) > fbe_struct_size)
        return true;
    if (!stmt_location.verify())
        return false;
    fbe_current_size += stmt_location.fbe_size();

    if ((fbe_current_size + stmt_len.fbe_size()) > fbe_struct_size)
        return true;
    if (!stmt_len.verify())
        return false;
    fbe_current_size += stmt_len.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RawStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RawStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RawStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RawStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RawStmt& fbe_value = static_cast<::pg_query::RawStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + stmt.fbe_size()) <= fbe_struct_size)
        {
            stmt.get(fbe_value.stmt);
        }
    else
        fbe_value.stmt = ::pg_query::Node();
    fbe_current_size += stmt.fbe_size();

    if ((fbe_current_size + stmt_location.fbe_size()) <= fbe_struct_size)
        {
            stmt_location.get(fbe_value.stmt_location);
        }
    else
        fbe_value.stmt_location = (int32_t)0ll;
    fbe_current_size += stmt_location.fbe_size();

    if ((fbe_current_size + stmt_len.fbe_size()) <= fbe_struct_size)
        {
            stmt_len.get(fbe_value.stmt_len);
        }
    else
        fbe_value.stmt_len = (int32_t)0ll;
    fbe_current_size += stmt_len.fbe_size();
}

size_t FieldModel_pg_query_RawStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RawStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RawStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RawStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RawStmt& fbe_value = static_cast<const ::pg_query::RawStmt&>(base_fbe_value);
    stmt.set(fbe_value.stmt);
    stmt_location.set(fbe_value.stmt_location);
    stmt_len.set(fbe_value.stmt_len);
}

namespace pg_query {

bool RawStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RawStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RawStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RawStmtModel::serialize(const ::pg_query::RawStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RawStmtModel::deserialize(::pg_query::RawStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_Query::FieldModelPtr_pg_query_Query(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Query::~FieldModelPtr_pg_query_Query()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Query::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Query::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Query::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Query::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Query::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Query::get(::pg_query::Query** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Query(_buffer, 0);

    ::pg_query::Query *tempModel = new ::pg_query::Query();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Query::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Query::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Query::set(const ::pg_query::Query* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Query(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Query::FieldModel_pg_query_Query(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , command_type(buffer, 4 + 4)
    , query_source(buffer, command_type.fbe_offset() + command_type.fbe_size())
    , can_set_tag(buffer, query_source.fbe_offset() + query_source.fbe_size())
    , utility_stmt(buffer, can_set_tag.fbe_offset() + can_set_tag.fbe_size())
    , result_relation(buffer, utility_stmt.fbe_offset() + utility_stmt.fbe_size())
    , has_aggs(buffer, result_relation.fbe_offset() + result_relation.fbe_size())
    , has_window_funcs(buffer, has_aggs.fbe_offset() + has_aggs.fbe_size())
    , has_target_srfs(buffer, has_window_funcs.fbe_offset() + has_window_funcs.fbe_size())
    , has_sub_links(buffer, has_target_srfs.fbe_offset() + has_target_srfs.fbe_size())
    , has_distinct_on(buffer, has_sub_links.fbe_offset() + has_sub_links.fbe_size())
    , has_recursive(buffer, has_distinct_on.fbe_offset() + has_distinct_on.fbe_size())
    , has_modifying_cte(buffer, has_recursive.fbe_offset() + has_recursive.fbe_size())
    , has_for_update(buffer, has_modifying_cte.fbe_offset() + has_modifying_cte.fbe_size())
    , has_row_security(buffer, has_for_update.fbe_offset() + has_for_update.fbe_size())
    , cte_list(buffer, has_row_security.fbe_offset() + has_row_security.fbe_size())
    , rtable(buffer, cte_list.fbe_offset() + cte_list.fbe_size())
    , jointree(buffer, rtable.fbe_offset() + rtable.fbe_size())
    , target_list(buffer, jointree.fbe_offset() + jointree.fbe_size())
    , override(buffer, target_list.fbe_offset() + target_list.fbe_size())
    , on_conflict(buffer, override.fbe_offset() + override.fbe_size())
    , returning_list(buffer, on_conflict.fbe_offset() + on_conflict.fbe_size())
    , group_clause(buffer, returning_list.fbe_offset() + returning_list.fbe_size())
    , grouping_sets(buffer, group_clause.fbe_offset() + group_clause.fbe_size())
    , having_qual(buffer, grouping_sets.fbe_offset() + grouping_sets.fbe_size())
    , window_clause(buffer, having_qual.fbe_offset() + having_qual.fbe_size())
    , distinct_clause(buffer, window_clause.fbe_offset() + window_clause.fbe_size())
    , sort_clause(buffer, distinct_clause.fbe_offset() + distinct_clause.fbe_size())
    , limit_offset(buffer, sort_clause.fbe_offset() + sort_clause.fbe_size())
    , limit_count(buffer, limit_offset.fbe_offset() + limit_offset.fbe_size())
    , limit_option(buffer, limit_count.fbe_offset() + limit_count.fbe_size())
    , row_marks(buffer, limit_option.fbe_offset() + limit_option.fbe_size())
    , set_operations(buffer, row_marks.fbe_offset() + row_marks.fbe_size())
    , constraint_deps(buffer, set_operations.fbe_offset() + set_operations.fbe_size())
    , with_check_options(buffer, constraint_deps.fbe_offset() + constraint_deps.fbe_size())
    , stmt_location(buffer, with_check_options.fbe_offset() + with_check_options.fbe_size())
    , stmt_len(buffer, stmt_location.fbe_offset() + stmt_location.fbe_size())
{}

size_t FieldModel_pg_query_Query::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + command_type.fbe_size()
        + query_source.fbe_size()
        + can_set_tag.fbe_size()
        + utility_stmt.fbe_size()
        + result_relation.fbe_size()
        + has_aggs.fbe_size()
        + has_window_funcs.fbe_size()
        + has_target_srfs.fbe_size()
        + has_sub_links.fbe_size()
        + has_distinct_on.fbe_size()
        + has_recursive.fbe_size()
        + has_modifying_cte.fbe_size()
        + has_for_update.fbe_size()
        + has_row_security.fbe_size()
        + cte_list.fbe_size()
        + rtable.fbe_size()
        + jointree.fbe_size()
        + target_list.fbe_size()
        + override.fbe_size()
        + on_conflict.fbe_size()
        + returning_list.fbe_size()
        + group_clause.fbe_size()
        + grouping_sets.fbe_size()
        + having_qual.fbe_size()
        + window_clause.fbe_size()
        + distinct_clause.fbe_size()
        + sort_clause.fbe_size()
        + limit_offset.fbe_size()
        + limit_count.fbe_size()
        + limit_option.fbe_size()
        + row_marks.fbe_size()
        + set_operations.fbe_size()
        + constraint_deps.fbe_size()
        + with_check_options.fbe_size()
        + stmt_location.fbe_size()
        + stmt_len.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Query::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + command_type.fbe_extra()
        + query_source.fbe_extra()
        + can_set_tag.fbe_extra()
        + utility_stmt.fbe_extra()
        + result_relation.fbe_extra()
        + has_aggs.fbe_extra()
        + has_window_funcs.fbe_extra()
        + has_target_srfs.fbe_extra()
        + has_sub_links.fbe_extra()
        + has_distinct_on.fbe_extra()
        + has_recursive.fbe_extra()
        + has_modifying_cte.fbe_extra()
        + has_for_update.fbe_extra()
        + has_row_security.fbe_extra()
        + cte_list.fbe_extra()
        + rtable.fbe_extra()
        + jointree.fbe_extra()
        + target_list.fbe_extra()
        + override.fbe_extra()
        + on_conflict.fbe_extra()
        + returning_list.fbe_extra()
        + group_clause.fbe_extra()
        + grouping_sets.fbe_extra()
        + having_qual.fbe_extra()
        + window_clause.fbe_extra()
        + distinct_clause.fbe_extra()
        + sort_clause.fbe_extra()
        + limit_offset.fbe_extra()
        + limit_count.fbe_extra()
        + limit_option.fbe_extra()
        + row_marks.fbe_extra()
        + set_operations.fbe_extra()
        + constraint_deps.fbe_extra()
        + with_check_options.fbe_extra()
        + stmt_location.fbe_extra()
        + stmt_len.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Query::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Query::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + command_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!command_type.verify())
        return false;
    fbe_current_size += command_type.fbe_size();

    if ((fbe_current_size + query_source.fbe_size()) > fbe_struct_size)
        return true;
    if (!query_source.verify())
        return false;
    fbe_current_size += query_source.fbe_size();

    if ((fbe_current_size + can_set_tag.fbe_size()) > fbe_struct_size)
        return true;
    if (!can_set_tag.verify())
        return false;
    fbe_current_size += can_set_tag.fbe_size();

    if ((fbe_current_size + utility_stmt.fbe_size()) > fbe_struct_size)
        return true;
    if (!utility_stmt.verify())
        return false;
    fbe_current_size += utility_stmt.fbe_size();

    if ((fbe_current_size + result_relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!result_relation.verify())
        return false;
    fbe_current_size += result_relation.fbe_size();

    if ((fbe_current_size + has_aggs.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_aggs.verify())
        return false;
    fbe_current_size += has_aggs.fbe_size();

    if ((fbe_current_size + has_window_funcs.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_window_funcs.verify())
        return false;
    fbe_current_size += has_window_funcs.fbe_size();

    if ((fbe_current_size + has_target_srfs.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_target_srfs.verify())
        return false;
    fbe_current_size += has_target_srfs.fbe_size();

    if ((fbe_current_size + has_sub_links.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_sub_links.verify())
        return false;
    fbe_current_size += has_sub_links.fbe_size();

    if ((fbe_current_size + has_distinct_on.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_distinct_on.verify())
        return false;
    fbe_current_size += has_distinct_on.fbe_size();

    if ((fbe_current_size + has_recursive.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_recursive.verify())
        return false;
    fbe_current_size += has_recursive.fbe_size();

    if ((fbe_current_size + has_modifying_cte.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_modifying_cte.verify())
        return false;
    fbe_current_size += has_modifying_cte.fbe_size();

    if ((fbe_current_size + has_for_update.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_for_update.verify())
        return false;
    fbe_current_size += has_for_update.fbe_size();

    if ((fbe_current_size + has_row_security.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_row_security.verify())
        return false;
    fbe_current_size += has_row_security.fbe_size();

    if ((fbe_current_size + cte_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!cte_list.verify())
        return false;
    fbe_current_size += cte_list.fbe_size();

    if ((fbe_current_size + rtable.fbe_size()) > fbe_struct_size)
        return true;
    if (!rtable.verify())
        return false;
    fbe_current_size += rtable.fbe_size();

    if ((fbe_current_size + jointree.fbe_size()) > fbe_struct_size)
        return true;
    if (!jointree.verify())
        return false;
    fbe_current_size += jointree.fbe_size();

    if ((fbe_current_size + target_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!target_list.verify())
        return false;
    fbe_current_size += target_list.fbe_size();

    if ((fbe_current_size + override.fbe_size()) > fbe_struct_size)
        return true;
    if (!override.verify())
        return false;
    fbe_current_size += override.fbe_size();

    if ((fbe_current_size + on_conflict.fbe_size()) > fbe_struct_size)
        return true;
    if (!on_conflict.verify())
        return false;
    fbe_current_size += on_conflict.fbe_size();

    if ((fbe_current_size + returning_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!returning_list.verify())
        return false;
    fbe_current_size += returning_list.fbe_size();

    if ((fbe_current_size + group_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!group_clause.verify())
        return false;
    fbe_current_size += group_clause.fbe_size();

    if ((fbe_current_size + grouping_sets.fbe_size()) > fbe_struct_size)
        return true;
    if (!grouping_sets.verify())
        return false;
    fbe_current_size += grouping_sets.fbe_size();

    if ((fbe_current_size + having_qual.fbe_size()) > fbe_struct_size)
        return true;
    if (!having_qual.verify())
        return false;
    fbe_current_size += having_qual.fbe_size();

    if ((fbe_current_size + window_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!window_clause.verify())
        return false;
    fbe_current_size += window_clause.fbe_size();

    if ((fbe_current_size + distinct_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!distinct_clause.verify())
        return false;
    fbe_current_size += distinct_clause.fbe_size();

    if ((fbe_current_size + sort_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!sort_clause.verify())
        return false;
    fbe_current_size += sort_clause.fbe_size();

    if ((fbe_current_size + limit_offset.fbe_size()) > fbe_struct_size)
        return true;
    if (!limit_offset.verify())
        return false;
    fbe_current_size += limit_offset.fbe_size();

    if ((fbe_current_size + limit_count.fbe_size()) > fbe_struct_size)
        return true;
    if (!limit_count.verify())
        return false;
    fbe_current_size += limit_count.fbe_size();

    if ((fbe_current_size + limit_option.fbe_size()) > fbe_struct_size)
        return true;
    if (!limit_option.verify())
        return false;
    fbe_current_size += limit_option.fbe_size();

    if ((fbe_current_size + row_marks.fbe_size()) > fbe_struct_size)
        return true;
    if (!row_marks.verify())
        return false;
    fbe_current_size += row_marks.fbe_size();

    if ((fbe_current_size + set_operations.fbe_size()) > fbe_struct_size)
        return true;
    if (!set_operations.verify())
        return false;
    fbe_current_size += set_operations.fbe_size();

    if ((fbe_current_size + constraint_deps.fbe_size()) > fbe_struct_size)
        return true;
    if (!constraint_deps.verify())
        return false;
    fbe_current_size += constraint_deps.fbe_size();

    if ((fbe_current_size + with_check_options.fbe_size()) > fbe_struct_size)
        return true;
    if (!with_check_options.verify())
        return false;
    fbe_current_size += with_check_options.fbe_size();

    if ((fbe_current_size + stmt_location.fbe_size()) > fbe_struct_size)
        return true;
    if (!stmt_location.verify())
        return false;
    fbe_current_size += stmt_location.fbe_size();

    if ((fbe_current_size + stmt_len.fbe_size()) > fbe_struct_size)
        return true;
    if (!stmt_len.verify())
        return false;
    fbe_current_size += stmt_len.fbe_size();

    return true;
}

size_t FieldModel_pg_query_Query::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Query::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Query::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Query::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::Query& fbe_value = static_cast<::pg_query::Query&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + command_type.fbe_size()) <= fbe_struct_size)
        {
            command_type.get(fbe_value.command_type);
        }
    else
        fbe_value.command_type = ::pg_query::CmdType();
    fbe_current_size += command_type.fbe_size();

    if ((fbe_current_size + query_source.fbe_size()) <= fbe_struct_size)
        {
            query_source.get(fbe_value.query_source);
        }
    else
        fbe_value.query_source = ::pg_query::QuerySource();
    fbe_current_size += query_source.fbe_size();

    if ((fbe_current_size + can_set_tag.fbe_size()) <= fbe_struct_size)
        {
            can_set_tag.get(fbe_value.can_set_tag);
        }
    else
        fbe_value.can_set_tag = false;
    fbe_current_size += can_set_tag.fbe_size();

    if ((fbe_current_size + utility_stmt.fbe_size()) <= fbe_struct_size)
        {
            utility_stmt.get(fbe_value.utility_stmt);
        }
    else
        fbe_value.utility_stmt = ::pg_query::Node();
    fbe_current_size += utility_stmt.fbe_size();

    if ((fbe_current_size + result_relation.fbe_size()) <= fbe_struct_size)
        {
            result_relation.get(fbe_value.result_relation);
        }
    else
        fbe_value.result_relation = (int32_t)0ll;
    fbe_current_size += result_relation.fbe_size();

    if ((fbe_current_size + has_aggs.fbe_size()) <= fbe_struct_size)
        {
            has_aggs.get(fbe_value.has_aggs);
        }
    else
        fbe_value.has_aggs = false;
    fbe_current_size += has_aggs.fbe_size();

    if ((fbe_current_size + has_window_funcs.fbe_size()) <= fbe_struct_size)
        {
            has_window_funcs.get(fbe_value.has_window_funcs);
        }
    else
        fbe_value.has_window_funcs = false;
    fbe_current_size += has_window_funcs.fbe_size();

    if ((fbe_current_size + has_target_srfs.fbe_size()) <= fbe_struct_size)
        {
            has_target_srfs.get(fbe_value.has_target_srfs);
        }
    else
        fbe_value.has_target_srfs = false;
    fbe_current_size += has_target_srfs.fbe_size();

    if ((fbe_current_size + has_sub_links.fbe_size()) <= fbe_struct_size)
        {
            has_sub_links.get(fbe_value.has_sub_links);
        }
    else
        fbe_value.has_sub_links = false;
    fbe_current_size += has_sub_links.fbe_size();

    if ((fbe_current_size + has_distinct_on.fbe_size()) <= fbe_struct_size)
        {
            has_distinct_on.get(fbe_value.has_distinct_on);
        }
    else
        fbe_value.has_distinct_on = false;
    fbe_current_size += has_distinct_on.fbe_size();

    if ((fbe_current_size + has_recursive.fbe_size()) <= fbe_struct_size)
        {
            has_recursive.get(fbe_value.has_recursive);
        }
    else
        fbe_value.has_recursive = false;
    fbe_current_size += has_recursive.fbe_size();

    if ((fbe_current_size + has_modifying_cte.fbe_size()) <= fbe_struct_size)
        {
            has_modifying_cte.get(fbe_value.has_modifying_cte);
        }
    else
        fbe_value.has_modifying_cte = false;
    fbe_current_size += has_modifying_cte.fbe_size();

    if ((fbe_current_size + has_for_update.fbe_size()) <= fbe_struct_size)
        {
            has_for_update.get(fbe_value.has_for_update);
        }
    else
        fbe_value.has_for_update = false;
    fbe_current_size += has_for_update.fbe_size();

    if ((fbe_current_size + has_row_security.fbe_size()) <= fbe_struct_size)
        {
            has_row_security.get(fbe_value.has_row_security);
        }
    else
        fbe_value.has_row_security = false;
    fbe_current_size += has_row_security.fbe_size();

    if ((fbe_current_size + cte_list.fbe_size()) <= fbe_struct_size)
        {
            cte_list.get(fbe_value.cte_list);
        }
    else
        fbe_value.cte_list.clear();
    fbe_current_size += cte_list.fbe_size();

    if ((fbe_current_size + rtable.fbe_size()) <= fbe_struct_size)
        {
            rtable.get(fbe_value.rtable);
        }
    else
        fbe_value.rtable.clear();
    fbe_current_size += rtable.fbe_size();

    if ((fbe_current_size + jointree.fbe_size()) <= fbe_struct_size)
        {
            jointree.get(&fbe_value.jointree);
        }
    else
        fbe_value.jointree = nullptr;
    fbe_current_size += jointree.fbe_size();

    if ((fbe_current_size + target_list.fbe_size()) <= fbe_struct_size)
        {
            target_list.get(fbe_value.target_list);
        }
    else
        fbe_value.target_list.clear();
    fbe_current_size += target_list.fbe_size();

    if ((fbe_current_size + override.fbe_size()) <= fbe_struct_size)
        {
            override.get(fbe_value.override);
        }
    else
        fbe_value.override = ::pg_query::OverridingKind();
    fbe_current_size += override.fbe_size();

    if ((fbe_current_size + on_conflict.fbe_size()) <= fbe_struct_size)
        {
            on_conflict.get(&fbe_value.on_conflict);
        }
    else
        fbe_value.on_conflict = nullptr;
    fbe_current_size += on_conflict.fbe_size();

    if ((fbe_current_size + returning_list.fbe_size()) <= fbe_struct_size)
        {
            returning_list.get(fbe_value.returning_list);
        }
    else
        fbe_value.returning_list.clear();
    fbe_current_size += returning_list.fbe_size();

    if ((fbe_current_size + group_clause.fbe_size()) <= fbe_struct_size)
        {
            group_clause.get(fbe_value.group_clause);
        }
    else
        fbe_value.group_clause.clear();
    fbe_current_size += group_clause.fbe_size();

    if ((fbe_current_size + grouping_sets.fbe_size()) <= fbe_struct_size)
        {
            grouping_sets.get(fbe_value.grouping_sets);
        }
    else
        fbe_value.grouping_sets.clear();
    fbe_current_size += grouping_sets.fbe_size();

    if ((fbe_current_size + having_qual.fbe_size()) <= fbe_struct_size)
        {
            having_qual.get(fbe_value.having_qual);
        }
    else
        fbe_value.having_qual = ::pg_query::Node();
    fbe_current_size += having_qual.fbe_size();

    if ((fbe_current_size + window_clause.fbe_size()) <= fbe_struct_size)
        {
            window_clause.get(fbe_value.window_clause);
        }
    else
        fbe_value.window_clause.clear();
    fbe_current_size += window_clause.fbe_size();

    if ((fbe_current_size + distinct_clause.fbe_size()) <= fbe_struct_size)
        {
            distinct_clause.get(fbe_value.distinct_clause);
        }
    else
        fbe_value.distinct_clause.clear();
    fbe_current_size += distinct_clause.fbe_size();

    if ((fbe_current_size + sort_clause.fbe_size()) <= fbe_struct_size)
        {
            sort_clause.get(fbe_value.sort_clause);
        }
    else
        fbe_value.sort_clause.clear();
    fbe_current_size += sort_clause.fbe_size();

    if ((fbe_current_size + limit_offset.fbe_size()) <= fbe_struct_size)
        {
            limit_offset.get(fbe_value.limit_offset);
        }
    else
        fbe_value.limit_offset = ::pg_query::Node();
    fbe_current_size += limit_offset.fbe_size();

    if ((fbe_current_size + limit_count.fbe_size()) <= fbe_struct_size)
        {
            limit_count.get(fbe_value.limit_count);
        }
    else
        fbe_value.limit_count = ::pg_query::Node();
    fbe_current_size += limit_count.fbe_size();

    if ((fbe_current_size + limit_option.fbe_size()) <= fbe_struct_size)
        {
            limit_option.get(fbe_value.limit_option);
        }
    else
        fbe_value.limit_option = ::pg_query::LimitOption();
    fbe_current_size += limit_option.fbe_size();

    if ((fbe_current_size + row_marks.fbe_size()) <= fbe_struct_size)
        {
            row_marks.get(fbe_value.row_marks);
        }
    else
        fbe_value.row_marks.clear();
    fbe_current_size += row_marks.fbe_size();

    if ((fbe_current_size + set_operations.fbe_size()) <= fbe_struct_size)
        {
            set_operations.get(fbe_value.set_operations);
        }
    else
        fbe_value.set_operations = ::pg_query::Node();
    fbe_current_size += set_operations.fbe_size();

    if ((fbe_current_size + constraint_deps.fbe_size()) <= fbe_struct_size)
        {
            constraint_deps.get(fbe_value.constraint_deps);
        }
    else
        fbe_value.constraint_deps.clear();
    fbe_current_size += constraint_deps.fbe_size();

    if ((fbe_current_size + with_check_options.fbe_size()) <= fbe_struct_size)
        {
            with_check_options.get(fbe_value.with_check_options);
        }
    else
        fbe_value.with_check_options.clear();
    fbe_current_size += with_check_options.fbe_size();

    if ((fbe_current_size + stmt_location.fbe_size()) <= fbe_struct_size)
        {
            stmt_location.get(fbe_value.stmt_location);
        }
    else
        fbe_value.stmt_location = (int32_t)0ll;
    fbe_current_size += stmt_location.fbe_size();

    if ((fbe_current_size + stmt_len.fbe_size()) <= fbe_struct_size)
        {
            stmt_len.get(fbe_value.stmt_len);
        }
    else
        fbe_value.stmt_len = (int32_t)0ll;
    fbe_current_size += stmt_len.fbe_size();
}

size_t FieldModel_pg_query_Query::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Query::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Query::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Query::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Query& fbe_value = static_cast<const ::pg_query::Query&>(base_fbe_value);
    command_type.set(fbe_value.command_type);
    query_source.set(fbe_value.query_source);
    can_set_tag.set(fbe_value.can_set_tag);
    utility_stmt.set(fbe_value.utility_stmt);
    result_relation.set(fbe_value.result_relation);
    has_aggs.set(fbe_value.has_aggs);
    has_window_funcs.set(fbe_value.has_window_funcs);
    has_target_srfs.set(fbe_value.has_target_srfs);
    has_sub_links.set(fbe_value.has_sub_links);
    has_distinct_on.set(fbe_value.has_distinct_on);
    has_recursive.set(fbe_value.has_recursive);
    has_modifying_cte.set(fbe_value.has_modifying_cte);
    has_for_update.set(fbe_value.has_for_update);
    has_row_security.set(fbe_value.has_row_security);
    cte_list.set(fbe_value.cte_list);
    rtable.set(fbe_value.rtable);
    jointree.set(fbe_value.jointree);
    target_list.set(fbe_value.target_list);
    override.set(fbe_value.override);
    on_conflict.set(fbe_value.on_conflict);
    returning_list.set(fbe_value.returning_list);
    group_clause.set(fbe_value.group_clause);
    grouping_sets.set(fbe_value.grouping_sets);
    having_qual.set(fbe_value.having_qual);
    window_clause.set(fbe_value.window_clause);
    distinct_clause.set(fbe_value.distinct_clause);
    sort_clause.set(fbe_value.sort_clause);
    limit_offset.set(fbe_value.limit_offset);
    limit_count.set(fbe_value.limit_count);
    limit_option.set(fbe_value.limit_option);
    row_marks.set(fbe_value.row_marks);
    set_operations.set(fbe_value.set_operations);
    constraint_deps.set(fbe_value.constraint_deps);
    with_check_options.set(fbe_value.with_check_options);
    stmt_location.set(fbe_value.stmt_location);
    stmt_len.set(fbe_value.stmt_len);
}

namespace pg_query {

bool QueryModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t QueryModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t QueryModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t QueryModel::serialize(const ::pg_query::Query& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t QueryModel::deserialize(::pg_query::Query& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_InsertStmt::FieldModelPtr_pg_query_InsertStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_InsertStmt::~FieldModelPtr_pg_query_InsertStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_InsertStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_InsertStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_InsertStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_InsertStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_InsertStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_InsertStmt::get(::pg_query::InsertStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_InsertStmt(_buffer, 0);

    ::pg_query::InsertStmt *tempModel = new ::pg_query::InsertStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_InsertStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_InsertStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_InsertStmt::set(const ::pg_query::InsertStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_InsertStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_InsertStmt::FieldModel_pg_query_InsertStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , cols(buffer, relation.fbe_offset() + relation.fbe_size())
    , select_stmt(buffer, cols.fbe_offset() + cols.fbe_size())
    , on_conflict_clause(buffer, select_stmt.fbe_offset() + select_stmt.fbe_size())
    , returning_list(buffer, on_conflict_clause.fbe_offset() + on_conflict_clause.fbe_size())
    , with_clause(buffer, returning_list.fbe_offset() + returning_list.fbe_size())
    , override(buffer, with_clause.fbe_offset() + with_clause.fbe_size())
{}

size_t FieldModel_pg_query_InsertStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + cols.fbe_size()
        + select_stmt.fbe_size()
        + on_conflict_clause.fbe_size()
        + returning_list.fbe_size()
        + with_clause.fbe_size()
        + override.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_InsertStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + cols.fbe_extra()
        + select_stmt.fbe_extra()
        + on_conflict_clause.fbe_extra()
        + returning_list.fbe_extra()
        + with_clause.fbe_extra()
        + override.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_InsertStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_InsertStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + cols.fbe_size()) > fbe_struct_size)
        return true;
    if (!cols.verify())
        return false;
    fbe_current_size += cols.fbe_size();

    if ((fbe_current_size + select_stmt.fbe_size()) > fbe_struct_size)
        return true;
    if (!select_stmt.verify())
        return false;
    fbe_current_size += select_stmt.fbe_size();

    if ((fbe_current_size + on_conflict_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!on_conflict_clause.verify())
        return false;
    fbe_current_size += on_conflict_clause.fbe_size();

    if ((fbe_current_size + returning_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!returning_list.verify())
        return false;
    fbe_current_size += returning_list.fbe_size();

    if ((fbe_current_size + with_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!with_clause.verify())
        return false;
    fbe_current_size += with_clause.fbe_size();

    if ((fbe_current_size + override.fbe_size()) > fbe_struct_size)
        return true;
    if (!override.verify())
        return false;
    fbe_current_size += override.fbe_size();

    return true;
}

size_t FieldModel_pg_query_InsertStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_InsertStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_InsertStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_InsertStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::InsertStmt& fbe_value = static_cast<::pg_query::InsertStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + cols.fbe_size()) <= fbe_struct_size)
        {
            cols.get(fbe_value.cols);
        }
    else
        fbe_value.cols.clear();
    fbe_current_size += cols.fbe_size();

    if ((fbe_current_size + select_stmt.fbe_size()) <= fbe_struct_size)
        {
            select_stmt.get(fbe_value.select_stmt);
        }
    else
        fbe_value.select_stmt = ::pg_query::Node();
    fbe_current_size += select_stmt.fbe_size();

    if ((fbe_current_size + on_conflict_clause.fbe_size()) <= fbe_struct_size)
        {
            on_conflict_clause.get(&fbe_value.on_conflict_clause);
        }
    else
        fbe_value.on_conflict_clause = nullptr;
    fbe_current_size += on_conflict_clause.fbe_size();

    if ((fbe_current_size + returning_list.fbe_size()) <= fbe_struct_size)
        {
            returning_list.get(fbe_value.returning_list);
        }
    else
        fbe_value.returning_list.clear();
    fbe_current_size += returning_list.fbe_size();

    if ((fbe_current_size + with_clause.fbe_size()) <= fbe_struct_size)
        {
            with_clause.get(&fbe_value.with_clause);
        }
    else
        fbe_value.with_clause = nullptr;
    fbe_current_size += with_clause.fbe_size();

    if ((fbe_current_size + override.fbe_size()) <= fbe_struct_size)
        {
            override.get(fbe_value.override);
        }
    else
        fbe_value.override = ::pg_query::OverridingKind();
    fbe_current_size += override.fbe_size();
}

size_t FieldModel_pg_query_InsertStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_InsertStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_InsertStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_InsertStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::InsertStmt& fbe_value = static_cast<const ::pg_query::InsertStmt&>(base_fbe_value);
    relation.set(fbe_value.relation);
    cols.set(fbe_value.cols);
    select_stmt.set(fbe_value.select_stmt);
    on_conflict_clause.set(fbe_value.on_conflict_clause);
    returning_list.set(fbe_value.returning_list);
    with_clause.set(fbe_value.with_clause);
    override.set(fbe_value.override);
}

namespace pg_query {

bool InsertStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t InsertStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t InsertStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t InsertStmtModel::serialize(const ::pg_query::InsertStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t InsertStmtModel::deserialize(::pg_query::InsertStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DeleteStmt::FieldModelPtr_pg_query_DeleteStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DeleteStmt::~FieldModelPtr_pg_query_DeleteStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DeleteStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DeleteStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DeleteStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DeleteStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DeleteStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DeleteStmt::get(::pg_query::DeleteStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DeleteStmt(_buffer, 0);

    ::pg_query::DeleteStmt *tempModel = new ::pg_query::DeleteStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DeleteStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DeleteStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DeleteStmt::set(const ::pg_query::DeleteStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DeleteStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DeleteStmt::FieldModel_pg_query_DeleteStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , using_clause(buffer, relation.fbe_offset() + relation.fbe_size())
    , where_clause(buffer, using_clause.fbe_offset() + using_clause.fbe_size())
    , returning_list(buffer, where_clause.fbe_offset() + where_clause.fbe_size())
    , with_clause(buffer, returning_list.fbe_offset() + returning_list.fbe_size())
{}

size_t FieldModel_pg_query_DeleteStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + using_clause.fbe_size()
        + where_clause.fbe_size()
        + returning_list.fbe_size()
        + with_clause.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DeleteStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + using_clause.fbe_extra()
        + where_clause.fbe_extra()
        + returning_list.fbe_extra()
        + with_clause.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DeleteStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DeleteStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + using_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!using_clause.verify())
        return false;
    fbe_current_size += using_clause.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!where_clause.verify())
        return false;
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + returning_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!returning_list.verify())
        return false;
    fbe_current_size += returning_list.fbe_size();

    if ((fbe_current_size + with_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!with_clause.verify())
        return false;
    fbe_current_size += with_clause.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DeleteStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DeleteStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DeleteStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DeleteStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DeleteStmt& fbe_value = static_cast<::pg_query::DeleteStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + using_clause.fbe_size()) <= fbe_struct_size)
        {
            using_clause.get(fbe_value.using_clause);
        }
    else
        fbe_value.using_clause.clear();
    fbe_current_size += using_clause.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) <= fbe_struct_size)
        {
            where_clause.get(fbe_value.where_clause);
        }
    else
        fbe_value.where_clause = ::pg_query::Node();
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + returning_list.fbe_size()) <= fbe_struct_size)
        {
            returning_list.get(fbe_value.returning_list);
        }
    else
        fbe_value.returning_list.clear();
    fbe_current_size += returning_list.fbe_size();

    if ((fbe_current_size + with_clause.fbe_size()) <= fbe_struct_size)
        {
            with_clause.get(&fbe_value.with_clause);
        }
    else
        fbe_value.with_clause = nullptr;
    fbe_current_size += with_clause.fbe_size();
}

size_t FieldModel_pg_query_DeleteStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DeleteStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DeleteStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DeleteStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DeleteStmt& fbe_value = static_cast<const ::pg_query::DeleteStmt&>(base_fbe_value);
    relation.set(fbe_value.relation);
    using_clause.set(fbe_value.using_clause);
    where_clause.set(fbe_value.where_clause);
    returning_list.set(fbe_value.returning_list);
    with_clause.set(fbe_value.with_clause);
}

namespace pg_query {

bool DeleteStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DeleteStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DeleteStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DeleteStmtModel::serialize(const ::pg_query::DeleteStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DeleteStmtModel::deserialize(::pg_query::DeleteStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_UpdateStmt::FieldModelPtr_pg_query_UpdateStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_UpdateStmt::~FieldModelPtr_pg_query_UpdateStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_UpdateStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_UpdateStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_UpdateStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_UpdateStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_UpdateStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_UpdateStmt::get(::pg_query::UpdateStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_UpdateStmt(_buffer, 0);

    ::pg_query::UpdateStmt *tempModel = new ::pg_query::UpdateStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_UpdateStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_UpdateStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_UpdateStmt::set(const ::pg_query::UpdateStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_UpdateStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_UpdateStmt::FieldModel_pg_query_UpdateStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , target_list(buffer, relation.fbe_offset() + relation.fbe_size())
    , where_clause(buffer, target_list.fbe_offset() + target_list.fbe_size())
    , from_clause(buffer, where_clause.fbe_offset() + where_clause.fbe_size())
    , returning_list(buffer, from_clause.fbe_offset() + from_clause.fbe_size())
    , with_clause(buffer, returning_list.fbe_offset() + returning_list.fbe_size())
{}

size_t FieldModel_pg_query_UpdateStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + target_list.fbe_size()
        + where_clause.fbe_size()
        + from_clause.fbe_size()
        + returning_list.fbe_size()
        + with_clause.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_UpdateStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + target_list.fbe_extra()
        + where_clause.fbe_extra()
        + from_clause.fbe_extra()
        + returning_list.fbe_extra()
        + with_clause.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_UpdateStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_UpdateStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + target_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!target_list.verify())
        return false;
    fbe_current_size += target_list.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!where_clause.verify())
        return false;
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + from_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!from_clause.verify())
        return false;
    fbe_current_size += from_clause.fbe_size();

    if ((fbe_current_size + returning_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!returning_list.verify())
        return false;
    fbe_current_size += returning_list.fbe_size();

    if ((fbe_current_size + with_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!with_clause.verify())
        return false;
    fbe_current_size += with_clause.fbe_size();

    return true;
}

size_t FieldModel_pg_query_UpdateStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_UpdateStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_UpdateStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_UpdateStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::UpdateStmt& fbe_value = static_cast<::pg_query::UpdateStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + target_list.fbe_size()) <= fbe_struct_size)
        {
            target_list.get(fbe_value.target_list);
        }
    else
        fbe_value.target_list.clear();
    fbe_current_size += target_list.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) <= fbe_struct_size)
        {
            where_clause.get(fbe_value.where_clause);
        }
    else
        fbe_value.where_clause = ::pg_query::Node();
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + from_clause.fbe_size()) <= fbe_struct_size)
        {
            from_clause.get(fbe_value.from_clause);
        }
    else
        fbe_value.from_clause.clear();
    fbe_current_size += from_clause.fbe_size();

    if ((fbe_current_size + returning_list.fbe_size()) <= fbe_struct_size)
        {
            returning_list.get(fbe_value.returning_list);
        }
    else
        fbe_value.returning_list.clear();
    fbe_current_size += returning_list.fbe_size();

    if ((fbe_current_size + with_clause.fbe_size()) <= fbe_struct_size)
        {
            with_clause.get(&fbe_value.with_clause);
        }
    else
        fbe_value.with_clause = nullptr;
    fbe_current_size += with_clause.fbe_size();
}

size_t FieldModel_pg_query_UpdateStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_UpdateStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_UpdateStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_UpdateStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::UpdateStmt& fbe_value = static_cast<const ::pg_query::UpdateStmt&>(base_fbe_value);
    relation.set(fbe_value.relation);
    target_list.set(fbe_value.target_list);
    where_clause.set(fbe_value.where_clause);
    from_clause.set(fbe_value.from_clause);
    returning_list.set(fbe_value.returning_list);
    with_clause.set(fbe_value.with_clause);
}

namespace pg_query {

bool UpdateStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t UpdateStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t UpdateStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t UpdateStmtModel::serialize(const ::pg_query::UpdateStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t UpdateStmtModel::deserialize(::pg_query::UpdateStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SelectStmt::FieldModelPtr_pg_query_SelectStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SelectStmt::~FieldModelPtr_pg_query_SelectStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SelectStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SelectStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SelectStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SelectStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SelectStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SelectStmt::get(::pg_query::SelectStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SelectStmt(_buffer, 0);

    ::pg_query::SelectStmt *tempModel = new ::pg_query::SelectStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SelectStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SelectStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SelectStmt::set(const ::pg_query::SelectStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SelectStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SelectStmt::FieldModel_pg_query_SelectStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , distinct_clause(buffer, 4 + 4)
    , into_clause(buffer, distinct_clause.fbe_offset() + distinct_clause.fbe_size())
    , target_list(buffer, into_clause.fbe_offset() + into_clause.fbe_size())
    , from_clause(buffer, target_list.fbe_offset() + target_list.fbe_size())
    , where_clause(buffer, from_clause.fbe_offset() + from_clause.fbe_size())
    , group_clause(buffer, where_clause.fbe_offset() + where_clause.fbe_size())
    , having_clause(buffer, group_clause.fbe_offset() + group_clause.fbe_size())
    , window_clause(buffer, having_clause.fbe_offset() + having_clause.fbe_size())
    , values_lists(buffer, window_clause.fbe_offset() + window_clause.fbe_size())
    , sort_clause(buffer, values_lists.fbe_offset() + values_lists.fbe_size())
    , limit_offset(buffer, sort_clause.fbe_offset() + sort_clause.fbe_size())
    , limit_count(buffer, limit_offset.fbe_offset() + limit_offset.fbe_size())
    , limit_option(buffer, limit_count.fbe_offset() + limit_count.fbe_size())
    , locking_clause(buffer, limit_option.fbe_offset() + limit_option.fbe_size())
    , with_clause(buffer, locking_clause.fbe_offset() + locking_clause.fbe_size())
    , op(buffer, with_clause.fbe_offset() + with_clause.fbe_size())
    , all(buffer, op.fbe_offset() + op.fbe_size())
    , larg(buffer, all.fbe_offset() + all.fbe_size())
    , rarg(buffer, larg.fbe_offset() + larg.fbe_size())
{}

size_t FieldModel_pg_query_SelectStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + distinct_clause.fbe_size()
        + into_clause.fbe_size()
        + target_list.fbe_size()
        + from_clause.fbe_size()
        + where_clause.fbe_size()
        + group_clause.fbe_size()
        + having_clause.fbe_size()
        + window_clause.fbe_size()
        + values_lists.fbe_size()
        + sort_clause.fbe_size()
        + limit_offset.fbe_size()
        + limit_count.fbe_size()
        + limit_option.fbe_size()
        + locking_clause.fbe_size()
        + with_clause.fbe_size()
        + op.fbe_size()
        + all.fbe_size()
        + larg.fbe_size()
        + rarg.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SelectStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + distinct_clause.fbe_extra()
        + into_clause.fbe_extra()
        + target_list.fbe_extra()
        + from_clause.fbe_extra()
        + where_clause.fbe_extra()
        + group_clause.fbe_extra()
        + having_clause.fbe_extra()
        + window_clause.fbe_extra()
        + values_lists.fbe_extra()
        + sort_clause.fbe_extra()
        + limit_offset.fbe_extra()
        + limit_count.fbe_extra()
        + limit_option.fbe_extra()
        + locking_clause.fbe_extra()
        + with_clause.fbe_extra()
        + op.fbe_extra()
        + all.fbe_extra()
        + larg.fbe_extra()
        + rarg.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SelectStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SelectStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + distinct_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!distinct_clause.verify())
        return false;
    fbe_current_size += distinct_clause.fbe_size();

    if ((fbe_current_size + into_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!into_clause.verify())
        return false;
    fbe_current_size += into_clause.fbe_size();

    if ((fbe_current_size + target_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!target_list.verify())
        return false;
    fbe_current_size += target_list.fbe_size();

    if ((fbe_current_size + from_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!from_clause.verify())
        return false;
    fbe_current_size += from_clause.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!where_clause.verify())
        return false;
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + group_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!group_clause.verify())
        return false;
    fbe_current_size += group_clause.fbe_size();

    if ((fbe_current_size + having_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!having_clause.verify())
        return false;
    fbe_current_size += having_clause.fbe_size();

    if ((fbe_current_size + window_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!window_clause.verify())
        return false;
    fbe_current_size += window_clause.fbe_size();

    if ((fbe_current_size + values_lists.fbe_size()) > fbe_struct_size)
        return true;
    if (!values_lists.verify())
        return false;
    fbe_current_size += values_lists.fbe_size();

    if ((fbe_current_size + sort_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!sort_clause.verify())
        return false;
    fbe_current_size += sort_clause.fbe_size();

    if ((fbe_current_size + limit_offset.fbe_size()) > fbe_struct_size)
        return true;
    if (!limit_offset.verify())
        return false;
    fbe_current_size += limit_offset.fbe_size();

    if ((fbe_current_size + limit_count.fbe_size()) > fbe_struct_size)
        return true;
    if (!limit_count.verify())
        return false;
    fbe_current_size += limit_count.fbe_size();

    if ((fbe_current_size + limit_option.fbe_size()) > fbe_struct_size)
        return true;
    if (!limit_option.verify())
        return false;
    fbe_current_size += limit_option.fbe_size();

    if ((fbe_current_size + locking_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!locking_clause.verify())
        return false;
    fbe_current_size += locking_clause.fbe_size();

    if ((fbe_current_size + with_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!with_clause.verify())
        return false;
    fbe_current_size += with_clause.fbe_size();

    if ((fbe_current_size + op.fbe_size()) > fbe_struct_size)
        return true;
    if (!op.verify())
        return false;
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + all.fbe_size()) > fbe_struct_size)
        return true;
    if (!all.verify())
        return false;
    fbe_current_size += all.fbe_size();

    if ((fbe_current_size + larg.fbe_size()) > fbe_struct_size)
        return true;
    if (!larg.verify())
        return false;
    fbe_current_size += larg.fbe_size();

    if ((fbe_current_size + rarg.fbe_size()) > fbe_struct_size)
        return true;
    if (!rarg.verify())
        return false;
    fbe_current_size += rarg.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SelectStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SelectStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SelectStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SelectStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SelectStmt& fbe_value = static_cast<::pg_query::SelectStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + distinct_clause.fbe_size()) <= fbe_struct_size)
        {
            distinct_clause.get(fbe_value.distinct_clause);
        }
    else
        fbe_value.distinct_clause.clear();
    fbe_current_size += distinct_clause.fbe_size();

    if ((fbe_current_size + into_clause.fbe_size()) <= fbe_struct_size)
        {
            into_clause.get(&fbe_value.into_clause);
        }
    else
        fbe_value.into_clause = nullptr;
    fbe_current_size += into_clause.fbe_size();

    if ((fbe_current_size + target_list.fbe_size()) <= fbe_struct_size)
        {
            target_list.get(fbe_value.target_list);
        }
    else
        fbe_value.target_list.clear();
    fbe_current_size += target_list.fbe_size();

    if ((fbe_current_size + from_clause.fbe_size()) <= fbe_struct_size)
        {
            from_clause.get(fbe_value.from_clause);
        }
    else
        fbe_value.from_clause.clear();
    fbe_current_size += from_clause.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) <= fbe_struct_size)
        {
            where_clause.get(fbe_value.where_clause);
        }
    else
        fbe_value.where_clause = ::pg_query::Node();
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + group_clause.fbe_size()) <= fbe_struct_size)
        {
            group_clause.get(fbe_value.group_clause);
        }
    else
        fbe_value.group_clause.clear();
    fbe_current_size += group_clause.fbe_size();

    if ((fbe_current_size + having_clause.fbe_size()) <= fbe_struct_size)
        {
            having_clause.get(fbe_value.having_clause);
        }
    else
        fbe_value.having_clause = ::pg_query::Node();
    fbe_current_size += having_clause.fbe_size();

    if ((fbe_current_size + window_clause.fbe_size()) <= fbe_struct_size)
        {
            window_clause.get(fbe_value.window_clause);
        }
    else
        fbe_value.window_clause.clear();
    fbe_current_size += window_clause.fbe_size();

    if ((fbe_current_size + values_lists.fbe_size()) <= fbe_struct_size)
        {
            values_lists.get(fbe_value.values_lists);
        }
    else
        fbe_value.values_lists.clear();
    fbe_current_size += values_lists.fbe_size();

    if ((fbe_current_size + sort_clause.fbe_size()) <= fbe_struct_size)
        {
            sort_clause.get(fbe_value.sort_clause);
        }
    else
        fbe_value.sort_clause.clear();
    fbe_current_size += sort_clause.fbe_size();

    if ((fbe_current_size + limit_offset.fbe_size()) <= fbe_struct_size)
        {
            limit_offset.get(fbe_value.limit_offset);
        }
    else
        fbe_value.limit_offset = ::pg_query::Node();
    fbe_current_size += limit_offset.fbe_size();

    if ((fbe_current_size + limit_count.fbe_size()) <= fbe_struct_size)
        {
            limit_count.get(fbe_value.limit_count);
        }
    else
        fbe_value.limit_count = ::pg_query::Node();
    fbe_current_size += limit_count.fbe_size();

    if ((fbe_current_size + limit_option.fbe_size()) <= fbe_struct_size)
        {
            limit_option.get(fbe_value.limit_option);
        }
    else
        fbe_value.limit_option = ::pg_query::LimitOption();
    fbe_current_size += limit_option.fbe_size();

    if ((fbe_current_size + locking_clause.fbe_size()) <= fbe_struct_size)
        {
            locking_clause.get(fbe_value.locking_clause);
        }
    else
        fbe_value.locking_clause.clear();
    fbe_current_size += locking_clause.fbe_size();

    if ((fbe_current_size + with_clause.fbe_size()) <= fbe_struct_size)
        {
            with_clause.get(&fbe_value.with_clause);
        }
    else
        fbe_value.with_clause = nullptr;
    fbe_current_size += with_clause.fbe_size();

    if ((fbe_current_size + op.fbe_size()) <= fbe_struct_size)
        {
            op.get(fbe_value.op);
        }
    else
        fbe_value.op = ::pg_query::SetOperation();
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + all.fbe_size()) <= fbe_struct_size)
        {
            all.get(fbe_value.all);
        }
    else
        fbe_value.all = false;
    fbe_current_size += all.fbe_size();

    if ((fbe_current_size + larg.fbe_size()) <= fbe_struct_size)
        {
            larg.get(&fbe_value.larg);
        }
    else
        fbe_value.larg = nullptr;
    fbe_current_size += larg.fbe_size();

    if ((fbe_current_size + rarg.fbe_size()) <= fbe_struct_size)
        {
            rarg.get(&fbe_value.rarg);
        }
    else
        fbe_value.rarg = nullptr;
    fbe_current_size += rarg.fbe_size();
}

size_t FieldModel_pg_query_SelectStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SelectStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SelectStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SelectStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SelectStmt& fbe_value = static_cast<const ::pg_query::SelectStmt&>(base_fbe_value);
    distinct_clause.set(fbe_value.distinct_clause);
    into_clause.set(fbe_value.into_clause);
    target_list.set(fbe_value.target_list);
    from_clause.set(fbe_value.from_clause);
    where_clause.set(fbe_value.where_clause);
    group_clause.set(fbe_value.group_clause);
    having_clause.set(fbe_value.having_clause);
    window_clause.set(fbe_value.window_clause);
    values_lists.set(fbe_value.values_lists);
    sort_clause.set(fbe_value.sort_clause);
    limit_offset.set(fbe_value.limit_offset);
    limit_count.set(fbe_value.limit_count);
    limit_option.set(fbe_value.limit_option);
    locking_clause.set(fbe_value.locking_clause);
    with_clause.set(fbe_value.with_clause);
    op.set(fbe_value.op);
    all.set(fbe_value.all);
    larg.set(fbe_value.larg);
    rarg.set(fbe_value.rarg);
}

namespace pg_query {

bool SelectStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SelectStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SelectStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SelectStmtModel::serialize(const ::pg_query::SelectStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SelectStmtModel::deserialize(::pg_query::SelectStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterTableStmt::FieldModelPtr_pg_query_AlterTableStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterTableStmt::~FieldModelPtr_pg_query_AlterTableStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterTableStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTableStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTableStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterTableStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTableStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTableStmt::get(::pg_query::AlterTableStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterTableStmt(_buffer, 0);

    ::pg_query::AlterTableStmt *tempModel = new ::pg_query::AlterTableStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterTableStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTableStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTableStmt::set(const ::pg_query::AlterTableStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterTableStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterTableStmt::FieldModel_pg_query_AlterTableStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , cmds(buffer, relation.fbe_offset() + relation.fbe_size())
    , relkind(buffer, cmds.fbe_offset() + cmds.fbe_size())
    , missing_ok(buffer, relkind.fbe_offset() + relkind.fbe_size())
{}

size_t FieldModel_pg_query_AlterTableStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + cmds.fbe_size()
        + relkind.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterTableStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + cmds.fbe_extra()
        + relkind.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterTableStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterTableStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + cmds.fbe_size()) > fbe_struct_size)
        return true;
    if (!cmds.verify())
        return false;
    fbe_current_size += cmds.fbe_size();

    if ((fbe_current_size + relkind.fbe_size()) > fbe_struct_size)
        return true;
    if (!relkind.verify())
        return false;
    fbe_current_size += relkind.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterTableStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTableStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTableStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterTableStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterTableStmt& fbe_value = static_cast<::pg_query::AlterTableStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + cmds.fbe_size()) <= fbe_struct_size)
        {
            cmds.get(fbe_value.cmds);
        }
    else
        fbe_value.cmds.clear();
    fbe_current_size += cmds.fbe_size();

    if ((fbe_current_size + relkind.fbe_size()) <= fbe_struct_size)
        {
            relkind.get(fbe_value.relkind);
        }
    else
        fbe_value.relkind = ::pg_query::ObjectType();
    fbe_current_size += relkind.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_AlterTableStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTableStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTableStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterTableStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterTableStmt& fbe_value = static_cast<const ::pg_query::AlterTableStmt&>(base_fbe_value);
    relation.set(fbe_value.relation);
    cmds.set(fbe_value.cmds);
    relkind.set(fbe_value.relkind);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool AlterTableStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterTableStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterTableStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterTableStmtModel::serialize(const ::pg_query::AlterTableStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterTableStmtModel::deserialize(::pg_query::AlterTableStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterTableCmd::FieldModelPtr_pg_query_AlterTableCmd(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterTableCmd::~FieldModelPtr_pg_query_AlterTableCmd()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterTableCmd::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTableCmd::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTableCmd::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterTableCmd::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTableCmd::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTableCmd::get(::pg_query::AlterTableCmd** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterTableCmd(_buffer, 0);

    ::pg_query::AlterTableCmd *tempModel = new ::pg_query::AlterTableCmd();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterTableCmd::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTableCmd::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTableCmd::set(const ::pg_query::AlterTableCmd* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterTableCmd(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterTableCmd::FieldModel_pg_query_AlterTableCmd(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , subtype(buffer, 4 + 4)
    , name(buffer, subtype.fbe_offset() + subtype.fbe_size())
    , num(buffer, name.fbe_offset() + name.fbe_size())
    , newowner(buffer, num.fbe_offset() + num.fbe_size())
    , def(buffer, newowner.fbe_offset() + newowner.fbe_size())
    , behavior(buffer, def.fbe_offset() + def.fbe_size())
    , missing_ok(buffer, behavior.fbe_offset() + behavior.fbe_size())
{}

size_t FieldModel_pg_query_AlterTableCmd::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + subtype.fbe_size()
        + name.fbe_size()
        + num.fbe_size()
        + newowner.fbe_size()
        + def.fbe_size()
        + behavior.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterTableCmd::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + subtype.fbe_extra()
        + name.fbe_extra()
        + num.fbe_extra()
        + newowner.fbe_extra()
        + def.fbe_extra()
        + behavior.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterTableCmd::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterTableCmd::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + subtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!subtype.verify())
        return false;
    fbe_current_size += subtype.fbe_size();

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + num.fbe_size()) > fbe_struct_size)
        return true;
    if (!num.verify())
        return false;
    fbe_current_size += num.fbe_size();

    if ((fbe_current_size + newowner.fbe_size()) > fbe_struct_size)
        return true;
    if (!newowner.verify())
        return false;
    fbe_current_size += newowner.fbe_size();

    if ((fbe_current_size + def.fbe_size()) > fbe_struct_size)
        return true;
    if (!def.verify())
        return false;
    fbe_current_size += def.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) > fbe_struct_size)
        return true;
    if (!behavior.verify())
        return false;
    fbe_current_size += behavior.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterTableCmd::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTableCmd::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTableCmd::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterTableCmd::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterTableCmd& fbe_value = static_cast<::pg_query::AlterTableCmd&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + subtype.fbe_size()) <= fbe_struct_size)
        {
            subtype.get(fbe_value.subtype);
        }
    else
        fbe_value.subtype = ::pg_query::AlterTableType();
    fbe_current_size += subtype.fbe_size();

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + num.fbe_size()) <= fbe_struct_size)
        {
            num.get(fbe_value.num);
        }
    else
        fbe_value.num = (int32_t)0ll;
    fbe_current_size += num.fbe_size();

    if ((fbe_current_size + newowner.fbe_size()) <= fbe_struct_size)
        {
            newowner.get(&fbe_value.newowner);
        }
    else
        fbe_value.newowner = nullptr;
    fbe_current_size += newowner.fbe_size();

    if ((fbe_current_size + def.fbe_size()) <= fbe_struct_size)
        {
            def.get(fbe_value.def);
        }
    else
        fbe_value.def = ::pg_query::Node();
    fbe_current_size += def.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) <= fbe_struct_size)
        {
            behavior.get(fbe_value.behavior);
        }
    else
        fbe_value.behavior = ::pg_query::DropBehavior();
    fbe_current_size += behavior.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_AlterTableCmd::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTableCmd::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTableCmd::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterTableCmd::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterTableCmd& fbe_value = static_cast<const ::pg_query::AlterTableCmd&>(base_fbe_value);
    subtype.set(fbe_value.subtype);
    name.set(fbe_value.name);
    num.set(fbe_value.num);
    newowner.set(fbe_value.newowner);
    def.set(fbe_value.def);
    behavior.set(fbe_value.behavior);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool AlterTableCmdModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterTableCmdModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterTableCmdModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterTableCmdModel::serialize(const ::pg_query::AlterTableCmd& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterTableCmdModel::deserialize(::pg_query::AlterTableCmd& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterDomainStmt::FieldModelPtr_pg_query_AlterDomainStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterDomainStmt::~FieldModelPtr_pg_query_AlterDomainStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterDomainStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterDomainStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterDomainStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterDomainStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterDomainStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterDomainStmt::get(::pg_query::AlterDomainStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterDomainStmt(_buffer, 0);

    ::pg_query::AlterDomainStmt *tempModel = new ::pg_query::AlterDomainStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterDomainStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterDomainStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterDomainStmt::set(const ::pg_query::AlterDomainStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterDomainStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterDomainStmt::FieldModel_pg_query_AlterDomainStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , subtype(buffer, 4 + 4)
    , type_name(buffer, subtype.fbe_offset() + subtype.fbe_size())
    , name(buffer, type_name.fbe_offset() + type_name.fbe_size())
    , def(buffer, name.fbe_offset() + name.fbe_size())
    , behavior(buffer, def.fbe_offset() + def.fbe_size())
    , missing_ok(buffer, behavior.fbe_offset() + behavior.fbe_size())
{}

size_t FieldModel_pg_query_AlterDomainStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + subtype.fbe_size()
        + type_name.fbe_size()
        + name.fbe_size()
        + def.fbe_size()
        + behavior.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterDomainStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + subtype.fbe_extra()
        + type_name.fbe_extra()
        + name.fbe_extra()
        + def.fbe_extra()
        + behavior.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterDomainStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterDomainStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + subtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!subtype.verify())
        return false;
    fbe_current_size += subtype.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + def.fbe_size()) > fbe_struct_size)
        return true;
    if (!def.verify())
        return false;
    fbe_current_size += def.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) > fbe_struct_size)
        return true;
    if (!behavior.verify())
        return false;
    fbe_current_size += behavior.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterDomainStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterDomainStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterDomainStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterDomainStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterDomainStmt& fbe_value = static_cast<::pg_query::AlterDomainStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + subtype.fbe_size()) <= fbe_struct_size)
        {
            subtype.get(fbe_value.subtype);
        }
    else
        fbe_value.subtype = "";
    fbe_current_size += subtype.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(fbe_value.type_name);
        }
    else
        fbe_value.type_name.clear();
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + def.fbe_size()) <= fbe_struct_size)
        {
            def.get(fbe_value.def);
        }
    else
        fbe_value.def = ::pg_query::Node();
    fbe_current_size += def.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) <= fbe_struct_size)
        {
            behavior.get(fbe_value.behavior);
        }
    else
        fbe_value.behavior = ::pg_query::DropBehavior();
    fbe_current_size += behavior.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_AlterDomainStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterDomainStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterDomainStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterDomainStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterDomainStmt& fbe_value = static_cast<const ::pg_query::AlterDomainStmt&>(base_fbe_value);
    subtype.set(fbe_value.subtype);
    type_name.set(fbe_value.type_name);
    name.set(fbe_value.name);
    def.set(fbe_value.def);
    behavior.set(fbe_value.behavior);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool AlterDomainStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterDomainStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterDomainStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterDomainStmtModel::serialize(const ::pg_query::AlterDomainStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterDomainStmtModel::deserialize(::pg_query::AlterDomainStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SetOperationStmt::FieldModelPtr_pg_query_SetOperationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SetOperationStmt::~FieldModelPtr_pg_query_SetOperationStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SetOperationStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SetOperationStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SetOperationStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SetOperationStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SetOperationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SetOperationStmt::get(::pg_query::SetOperationStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SetOperationStmt(_buffer, 0);

    ::pg_query::SetOperationStmt *tempModel = new ::pg_query::SetOperationStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SetOperationStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SetOperationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SetOperationStmt::set(const ::pg_query::SetOperationStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SetOperationStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SetOperationStmt::FieldModel_pg_query_SetOperationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , op(buffer, 4 + 4)
    , all(buffer, op.fbe_offset() + op.fbe_size())
    , larg(buffer, all.fbe_offset() + all.fbe_size())
    , rarg(buffer, larg.fbe_offset() + larg.fbe_size())
    , col_types(buffer, rarg.fbe_offset() + rarg.fbe_size())
    , col_typmods(buffer, col_types.fbe_offset() + col_types.fbe_size())
    , col_collations(buffer, col_typmods.fbe_offset() + col_typmods.fbe_size())
    , group_clauses(buffer, col_collations.fbe_offset() + col_collations.fbe_size())
{}

size_t FieldModel_pg_query_SetOperationStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + op.fbe_size()
        + all.fbe_size()
        + larg.fbe_size()
        + rarg.fbe_size()
        + col_types.fbe_size()
        + col_typmods.fbe_size()
        + col_collations.fbe_size()
        + group_clauses.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SetOperationStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + op.fbe_extra()
        + all.fbe_extra()
        + larg.fbe_extra()
        + rarg.fbe_extra()
        + col_types.fbe_extra()
        + col_typmods.fbe_extra()
        + col_collations.fbe_extra()
        + group_clauses.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SetOperationStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SetOperationStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + op.fbe_size()) > fbe_struct_size)
        return true;
    if (!op.verify())
        return false;
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + all.fbe_size()) > fbe_struct_size)
        return true;
    if (!all.verify())
        return false;
    fbe_current_size += all.fbe_size();

    if ((fbe_current_size + larg.fbe_size()) > fbe_struct_size)
        return true;
    if (!larg.verify())
        return false;
    fbe_current_size += larg.fbe_size();

    if ((fbe_current_size + rarg.fbe_size()) > fbe_struct_size)
        return true;
    if (!rarg.verify())
        return false;
    fbe_current_size += rarg.fbe_size();

    if ((fbe_current_size + col_types.fbe_size()) > fbe_struct_size)
        return true;
    if (!col_types.verify())
        return false;
    fbe_current_size += col_types.fbe_size();

    if ((fbe_current_size + col_typmods.fbe_size()) > fbe_struct_size)
        return true;
    if (!col_typmods.verify())
        return false;
    fbe_current_size += col_typmods.fbe_size();

    if ((fbe_current_size + col_collations.fbe_size()) > fbe_struct_size)
        return true;
    if (!col_collations.verify())
        return false;
    fbe_current_size += col_collations.fbe_size();

    if ((fbe_current_size + group_clauses.fbe_size()) > fbe_struct_size)
        return true;
    if (!group_clauses.verify())
        return false;
    fbe_current_size += group_clauses.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SetOperationStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SetOperationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SetOperationStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SetOperationStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SetOperationStmt& fbe_value = static_cast<::pg_query::SetOperationStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + op.fbe_size()) <= fbe_struct_size)
        {
            op.get(fbe_value.op);
        }
    else
        fbe_value.op = ::pg_query::SetOperation();
    fbe_current_size += op.fbe_size();

    if ((fbe_current_size + all.fbe_size()) <= fbe_struct_size)
        {
            all.get(fbe_value.all);
        }
    else
        fbe_value.all = false;
    fbe_current_size += all.fbe_size();

    if ((fbe_current_size + larg.fbe_size()) <= fbe_struct_size)
        {
            larg.get(fbe_value.larg);
        }
    else
        fbe_value.larg = ::pg_query::Node();
    fbe_current_size += larg.fbe_size();

    if ((fbe_current_size + rarg.fbe_size()) <= fbe_struct_size)
        {
            rarg.get(fbe_value.rarg);
        }
    else
        fbe_value.rarg = ::pg_query::Node();
    fbe_current_size += rarg.fbe_size();

    if ((fbe_current_size + col_types.fbe_size()) <= fbe_struct_size)
        {
            col_types.get(fbe_value.col_types);
        }
    else
        fbe_value.col_types.clear();
    fbe_current_size += col_types.fbe_size();

    if ((fbe_current_size + col_typmods.fbe_size()) <= fbe_struct_size)
        {
            col_typmods.get(fbe_value.col_typmods);
        }
    else
        fbe_value.col_typmods.clear();
    fbe_current_size += col_typmods.fbe_size();

    if ((fbe_current_size + col_collations.fbe_size()) <= fbe_struct_size)
        {
            col_collations.get(fbe_value.col_collations);
        }
    else
        fbe_value.col_collations.clear();
    fbe_current_size += col_collations.fbe_size();

    if ((fbe_current_size + group_clauses.fbe_size()) <= fbe_struct_size)
        {
            group_clauses.get(fbe_value.group_clauses);
        }
    else
        fbe_value.group_clauses.clear();
    fbe_current_size += group_clauses.fbe_size();
}

size_t FieldModel_pg_query_SetOperationStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SetOperationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SetOperationStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SetOperationStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SetOperationStmt& fbe_value = static_cast<const ::pg_query::SetOperationStmt&>(base_fbe_value);
    op.set(fbe_value.op);
    all.set(fbe_value.all);
    larg.set(fbe_value.larg);
    rarg.set(fbe_value.rarg);
    col_types.set(fbe_value.col_types);
    col_typmods.set(fbe_value.col_typmods);
    col_collations.set(fbe_value.col_collations);
    group_clauses.set(fbe_value.group_clauses);
}

namespace pg_query {

bool SetOperationStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SetOperationStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SetOperationStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SetOperationStmtModel::serialize(const ::pg_query::SetOperationStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SetOperationStmtModel::deserialize(::pg_query::SetOperationStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_GrantStmt::FieldModelPtr_pg_query_GrantStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_GrantStmt::~FieldModelPtr_pg_query_GrantStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_GrantStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_GrantStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_GrantStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_GrantStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_GrantStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_GrantStmt::get(::pg_query::GrantStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_GrantStmt(_buffer, 0);

    ::pg_query::GrantStmt *tempModel = new ::pg_query::GrantStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_GrantStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_GrantStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_GrantStmt::set(const ::pg_query::GrantStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_GrantStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_GrantStmt::FieldModel_pg_query_GrantStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , is_grant(buffer, 4 + 4)
    , targtype(buffer, is_grant.fbe_offset() + is_grant.fbe_size())
    , objtype(buffer, targtype.fbe_offset() + targtype.fbe_size())
    , objects(buffer, objtype.fbe_offset() + objtype.fbe_size())
    , privileges(buffer, objects.fbe_offset() + objects.fbe_size())
    , grantees(buffer, privileges.fbe_offset() + privileges.fbe_size())
    , grant_option(buffer, grantees.fbe_offset() + grantees.fbe_size())
    , behavior(buffer, grant_option.fbe_offset() + grant_option.fbe_size())
{}

size_t FieldModel_pg_query_GrantStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + is_grant.fbe_size()
        + targtype.fbe_size()
        + objtype.fbe_size()
        + objects.fbe_size()
        + privileges.fbe_size()
        + grantees.fbe_size()
        + grant_option.fbe_size()
        + behavior.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_GrantStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + is_grant.fbe_extra()
        + targtype.fbe_extra()
        + objtype.fbe_extra()
        + objects.fbe_extra()
        + privileges.fbe_extra()
        + grantees.fbe_extra()
        + grant_option.fbe_extra()
        + behavior.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_GrantStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_GrantStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + is_grant.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_grant.verify())
        return false;
    fbe_current_size += is_grant.fbe_size();

    if ((fbe_current_size + targtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!targtype.verify())
        return false;
    fbe_current_size += targtype.fbe_size();

    if ((fbe_current_size + objtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!objtype.verify())
        return false;
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + objects.fbe_size()) > fbe_struct_size)
        return true;
    if (!objects.verify())
        return false;
    fbe_current_size += objects.fbe_size();

    if ((fbe_current_size + privileges.fbe_size()) > fbe_struct_size)
        return true;
    if (!privileges.verify())
        return false;
    fbe_current_size += privileges.fbe_size();

    if ((fbe_current_size + grantees.fbe_size()) > fbe_struct_size)
        return true;
    if (!grantees.verify())
        return false;
    fbe_current_size += grantees.fbe_size();

    if ((fbe_current_size + grant_option.fbe_size()) > fbe_struct_size)
        return true;
    if (!grant_option.verify())
        return false;
    fbe_current_size += grant_option.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) > fbe_struct_size)
        return true;
    if (!behavior.verify())
        return false;
    fbe_current_size += behavior.fbe_size();

    return true;
}

size_t FieldModel_pg_query_GrantStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_GrantStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_GrantStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_GrantStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::GrantStmt& fbe_value = static_cast<::pg_query::GrantStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + is_grant.fbe_size()) <= fbe_struct_size)
        {
            is_grant.get(fbe_value.is_grant);
        }
    else
        fbe_value.is_grant = false;
    fbe_current_size += is_grant.fbe_size();

    if ((fbe_current_size + targtype.fbe_size()) <= fbe_struct_size)
        {
            targtype.get(fbe_value.targtype);
        }
    else
        fbe_value.targtype = ::pg_query::GrantTargetType();
    fbe_current_size += targtype.fbe_size();

    if ((fbe_current_size + objtype.fbe_size()) <= fbe_struct_size)
        {
            objtype.get(fbe_value.objtype);
        }
    else
        fbe_value.objtype = ::pg_query::ObjectType();
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + objects.fbe_size()) <= fbe_struct_size)
        {
            objects.get(fbe_value.objects);
        }
    else
        fbe_value.objects.clear();
    fbe_current_size += objects.fbe_size();

    if ((fbe_current_size + privileges.fbe_size()) <= fbe_struct_size)
        {
            privileges.get(fbe_value.privileges);
        }
    else
        fbe_value.privileges.clear();
    fbe_current_size += privileges.fbe_size();

    if ((fbe_current_size + grantees.fbe_size()) <= fbe_struct_size)
        {
            grantees.get(fbe_value.grantees);
        }
    else
        fbe_value.grantees.clear();
    fbe_current_size += grantees.fbe_size();

    if ((fbe_current_size + grant_option.fbe_size()) <= fbe_struct_size)
        {
            grant_option.get(fbe_value.grant_option);
        }
    else
        fbe_value.grant_option = false;
    fbe_current_size += grant_option.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) <= fbe_struct_size)
        {
            behavior.get(fbe_value.behavior);
        }
    else
        fbe_value.behavior = ::pg_query::DropBehavior();
    fbe_current_size += behavior.fbe_size();
}

size_t FieldModel_pg_query_GrantStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_GrantStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_GrantStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_GrantStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::GrantStmt& fbe_value = static_cast<const ::pg_query::GrantStmt&>(base_fbe_value);
    is_grant.set(fbe_value.is_grant);
    targtype.set(fbe_value.targtype);
    objtype.set(fbe_value.objtype);
    objects.set(fbe_value.objects);
    privileges.set(fbe_value.privileges);
    grantees.set(fbe_value.grantees);
    grant_option.set(fbe_value.grant_option);
    behavior.set(fbe_value.behavior);
}

namespace pg_query {

bool GrantStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t GrantStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t GrantStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t GrantStmtModel::serialize(const ::pg_query::GrantStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t GrantStmtModel::deserialize(::pg_query::GrantStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_GrantRoleStmt::FieldModelPtr_pg_query_GrantRoleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_GrantRoleStmt::~FieldModelPtr_pg_query_GrantRoleStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_GrantRoleStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_GrantRoleStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_GrantRoleStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_GrantRoleStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_GrantRoleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_GrantRoleStmt::get(::pg_query::GrantRoleStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_GrantRoleStmt(_buffer, 0);

    ::pg_query::GrantRoleStmt *tempModel = new ::pg_query::GrantRoleStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_GrantRoleStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_GrantRoleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_GrantRoleStmt::set(const ::pg_query::GrantRoleStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_GrantRoleStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_GrantRoleStmt::FieldModel_pg_query_GrantRoleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , granted_roles(buffer, 4 + 4)
    , grantee_roles(buffer, granted_roles.fbe_offset() + granted_roles.fbe_size())
    , is_grant(buffer, grantee_roles.fbe_offset() + grantee_roles.fbe_size())
    , admin_opt(buffer, is_grant.fbe_offset() + is_grant.fbe_size())
    , grantor(buffer, admin_opt.fbe_offset() + admin_opt.fbe_size())
    , behavior(buffer, grantor.fbe_offset() + grantor.fbe_size())
{}

size_t FieldModel_pg_query_GrantRoleStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + granted_roles.fbe_size()
        + grantee_roles.fbe_size()
        + is_grant.fbe_size()
        + admin_opt.fbe_size()
        + grantor.fbe_size()
        + behavior.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_GrantRoleStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + granted_roles.fbe_extra()
        + grantee_roles.fbe_extra()
        + is_grant.fbe_extra()
        + admin_opt.fbe_extra()
        + grantor.fbe_extra()
        + behavior.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_GrantRoleStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_GrantRoleStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + granted_roles.fbe_size()) > fbe_struct_size)
        return true;
    if (!granted_roles.verify())
        return false;
    fbe_current_size += granted_roles.fbe_size();

    if ((fbe_current_size + grantee_roles.fbe_size()) > fbe_struct_size)
        return true;
    if (!grantee_roles.verify())
        return false;
    fbe_current_size += grantee_roles.fbe_size();

    if ((fbe_current_size + is_grant.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_grant.verify())
        return false;
    fbe_current_size += is_grant.fbe_size();

    if ((fbe_current_size + admin_opt.fbe_size()) > fbe_struct_size)
        return true;
    if (!admin_opt.verify())
        return false;
    fbe_current_size += admin_opt.fbe_size();

    if ((fbe_current_size + grantor.fbe_size()) > fbe_struct_size)
        return true;
    if (!grantor.verify())
        return false;
    fbe_current_size += grantor.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) > fbe_struct_size)
        return true;
    if (!behavior.verify())
        return false;
    fbe_current_size += behavior.fbe_size();

    return true;
}

size_t FieldModel_pg_query_GrantRoleStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_GrantRoleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_GrantRoleStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_GrantRoleStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::GrantRoleStmt& fbe_value = static_cast<::pg_query::GrantRoleStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + granted_roles.fbe_size()) <= fbe_struct_size)
        {
            granted_roles.get(fbe_value.granted_roles);
        }
    else
        fbe_value.granted_roles.clear();
    fbe_current_size += granted_roles.fbe_size();

    if ((fbe_current_size + grantee_roles.fbe_size()) <= fbe_struct_size)
        {
            grantee_roles.get(fbe_value.grantee_roles);
        }
    else
        fbe_value.grantee_roles.clear();
    fbe_current_size += grantee_roles.fbe_size();

    if ((fbe_current_size + is_grant.fbe_size()) <= fbe_struct_size)
        {
            is_grant.get(fbe_value.is_grant);
        }
    else
        fbe_value.is_grant = false;
    fbe_current_size += is_grant.fbe_size();

    if ((fbe_current_size + admin_opt.fbe_size()) <= fbe_struct_size)
        {
            admin_opt.get(fbe_value.admin_opt);
        }
    else
        fbe_value.admin_opt = false;
    fbe_current_size += admin_opt.fbe_size();

    if ((fbe_current_size + grantor.fbe_size()) <= fbe_struct_size)
        {
            grantor.get(&fbe_value.grantor);
        }
    else
        fbe_value.grantor = nullptr;
    fbe_current_size += grantor.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) <= fbe_struct_size)
        {
            behavior.get(fbe_value.behavior);
        }
    else
        fbe_value.behavior = ::pg_query::DropBehavior();
    fbe_current_size += behavior.fbe_size();
}

size_t FieldModel_pg_query_GrantRoleStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_GrantRoleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_GrantRoleStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_GrantRoleStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::GrantRoleStmt& fbe_value = static_cast<const ::pg_query::GrantRoleStmt&>(base_fbe_value);
    granted_roles.set(fbe_value.granted_roles);
    grantee_roles.set(fbe_value.grantee_roles);
    is_grant.set(fbe_value.is_grant);
    admin_opt.set(fbe_value.admin_opt);
    grantor.set(fbe_value.grantor);
    behavior.set(fbe_value.behavior);
}

namespace pg_query {

bool GrantRoleStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t GrantRoleStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t GrantRoleStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t GrantRoleStmtModel::serialize(const ::pg_query::GrantRoleStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t GrantRoleStmtModel::deserialize(::pg_query::GrantRoleStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::~FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::get(::pg_query::AlterDefaultPrivilegesStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterDefaultPrivilegesStmt(_buffer, 0);

    ::pg_query::AlterDefaultPrivilegesStmt *tempModel = new ::pg_query::AlterDefaultPrivilegesStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterDefaultPrivilegesStmt::set(const ::pg_query::AlterDefaultPrivilegesStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterDefaultPrivilegesStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterDefaultPrivilegesStmt::FieldModel_pg_query_AlterDefaultPrivilegesStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , options(buffer, 4 + 4)
    , action(buffer, options.fbe_offset() + options.fbe_size())
{}

size_t FieldModel_pg_query_AlterDefaultPrivilegesStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + options.fbe_size()
        + action.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterDefaultPrivilegesStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + options.fbe_extra()
        + action.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterDefaultPrivilegesStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterDefaultPrivilegesStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + action.fbe_size()) > fbe_struct_size)
        return true;
    if (!action.verify())
        return false;
    fbe_current_size += action.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterDefaultPrivilegesStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterDefaultPrivilegesStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterDefaultPrivilegesStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterDefaultPrivilegesStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterDefaultPrivilegesStmt& fbe_value = static_cast<::pg_query::AlterDefaultPrivilegesStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + action.fbe_size()) <= fbe_struct_size)
        {
            action.get(&fbe_value.action);
        }
    else
        fbe_value.action = nullptr;
    fbe_current_size += action.fbe_size();
}

size_t FieldModel_pg_query_AlterDefaultPrivilegesStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterDefaultPrivilegesStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterDefaultPrivilegesStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterDefaultPrivilegesStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterDefaultPrivilegesStmt& fbe_value = static_cast<const ::pg_query::AlterDefaultPrivilegesStmt&>(base_fbe_value);
    options.set(fbe_value.options);
    action.set(fbe_value.action);
}

namespace pg_query {

bool AlterDefaultPrivilegesStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterDefaultPrivilegesStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterDefaultPrivilegesStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterDefaultPrivilegesStmtModel::serialize(const ::pg_query::AlterDefaultPrivilegesStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterDefaultPrivilegesStmtModel::deserialize(::pg_query::AlterDefaultPrivilegesStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ClosePortalStmt::FieldModelPtr_pg_query_ClosePortalStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ClosePortalStmt::~FieldModelPtr_pg_query_ClosePortalStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ClosePortalStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ClosePortalStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ClosePortalStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ClosePortalStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ClosePortalStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ClosePortalStmt::get(::pg_query::ClosePortalStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ClosePortalStmt(_buffer, 0);

    ::pg_query::ClosePortalStmt *tempModel = new ::pg_query::ClosePortalStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ClosePortalStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ClosePortalStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ClosePortalStmt::set(const ::pg_query::ClosePortalStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ClosePortalStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ClosePortalStmt::FieldModel_pg_query_ClosePortalStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , portalname(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_ClosePortalStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + portalname.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ClosePortalStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + portalname.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ClosePortalStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ClosePortalStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + portalname.fbe_size()) > fbe_struct_size)
        return true;
    if (!portalname.verify())
        return false;
    fbe_current_size += portalname.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ClosePortalStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ClosePortalStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ClosePortalStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ClosePortalStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ClosePortalStmt& fbe_value = static_cast<::pg_query::ClosePortalStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + portalname.fbe_size()) <= fbe_struct_size)
        {
            portalname.get(fbe_value.portalname);
        }
    else
        fbe_value.portalname = "";
    fbe_current_size += portalname.fbe_size();
}

size_t FieldModel_pg_query_ClosePortalStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ClosePortalStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ClosePortalStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ClosePortalStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ClosePortalStmt& fbe_value = static_cast<const ::pg_query::ClosePortalStmt&>(base_fbe_value);
    portalname.set(fbe_value.portalname);
}

namespace pg_query {

bool ClosePortalStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ClosePortalStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ClosePortalStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ClosePortalStmtModel::serialize(const ::pg_query::ClosePortalStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ClosePortalStmtModel::deserialize(::pg_query::ClosePortalStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ClusterStmt::FieldModelPtr_pg_query_ClusterStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ClusterStmt::~FieldModelPtr_pg_query_ClusterStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ClusterStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ClusterStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ClusterStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ClusterStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ClusterStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ClusterStmt::get(::pg_query::ClusterStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ClusterStmt(_buffer, 0);

    ::pg_query::ClusterStmt *tempModel = new ::pg_query::ClusterStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ClusterStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ClusterStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ClusterStmt::set(const ::pg_query::ClusterStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ClusterStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ClusterStmt::FieldModel_pg_query_ClusterStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , indexname(buffer, relation.fbe_offset() + relation.fbe_size())
    , options(buffer, indexname.fbe_offset() + indexname.fbe_size())
{}

size_t FieldModel_pg_query_ClusterStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + indexname.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ClusterStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + indexname.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ClusterStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ClusterStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + indexname.fbe_size()) > fbe_struct_size)
        return true;
    if (!indexname.verify())
        return false;
    fbe_current_size += indexname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ClusterStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ClusterStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ClusterStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ClusterStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ClusterStmt& fbe_value = static_cast<::pg_query::ClusterStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + indexname.fbe_size()) <= fbe_struct_size)
        {
            indexname.get(fbe_value.indexname);
        }
    else
        fbe_value.indexname = "";
    fbe_current_size += indexname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options = (int32_t)0ll;
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_ClusterStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ClusterStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ClusterStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ClusterStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ClusterStmt& fbe_value = static_cast<const ::pg_query::ClusterStmt&>(base_fbe_value);
    relation.set(fbe_value.relation);
    indexname.set(fbe_value.indexname);
    options.set(fbe_value.options);
}

namespace pg_query {

bool ClusterStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ClusterStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ClusterStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ClusterStmtModel::serialize(const ::pg_query::ClusterStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ClusterStmtModel::deserialize(::pg_query::ClusterStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CopyStmt::FieldModelPtr_pg_query_CopyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CopyStmt::~FieldModelPtr_pg_query_CopyStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CopyStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CopyStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CopyStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CopyStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CopyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CopyStmt::get(::pg_query::CopyStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CopyStmt(_buffer, 0);

    ::pg_query::CopyStmt *tempModel = new ::pg_query::CopyStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CopyStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CopyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CopyStmt::set(const ::pg_query::CopyStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CopyStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CopyStmt::FieldModel_pg_query_CopyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , query(buffer, relation.fbe_offset() + relation.fbe_size())
    , attlist(buffer, query.fbe_offset() + query.fbe_size())
    , is_from(buffer, attlist.fbe_offset() + attlist.fbe_size())
    , is_program(buffer, is_from.fbe_offset() + is_from.fbe_size())
    , filename(buffer, is_program.fbe_offset() + is_program.fbe_size())
    , options(buffer, filename.fbe_offset() + filename.fbe_size())
    , where_clause(buffer, options.fbe_offset() + options.fbe_size())
{}

size_t FieldModel_pg_query_CopyStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + query.fbe_size()
        + attlist.fbe_size()
        + is_from.fbe_size()
        + is_program.fbe_size()
        + filename.fbe_size()
        + options.fbe_size()
        + where_clause.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CopyStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + query.fbe_extra()
        + attlist.fbe_extra()
        + is_from.fbe_extra()
        + is_program.fbe_extra()
        + filename.fbe_extra()
        + options.fbe_extra()
        + where_clause.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CopyStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CopyStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + query.fbe_size()) > fbe_struct_size)
        return true;
    if (!query.verify())
        return false;
    fbe_current_size += query.fbe_size();

    if ((fbe_current_size + attlist.fbe_size()) > fbe_struct_size)
        return true;
    if (!attlist.verify())
        return false;
    fbe_current_size += attlist.fbe_size();

    if ((fbe_current_size + is_from.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_from.verify())
        return false;
    fbe_current_size += is_from.fbe_size();

    if ((fbe_current_size + is_program.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_program.verify())
        return false;
    fbe_current_size += is_program.fbe_size();

    if ((fbe_current_size + filename.fbe_size()) > fbe_struct_size)
        return true;
    if (!filename.verify())
        return false;
    fbe_current_size += filename.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!where_clause.verify())
        return false;
    fbe_current_size += where_clause.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CopyStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CopyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CopyStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CopyStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CopyStmt& fbe_value = static_cast<::pg_query::CopyStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + query.fbe_size()) <= fbe_struct_size)
        {
            query.get(fbe_value.query);
        }
    else
        fbe_value.query = ::pg_query::Node();
    fbe_current_size += query.fbe_size();

    if ((fbe_current_size + attlist.fbe_size()) <= fbe_struct_size)
        {
            attlist.get(fbe_value.attlist);
        }
    else
        fbe_value.attlist.clear();
    fbe_current_size += attlist.fbe_size();

    if ((fbe_current_size + is_from.fbe_size()) <= fbe_struct_size)
        {
            is_from.get(fbe_value.is_from);
        }
    else
        fbe_value.is_from = false;
    fbe_current_size += is_from.fbe_size();

    if ((fbe_current_size + is_program.fbe_size()) <= fbe_struct_size)
        {
            is_program.get(fbe_value.is_program);
        }
    else
        fbe_value.is_program = false;
    fbe_current_size += is_program.fbe_size();

    if ((fbe_current_size + filename.fbe_size()) <= fbe_struct_size)
        {
            filename.get(fbe_value.filename);
        }
    else
        fbe_value.filename = "";
    fbe_current_size += filename.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) <= fbe_struct_size)
        {
            where_clause.get(fbe_value.where_clause);
        }
    else
        fbe_value.where_clause = ::pg_query::Node();
    fbe_current_size += where_clause.fbe_size();
}

size_t FieldModel_pg_query_CopyStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CopyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CopyStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CopyStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CopyStmt& fbe_value = static_cast<const ::pg_query::CopyStmt&>(base_fbe_value);
    relation.set(fbe_value.relation);
    query.set(fbe_value.query);
    attlist.set(fbe_value.attlist);
    is_from.set(fbe_value.is_from);
    is_program.set(fbe_value.is_program);
    filename.set(fbe_value.filename);
    options.set(fbe_value.options);
    where_clause.set(fbe_value.where_clause);
}

namespace pg_query {

bool CopyStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CopyStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CopyStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CopyStmtModel::serialize(const ::pg_query::CopyStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CopyStmtModel::deserialize(::pg_query::CopyStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateStmt::FieldModelPtr_pg_query_CreateStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateStmt::~FieldModelPtr_pg_query_CreateStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateStmt::get(::pg_query::CreateStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateStmt(_buffer, 0);

    ::pg_query::CreateStmt *tempModel = new ::pg_query::CreateStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateStmt::set(const ::pg_query::CreateStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateStmt::FieldModel_pg_query_CreateStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , table_elts(buffer, relation.fbe_offset() + relation.fbe_size())
    , inh_relations(buffer, table_elts.fbe_offset() + table_elts.fbe_size())
    , partbound(buffer, inh_relations.fbe_offset() + inh_relations.fbe_size())
    , partspec(buffer, partbound.fbe_offset() + partbound.fbe_size())
    , of_typename(buffer, partspec.fbe_offset() + partspec.fbe_size())
    , constraints(buffer, of_typename.fbe_offset() + of_typename.fbe_size())
    , options(buffer, constraints.fbe_offset() + constraints.fbe_size())
    , oncommit(buffer, options.fbe_offset() + options.fbe_size())
    , tablespacename(buffer, oncommit.fbe_offset() + oncommit.fbe_size())
    , access_method(buffer, tablespacename.fbe_offset() + tablespacename.fbe_size())
    , if_not_exists(buffer, access_method.fbe_offset() + access_method.fbe_size())
{}

size_t FieldModel_pg_query_CreateStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + table_elts.fbe_size()
        + inh_relations.fbe_size()
        + partbound.fbe_size()
        + partspec.fbe_size()
        + of_typename.fbe_size()
        + constraints.fbe_size()
        + options.fbe_size()
        + oncommit.fbe_size()
        + tablespacename.fbe_size()
        + access_method.fbe_size()
        + if_not_exists.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + table_elts.fbe_extra()
        + inh_relations.fbe_extra()
        + partbound.fbe_extra()
        + partspec.fbe_extra()
        + of_typename.fbe_extra()
        + constraints.fbe_extra()
        + options.fbe_extra()
        + oncommit.fbe_extra()
        + tablespacename.fbe_extra()
        + access_method.fbe_extra()
        + if_not_exists.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + table_elts.fbe_size()) > fbe_struct_size)
        return true;
    if (!table_elts.verify())
        return false;
    fbe_current_size += table_elts.fbe_size();

    if ((fbe_current_size + inh_relations.fbe_size()) > fbe_struct_size)
        return true;
    if (!inh_relations.verify())
        return false;
    fbe_current_size += inh_relations.fbe_size();

    if ((fbe_current_size + partbound.fbe_size()) > fbe_struct_size)
        return true;
    if (!partbound.verify())
        return false;
    fbe_current_size += partbound.fbe_size();

    if ((fbe_current_size + partspec.fbe_size()) > fbe_struct_size)
        return true;
    if (!partspec.verify())
        return false;
    fbe_current_size += partspec.fbe_size();

    if ((fbe_current_size + of_typename.fbe_size()) > fbe_struct_size)
        return true;
    if (!of_typename.verify())
        return false;
    fbe_current_size += of_typename.fbe_size();

    if ((fbe_current_size + constraints.fbe_size()) > fbe_struct_size)
        return true;
    if (!constraints.verify())
        return false;
    fbe_current_size += constraints.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + oncommit.fbe_size()) > fbe_struct_size)
        return true;
    if (!oncommit.verify())
        return false;
    fbe_current_size += oncommit.fbe_size();

    if ((fbe_current_size + tablespacename.fbe_size()) > fbe_struct_size)
        return true;
    if (!tablespacename.verify())
        return false;
    fbe_current_size += tablespacename.fbe_size();

    if ((fbe_current_size + access_method.fbe_size()) > fbe_struct_size)
        return true;
    if (!access_method.verify())
        return false;
    fbe_current_size += access_method.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateStmt& fbe_value = static_cast<::pg_query::CreateStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + table_elts.fbe_size()) <= fbe_struct_size)
        {
            table_elts.get(fbe_value.table_elts);
        }
    else
        fbe_value.table_elts.clear();
    fbe_current_size += table_elts.fbe_size();

    if ((fbe_current_size + inh_relations.fbe_size()) <= fbe_struct_size)
        {
            inh_relations.get(fbe_value.inh_relations);
        }
    else
        fbe_value.inh_relations.clear();
    fbe_current_size += inh_relations.fbe_size();

    if ((fbe_current_size + partbound.fbe_size()) <= fbe_struct_size)
        {
            partbound.get(&fbe_value.partbound);
        }
    else
        fbe_value.partbound = nullptr;
    fbe_current_size += partbound.fbe_size();

    if ((fbe_current_size + partspec.fbe_size()) <= fbe_struct_size)
        {
            partspec.get(&fbe_value.partspec);
        }
    else
        fbe_value.partspec = nullptr;
    fbe_current_size += partspec.fbe_size();

    if ((fbe_current_size + of_typename.fbe_size()) <= fbe_struct_size)
        {
            of_typename.get(&fbe_value.of_typename);
        }
    else
        fbe_value.of_typename = nullptr;
    fbe_current_size += of_typename.fbe_size();

    if ((fbe_current_size + constraints.fbe_size()) <= fbe_struct_size)
        {
            constraints.get(fbe_value.constraints);
        }
    else
        fbe_value.constraints.clear();
    fbe_current_size += constraints.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + oncommit.fbe_size()) <= fbe_struct_size)
        {
            oncommit.get(fbe_value.oncommit);
        }
    else
        fbe_value.oncommit = ::pg_query::OnCommitAction();
    fbe_current_size += oncommit.fbe_size();

    if ((fbe_current_size + tablespacename.fbe_size()) <= fbe_struct_size)
        {
            tablespacename.get(fbe_value.tablespacename);
        }
    else
        fbe_value.tablespacename = "";
    fbe_current_size += tablespacename.fbe_size();

    if ((fbe_current_size + access_method.fbe_size()) <= fbe_struct_size)
        {
            access_method.get(fbe_value.access_method);
        }
    else
        fbe_value.access_method = "";
    fbe_current_size += access_method.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();
}

size_t FieldModel_pg_query_CreateStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateStmt& fbe_value = static_cast<const ::pg_query::CreateStmt&>(base_fbe_value);
    relation.set(fbe_value.relation);
    table_elts.set(fbe_value.table_elts);
    inh_relations.set(fbe_value.inh_relations);
    partbound.set(fbe_value.partbound);
    partspec.set(fbe_value.partspec);
    of_typename.set(fbe_value.of_typename);
    constraints.set(fbe_value.constraints);
    options.set(fbe_value.options);
    oncommit.set(fbe_value.oncommit);
    tablespacename.set(fbe_value.tablespacename);
    access_method.set(fbe_value.access_method);
    if_not_exists.set(fbe_value.if_not_exists);
}

namespace pg_query {

bool CreateStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateStmtModel::serialize(const ::pg_query::CreateStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateStmtModel::deserialize(::pg_query::CreateStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DefineStmt::FieldModelPtr_pg_query_DefineStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DefineStmt::~FieldModelPtr_pg_query_DefineStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DefineStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DefineStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DefineStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DefineStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DefineStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DefineStmt::get(::pg_query::DefineStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DefineStmt(_buffer, 0);

    ::pg_query::DefineStmt *tempModel = new ::pg_query::DefineStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DefineStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DefineStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DefineStmt::set(const ::pg_query::DefineStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DefineStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DefineStmt::FieldModel_pg_query_DefineStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , oldstyle(buffer, kind.fbe_offset() + kind.fbe_size())
    , defnames(buffer, oldstyle.fbe_offset() + oldstyle.fbe_size())
    , args(buffer, defnames.fbe_offset() + defnames.fbe_size())
    , definition(buffer, args.fbe_offset() + args.fbe_size())
    , if_not_exists(buffer, definition.fbe_offset() + definition.fbe_size())
    , replace(buffer, if_not_exists.fbe_offset() + if_not_exists.fbe_size())
{}

size_t FieldModel_pg_query_DefineStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + oldstyle.fbe_size()
        + defnames.fbe_size()
        + args.fbe_size()
        + definition.fbe_size()
        + if_not_exists.fbe_size()
        + replace.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DefineStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + oldstyle.fbe_extra()
        + defnames.fbe_extra()
        + args.fbe_extra()
        + definition.fbe_extra()
        + if_not_exists.fbe_extra()
        + replace.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DefineStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DefineStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + oldstyle.fbe_size()) > fbe_struct_size)
        return true;
    if (!oldstyle.verify())
        return false;
    fbe_current_size += oldstyle.fbe_size();

    if ((fbe_current_size + defnames.fbe_size()) > fbe_struct_size)
        return true;
    if (!defnames.verify())
        return false;
    fbe_current_size += defnames.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + definition.fbe_size()) > fbe_struct_size)
        return true;
    if (!definition.verify())
        return false;
    fbe_current_size += definition.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) > fbe_struct_size)
        return true;
    if (!replace.verify())
        return false;
    fbe_current_size += replace.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DefineStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DefineStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DefineStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DefineStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DefineStmt& fbe_value = static_cast<::pg_query::DefineStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::ObjectType();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + oldstyle.fbe_size()) <= fbe_struct_size)
        {
            oldstyle.get(fbe_value.oldstyle);
        }
    else
        fbe_value.oldstyle = false;
    fbe_current_size += oldstyle.fbe_size();

    if ((fbe_current_size + defnames.fbe_size()) <= fbe_struct_size)
        {
            defnames.get(fbe_value.defnames);
        }
    else
        fbe_value.defnames.clear();
    fbe_current_size += defnames.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + definition.fbe_size()) <= fbe_struct_size)
        {
            definition.get(fbe_value.definition);
        }
    else
        fbe_value.definition.clear();
    fbe_current_size += definition.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) <= fbe_struct_size)
        {
            replace.get(fbe_value.replace);
        }
    else
        fbe_value.replace = false;
    fbe_current_size += replace.fbe_size();
}

size_t FieldModel_pg_query_DefineStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DefineStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DefineStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DefineStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DefineStmt& fbe_value = static_cast<const ::pg_query::DefineStmt&>(base_fbe_value);
    kind.set(fbe_value.kind);
    oldstyle.set(fbe_value.oldstyle);
    defnames.set(fbe_value.defnames);
    args.set(fbe_value.args);
    definition.set(fbe_value.definition);
    if_not_exists.set(fbe_value.if_not_exists);
    replace.set(fbe_value.replace);
}

namespace pg_query {

bool DefineStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DefineStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DefineStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DefineStmtModel::serialize(const ::pg_query::DefineStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DefineStmtModel::deserialize(::pg_query::DefineStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DropStmt::FieldModelPtr_pg_query_DropStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DropStmt::~FieldModelPtr_pg_query_DropStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DropStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DropStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DropStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DropStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropStmt::get(::pg_query::DropStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DropStmt(_buffer, 0);

    ::pg_query::DropStmt *tempModel = new ::pg_query::DropStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DropStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropStmt::set(const ::pg_query::DropStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DropStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DropStmt::FieldModel_pg_query_DropStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , objects(buffer, 4 + 4)
    , remove_type(buffer, objects.fbe_offset() + objects.fbe_size())
    , behavior(buffer, remove_type.fbe_offset() + remove_type.fbe_size())
    , missing_ok(buffer, behavior.fbe_offset() + behavior.fbe_size())
    , concurrent(buffer, missing_ok.fbe_offset() + missing_ok.fbe_size())
{}

size_t FieldModel_pg_query_DropStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + objects.fbe_size()
        + remove_type.fbe_size()
        + behavior.fbe_size()
        + missing_ok.fbe_size()
        + concurrent.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DropStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + objects.fbe_extra()
        + remove_type.fbe_extra()
        + behavior.fbe_extra()
        + missing_ok.fbe_extra()
        + concurrent.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DropStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DropStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objects.fbe_size()) > fbe_struct_size)
        return true;
    if (!objects.verify())
        return false;
    fbe_current_size += objects.fbe_size();

    if ((fbe_current_size + remove_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!remove_type.verify())
        return false;
    fbe_current_size += remove_type.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) > fbe_struct_size)
        return true;
    if (!behavior.verify())
        return false;
    fbe_current_size += behavior.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    if ((fbe_current_size + concurrent.fbe_size()) > fbe_struct_size)
        return true;
    if (!concurrent.verify())
        return false;
    fbe_current_size += concurrent.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DropStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DropStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DropStmt& fbe_value = static_cast<::pg_query::DropStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objects.fbe_size()) <= fbe_struct_size)
        {
            objects.get(fbe_value.objects);
        }
    else
        fbe_value.objects.clear();
    fbe_current_size += objects.fbe_size();

    if ((fbe_current_size + remove_type.fbe_size()) <= fbe_struct_size)
        {
            remove_type.get(fbe_value.remove_type);
        }
    else
        fbe_value.remove_type = ::pg_query::ObjectType();
    fbe_current_size += remove_type.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) <= fbe_struct_size)
        {
            behavior.get(fbe_value.behavior);
        }
    else
        fbe_value.behavior = ::pg_query::DropBehavior();
    fbe_current_size += behavior.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();

    if ((fbe_current_size + concurrent.fbe_size()) <= fbe_struct_size)
        {
            concurrent.get(fbe_value.concurrent);
        }
    else
        fbe_value.concurrent = false;
    fbe_current_size += concurrent.fbe_size();
}

size_t FieldModel_pg_query_DropStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DropStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DropStmt& fbe_value = static_cast<const ::pg_query::DropStmt&>(base_fbe_value);
    objects.set(fbe_value.objects);
    remove_type.set(fbe_value.remove_type);
    behavior.set(fbe_value.behavior);
    missing_ok.set(fbe_value.missing_ok);
    concurrent.set(fbe_value.concurrent);
}

namespace pg_query {

bool DropStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DropStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DropStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DropStmtModel::serialize(const ::pg_query::DropStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DropStmtModel::deserialize(::pg_query::DropStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_TruncateStmt::FieldModelPtr_pg_query_TruncateStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_TruncateStmt::~FieldModelPtr_pg_query_TruncateStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_TruncateStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_TruncateStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_TruncateStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_TruncateStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TruncateStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TruncateStmt::get(::pg_query::TruncateStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_TruncateStmt(_buffer, 0);

    ::pg_query::TruncateStmt *tempModel = new ::pg_query::TruncateStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_TruncateStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TruncateStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TruncateStmt::set(const ::pg_query::TruncateStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_TruncateStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_TruncateStmt::FieldModel_pg_query_TruncateStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relations(buffer, 4 + 4)
    , restart_seqs(buffer, relations.fbe_offset() + relations.fbe_size())
    , behavior(buffer, restart_seqs.fbe_offset() + restart_seqs.fbe_size())
{}

size_t FieldModel_pg_query_TruncateStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relations.fbe_size()
        + restart_seqs.fbe_size()
        + behavior.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_TruncateStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relations.fbe_extra()
        + restart_seqs.fbe_extra()
        + behavior.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_TruncateStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_TruncateStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relations.fbe_size()) > fbe_struct_size)
        return true;
    if (!relations.verify())
        return false;
    fbe_current_size += relations.fbe_size();

    if ((fbe_current_size + restart_seqs.fbe_size()) > fbe_struct_size)
        return true;
    if (!restart_seqs.verify())
        return false;
    fbe_current_size += restart_seqs.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) > fbe_struct_size)
        return true;
    if (!behavior.verify())
        return false;
    fbe_current_size += behavior.fbe_size();

    return true;
}

size_t FieldModel_pg_query_TruncateStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TruncateStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TruncateStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_TruncateStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::TruncateStmt& fbe_value = static_cast<::pg_query::TruncateStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relations.fbe_size()) <= fbe_struct_size)
        {
            relations.get(fbe_value.relations);
        }
    else
        fbe_value.relations.clear();
    fbe_current_size += relations.fbe_size();

    if ((fbe_current_size + restart_seqs.fbe_size()) <= fbe_struct_size)
        {
            restart_seqs.get(fbe_value.restart_seqs);
        }
    else
        fbe_value.restart_seqs = false;
    fbe_current_size += restart_seqs.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) <= fbe_struct_size)
        {
            behavior.get(fbe_value.behavior);
        }
    else
        fbe_value.behavior = ::pg_query::DropBehavior();
    fbe_current_size += behavior.fbe_size();
}

size_t FieldModel_pg_query_TruncateStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TruncateStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TruncateStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_TruncateStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::TruncateStmt& fbe_value = static_cast<const ::pg_query::TruncateStmt&>(base_fbe_value);
    relations.set(fbe_value.relations);
    restart_seqs.set(fbe_value.restart_seqs);
    behavior.set(fbe_value.behavior);
}

namespace pg_query {

bool TruncateStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TruncateStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TruncateStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TruncateStmtModel::serialize(const ::pg_query::TruncateStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TruncateStmtModel::deserialize(::pg_query::TruncateStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CommentStmt::FieldModelPtr_pg_query_CommentStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CommentStmt::~FieldModelPtr_pg_query_CommentStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CommentStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CommentStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CommentStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CommentStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CommentStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CommentStmt::get(::pg_query::CommentStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CommentStmt(_buffer, 0);

    ::pg_query::CommentStmt *tempModel = new ::pg_query::CommentStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CommentStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CommentStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CommentStmt::set(const ::pg_query::CommentStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CommentStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CommentStmt::FieldModel_pg_query_CommentStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , objtype(buffer, 4 + 4)
    , object(buffer, objtype.fbe_offset() + objtype.fbe_size())
    , comment(buffer, object.fbe_offset() + object.fbe_size())
{}

size_t FieldModel_pg_query_CommentStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + objtype.fbe_size()
        + object.fbe_size()
        + comment.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CommentStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + objtype.fbe_extra()
        + object.fbe_extra()
        + comment.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CommentStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CommentStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!objtype.verify())
        return false;
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + object.fbe_size()) > fbe_struct_size)
        return true;
    if (!object.verify())
        return false;
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + comment.fbe_size()) > fbe_struct_size)
        return true;
    if (!comment.verify())
        return false;
    fbe_current_size += comment.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CommentStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CommentStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CommentStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CommentStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CommentStmt& fbe_value = static_cast<::pg_query::CommentStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objtype.fbe_size()) <= fbe_struct_size)
        {
            objtype.get(fbe_value.objtype);
        }
    else
        fbe_value.objtype = ::pg_query::ObjectType();
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + object.fbe_size()) <= fbe_struct_size)
        {
            object.get(fbe_value.object);
        }
    else
        fbe_value.object = ::pg_query::Node();
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + comment.fbe_size()) <= fbe_struct_size)
        {
            comment.get(fbe_value.comment);
        }
    else
        fbe_value.comment = "";
    fbe_current_size += comment.fbe_size();
}

size_t FieldModel_pg_query_CommentStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CommentStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CommentStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CommentStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CommentStmt& fbe_value = static_cast<const ::pg_query::CommentStmt&>(base_fbe_value);
    objtype.set(fbe_value.objtype);
    object.set(fbe_value.object);
    comment.set(fbe_value.comment);
}

namespace pg_query {

bool CommentStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CommentStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CommentStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CommentStmtModel::serialize(const ::pg_query::CommentStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CommentStmtModel::deserialize(::pg_query::CommentStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_FetchStmt::FieldModelPtr_pg_query_FetchStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_FetchStmt::~FieldModelPtr_pg_query_FetchStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_FetchStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_FetchStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_FetchStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_FetchStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FetchStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FetchStmt::get(::pg_query::FetchStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_FetchStmt(_buffer, 0);

    ::pg_query::FetchStmt *tempModel = new ::pg_query::FetchStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_FetchStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FetchStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FetchStmt::set(const ::pg_query::FetchStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_FetchStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_FetchStmt::FieldModel_pg_query_FetchStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , direction(buffer, 4 + 4)
    , how_many(buffer, direction.fbe_offset() + direction.fbe_size())
    , portalname(buffer, how_many.fbe_offset() + how_many.fbe_size())
    , ismove(buffer, portalname.fbe_offset() + portalname.fbe_size())
{}

size_t FieldModel_pg_query_FetchStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + direction.fbe_size()
        + how_many.fbe_size()
        + portalname.fbe_size()
        + ismove.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_FetchStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + direction.fbe_extra()
        + how_many.fbe_extra()
        + portalname.fbe_extra()
        + ismove.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_FetchStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_FetchStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + direction.fbe_size()) > fbe_struct_size)
        return true;
    if (!direction.verify())
        return false;
    fbe_current_size += direction.fbe_size();

    if ((fbe_current_size + how_many.fbe_size()) > fbe_struct_size)
        return true;
    if (!how_many.verify())
        return false;
    fbe_current_size += how_many.fbe_size();

    if ((fbe_current_size + portalname.fbe_size()) > fbe_struct_size)
        return true;
    if (!portalname.verify())
        return false;
    fbe_current_size += portalname.fbe_size();

    if ((fbe_current_size + ismove.fbe_size()) > fbe_struct_size)
        return true;
    if (!ismove.verify())
        return false;
    fbe_current_size += ismove.fbe_size();

    return true;
}

size_t FieldModel_pg_query_FetchStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FetchStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FetchStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_FetchStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::FetchStmt& fbe_value = static_cast<::pg_query::FetchStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + direction.fbe_size()) <= fbe_struct_size)
        {
            direction.get(fbe_value.direction);
        }
    else
        fbe_value.direction = ::pg_query::FetchDirection();
    fbe_current_size += direction.fbe_size();

    if ((fbe_current_size + how_many.fbe_size()) <= fbe_struct_size)
        {
            how_many.get(fbe_value.how_many);
        }
    else
        fbe_value.how_many = (int64_t)0ll;
    fbe_current_size += how_many.fbe_size();

    if ((fbe_current_size + portalname.fbe_size()) <= fbe_struct_size)
        {
            portalname.get(fbe_value.portalname);
        }
    else
        fbe_value.portalname = "";
    fbe_current_size += portalname.fbe_size();

    if ((fbe_current_size + ismove.fbe_size()) <= fbe_struct_size)
        {
            ismove.get(fbe_value.ismove);
        }
    else
        fbe_value.ismove = false;
    fbe_current_size += ismove.fbe_size();
}

size_t FieldModel_pg_query_FetchStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FetchStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FetchStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_FetchStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::FetchStmt& fbe_value = static_cast<const ::pg_query::FetchStmt&>(base_fbe_value);
    direction.set(fbe_value.direction);
    how_many.set(fbe_value.how_many);
    portalname.set(fbe_value.portalname);
    ismove.set(fbe_value.ismove);
}

namespace pg_query {

bool FetchStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t FetchStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t FetchStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t FetchStmtModel::serialize(const ::pg_query::FetchStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t FetchStmtModel::deserialize(::pg_query::FetchStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_IndexStmt::FieldModelPtr_pg_query_IndexStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_IndexStmt::~FieldModelPtr_pg_query_IndexStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_IndexStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_IndexStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_IndexStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_IndexStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_IndexStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_IndexStmt::get(::pg_query::IndexStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_IndexStmt(_buffer, 0);

    ::pg_query::IndexStmt *tempModel = new ::pg_query::IndexStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_IndexStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_IndexStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_IndexStmt::set(const ::pg_query::IndexStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_IndexStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_IndexStmt::FieldModel_pg_query_IndexStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , idxname(buffer, 4 + 4)
    , relation(buffer, idxname.fbe_offset() + idxname.fbe_size())
    , access_method(buffer, relation.fbe_offset() + relation.fbe_size())
    , table_space(buffer, access_method.fbe_offset() + access_method.fbe_size())
    , index_params(buffer, table_space.fbe_offset() + table_space.fbe_size())
    , index_including_params(buffer, index_params.fbe_offset() + index_params.fbe_size())
    , options(buffer, index_including_params.fbe_offset() + index_including_params.fbe_size())
    , where_clause(buffer, options.fbe_offset() + options.fbe_size())
    , exclude_op_names(buffer, where_clause.fbe_offset() + where_clause.fbe_size())
    , idxcomment(buffer, exclude_op_names.fbe_offset() + exclude_op_names.fbe_size())
    , index_oid(buffer, idxcomment.fbe_offset() + idxcomment.fbe_size())
    , old_node(buffer, index_oid.fbe_offset() + index_oid.fbe_size())
    , old_create_subid(buffer, old_node.fbe_offset() + old_node.fbe_size())
    , old_first_relfilenode_subid(buffer, old_create_subid.fbe_offset() + old_create_subid.fbe_size())
    , unique(buffer, old_first_relfilenode_subid.fbe_offset() + old_first_relfilenode_subid.fbe_size())
    , primary(buffer, unique.fbe_offset() + unique.fbe_size())
    , isconstraint(buffer, primary.fbe_offset() + primary.fbe_size())
    , deferrable(buffer, isconstraint.fbe_offset() + isconstraint.fbe_size())
    , initdeferred(buffer, deferrable.fbe_offset() + deferrable.fbe_size())
    , transformed(buffer, initdeferred.fbe_offset() + initdeferred.fbe_size())
    , concurrent(buffer, transformed.fbe_offset() + transformed.fbe_size())
    , if_not_exists(buffer, concurrent.fbe_offset() + concurrent.fbe_size())
    , reset_default_tblspc(buffer, if_not_exists.fbe_offset() + if_not_exists.fbe_size())
{}

size_t FieldModel_pg_query_IndexStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + idxname.fbe_size()
        + relation.fbe_size()
        + access_method.fbe_size()
        + table_space.fbe_size()
        + index_params.fbe_size()
        + index_including_params.fbe_size()
        + options.fbe_size()
        + where_clause.fbe_size()
        + exclude_op_names.fbe_size()
        + idxcomment.fbe_size()
        + index_oid.fbe_size()
        + old_node.fbe_size()
        + old_create_subid.fbe_size()
        + old_first_relfilenode_subid.fbe_size()
        + unique.fbe_size()
        + primary.fbe_size()
        + isconstraint.fbe_size()
        + deferrable.fbe_size()
        + initdeferred.fbe_size()
        + transformed.fbe_size()
        + concurrent.fbe_size()
        + if_not_exists.fbe_size()
        + reset_default_tblspc.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_IndexStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + idxname.fbe_extra()
        + relation.fbe_extra()
        + access_method.fbe_extra()
        + table_space.fbe_extra()
        + index_params.fbe_extra()
        + index_including_params.fbe_extra()
        + options.fbe_extra()
        + where_clause.fbe_extra()
        + exclude_op_names.fbe_extra()
        + idxcomment.fbe_extra()
        + index_oid.fbe_extra()
        + old_node.fbe_extra()
        + old_create_subid.fbe_extra()
        + old_first_relfilenode_subid.fbe_extra()
        + unique.fbe_extra()
        + primary.fbe_extra()
        + isconstraint.fbe_extra()
        + deferrable.fbe_extra()
        + initdeferred.fbe_extra()
        + transformed.fbe_extra()
        + concurrent.fbe_extra()
        + if_not_exists.fbe_extra()
        + reset_default_tblspc.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_IndexStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_IndexStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + idxname.fbe_size()) > fbe_struct_size)
        return true;
    if (!idxname.verify())
        return false;
    fbe_current_size += idxname.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + access_method.fbe_size()) > fbe_struct_size)
        return true;
    if (!access_method.verify())
        return false;
    fbe_current_size += access_method.fbe_size();

    if ((fbe_current_size + table_space.fbe_size()) > fbe_struct_size)
        return true;
    if (!table_space.verify())
        return false;
    fbe_current_size += table_space.fbe_size();

    if ((fbe_current_size + index_params.fbe_size()) > fbe_struct_size)
        return true;
    if (!index_params.verify())
        return false;
    fbe_current_size += index_params.fbe_size();

    if ((fbe_current_size + index_including_params.fbe_size()) > fbe_struct_size)
        return true;
    if (!index_including_params.verify())
        return false;
    fbe_current_size += index_including_params.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!where_clause.verify())
        return false;
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + exclude_op_names.fbe_size()) > fbe_struct_size)
        return true;
    if (!exclude_op_names.verify())
        return false;
    fbe_current_size += exclude_op_names.fbe_size();

    if ((fbe_current_size + idxcomment.fbe_size()) > fbe_struct_size)
        return true;
    if (!idxcomment.verify())
        return false;
    fbe_current_size += idxcomment.fbe_size();

    if ((fbe_current_size + index_oid.fbe_size()) > fbe_struct_size)
        return true;
    if (!index_oid.verify())
        return false;
    fbe_current_size += index_oid.fbe_size();

    if ((fbe_current_size + old_node.fbe_size()) > fbe_struct_size)
        return true;
    if (!old_node.verify())
        return false;
    fbe_current_size += old_node.fbe_size();

    if ((fbe_current_size + old_create_subid.fbe_size()) > fbe_struct_size)
        return true;
    if (!old_create_subid.verify())
        return false;
    fbe_current_size += old_create_subid.fbe_size();

    if ((fbe_current_size + old_first_relfilenode_subid.fbe_size()) > fbe_struct_size)
        return true;
    if (!old_first_relfilenode_subid.verify())
        return false;
    fbe_current_size += old_first_relfilenode_subid.fbe_size();

    if ((fbe_current_size + unique.fbe_size()) > fbe_struct_size)
        return true;
    if (!unique.verify())
        return false;
    fbe_current_size += unique.fbe_size();

    if ((fbe_current_size + primary.fbe_size()) > fbe_struct_size)
        return true;
    if (!primary.verify())
        return false;
    fbe_current_size += primary.fbe_size();

    if ((fbe_current_size + isconstraint.fbe_size()) > fbe_struct_size)
        return true;
    if (!isconstraint.verify())
        return false;
    fbe_current_size += isconstraint.fbe_size();

    if ((fbe_current_size + deferrable.fbe_size()) > fbe_struct_size)
        return true;
    if (!deferrable.verify())
        return false;
    fbe_current_size += deferrable.fbe_size();

    if ((fbe_current_size + initdeferred.fbe_size()) > fbe_struct_size)
        return true;
    if (!initdeferred.verify())
        return false;
    fbe_current_size += initdeferred.fbe_size();

    if ((fbe_current_size + transformed.fbe_size()) > fbe_struct_size)
        return true;
    if (!transformed.verify())
        return false;
    fbe_current_size += transformed.fbe_size();

    if ((fbe_current_size + concurrent.fbe_size()) > fbe_struct_size)
        return true;
    if (!concurrent.verify())
        return false;
    fbe_current_size += concurrent.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + reset_default_tblspc.fbe_size()) > fbe_struct_size)
        return true;
    if (!reset_default_tblspc.verify())
        return false;
    fbe_current_size += reset_default_tblspc.fbe_size();

    return true;
}

size_t FieldModel_pg_query_IndexStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_IndexStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_IndexStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_IndexStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::IndexStmt& fbe_value = static_cast<::pg_query::IndexStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + idxname.fbe_size()) <= fbe_struct_size)
        {
            idxname.get(fbe_value.idxname);
        }
    else
        fbe_value.idxname = "";
    fbe_current_size += idxname.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + access_method.fbe_size()) <= fbe_struct_size)
        {
            access_method.get(fbe_value.access_method);
        }
    else
        fbe_value.access_method = "";
    fbe_current_size += access_method.fbe_size();

    if ((fbe_current_size + table_space.fbe_size()) <= fbe_struct_size)
        {
            table_space.get(fbe_value.table_space);
        }
    else
        fbe_value.table_space = "";
    fbe_current_size += table_space.fbe_size();

    if ((fbe_current_size + index_params.fbe_size()) <= fbe_struct_size)
        {
            index_params.get(fbe_value.index_params);
        }
    else
        fbe_value.index_params.clear();
    fbe_current_size += index_params.fbe_size();

    if ((fbe_current_size + index_including_params.fbe_size()) <= fbe_struct_size)
        {
            index_including_params.get(fbe_value.index_including_params);
        }
    else
        fbe_value.index_including_params.clear();
    fbe_current_size += index_including_params.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) <= fbe_struct_size)
        {
            where_clause.get(fbe_value.where_clause);
        }
    else
        fbe_value.where_clause = ::pg_query::Node();
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + exclude_op_names.fbe_size()) <= fbe_struct_size)
        {
            exclude_op_names.get(fbe_value.exclude_op_names);
        }
    else
        fbe_value.exclude_op_names.clear();
    fbe_current_size += exclude_op_names.fbe_size();

    if ((fbe_current_size + idxcomment.fbe_size()) <= fbe_struct_size)
        {
            idxcomment.get(fbe_value.idxcomment);
        }
    else
        fbe_value.idxcomment = "";
    fbe_current_size += idxcomment.fbe_size();

    if ((fbe_current_size + index_oid.fbe_size()) <= fbe_struct_size)
        {
            index_oid.get(fbe_value.index_oid);
        }
    else
        fbe_value.index_oid = (uint32_t)0ull;
    fbe_current_size += index_oid.fbe_size();

    if ((fbe_current_size + old_node.fbe_size()) <= fbe_struct_size)
        {
            old_node.get(fbe_value.old_node);
        }
    else
        fbe_value.old_node = (uint32_t)0ull;
    fbe_current_size += old_node.fbe_size();

    if ((fbe_current_size + old_create_subid.fbe_size()) <= fbe_struct_size)
        {
            old_create_subid.get(fbe_value.old_create_subid);
        }
    else
        fbe_value.old_create_subid = (uint32_t)0ull;
    fbe_current_size += old_create_subid.fbe_size();

    if ((fbe_current_size + old_first_relfilenode_subid.fbe_size()) <= fbe_struct_size)
        {
            old_first_relfilenode_subid.get(fbe_value.old_first_relfilenode_subid);
        }
    else
        fbe_value.old_first_relfilenode_subid = (uint32_t)0ull;
    fbe_current_size += old_first_relfilenode_subid.fbe_size();

    if ((fbe_current_size + unique.fbe_size()) <= fbe_struct_size)
        {
            unique.get(fbe_value.unique);
        }
    else
        fbe_value.unique = false;
    fbe_current_size += unique.fbe_size();

    if ((fbe_current_size + primary.fbe_size()) <= fbe_struct_size)
        {
            primary.get(fbe_value.primary);
        }
    else
        fbe_value.primary = false;
    fbe_current_size += primary.fbe_size();

    if ((fbe_current_size + isconstraint.fbe_size()) <= fbe_struct_size)
        {
            isconstraint.get(fbe_value.isconstraint);
        }
    else
        fbe_value.isconstraint = false;
    fbe_current_size += isconstraint.fbe_size();

    if ((fbe_current_size + deferrable.fbe_size()) <= fbe_struct_size)
        {
            deferrable.get(fbe_value.deferrable);
        }
    else
        fbe_value.deferrable = false;
    fbe_current_size += deferrable.fbe_size();

    if ((fbe_current_size + initdeferred.fbe_size()) <= fbe_struct_size)
        {
            initdeferred.get(fbe_value.initdeferred);
        }
    else
        fbe_value.initdeferred = false;
    fbe_current_size += initdeferred.fbe_size();

    if ((fbe_current_size + transformed.fbe_size()) <= fbe_struct_size)
        {
            transformed.get(fbe_value.transformed);
        }
    else
        fbe_value.transformed = false;
    fbe_current_size += transformed.fbe_size();

    if ((fbe_current_size + concurrent.fbe_size()) <= fbe_struct_size)
        {
            concurrent.get(fbe_value.concurrent);
        }
    else
        fbe_value.concurrent = false;
    fbe_current_size += concurrent.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + reset_default_tblspc.fbe_size()) <= fbe_struct_size)
        {
            reset_default_tblspc.get(fbe_value.reset_default_tblspc);
        }
    else
        fbe_value.reset_default_tblspc = false;
    fbe_current_size += reset_default_tblspc.fbe_size();
}

size_t FieldModel_pg_query_IndexStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_IndexStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_IndexStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_IndexStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::IndexStmt& fbe_value = static_cast<const ::pg_query::IndexStmt&>(base_fbe_value);
    idxname.set(fbe_value.idxname);
    relation.set(fbe_value.relation);
    access_method.set(fbe_value.access_method);
    table_space.set(fbe_value.table_space);
    index_params.set(fbe_value.index_params);
    index_including_params.set(fbe_value.index_including_params);
    options.set(fbe_value.options);
    where_clause.set(fbe_value.where_clause);
    exclude_op_names.set(fbe_value.exclude_op_names);
    idxcomment.set(fbe_value.idxcomment);
    index_oid.set(fbe_value.index_oid);
    old_node.set(fbe_value.old_node);
    old_create_subid.set(fbe_value.old_create_subid);
    old_first_relfilenode_subid.set(fbe_value.old_first_relfilenode_subid);
    unique.set(fbe_value.unique);
    primary.set(fbe_value.primary);
    isconstraint.set(fbe_value.isconstraint);
    deferrable.set(fbe_value.deferrable);
    initdeferred.set(fbe_value.initdeferred);
    transformed.set(fbe_value.transformed);
    concurrent.set(fbe_value.concurrent);
    if_not_exists.set(fbe_value.if_not_exists);
    reset_default_tblspc.set(fbe_value.reset_default_tblspc);
}

namespace pg_query {

bool IndexStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t IndexStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t IndexStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t IndexStmtModel::serialize(const ::pg_query::IndexStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t IndexStmtModel::deserialize(::pg_query::IndexStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateFunctionStmt::FieldModelPtr_pg_query_CreateFunctionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateFunctionStmt::~FieldModelPtr_pg_query_CreateFunctionStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateFunctionStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateFunctionStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateFunctionStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateFunctionStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateFunctionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateFunctionStmt::get(::pg_query::CreateFunctionStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateFunctionStmt(_buffer, 0);

    ::pg_query::CreateFunctionStmt *tempModel = new ::pg_query::CreateFunctionStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateFunctionStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateFunctionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateFunctionStmt::set(const ::pg_query::CreateFunctionStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateFunctionStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateFunctionStmt::FieldModel_pg_query_CreateFunctionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , is_procedure(buffer, 4 + 4)
    , replace(buffer, is_procedure.fbe_offset() + is_procedure.fbe_size())
    , funcname(buffer, replace.fbe_offset() + replace.fbe_size())
    , parameters(buffer, funcname.fbe_offset() + funcname.fbe_size())
    , return_type(buffer, parameters.fbe_offset() + parameters.fbe_size())
    , options(buffer, return_type.fbe_offset() + return_type.fbe_size())
{}

size_t FieldModel_pg_query_CreateFunctionStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + is_procedure.fbe_size()
        + replace.fbe_size()
        + funcname.fbe_size()
        + parameters.fbe_size()
        + return_type.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateFunctionStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + is_procedure.fbe_extra()
        + replace.fbe_extra()
        + funcname.fbe_extra()
        + parameters.fbe_extra()
        + return_type.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateFunctionStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateFunctionStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + is_procedure.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_procedure.verify())
        return false;
    fbe_current_size += is_procedure.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) > fbe_struct_size)
        return true;
    if (!replace.verify())
        return false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + funcname.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcname.verify())
        return false;
    fbe_current_size += funcname.fbe_size();

    if ((fbe_current_size + parameters.fbe_size()) > fbe_struct_size)
        return true;
    if (!parameters.verify())
        return false;
    fbe_current_size += parameters.fbe_size();

    if ((fbe_current_size + return_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!return_type.verify())
        return false;
    fbe_current_size += return_type.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateFunctionStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateFunctionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateFunctionStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateFunctionStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateFunctionStmt& fbe_value = static_cast<::pg_query::CreateFunctionStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + is_procedure.fbe_size()) <= fbe_struct_size)
        {
            is_procedure.get(fbe_value.is_procedure);
        }
    else
        fbe_value.is_procedure = false;
    fbe_current_size += is_procedure.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) <= fbe_struct_size)
        {
            replace.get(fbe_value.replace);
        }
    else
        fbe_value.replace = false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + funcname.fbe_size()) <= fbe_struct_size)
        {
            funcname.get(fbe_value.funcname);
        }
    else
        fbe_value.funcname.clear();
    fbe_current_size += funcname.fbe_size();

    if ((fbe_current_size + parameters.fbe_size()) <= fbe_struct_size)
        {
            parameters.get(fbe_value.parameters);
        }
    else
        fbe_value.parameters.clear();
    fbe_current_size += parameters.fbe_size();

    if ((fbe_current_size + return_type.fbe_size()) <= fbe_struct_size)
        {
            return_type.get(&fbe_value.return_type);
        }
    else
        fbe_value.return_type = nullptr;
    fbe_current_size += return_type.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreateFunctionStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateFunctionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateFunctionStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateFunctionStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateFunctionStmt& fbe_value = static_cast<const ::pg_query::CreateFunctionStmt&>(base_fbe_value);
    is_procedure.set(fbe_value.is_procedure);
    replace.set(fbe_value.replace);
    funcname.set(fbe_value.funcname);
    parameters.set(fbe_value.parameters);
    return_type.set(fbe_value.return_type);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreateFunctionStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateFunctionStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateFunctionStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateFunctionStmtModel::serialize(const ::pg_query::CreateFunctionStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateFunctionStmtModel::deserialize(::pg_query::CreateFunctionStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterFunctionStmt::FieldModelPtr_pg_query_AlterFunctionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterFunctionStmt::~FieldModelPtr_pg_query_AlterFunctionStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterFunctionStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterFunctionStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterFunctionStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterFunctionStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterFunctionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterFunctionStmt::get(::pg_query::AlterFunctionStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterFunctionStmt(_buffer, 0);

    ::pg_query::AlterFunctionStmt *tempModel = new ::pg_query::AlterFunctionStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterFunctionStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterFunctionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterFunctionStmt::set(const ::pg_query::AlterFunctionStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterFunctionStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterFunctionStmt::FieldModel_pg_query_AlterFunctionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , objtype(buffer, 4 + 4)
    , func(buffer, objtype.fbe_offset() + objtype.fbe_size())
    , actions(buffer, func.fbe_offset() + func.fbe_size())
{}

size_t FieldModel_pg_query_AlterFunctionStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + objtype.fbe_size()
        + func.fbe_size()
        + actions.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterFunctionStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + objtype.fbe_extra()
        + func.fbe_extra()
        + actions.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterFunctionStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterFunctionStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!objtype.verify())
        return false;
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + func.fbe_size()) > fbe_struct_size)
        return true;
    if (!func.verify())
        return false;
    fbe_current_size += func.fbe_size();

    if ((fbe_current_size + actions.fbe_size()) > fbe_struct_size)
        return true;
    if (!actions.verify())
        return false;
    fbe_current_size += actions.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterFunctionStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterFunctionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterFunctionStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterFunctionStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterFunctionStmt& fbe_value = static_cast<::pg_query::AlterFunctionStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objtype.fbe_size()) <= fbe_struct_size)
        {
            objtype.get(fbe_value.objtype);
        }
    else
        fbe_value.objtype = ::pg_query::ObjectType();
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + func.fbe_size()) <= fbe_struct_size)
        {
            func.get(&fbe_value.func);
        }
    else
        fbe_value.func = nullptr;
    fbe_current_size += func.fbe_size();

    if ((fbe_current_size + actions.fbe_size()) <= fbe_struct_size)
        {
            actions.get(fbe_value.actions);
        }
    else
        fbe_value.actions.clear();
    fbe_current_size += actions.fbe_size();
}

size_t FieldModel_pg_query_AlterFunctionStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterFunctionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterFunctionStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterFunctionStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterFunctionStmt& fbe_value = static_cast<const ::pg_query::AlterFunctionStmt&>(base_fbe_value);
    objtype.set(fbe_value.objtype);
    func.set(fbe_value.func);
    actions.set(fbe_value.actions);
}

namespace pg_query {

bool AlterFunctionStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterFunctionStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterFunctionStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterFunctionStmtModel::serialize(const ::pg_query::AlterFunctionStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterFunctionStmtModel::deserialize(::pg_query::AlterFunctionStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DoStmt::FieldModelPtr_pg_query_DoStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DoStmt::~FieldModelPtr_pg_query_DoStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DoStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DoStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DoStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DoStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DoStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DoStmt::get(::pg_query::DoStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DoStmt(_buffer, 0);

    ::pg_query::DoStmt *tempModel = new ::pg_query::DoStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DoStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DoStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DoStmt::set(const ::pg_query::DoStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DoStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DoStmt::FieldModel_pg_query_DoStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , args(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_DoStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + args.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DoStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + args.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DoStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DoStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DoStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DoStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DoStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DoStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DoStmt& fbe_value = static_cast<::pg_query::DoStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();
}

size_t FieldModel_pg_query_DoStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DoStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DoStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DoStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DoStmt& fbe_value = static_cast<const ::pg_query::DoStmt&>(base_fbe_value);
    args.set(fbe_value.args);
}

namespace pg_query {

bool DoStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DoStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DoStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DoStmtModel::serialize(const ::pg_query::DoStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DoStmtModel::deserialize(::pg_query::DoStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RenameStmt::FieldModelPtr_pg_query_RenameStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RenameStmt::~FieldModelPtr_pg_query_RenameStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RenameStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RenameStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RenameStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RenameStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RenameStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RenameStmt::get(::pg_query::RenameStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RenameStmt(_buffer, 0);

    ::pg_query::RenameStmt *tempModel = new ::pg_query::RenameStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RenameStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RenameStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RenameStmt::set(const ::pg_query::RenameStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RenameStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RenameStmt::FieldModel_pg_query_RenameStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , rename_type(buffer, 4 + 4)
    , relation_type(buffer, rename_type.fbe_offset() + rename_type.fbe_size())
    , relation(buffer, relation_type.fbe_offset() + relation_type.fbe_size())
    , object(buffer, relation.fbe_offset() + relation.fbe_size())
    , subname(buffer, object.fbe_offset() + object.fbe_size())
    , newname(buffer, subname.fbe_offset() + subname.fbe_size())
    , behavior(buffer, newname.fbe_offset() + newname.fbe_size())
    , missing_ok(buffer, behavior.fbe_offset() + behavior.fbe_size())
{}

size_t FieldModel_pg_query_RenameStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + rename_type.fbe_size()
        + relation_type.fbe_size()
        + relation.fbe_size()
        + object.fbe_size()
        + subname.fbe_size()
        + newname.fbe_size()
        + behavior.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RenameStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + rename_type.fbe_extra()
        + relation_type.fbe_extra()
        + relation.fbe_extra()
        + object.fbe_extra()
        + subname.fbe_extra()
        + newname.fbe_extra()
        + behavior.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RenameStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RenameStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rename_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!rename_type.verify())
        return false;
    fbe_current_size += rename_type.fbe_size();

    if ((fbe_current_size + relation_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation_type.verify())
        return false;
    fbe_current_size += relation_type.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + object.fbe_size()) > fbe_struct_size)
        return true;
    if (!object.verify())
        return false;
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + subname.fbe_size()) > fbe_struct_size)
        return true;
    if (!subname.verify())
        return false;
    fbe_current_size += subname.fbe_size();

    if ((fbe_current_size + newname.fbe_size()) > fbe_struct_size)
        return true;
    if (!newname.verify())
        return false;
    fbe_current_size += newname.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) > fbe_struct_size)
        return true;
    if (!behavior.verify())
        return false;
    fbe_current_size += behavior.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RenameStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RenameStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RenameStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RenameStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RenameStmt& fbe_value = static_cast<::pg_query::RenameStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rename_type.fbe_size()) <= fbe_struct_size)
        {
            rename_type.get(fbe_value.rename_type);
        }
    else
        fbe_value.rename_type = ::pg_query::ObjectType();
    fbe_current_size += rename_type.fbe_size();

    if ((fbe_current_size + relation_type.fbe_size()) <= fbe_struct_size)
        {
            relation_type.get(fbe_value.relation_type);
        }
    else
        fbe_value.relation_type = ::pg_query::ObjectType();
    fbe_current_size += relation_type.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + object.fbe_size()) <= fbe_struct_size)
        {
            object.get(fbe_value.object);
        }
    else
        fbe_value.object = ::pg_query::Node();
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + subname.fbe_size()) <= fbe_struct_size)
        {
            subname.get(fbe_value.subname);
        }
    else
        fbe_value.subname = "";
    fbe_current_size += subname.fbe_size();

    if ((fbe_current_size + newname.fbe_size()) <= fbe_struct_size)
        {
            newname.get(fbe_value.newname);
        }
    else
        fbe_value.newname = "";
    fbe_current_size += newname.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) <= fbe_struct_size)
        {
            behavior.get(fbe_value.behavior);
        }
    else
        fbe_value.behavior = ::pg_query::DropBehavior();
    fbe_current_size += behavior.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_RenameStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RenameStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RenameStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RenameStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RenameStmt& fbe_value = static_cast<const ::pg_query::RenameStmt&>(base_fbe_value);
    rename_type.set(fbe_value.rename_type);
    relation_type.set(fbe_value.relation_type);
    relation.set(fbe_value.relation);
    object.set(fbe_value.object);
    subname.set(fbe_value.subname);
    newname.set(fbe_value.newname);
    behavior.set(fbe_value.behavior);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool RenameStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RenameStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RenameStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RenameStmtModel::serialize(const ::pg_query::RenameStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RenameStmtModel::deserialize(::pg_query::RenameStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RuleStmt::FieldModelPtr_pg_query_RuleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RuleStmt::~FieldModelPtr_pg_query_RuleStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RuleStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RuleStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RuleStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RuleStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RuleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RuleStmt::get(::pg_query::RuleStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RuleStmt(_buffer, 0);

    ::pg_query::RuleStmt *tempModel = new ::pg_query::RuleStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RuleStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RuleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RuleStmt::set(const ::pg_query::RuleStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RuleStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RuleStmt::FieldModel_pg_query_RuleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , rulename(buffer, relation.fbe_offset() + relation.fbe_size())
    , where_clause(buffer, rulename.fbe_offset() + rulename.fbe_size())
    , event(buffer, where_clause.fbe_offset() + where_clause.fbe_size())
    , instead(buffer, event.fbe_offset() + event.fbe_size())
    , actions(buffer, instead.fbe_offset() + instead.fbe_size())
    , replace(buffer, actions.fbe_offset() + actions.fbe_size())
{}

size_t FieldModel_pg_query_RuleStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + rulename.fbe_size()
        + where_clause.fbe_size()
        + event.fbe_size()
        + instead.fbe_size()
        + actions.fbe_size()
        + replace.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RuleStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + rulename.fbe_extra()
        + where_clause.fbe_extra()
        + event.fbe_extra()
        + instead.fbe_extra()
        + actions.fbe_extra()
        + replace.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RuleStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RuleStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + rulename.fbe_size()) > fbe_struct_size)
        return true;
    if (!rulename.verify())
        return false;
    fbe_current_size += rulename.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!where_clause.verify())
        return false;
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + event.fbe_size()) > fbe_struct_size)
        return true;
    if (!event.verify())
        return false;
    fbe_current_size += event.fbe_size();

    if ((fbe_current_size + instead.fbe_size()) > fbe_struct_size)
        return true;
    if (!instead.verify())
        return false;
    fbe_current_size += instead.fbe_size();

    if ((fbe_current_size + actions.fbe_size()) > fbe_struct_size)
        return true;
    if (!actions.verify())
        return false;
    fbe_current_size += actions.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) > fbe_struct_size)
        return true;
    if (!replace.verify())
        return false;
    fbe_current_size += replace.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RuleStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RuleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RuleStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RuleStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RuleStmt& fbe_value = static_cast<::pg_query::RuleStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + rulename.fbe_size()) <= fbe_struct_size)
        {
            rulename.get(fbe_value.rulename);
        }
    else
        fbe_value.rulename = "";
    fbe_current_size += rulename.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) <= fbe_struct_size)
        {
            where_clause.get(fbe_value.where_clause);
        }
    else
        fbe_value.where_clause = ::pg_query::Node();
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + event.fbe_size()) <= fbe_struct_size)
        {
            event.get(fbe_value.event);
        }
    else
        fbe_value.event = ::pg_query::CmdType();
    fbe_current_size += event.fbe_size();

    if ((fbe_current_size + instead.fbe_size()) <= fbe_struct_size)
        {
            instead.get(fbe_value.instead);
        }
    else
        fbe_value.instead = false;
    fbe_current_size += instead.fbe_size();

    if ((fbe_current_size + actions.fbe_size()) <= fbe_struct_size)
        {
            actions.get(fbe_value.actions);
        }
    else
        fbe_value.actions.clear();
    fbe_current_size += actions.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) <= fbe_struct_size)
        {
            replace.get(fbe_value.replace);
        }
    else
        fbe_value.replace = false;
    fbe_current_size += replace.fbe_size();
}

size_t FieldModel_pg_query_RuleStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RuleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RuleStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RuleStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RuleStmt& fbe_value = static_cast<const ::pg_query::RuleStmt&>(base_fbe_value);
    relation.set(fbe_value.relation);
    rulename.set(fbe_value.rulename);
    where_clause.set(fbe_value.where_clause);
    event.set(fbe_value.event);
    instead.set(fbe_value.instead);
    actions.set(fbe_value.actions);
    replace.set(fbe_value.replace);
}

namespace pg_query {

bool RuleStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RuleStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RuleStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RuleStmtModel::serialize(const ::pg_query::RuleStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RuleStmtModel::deserialize(::pg_query::RuleStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_NotifyStmt::FieldModelPtr_pg_query_NotifyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_NotifyStmt::~FieldModelPtr_pg_query_NotifyStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_NotifyStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_NotifyStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_NotifyStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_NotifyStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NotifyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NotifyStmt::get(::pg_query::NotifyStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_NotifyStmt(_buffer, 0);

    ::pg_query::NotifyStmt *tempModel = new ::pg_query::NotifyStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_NotifyStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_NotifyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_NotifyStmt::set(const ::pg_query::NotifyStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_NotifyStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_NotifyStmt::FieldModel_pg_query_NotifyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , conditionname(buffer, 4 + 4)
    , payload(buffer, conditionname.fbe_offset() + conditionname.fbe_size())
{}

size_t FieldModel_pg_query_NotifyStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + conditionname.fbe_size()
        + payload.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_NotifyStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + conditionname.fbe_extra()
        + payload.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_NotifyStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_NotifyStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + conditionname.fbe_size()) > fbe_struct_size)
        return true;
    if (!conditionname.verify())
        return false;
    fbe_current_size += conditionname.fbe_size();

    if ((fbe_current_size + payload.fbe_size()) > fbe_struct_size)
        return true;
    if (!payload.verify())
        return false;
    fbe_current_size += payload.fbe_size();

    return true;
}

size_t FieldModel_pg_query_NotifyStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NotifyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NotifyStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_NotifyStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::NotifyStmt& fbe_value = static_cast<::pg_query::NotifyStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + conditionname.fbe_size()) <= fbe_struct_size)
        {
            conditionname.get(fbe_value.conditionname);
        }
    else
        fbe_value.conditionname = "";
    fbe_current_size += conditionname.fbe_size();

    if ((fbe_current_size + payload.fbe_size()) <= fbe_struct_size)
        {
            payload.get(fbe_value.payload);
        }
    else
        fbe_value.payload = "";
    fbe_current_size += payload.fbe_size();
}

size_t FieldModel_pg_query_NotifyStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_NotifyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_NotifyStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_NotifyStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::NotifyStmt& fbe_value = static_cast<const ::pg_query::NotifyStmt&>(base_fbe_value);
    conditionname.set(fbe_value.conditionname);
    payload.set(fbe_value.payload);
}

namespace pg_query {

bool NotifyStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t NotifyStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t NotifyStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t NotifyStmtModel::serialize(const ::pg_query::NotifyStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t NotifyStmtModel::deserialize(::pg_query::NotifyStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ListenStmt::FieldModelPtr_pg_query_ListenStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ListenStmt::~FieldModelPtr_pg_query_ListenStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ListenStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ListenStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ListenStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ListenStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ListenStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ListenStmt::get(::pg_query::ListenStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ListenStmt(_buffer, 0);

    ::pg_query::ListenStmt *tempModel = new ::pg_query::ListenStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ListenStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ListenStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ListenStmt::set(const ::pg_query::ListenStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ListenStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ListenStmt::FieldModel_pg_query_ListenStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , conditionname(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_ListenStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + conditionname.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ListenStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + conditionname.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ListenStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ListenStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + conditionname.fbe_size()) > fbe_struct_size)
        return true;
    if (!conditionname.verify())
        return false;
    fbe_current_size += conditionname.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ListenStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ListenStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ListenStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ListenStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ListenStmt& fbe_value = static_cast<::pg_query::ListenStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + conditionname.fbe_size()) <= fbe_struct_size)
        {
            conditionname.get(fbe_value.conditionname);
        }
    else
        fbe_value.conditionname = "";
    fbe_current_size += conditionname.fbe_size();
}

size_t FieldModel_pg_query_ListenStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ListenStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ListenStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ListenStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ListenStmt& fbe_value = static_cast<const ::pg_query::ListenStmt&>(base_fbe_value);
    conditionname.set(fbe_value.conditionname);
}

namespace pg_query {

bool ListenStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ListenStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ListenStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ListenStmtModel::serialize(const ::pg_query::ListenStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ListenStmtModel::deserialize(::pg_query::ListenStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_UnlistenStmt::FieldModelPtr_pg_query_UnlistenStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_UnlistenStmt::~FieldModelPtr_pg_query_UnlistenStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_UnlistenStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_UnlistenStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_UnlistenStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_UnlistenStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_UnlistenStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_UnlistenStmt::get(::pg_query::UnlistenStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_UnlistenStmt(_buffer, 0);

    ::pg_query::UnlistenStmt *tempModel = new ::pg_query::UnlistenStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_UnlistenStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_UnlistenStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_UnlistenStmt::set(const ::pg_query::UnlistenStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_UnlistenStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_UnlistenStmt::FieldModel_pg_query_UnlistenStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , conditionname(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_UnlistenStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + conditionname.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_UnlistenStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + conditionname.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_UnlistenStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_UnlistenStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + conditionname.fbe_size()) > fbe_struct_size)
        return true;
    if (!conditionname.verify())
        return false;
    fbe_current_size += conditionname.fbe_size();

    return true;
}

size_t FieldModel_pg_query_UnlistenStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_UnlistenStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_UnlistenStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_UnlistenStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::UnlistenStmt& fbe_value = static_cast<::pg_query::UnlistenStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + conditionname.fbe_size()) <= fbe_struct_size)
        {
            conditionname.get(fbe_value.conditionname);
        }
    else
        fbe_value.conditionname = "";
    fbe_current_size += conditionname.fbe_size();
}

size_t FieldModel_pg_query_UnlistenStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_UnlistenStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_UnlistenStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_UnlistenStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::UnlistenStmt& fbe_value = static_cast<const ::pg_query::UnlistenStmt&>(base_fbe_value);
    conditionname.set(fbe_value.conditionname);
}

namespace pg_query {

bool UnlistenStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t UnlistenStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t UnlistenStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t UnlistenStmtModel::serialize(const ::pg_query::UnlistenStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t UnlistenStmtModel::deserialize(::pg_query::UnlistenStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_TransactionStmt::FieldModelPtr_pg_query_TransactionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_TransactionStmt::~FieldModelPtr_pg_query_TransactionStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_TransactionStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_TransactionStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_TransactionStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_TransactionStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TransactionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TransactionStmt::get(::pg_query::TransactionStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_TransactionStmt(_buffer, 0);

    ::pg_query::TransactionStmt *tempModel = new ::pg_query::TransactionStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_TransactionStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TransactionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TransactionStmt::set(const ::pg_query::TransactionStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_TransactionStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_TransactionStmt::FieldModel_pg_query_TransactionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , options(buffer, kind.fbe_offset() + kind.fbe_size())
    , savepoint_name(buffer, options.fbe_offset() + options.fbe_size())
    , gid(buffer, savepoint_name.fbe_offset() + savepoint_name.fbe_size())
    , chain(buffer, gid.fbe_offset() + gid.fbe_size())
{}

size_t FieldModel_pg_query_TransactionStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + options.fbe_size()
        + savepoint_name.fbe_size()
        + gid.fbe_size()
        + chain.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_TransactionStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + options.fbe_extra()
        + savepoint_name.fbe_extra()
        + gid.fbe_extra()
        + chain.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_TransactionStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_TransactionStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + savepoint_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!savepoint_name.verify())
        return false;
    fbe_current_size += savepoint_name.fbe_size();

    if ((fbe_current_size + gid.fbe_size()) > fbe_struct_size)
        return true;
    if (!gid.verify())
        return false;
    fbe_current_size += gid.fbe_size();

    if ((fbe_current_size + chain.fbe_size()) > fbe_struct_size)
        return true;
    if (!chain.verify())
        return false;
    fbe_current_size += chain.fbe_size();

    return true;
}

size_t FieldModel_pg_query_TransactionStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TransactionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TransactionStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_TransactionStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::TransactionStmt& fbe_value = static_cast<::pg_query::TransactionStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::TransactionStmtKind();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + savepoint_name.fbe_size()) <= fbe_struct_size)
        {
            savepoint_name.get(fbe_value.savepoint_name);
        }
    else
        fbe_value.savepoint_name = "";
    fbe_current_size += savepoint_name.fbe_size();

    if ((fbe_current_size + gid.fbe_size()) <= fbe_struct_size)
        {
            gid.get(fbe_value.gid);
        }
    else
        fbe_value.gid = "";
    fbe_current_size += gid.fbe_size();

    if ((fbe_current_size + chain.fbe_size()) <= fbe_struct_size)
        {
            chain.get(fbe_value.chain);
        }
    else
        fbe_value.chain = false;
    fbe_current_size += chain.fbe_size();
}

size_t FieldModel_pg_query_TransactionStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TransactionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TransactionStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_TransactionStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::TransactionStmt& fbe_value = static_cast<const ::pg_query::TransactionStmt&>(base_fbe_value);
    kind.set(fbe_value.kind);
    options.set(fbe_value.options);
    savepoint_name.set(fbe_value.savepoint_name);
    gid.set(fbe_value.gid);
    chain.set(fbe_value.chain);
}

namespace pg_query {

bool TransactionStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TransactionStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TransactionStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TransactionStmtModel::serialize(const ::pg_query::TransactionStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TransactionStmtModel::deserialize(::pg_query::TransactionStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ViewStmt::FieldModelPtr_pg_query_ViewStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ViewStmt::~FieldModelPtr_pg_query_ViewStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ViewStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ViewStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ViewStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ViewStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ViewStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ViewStmt::get(::pg_query::ViewStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ViewStmt(_buffer, 0);

    ::pg_query::ViewStmt *tempModel = new ::pg_query::ViewStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ViewStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ViewStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ViewStmt::set(const ::pg_query::ViewStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ViewStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ViewStmt::FieldModel_pg_query_ViewStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , view(buffer, 4 + 4)
    , aliases(buffer, view.fbe_offset() + view.fbe_size())
    , query(buffer, aliases.fbe_offset() + aliases.fbe_size())
    , replace(buffer, query.fbe_offset() + query.fbe_size())
    , options(buffer, replace.fbe_offset() + replace.fbe_size())
    , with_check_option(buffer, options.fbe_offset() + options.fbe_size())
{}

size_t FieldModel_pg_query_ViewStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + view.fbe_size()
        + aliases.fbe_size()
        + query.fbe_size()
        + replace.fbe_size()
        + options.fbe_size()
        + with_check_option.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ViewStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + view.fbe_extra()
        + aliases.fbe_extra()
        + query.fbe_extra()
        + replace.fbe_extra()
        + options.fbe_extra()
        + with_check_option.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ViewStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ViewStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + view.fbe_size()) > fbe_struct_size)
        return true;
    if (!view.verify())
        return false;
    fbe_current_size += view.fbe_size();

    if ((fbe_current_size + aliases.fbe_size()) > fbe_struct_size)
        return true;
    if (!aliases.verify())
        return false;
    fbe_current_size += aliases.fbe_size();

    if ((fbe_current_size + query.fbe_size()) > fbe_struct_size)
        return true;
    if (!query.verify())
        return false;
    fbe_current_size += query.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) > fbe_struct_size)
        return true;
    if (!replace.verify())
        return false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + with_check_option.fbe_size()) > fbe_struct_size)
        return true;
    if (!with_check_option.verify())
        return false;
    fbe_current_size += with_check_option.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ViewStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ViewStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ViewStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ViewStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ViewStmt& fbe_value = static_cast<::pg_query::ViewStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + view.fbe_size()) <= fbe_struct_size)
        {
            view.get(&fbe_value.view);
        }
    else
        fbe_value.view = nullptr;
    fbe_current_size += view.fbe_size();

    if ((fbe_current_size + aliases.fbe_size()) <= fbe_struct_size)
        {
            aliases.get(fbe_value.aliases);
        }
    else
        fbe_value.aliases.clear();
    fbe_current_size += aliases.fbe_size();

    if ((fbe_current_size + query.fbe_size()) <= fbe_struct_size)
        {
            query.get(fbe_value.query);
        }
    else
        fbe_value.query = ::pg_query::Node();
    fbe_current_size += query.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) <= fbe_struct_size)
        {
            replace.get(fbe_value.replace);
        }
    else
        fbe_value.replace = false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + with_check_option.fbe_size()) <= fbe_struct_size)
        {
            with_check_option.get(fbe_value.with_check_option);
        }
    else
        fbe_value.with_check_option = ::pg_query::ViewCheckOption();
    fbe_current_size += with_check_option.fbe_size();
}

size_t FieldModel_pg_query_ViewStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ViewStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ViewStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ViewStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ViewStmt& fbe_value = static_cast<const ::pg_query::ViewStmt&>(base_fbe_value);
    view.set(fbe_value.view);
    aliases.set(fbe_value.aliases);
    query.set(fbe_value.query);
    replace.set(fbe_value.replace);
    options.set(fbe_value.options);
    with_check_option.set(fbe_value.with_check_option);
}

namespace pg_query {

bool ViewStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ViewStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ViewStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ViewStmtModel::serialize(const ::pg_query::ViewStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ViewStmtModel::deserialize(::pg_query::ViewStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_LoadStmt::FieldModelPtr_pg_query_LoadStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_LoadStmt::~FieldModelPtr_pg_query_LoadStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_LoadStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_LoadStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_LoadStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_LoadStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_LoadStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_LoadStmt::get(::pg_query::LoadStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_LoadStmt(_buffer, 0);

    ::pg_query::LoadStmt *tempModel = new ::pg_query::LoadStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_LoadStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_LoadStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_LoadStmt::set(const ::pg_query::LoadStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_LoadStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_LoadStmt::FieldModel_pg_query_LoadStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , filename(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_LoadStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + filename.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_LoadStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + filename.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_LoadStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_LoadStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + filename.fbe_size()) > fbe_struct_size)
        return true;
    if (!filename.verify())
        return false;
    fbe_current_size += filename.fbe_size();

    return true;
}

size_t FieldModel_pg_query_LoadStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_LoadStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_LoadStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_LoadStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::LoadStmt& fbe_value = static_cast<::pg_query::LoadStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + filename.fbe_size()) <= fbe_struct_size)
        {
            filename.get(fbe_value.filename);
        }
    else
        fbe_value.filename = "";
    fbe_current_size += filename.fbe_size();
}

size_t FieldModel_pg_query_LoadStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_LoadStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_LoadStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_LoadStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::LoadStmt& fbe_value = static_cast<const ::pg_query::LoadStmt&>(base_fbe_value);
    filename.set(fbe_value.filename);
}

namespace pg_query {

bool LoadStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t LoadStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t LoadStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t LoadStmtModel::serialize(const ::pg_query::LoadStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t LoadStmtModel::deserialize(::pg_query::LoadStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateDomainStmt::FieldModelPtr_pg_query_CreateDomainStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateDomainStmt::~FieldModelPtr_pg_query_CreateDomainStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateDomainStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateDomainStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateDomainStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateDomainStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateDomainStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateDomainStmt::get(::pg_query::CreateDomainStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateDomainStmt(_buffer, 0);

    ::pg_query::CreateDomainStmt *tempModel = new ::pg_query::CreateDomainStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateDomainStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateDomainStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateDomainStmt::set(const ::pg_query::CreateDomainStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateDomainStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateDomainStmt::FieldModel_pg_query_CreateDomainStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , domainname(buffer, 4 + 4)
    , type_name(buffer, domainname.fbe_offset() + domainname.fbe_size())
    , coll_clause(buffer, type_name.fbe_offset() + type_name.fbe_size())
    , constraints(buffer, coll_clause.fbe_offset() + coll_clause.fbe_size())
{}

size_t FieldModel_pg_query_CreateDomainStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + domainname.fbe_size()
        + type_name.fbe_size()
        + coll_clause.fbe_size()
        + constraints.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateDomainStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + domainname.fbe_extra()
        + type_name.fbe_extra()
        + coll_clause.fbe_extra()
        + constraints.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateDomainStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateDomainStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + domainname.fbe_size()) > fbe_struct_size)
        return true;
    if (!domainname.verify())
        return false;
    fbe_current_size += domainname.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + coll_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!coll_clause.verify())
        return false;
    fbe_current_size += coll_clause.fbe_size();

    if ((fbe_current_size + constraints.fbe_size()) > fbe_struct_size)
        return true;
    if (!constraints.verify())
        return false;
    fbe_current_size += constraints.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateDomainStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateDomainStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateDomainStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateDomainStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateDomainStmt& fbe_value = static_cast<::pg_query::CreateDomainStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + domainname.fbe_size()) <= fbe_struct_size)
        {
            domainname.get(fbe_value.domainname);
        }
    else
        fbe_value.domainname.clear();
    fbe_current_size += domainname.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(&fbe_value.type_name);
        }
    else
        fbe_value.type_name = nullptr;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + coll_clause.fbe_size()) <= fbe_struct_size)
        {
            coll_clause.get(&fbe_value.coll_clause);
        }
    else
        fbe_value.coll_clause = nullptr;
    fbe_current_size += coll_clause.fbe_size();

    if ((fbe_current_size + constraints.fbe_size()) <= fbe_struct_size)
        {
            constraints.get(fbe_value.constraints);
        }
    else
        fbe_value.constraints.clear();
    fbe_current_size += constraints.fbe_size();
}

size_t FieldModel_pg_query_CreateDomainStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateDomainStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateDomainStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateDomainStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateDomainStmt& fbe_value = static_cast<const ::pg_query::CreateDomainStmt&>(base_fbe_value);
    domainname.set(fbe_value.domainname);
    type_name.set(fbe_value.type_name);
    coll_clause.set(fbe_value.coll_clause);
    constraints.set(fbe_value.constraints);
}

namespace pg_query {

bool CreateDomainStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateDomainStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateDomainStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateDomainStmtModel::serialize(const ::pg_query::CreateDomainStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateDomainStmtModel::deserialize(::pg_query::CreateDomainStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreatedbStmt::FieldModelPtr_pg_query_CreatedbStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreatedbStmt::~FieldModelPtr_pg_query_CreatedbStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreatedbStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreatedbStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreatedbStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreatedbStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreatedbStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreatedbStmt::get(::pg_query::CreatedbStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreatedbStmt(_buffer, 0);

    ::pg_query::CreatedbStmt *tempModel = new ::pg_query::CreatedbStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreatedbStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreatedbStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreatedbStmt::set(const ::pg_query::CreatedbStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreatedbStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreatedbStmt::FieldModel_pg_query_CreatedbStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , dbname(buffer, 4 + 4)
    , options(buffer, dbname.fbe_offset() + dbname.fbe_size())
{}

size_t FieldModel_pg_query_CreatedbStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + dbname.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreatedbStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + dbname.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreatedbStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreatedbStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dbname.fbe_size()) > fbe_struct_size)
        return true;
    if (!dbname.verify())
        return false;
    fbe_current_size += dbname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreatedbStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreatedbStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreatedbStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreatedbStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreatedbStmt& fbe_value = static_cast<::pg_query::CreatedbStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dbname.fbe_size()) <= fbe_struct_size)
        {
            dbname.get(fbe_value.dbname);
        }
    else
        fbe_value.dbname = "";
    fbe_current_size += dbname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreatedbStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreatedbStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreatedbStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreatedbStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreatedbStmt& fbe_value = static_cast<const ::pg_query::CreatedbStmt&>(base_fbe_value);
    dbname.set(fbe_value.dbname);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreatedbStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreatedbStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreatedbStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreatedbStmtModel::serialize(const ::pg_query::CreatedbStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreatedbStmtModel::deserialize(::pg_query::CreatedbStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DropdbStmt::FieldModelPtr_pg_query_DropdbStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DropdbStmt::~FieldModelPtr_pg_query_DropdbStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DropdbStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DropdbStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DropdbStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DropdbStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropdbStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropdbStmt::get(::pg_query::DropdbStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DropdbStmt(_buffer, 0);

    ::pg_query::DropdbStmt *tempModel = new ::pg_query::DropdbStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DropdbStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropdbStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropdbStmt::set(const ::pg_query::DropdbStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DropdbStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DropdbStmt::FieldModel_pg_query_DropdbStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , dbname(buffer, 4 + 4)
    , missing_ok(buffer, dbname.fbe_offset() + dbname.fbe_size())
    , options(buffer, missing_ok.fbe_offset() + missing_ok.fbe_size())
{}

size_t FieldModel_pg_query_DropdbStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + dbname.fbe_size()
        + missing_ok.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DropdbStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + dbname.fbe_extra()
        + missing_ok.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DropdbStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DropdbStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dbname.fbe_size()) > fbe_struct_size)
        return true;
    if (!dbname.verify())
        return false;
    fbe_current_size += dbname.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DropdbStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropdbStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropdbStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DropdbStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DropdbStmt& fbe_value = static_cast<::pg_query::DropdbStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dbname.fbe_size()) <= fbe_struct_size)
        {
            dbname.get(fbe_value.dbname);
        }
    else
        fbe_value.dbname = "";
    fbe_current_size += dbname.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_DropdbStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropdbStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropdbStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DropdbStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DropdbStmt& fbe_value = static_cast<const ::pg_query::DropdbStmt&>(base_fbe_value);
    dbname.set(fbe_value.dbname);
    missing_ok.set(fbe_value.missing_ok);
    options.set(fbe_value.options);
}

namespace pg_query {

bool DropdbStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DropdbStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DropdbStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DropdbStmtModel::serialize(const ::pg_query::DropdbStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DropdbStmtModel::deserialize(::pg_query::DropdbStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_VacuumStmt::FieldModelPtr_pg_query_VacuumStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_VacuumStmt::~FieldModelPtr_pg_query_VacuumStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_VacuumStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_VacuumStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_VacuumStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_VacuumStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_VacuumStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_VacuumStmt::get(::pg_query::VacuumStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_VacuumStmt(_buffer, 0);

    ::pg_query::VacuumStmt *tempModel = new ::pg_query::VacuumStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_VacuumStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_VacuumStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_VacuumStmt::set(const ::pg_query::VacuumStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_VacuumStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_VacuumStmt::FieldModel_pg_query_VacuumStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , options(buffer, 4 + 4)
    , rels(buffer, options.fbe_offset() + options.fbe_size())
    , is_vacuumcmd(buffer, rels.fbe_offset() + rels.fbe_size())
{}

size_t FieldModel_pg_query_VacuumStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + options.fbe_size()
        + rels.fbe_size()
        + is_vacuumcmd.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_VacuumStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + options.fbe_extra()
        + rels.fbe_extra()
        + is_vacuumcmd.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_VacuumStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_VacuumStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + rels.fbe_size()) > fbe_struct_size)
        return true;
    if (!rels.verify())
        return false;
    fbe_current_size += rels.fbe_size();

    if ((fbe_current_size + is_vacuumcmd.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_vacuumcmd.verify())
        return false;
    fbe_current_size += is_vacuumcmd.fbe_size();

    return true;
}

size_t FieldModel_pg_query_VacuumStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_VacuumStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_VacuumStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_VacuumStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::VacuumStmt& fbe_value = static_cast<::pg_query::VacuumStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + rels.fbe_size()) <= fbe_struct_size)
        {
            rels.get(fbe_value.rels);
        }
    else
        fbe_value.rels.clear();
    fbe_current_size += rels.fbe_size();

    if ((fbe_current_size + is_vacuumcmd.fbe_size()) <= fbe_struct_size)
        {
            is_vacuumcmd.get(fbe_value.is_vacuumcmd);
        }
    else
        fbe_value.is_vacuumcmd = false;
    fbe_current_size += is_vacuumcmd.fbe_size();
}

size_t FieldModel_pg_query_VacuumStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_VacuumStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_VacuumStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_VacuumStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::VacuumStmt& fbe_value = static_cast<const ::pg_query::VacuumStmt&>(base_fbe_value);
    options.set(fbe_value.options);
    rels.set(fbe_value.rels);
    is_vacuumcmd.set(fbe_value.is_vacuumcmd);
}

namespace pg_query {

bool VacuumStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t VacuumStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t VacuumStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t VacuumStmtModel::serialize(const ::pg_query::VacuumStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t VacuumStmtModel::deserialize(::pg_query::VacuumStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ExplainStmt::FieldModelPtr_pg_query_ExplainStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ExplainStmt::~FieldModelPtr_pg_query_ExplainStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ExplainStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ExplainStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ExplainStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ExplainStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ExplainStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ExplainStmt::get(::pg_query::ExplainStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ExplainStmt(_buffer, 0);

    ::pg_query::ExplainStmt *tempModel = new ::pg_query::ExplainStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ExplainStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ExplainStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ExplainStmt::set(const ::pg_query::ExplainStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ExplainStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ExplainStmt::FieldModel_pg_query_ExplainStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , query(buffer, 4 + 4)
    , options(buffer, query.fbe_offset() + query.fbe_size())
{}

size_t FieldModel_pg_query_ExplainStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + query.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ExplainStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + query.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ExplainStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ExplainStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + query.fbe_size()) > fbe_struct_size)
        return true;
    if (!query.verify())
        return false;
    fbe_current_size += query.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ExplainStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ExplainStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ExplainStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ExplainStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ExplainStmt& fbe_value = static_cast<::pg_query::ExplainStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + query.fbe_size()) <= fbe_struct_size)
        {
            query.get(fbe_value.query);
        }
    else
        fbe_value.query = ::pg_query::Node();
    fbe_current_size += query.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_ExplainStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ExplainStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ExplainStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ExplainStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ExplainStmt& fbe_value = static_cast<const ::pg_query::ExplainStmt&>(base_fbe_value);
    query.set(fbe_value.query);
    options.set(fbe_value.options);
}

namespace pg_query {

bool ExplainStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ExplainStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ExplainStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ExplainStmtModel::serialize(const ::pg_query::ExplainStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ExplainStmtModel::deserialize(::pg_query::ExplainStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateTableAsStmt::FieldModelPtr_pg_query_CreateTableAsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateTableAsStmt::~FieldModelPtr_pg_query_CreateTableAsStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateTableAsStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateTableAsStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateTableAsStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateTableAsStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateTableAsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateTableAsStmt::get(::pg_query::CreateTableAsStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateTableAsStmt(_buffer, 0);

    ::pg_query::CreateTableAsStmt *tempModel = new ::pg_query::CreateTableAsStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateTableAsStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateTableAsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateTableAsStmt::set(const ::pg_query::CreateTableAsStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateTableAsStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateTableAsStmt::FieldModel_pg_query_CreateTableAsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , query(buffer, 4 + 4)
    , into(buffer, query.fbe_offset() + query.fbe_size())
    , relkind(buffer, into.fbe_offset() + into.fbe_size())
    , is_select_into(buffer, relkind.fbe_offset() + relkind.fbe_size())
    , if_not_exists(buffer, is_select_into.fbe_offset() + is_select_into.fbe_size())
{}

size_t FieldModel_pg_query_CreateTableAsStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + query.fbe_size()
        + into.fbe_size()
        + relkind.fbe_size()
        + is_select_into.fbe_size()
        + if_not_exists.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateTableAsStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + query.fbe_extra()
        + into.fbe_extra()
        + relkind.fbe_extra()
        + is_select_into.fbe_extra()
        + if_not_exists.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateTableAsStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateTableAsStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + query.fbe_size()) > fbe_struct_size)
        return true;
    if (!query.verify())
        return false;
    fbe_current_size += query.fbe_size();

    if ((fbe_current_size + into.fbe_size()) > fbe_struct_size)
        return true;
    if (!into.verify())
        return false;
    fbe_current_size += into.fbe_size();

    if ((fbe_current_size + relkind.fbe_size()) > fbe_struct_size)
        return true;
    if (!relkind.verify())
        return false;
    fbe_current_size += relkind.fbe_size();

    if ((fbe_current_size + is_select_into.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_select_into.verify())
        return false;
    fbe_current_size += is_select_into.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateTableAsStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateTableAsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateTableAsStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateTableAsStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateTableAsStmt& fbe_value = static_cast<::pg_query::CreateTableAsStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + query.fbe_size()) <= fbe_struct_size)
        {
            query.get(fbe_value.query);
        }
    else
        fbe_value.query = ::pg_query::Node();
    fbe_current_size += query.fbe_size();

    if ((fbe_current_size + into.fbe_size()) <= fbe_struct_size)
        {
            into.get(&fbe_value.into);
        }
    else
        fbe_value.into = nullptr;
    fbe_current_size += into.fbe_size();

    if ((fbe_current_size + relkind.fbe_size()) <= fbe_struct_size)
        {
            relkind.get(fbe_value.relkind);
        }
    else
        fbe_value.relkind = ::pg_query::ObjectType();
    fbe_current_size += relkind.fbe_size();

    if ((fbe_current_size + is_select_into.fbe_size()) <= fbe_struct_size)
        {
            is_select_into.get(fbe_value.is_select_into);
        }
    else
        fbe_value.is_select_into = false;
    fbe_current_size += is_select_into.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();
}

size_t FieldModel_pg_query_CreateTableAsStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateTableAsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateTableAsStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateTableAsStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateTableAsStmt& fbe_value = static_cast<const ::pg_query::CreateTableAsStmt&>(base_fbe_value);
    query.set(fbe_value.query);
    into.set(fbe_value.into);
    relkind.set(fbe_value.relkind);
    is_select_into.set(fbe_value.is_select_into);
    if_not_exists.set(fbe_value.if_not_exists);
}

namespace pg_query {

bool CreateTableAsStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateTableAsStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateTableAsStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateTableAsStmtModel::serialize(const ::pg_query::CreateTableAsStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateTableAsStmtModel::deserialize(::pg_query::CreateTableAsStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateSeqStmt::FieldModelPtr_pg_query_CreateSeqStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateSeqStmt::~FieldModelPtr_pg_query_CreateSeqStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateSeqStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateSeqStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateSeqStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateSeqStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateSeqStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateSeqStmt::get(::pg_query::CreateSeqStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateSeqStmt(_buffer, 0);

    ::pg_query::CreateSeqStmt *tempModel = new ::pg_query::CreateSeqStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateSeqStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateSeqStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateSeqStmt::set(const ::pg_query::CreateSeqStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateSeqStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateSeqStmt::FieldModel_pg_query_CreateSeqStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , sequence(buffer, 4 + 4)
    , options(buffer, sequence.fbe_offset() + sequence.fbe_size())
    , owner_id(buffer, options.fbe_offset() + options.fbe_size())
    , for_identity(buffer, owner_id.fbe_offset() + owner_id.fbe_size())
    , if_not_exists(buffer, for_identity.fbe_offset() + for_identity.fbe_size())
{}

size_t FieldModel_pg_query_CreateSeqStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + sequence.fbe_size()
        + options.fbe_size()
        + owner_id.fbe_size()
        + for_identity.fbe_size()
        + if_not_exists.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateSeqStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + sequence.fbe_extra()
        + options.fbe_extra()
        + owner_id.fbe_extra()
        + for_identity.fbe_extra()
        + if_not_exists.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateSeqStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateSeqStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + sequence.fbe_size()) > fbe_struct_size)
        return true;
    if (!sequence.verify())
        return false;
    fbe_current_size += sequence.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + owner_id.fbe_size()) > fbe_struct_size)
        return true;
    if (!owner_id.verify())
        return false;
    fbe_current_size += owner_id.fbe_size();

    if ((fbe_current_size + for_identity.fbe_size()) > fbe_struct_size)
        return true;
    if (!for_identity.verify())
        return false;
    fbe_current_size += for_identity.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateSeqStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateSeqStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateSeqStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateSeqStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateSeqStmt& fbe_value = static_cast<::pg_query::CreateSeqStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + sequence.fbe_size()) <= fbe_struct_size)
        {
            sequence.get(&fbe_value.sequence);
        }
    else
        fbe_value.sequence = nullptr;
    fbe_current_size += sequence.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + owner_id.fbe_size()) <= fbe_struct_size)
        {
            owner_id.get(fbe_value.owner_id);
        }
    else
        fbe_value.owner_id = (uint32_t)0ull;
    fbe_current_size += owner_id.fbe_size();

    if ((fbe_current_size + for_identity.fbe_size()) <= fbe_struct_size)
        {
            for_identity.get(fbe_value.for_identity);
        }
    else
        fbe_value.for_identity = false;
    fbe_current_size += for_identity.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();
}

size_t FieldModel_pg_query_CreateSeqStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateSeqStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateSeqStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateSeqStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateSeqStmt& fbe_value = static_cast<const ::pg_query::CreateSeqStmt&>(base_fbe_value);
    sequence.set(fbe_value.sequence);
    options.set(fbe_value.options);
    owner_id.set(fbe_value.owner_id);
    for_identity.set(fbe_value.for_identity);
    if_not_exists.set(fbe_value.if_not_exists);
}

namespace pg_query {

bool CreateSeqStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateSeqStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateSeqStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateSeqStmtModel::serialize(const ::pg_query::CreateSeqStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateSeqStmtModel::deserialize(::pg_query::CreateSeqStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterSeqStmt::FieldModelPtr_pg_query_AlterSeqStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterSeqStmt::~FieldModelPtr_pg_query_AlterSeqStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterSeqStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterSeqStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterSeqStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterSeqStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterSeqStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterSeqStmt::get(::pg_query::AlterSeqStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterSeqStmt(_buffer, 0);

    ::pg_query::AlterSeqStmt *tempModel = new ::pg_query::AlterSeqStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterSeqStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterSeqStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterSeqStmt::set(const ::pg_query::AlterSeqStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterSeqStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterSeqStmt::FieldModel_pg_query_AlterSeqStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , sequence(buffer, 4 + 4)
    , options(buffer, sequence.fbe_offset() + sequence.fbe_size())
    , for_identity(buffer, options.fbe_offset() + options.fbe_size())
    , missing_ok(buffer, for_identity.fbe_offset() + for_identity.fbe_size())
{}

size_t FieldModel_pg_query_AlterSeqStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + sequence.fbe_size()
        + options.fbe_size()
        + for_identity.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterSeqStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + sequence.fbe_extra()
        + options.fbe_extra()
        + for_identity.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterSeqStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterSeqStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + sequence.fbe_size()) > fbe_struct_size)
        return true;
    if (!sequence.verify())
        return false;
    fbe_current_size += sequence.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + for_identity.fbe_size()) > fbe_struct_size)
        return true;
    if (!for_identity.verify())
        return false;
    fbe_current_size += for_identity.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterSeqStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterSeqStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterSeqStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterSeqStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterSeqStmt& fbe_value = static_cast<::pg_query::AlterSeqStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + sequence.fbe_size()) <= fbe_struct_size)
        {
            sequence.get(&fbe_value.sequence);
        }
    else
        fbe_value.sequence = nullptr;
    fbe_current_size += sequence.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + for_identity.fbe_size()) <= fbe_struct_size)
        {
            for_identity.get(fbe_value.for_identity);
        }
    else
        fbe_value.for_identity = false;
    fbe_current_size += for_identity.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_AlterSeqStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterSeqStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterSeqStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterSeqStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterSeqStmt& fbe_value = static_cast<const ::pg_query::AlterSeqStmt&>(base_fbe_value);
    sequence.set(fbe_value.sequence);
    options.set(fbe_value.options);
    for_identity.set(fbe_value.for_identity);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool AlterSeqStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterSeqStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterSeqStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterSeqStmtModel::serialize(const ::pg_query::AlterSeqStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterSeqStmtModel::deserialize(::pg_query::AlterSeqStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_VariableSetStmt::FieldModelPtr_pg_query_VariableSetStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_VariableSetStmt::~FieldModelPtr_pg_query_VariableSetStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_VariableSetStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_VariableSetStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_VariableSetStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_VariableSetStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_VariableSetStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_VariableSetStmt::get(::pg_query::VariableSetStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_VariableSetStmt(_buffer, 0);

    ::pg_query::VariableSetStmt *tempModel = new ::pg_query::VariableSetStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_VariableSetStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_VariableSetStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_VariableSetStmt::set(const ::pg_query::VariableSetStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_VariableSetStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_VariableSetStmt::FieldModel_pg_query_VariableSetStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , name(buffer, kind.fbe_offset() + kind.fbe_size())
    , args(buffer, name.fbe_offset() + name.fbe_size())
    , is_local(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_VariableSetStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + name.fbe_size()
        + args.fbe_size()
        + is_local.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_VariableSetStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + name.fbe_extra()
        + args.fbe_extra()
        + is_local.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_VariableSetStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_VariableSetStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + is_local.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_local.verify())
        return false;
    fbe_current_size += is_local.fbe_size();

    return true;
}

size_t FieldModel_pg_query_VariableSetStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_VariableSetStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_VariableSetStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_VariableSetStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::VariableSetStmt& fbe_value = static_cast<::pg_query::VariableSetStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::VariableSetKind();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + is_local.fbe_size()) <= fbe_struct_size)
        {
            is_local.get(fbe_value.is_local);
        }
    else
        fbe_value.is_local = false;
    fbe_current_size += is_local.fbe_size();
}

size_t FieldModel_pg_query_VariableSetStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_VariableSetStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_VariableSetStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_VariableSetStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::VariableSetStmt& fbe_value = static_cast<const ::pg_query::VariableSetStmt&>(base_fbe_value);
    kind.set(fbe_value.kind);
    name.set(fbe_value.name);
    args.set(fbe_value.args);
    is_local.set(fbe_value.is_local);
}

namespace pg_query {

bool VariableSetStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t VariableSetStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t VariableSetStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t VariableSetStmtModel::serialize(const ::pg_query::VariableSetStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t VariableSetStmtModel::deserialize(::pg_query::VariableSetStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_VariableShowStmt::FieldModelPtr_pg_query_VariableShowStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_VariableShowStmt::~FieldModelPtr_pg_query_VariableShowStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_VariableShowStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_VariableShowStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_VariableShowStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_VariableShowStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_VariableShowStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_VariableShowStmt::get(::pg_query::VariableShowStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_VariableShowStmt(_buffer, 0);

    ::pg_query::VariableShowStmt *tempModel = new ::pg_query::VariableShowStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_VariableShowStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_VariableShowStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_VariableShowStmt::set(const ::pg_query::VariableShowStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_VariableShowStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_VariableShowStmt::FieldModel_pg_query_VariableShowStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_VariableShowStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_VariableShowStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_VariableShowStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_VariableShowStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    return true;
}

size_t FieldModel_pg_query_VariableShowStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_VariableShowStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_VariableShowStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_VariableShowStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::VariableShowStmt& fbe_value = static_cast<::pg_query::VariableShowStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();
}

size_t FieldModel_pg_query_VariableShowStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_VariableShowStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_VariableShowStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_VariableShowStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::VariableShowStmt& fbe_value = static_cast<const ::pg_query::VariableShowStmt&>(base_fbe_value);
    name.set(fbe_value.name);
}

namespace pg_query {

bool VariableShowStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t VariableShowStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t VariableShowStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t VariableShowStmtModel::serialize(const ::pg_query::VariableShowStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t VariableShowStmtModel::deserialize(::pg_query::VariableShowStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DiscardStmt::FieldModelPtr_pg_query_DiscardStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DiscardStmt::~FieldModelPtr_pg_query_DiscardStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DiscardStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DiscardStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DiscardStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DiscardStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DiscardStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DiscardStmt::get(::pg_query::DiscardStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DiscardStmt(_buffer, 0);

    ::pg_query::DiscardStmt *tempModel = new ::pg_query::DiscardStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DiscardStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DiscardStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DiscardStmt::set(const ::pg_query::DiscardStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DiscardStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DiscardStmt::FieldModel_pg_query_DiscardStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , target(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_DiscardStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + target.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DiscardStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + target.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DiscardStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DiscardStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + target.fbe_size()) > fbe_struct_size)
        return true;
    if (!target.verify())
        return false;
    fbe_current_size += target.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DiscardStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DiscardStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DiscardStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DiscardStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DiscardStmt& fbe_value = static_cast<::pg_query::DiscardStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + target.fbe_size()) <= fbe_struct_size)
        {
            target.get(fbe_value.target);
        }
    else
        fbe_value.target = ::pg_query::DiscardMode();
    fbe_current_size += target.fbe_size();
}

size_t FieldModel_pg_query_DiscardStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DiscardStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DiscardStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DiscardStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DiscardStmt& fbe_value = static_cast<const ::pg_query::DiscardStmt&>(base_fbe_value);
    target.set(fbe_value.target);
}

namespace pg_query {

bool DiscardStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DiscardStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DiscardStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DiscardStmtModel::serialize(const ::pg_query::DiscardStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DiscardStmtModel::deserialize(::pg_query::DiscardStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateTrigStmt::FieldModelPtr_pg_query_CreateTrigStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateTrigStmt::~FieldModelPtr_pg_query_CreateTrigStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateTrigStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateTrigStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateTrigStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateTrigStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateTrigStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateTrigStmt::get(::pg_query::CreateTrigStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateTrigStmt(_buffer, 0);

    ::pg_query::CreateTrigStmt *tempModel = new ::pg_query::CreateTrigStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateTrigStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateTrigStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateTrigStmt::set(const ::pg_query::CreateTrigStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateTrigStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateTrigStmt::FieldModel_pg_query_CreateTrigStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , trigname(buffer, 4 + 4)
    , relation(buffer, trigname.fbe_offset() + trigname.fbe_size())
    , funcname(buffer, relation.fbe_offset() + relation.fbe_size())
    , args(buffer, funcname.fbe_offset() + funcname.fbe_size())
    , row(buffer, args.fbe_offset() + args.fbe_size())
    , timing(buffer, row.fbe_offset() + row.fbe_size())
    , events(buffer, timing.fbe_offset() + timing.fbe_size())
    , columns(buffer, events.fbe_offset() + events.fbe_size())
    , when_clause(buffer, columns.fbe_offset() + columns.fbe_size())
    , isconstraint(buffer, when_clause.fbe_offset() + when_clause.fbe_size())
    , transition_rels(buffer, isconstraint.fbe_offset() + isconstraint.fbe_size())
    , deferrable(buffer, transition_rels.fbe_offset() + transition_rels.fbe_size())
    , initdeferred(buffer, deferrable.fbe_offset() + deferrable.fbe_size())
    , constrrel(buffer, initdeferred.fbe_offset() + initdeferred.fbe_size())
{}

size_t FieldModel_pg_query_CreateTrigStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + trigname.fbe_size()
        + relation.fbe_size()
        + funcname.fbe_size()
        + args.fbe_size()
        + row.fbe_size()
        + timing.fbe_size()
        + events.fbe_size()
        + columns.fbe_size()
        + when_clause.fbe_size()
        + isconstraint.fbe_size()
        + transition_rels.fbe_size()
        + deferrable.fbe_size()
        + initdeferred.fbe_size()
        + constrrel.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateTrigStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + trigname.fbe_extra()
        + relation.fbe_extra()
        + funcname.fbe_extra()
        + args.fbe_extra()
        + row.fbe_extra()
        + timing.fbe_extra()
        + events.fbe_extra()
        + columns.fbe_extra()
        + when_clause.fbe_extra()
        + isconstraint.fbe_extra()
        + transition_rels.fbe_extra()
        + deferrable.fbe_extra()
        + initdeferred.fbe_extra()
        + constrrel.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateTrigStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateTrigStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + trigname.fbe_size()) > fbe_struct_size)
        return true;
    if (!trigname.verify())
        return false;
    fbe_current_size += trigname.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + funcname.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcname.verify())
        return false;
    fbe_current_size += funcname.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + row.fbe_size()) > fbe_struct_size)
        return true;
    if (!row.verify())
        return false;
    fbe_current_size += row.fbe_size();

    if ((fbe_current_size + timing.fbe_size()) > fbe_struct_size)
        return true;
    if (!timing.verify())
        return false;
    fbe_current_size += timing.fbe_size();

    if ((fbe_current_size + events.fbe_size()) > fbe_struct_size)
        return true;
    if (!events.verify())
        return false;
    fbe_current_size += events.fbe_size();

    if ((fbe_current_size + columns.fbe_size()) > fbe_struct_size)
        return true;
    if (!columns.verify())
        return false;
    fbe_current_size += columns.fbe_size();

    if ((fbe_current_size + when_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!when_clause.verify())
        return false;
    fbe_current_size += when_clause.fbe_size();

    if ((fbe_current_size + isconstraint.fbe_size()) > fbe_struct_size)
        return true;
    if (!isconstraint.verify())
        return false;
    fbe_current_size += isconstraint.fbe_size();

    if ((fbe_current_size + transition_rels.fbe_size()) > fbe_struct_size)
        return true;
    if (!transition_rels.verify())
        return false;
    fbe_current_size += transition_rels.fbe_size();

    if ((fbe_current_size + deferrable.fbe_size()) > fbe_struct_size)
        return true;
    if (!deferrable.verify())
        return false;
    fbe_current_size += deferrable.fbe_size();

    if ((fbe_current_size + initdeferred.fbe_size()) > fbe_struct_size)
        return true;
    if (!initdeferred.verify())
        return false;
    fbe_current_size += initdeferred.fbe_size();

    if ((fbe_current_size + constrrel.fbe_size()) > fbe_struct_size)
        return true;
    if (!constrrel.verify())
        return false;
    fbe_current_size += constrrel.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateTrigStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateTrigStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateTrigStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateTrigStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateTrigStmt& fbe_value = static_cast<::pg_query::CreateTrigStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + trigname.fbe_size()) <= fbe_struct_size)
        {
            trigname.get(fbe_value.trigname);
        }
    else
        fbe_value.trigname = "";
    fbe_current_size += trigname.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + funcname.fbe_size()) <= fbe_struct_size)
        {
            funcname.get(fbe_value.funcname);
        }
    else
        fbe_value.funcname.clear();
    fbe_current_size += funcname.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + row.fbe_size()) <= fbe_struct_size)
        {
            row.get(fbe_value.row);
        }
    else
        fbe_value.row = false;
    fbe_current_size += row.fbe_size();

    if ((fbe_current_size + timing.fbe_size()) <= fbe_struct_size)
        {
            timing.get(fbe_value.timing);
        }
    else
        fbe_value.timing = (int32_t)0ll;
    fbe_current_size += timing.fbe_size();

    if ((fbe_current_size + events.fbe_size()) <= fbe_struct_size)
        {
            events.get(fbe_value.events);
        }
    else
        fbe_value.events = (int32_t)0ll;
    fbe_current_size += events.fbe_size();

    if ((fbe_current_size + columns.fbe_size()) <= fbe_struct_size)
        {
            columns.get(fbe_value.columns);
        }
    else
        fbe_value.columns.clear();
    fbe_current_size += columns.fbe_size();

    if ((fbe_current_size + when_clause.fbe_size()) <= fbe_struct_size)
        {
            when_clause.get(fbe_value.when_clause);
        }
    else
        fbe_value.when_clause = ::pg_query::Node();
    fbe_current_size += when_clause.fbe_size();

    if ((fbe_current_size + isconstraint.fbe_size()) <= fbe_struct_size)
        {
            isconstraint.get(fbe_value.isconstraint);
        }
    else
        fbe_value.isconstraint = false;
    fbe_current_size += isconstraint.fbe_size();

    if ((fbe_current_size + transition_rels.fbe_size()) <= fbe_struct_size)
        {
            transition_rels.get(fbe_value.transition_rels);
        }
    else
        fbe_value.transition_rels.clear();
    fbe_current_size += transition_rels.fbe_size();

    if ((fbe_current_size + deferrable.fbe_size()) <= fbe_struct_size)
        {
            deferrable.get(fbe_value.deferrable);
        }
    else
        fbe_value.deferrable = false;
    fbe_current_size += deferrable.fbe_size();

    if ((fbe_current_size + initdeferred.fbe_size()) <= fbe_struct_size)
        {
            initdeferred.get(fbe_value.initdeferred);
        }
    else
        fbe_value.initdeferred = false;
    fbe_current_size += initdeferred.fbe_size();

    if ((fbe_current_size + constrrel.fbe_size()) <= fbe_struct_size)
        {
            constrrel.get(&fbe_value.constrrel);
        }
    else
        fbe_value.constrrel = nullptr;
    fbe_current_size += constrrel.fbe_size();
}

size_t FieldModel_pg_query_CreateTrigStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateTrigStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateTrigStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateTrigStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateTrigStmt& fbe_value = static_cast<const ::pg_query::CreateTrigStmt&>(base_fbe_value);
    trigname.set(fbe_value.trigname);
    relation.set(fbe_value.relation);
    funcname.set(fbe_value.funcname);
    args.set(fbe_value.args);
    row.set(fbe_value.row);
    timing.set(fbe_value.timing);
    events.set(fbe_value.events);
    columns.set(fbe_value.columns);
    when_clause.set(fbe_value.when_clause);
    isconstraint.set(fbe_value.isconstraint);
    transition_rels.set(fbe_value.transition_rels);
    deferrable.set(fbe_value.deferrable);
    initdeferred.set(fbe_value.initdeferred);
    constrrel.set(fbe_value.constrrel);
}

namespace pg_query {

bool CreateTrigStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateTrigStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateTrigStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateTrigStmtModel::serialize(const ::pg_query::CreateTrigStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateTrigStmtModel::deserialize(::pg_query::CreateTrigStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreatePLangStmt::FieldModelPtr_pg_query_CreatePLangStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreatePLangStmt::~FieldModelPtr_pg_query_CreatePLangStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreatePLangStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreatePLangStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreatePLangStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreatePLangStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreatePLangStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreatePLangStmt::get(::pg_query::CreatePLangStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreatePLangStmt(_buffer, 0);

    ::pg_query::CreatePLangStmt *tempModel = new ::pg_query::CreatePLangStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreatePLangStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreatePLangStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreatePLangStmt::set(const ::pg_query::CreatePLangStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreatePLangStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreatePLangStmt::FieldModel_pg_query_CreatePLangStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , replace(buffer, 4 + 4)
    , plname(buffer, replace.fbe_offset() + replace.fbe_size())
    , plhandler(buffer, plname.fbe_offset() + plname.fbe_size())
    , plinline(buffer, plhandler.fbe_offset() + plhandler.fbe_size())
    , plvalidator(buffer, plinline.fbe_offset() + plinline.fbe_size())
    , pltrusted(buffer, plvalidator.fbe_offset() + plvalidator.fbe_size())
{}

size_t FieldModel_pg_query_CreatePLangStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + replace.fbe_size()
        + plname.fbe_size()
        + plhandler.fbe_size()
        + plinline.fbe_size()
        + plvalidator.fbe_size()
        + pltrusted.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreatePLangStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + replace.fbe_extra()
        + plname.fbe_extra()
        + plhandler.fbe_extra()
        + plinline.fbe_extra()
        + plvalidator.fbe_extra()
        + pltrusted.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreatePLangStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreatePLangStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + replace.fbe_size()) > fbe_struct_size)
        return true;
    if (!replace.verify())
        return false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + plname.fbe_size()) > fbe_struct_size)
        return true;
    if (!plname.verify())
        return false;
    fbe_current_size += plname.fbe_size();

    if ((fbe_current_size + plhandler.fbe_size()) > fbe_struct_size)
        return true;
    if (!plhandler.verify())
        return false;
    fbe_current_size += plhandler.fbe_size();

    if ((fbe_current_size + plinline.fbe_size()) > fbe_struct_size)
        return true;
    if (!plinline.verify())
        return false;
    fbe_current_size += plinline.fbe_size();

    if ((fbe_current_size + plvalidator.fbe_size()) > fbe_struct_size)
        return true;
    if (!plvalidator.verify())
        return false;
    fbe_current_size += plvalidator.fbe_size();

    if ((fbe_current_size + pltrusted.fbe_size()) > fbe_struct_size)
        return true;
    if (!pltrusted.verify())
        return false;
    fbe_current_size += pltrusted.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreatePLangStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreatePLangStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreatePLangStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreatePLangStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreatePLangStmt& fbe_value = static_cast<::pg_query::CreatePLangStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + replace.fbe_size()) <= fbe_struct_size)
        {
            replace.get(fbe_value.replace);
        }
    else
        fbe_value.replace = false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + plname.fbe_size()) <= fbe_struct_size)
        {
            plname.get(fbe_value.plname);
        }
    else
        fbe_value.plname = "";
    fbe_current_size += plname.fbe_size();

    if ((fbe_current_size + plhandler.fbe_size()) <= fbe_struct_size)
        {
            plhandler.get(fbe_value.plhandler);
        }
    else
        fbe_value.plhandler.clear();
    fbe_current_size += plhandler.fbe_size();

    if ((fbe_current_size + plinline.fbe_size()) <= fbe_struct_size)
        {
            plinline.get(fbe_value.plinline);
        }
    else
        fbe_value.plinline.clear();
    fbe_current_size += plinline.fbe_size();

    if ((fbe_current_size + plvalidator.fbe_size()) <= fbe_struct_size)
        {
            plvalidator.get(fbe_value.plvalidator);
        }
    else
        fbe_value.plvalidator.clear();
    fbe_current_size += plvalidator.fbe_size();

    if ((fbe_current_size + pltrusted.fbe_size()) <= fbe_struct_size)
        {
            pltrusted.get(fbe_value.pltrusted);
        }
    else
        fbe_value.pltrusted = false;
    fbe_current_size += pltrusted.fbe_size();
}

size_t FieldModel_pg_query_CreatePLangStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreatePLangStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreatePLangStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreatePLangStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreatePLangStmt& fbe_value = static_cast<const ::pg_query::CreatePLangStmt&>(base_fbe_value);
    replace.set(fbe_value.replace);
    plname.set(fbe_value.plname);
    plhandler.set(fbe_value.plhandler);
    plinline.set(fbe_value.plinline);
    plvalidator.set(fbe_value.plvalidator);
    pltrusted.set(fbe_value.pltrusted);
}

namespace pg_query {

bool CreatePLangStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreatePLangStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreatePLangStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreatePLangStmtModel::serialize(const ::pg_query::CreatePLangStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreatePLangStmtModel::deserialize(::pg_query::CreatePLangStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateRoleStmt::FieldModelPtr_pg_query_CreateRoleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateRoleStmt::~FieldModelPtr_pg_query_CreateRoleStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateRoleStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateRoleStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateRoleStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateRoleStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateRoleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateRoleStmt::get(::pg_query::CreateRoleStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateRoleStmt(_buffer, 0);

    ::pg_query::CreateRoleStmt *tempModel = new ::pg_query::CreateRoleStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateRoleStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateRoleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateRoleStmt::set(const ::pg_query::CreateRoleStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateRoleStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateRoleStmt::FieldModel_pg_query_CreateRoleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , stmt_type(buffer, 4 + 4)
    , role(buffer, stmt_type.fbe_offset() + stmt_type.fbe_size())
    , options(buffer, role.fbe_offset() + role.fbe_size())
{}

size_t FieldModel_pg_query_CreateRoleStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + stmt_type.fbe_size()
        + role.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateRoleStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + stmt_type.fbe_extra()
        + role.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateRoleStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateRoleStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + stmt_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!stmt_type.verify())
        return false;
    fbe_current_size += stmt_type.fbe_size();

    if ((fbe_current_size + role.fbe_size()) > fbe_struct_size)
        return true;
    if (!role.verify())
        return false;
    fbe_current_size += role.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateRoleStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateRoleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateRoleStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateRoleStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateRoleStmt& fbe_value = static_cast<::pg_query::CreateRoleStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + stmt_type.fbe_size()) <= fbe_struct_size)
        {
            stmt_type.get(fbe_value.stmt_type);
        }
    else
        fbe_value.stmt_type = ::pg_query::RoleStmtType();
    fbe_current_size += stmt_type.fbe_size();

    if ((fbe_current_size + role.fbe_size()) <= fbe_struct_size)
        {
            role.get(fbe_value.role);
        }
    else
        fbe_value.role = "";
    fbe_current_size += role.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreateRoleStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateRoleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateRoleStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateRoleStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateRoleStmt& fbe_value = static_cast<const ::pg_query::CreateRoleStmt&>(base_fbe_value);
    stmt_type.set(fbe_value.stmt_type);
    role.set(fbe_value.role);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreateRoleStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateRoleStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateRoleStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateRoleStmtModel::serialize(const ::pg_query::CreateRoleStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateRoleStmtModel::deserialize(::pg_query::CreateRoleStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterRoleStmt::FieldModelPtr_pg_query_AlterRoleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterRoleStmt::~FieldModelPtr_pg_query_AlterRoleStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterRoleStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterRoleStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterRoleStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterRoleStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterRoleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterRoleStmt::get(::pg_query::AlterRoleStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterRoleStmt(_buffer, 0);

    ::pg_query::AlterRoleStmt *tempModel = new ::pg_query::AlterRoleStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterRoleStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterRoleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterRoleStmt::set(const ::pg_query::AlterRoleStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterRoleStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterRoleStmt::FieldModel_pg_query_AlterRoleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , role(buffer, 4 + 4)
    , options(buffer, role.fbe_offset() + role.fbe_size())
    , action(buffer, options.fbe_offset() + options.fbe_size())
{}

size_t FieldModel_pg_query_AlterRoleStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + role.fbe_size()
        + options.fbe_size()
        + action.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterRoleStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + role.fbe_extra()
        + options.fbe_extra()
        + action.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterRoleStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterRoleStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + role.fbe_size()) > fbe_struct_size)
        return true;
    if (!role.verify())
        return false;
    fbe_current_size += role.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + action.fbe_size()) > fbe_struct_size)
        return true;
    if (!action.verify())
        return false;
    fbe_current_size += action.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterRoleStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterRoleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterRoleStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterRoleStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterRoleStmt& fbe_value = static_cast<::pg_query::AlterRoleStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + role.fbe_size()) <= fbe_struct_size)
        {
            role.get(&fbe_value.role);
        }
    else
        fbe_value.role = nullptr;
    fbe_current_size += role.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + action.fbe_size()) <= fbe_struct_size)
        {
            action.get(fbe_value.action);
        }
    else
        fbe_value.action = (int32_t)0ll;
    fbe_current_size += action.fbe_size();
}

size_t FieldModel_pg_query_AlterRoleStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterRoleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterRoleStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterRoleStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterRoleStmt& fbe_value = static_cast<const ::pg_query::AlterRoleStmt&>(base_fbe_value);
    role.set(fbe_value.role);
    options.set(fbe_value.options);
    action.set(fbe_value.action);
}

namespace pg_query {

bool AlterRoleStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterRoleStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterRoleStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterRoleStmtModel::serialize(const ::pg_query::AlterRoleStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterRoleStmtModel::deserialize(::pg_query::AlterRoleStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DropRoleStmt::FieldModelPtr_pg_query_DropRoleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DropRoleStmt::~FieldModelPtr_pg_query_DropRoleStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DropRoleStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DropRoleStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DropRoleStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DropRoleStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropRoleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropRoleStmt::get(::pg_query::DropRoleStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DropRoleStmt(_buffer, 0);

    ::pg_query::DropRoleStmt *tempModel = new ::pg_query::DropRoleStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DropRoleStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropRoleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropRoleStmt::set(const ::pg_query::DropRoleStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DropRoleStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DropRoleStmt::FieldModel_pg_query_DropRoleStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , roles(buffer, 4 + 4)
    , missing_ok(buffer, roles.fbe_offset() + roles.fbe_size())
{}

size_t FieldModel_pg_query_DropRoleStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + roles.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DropRoleStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + roles.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DropRoleStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DropRoleStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + roles.fbe_size()) > fbe_struct_size)
        return true;
    if (!roles.verify())
        return false;
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DropRoleStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropRoleStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropRoleStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DropRoleStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DropRoleStmt& fbe_value = static_cast<::pg_query::DropRoleStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + roles.fbe_size()) <= fbe_struct_size)
        {
            roles.get(fbe_value.roles);
        }
    else
        fbe_value.roles.clear();
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_DropRoleStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropRoleStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropRoleStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DropRoleStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DropRoleStmt& fbe_value = static_cast<const ::pg_query::DropRoleStmt&>(base_fbe_value);
    roles.set(fbe_value.roles);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool DropRoleStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DropRoleStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DropRoleStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DropRoleStmtModel::serialize(const ::pg_query::DropRoleStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DropRoleStmtModel::deserialize(::pg_query::DropRoleStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_LockStmt::FieldModelPtr_pg_query_LockStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_LockStmt::~FieldModelPtr_pg_query_LockStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_LockStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_LockStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_LockStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_LockStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_LockStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_LockStmt::get(::pg_query::LockStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_LockStmt(_buffer, 0);

    ::pg_query::LockStmt *tempModel = new ::pg_query::LockStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_LockStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_LockStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_LockStmt::set(const ::pg_query::LockStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_LockStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_LockStmt::FieldModel_pg_query_LockStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relations(buffer, 4 + 4)
    , mode(buffer, relations.fbe_offset() + relations.fbe_size())
    , nowait(buffer, mode.fbe_offset() + mode.fbe_size())
{}

size_t FieldModel_pg_query_LockStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relations.fbe_size()
        + mode.fbe_size()
        + nowait.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_LockStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relations.fbe_extra()
        + mode.fbe_extra()
        + nowait.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_LockStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_LockStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relations.fbe_size()) > fbe_struct_size)
        return true;
    if (!relations.verify())
        return false;
    fbe_current_size += relations.fbe_size();

    if ((fbe_current_size + mode.fbe_size()) > fbe_struct_size)
        return true;
    if (!mode.verify())
        return false;
    fbe_current_size += mode.fbe_size();

    if ((fbe_current_size + nowait.fbe_size()) > fbe_struct_size)
        return true;
    if (!nowait.verify())
        return false;
    fbe_current_size += nowait.fbe_size();

    return true;
}

size_t FieldModel_pg_query_LockStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_LockStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_LockStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_LockStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::LockStmt& fbe_value = static_cast<::pg_query::LockStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relations.fbe_size()) <= fbe_struct_size)
        {
            relations.get(fbe_value.relations);
        }
    else
        fbe_value.relations.clear();
    fbe_current_size += relations.fbe_size();

    if ((fbe_current_size + mode.fbe_size()) <= fbe_struct_size)
        {
            mode.get(fbe_value.mode);
        }
    else
        fbe_value.mode = (int32_t)0ll;
    fbe_current_size += mode.fbe_size();

    if ((fbe_current_size + nowait.fbe_size()) <= fbe_struct_size)
        {
            nowait.get(fbe_value.nowait);
        }
    else
        fbe_value.nowait = false;
    fbe_current_size += nowait.fbe_size();
}

size_t FieldModel_pg_query_LockStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_LockStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_LockStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_LockStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::LockStmt& fbe_value = static_cast<const ::pg_query::LockStmt&>(base_fbe_value);
    relations.set(fbe_value.relations);
    mode.set(fbe_value.mode);
    nowait.set(fbe_value.nowait);
}

namespace pg_query {

bool LockStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t LockStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t LockStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t LockStmtModel::serialize(const ::pg_query::LockStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t LockStmtModel::deserialize(::pg_query::LockStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ConstraintsSetStmt::FieldModelPtr_pg_query_ConstraintsSetStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ConstraintsSetStmt::~FieldModelPtr_pg_query_ConstraintsSetStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ConstraintsSetStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ConstraintsSetStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ConstraintsSetStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ConstraintsSetStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ConstraintsSetStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ConstraintsSetStmt::get(::pg_query::ConstraintsSetStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ConstraintsSetStmt(_buffer, 0);

    ::pg_query::ConstraintsSetStmt *tempModel = new ::pg_query::ConstraintsSetStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ConstraintsSetStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ConstraintsSetStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ConstraintsSetStmt::set(const ::pg_query::ConstraintsSetStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ConstraintsSetStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ConstraintsSetStmt::FieldModel_pg_query_ConstraintsSetStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , constraints(buffer, 4 + 4)
    , deferred(buffer, constraints.fbe_offset() + constraints.fbe_size())
{}

size_t FieldModel_pg_query_ConstraintsSetStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + constraints.fbe_size()
        + deferred.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ConstraintsSetStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + constraints.fbe_extra()
        + deferred.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ConstraintsSetStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ConstraintsSetStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + constraints.fbe_size()) > fbe_struct_size)
        return true;
    if (!constraints.verify())
        return false;
    fbe_current_size += constraints.fbe_size();

    if ((fbe_current_size + deferred.fbe_size()) > fbe_struct_size)
        return true;
    if (!deferred.verify())
        return false;
    fbe_current_size += deferred.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ConstraintsSetStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ConstraintsSetStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ConstraintsSetStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ConstraintsSetStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ConstraintsSetStmt& fbe_value = static_cast<::pg_query::ConstraintsSetStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + constraints.fbe_size()) <= fbe_struct_size)
        {
            constraints.get(fbe_value.constraints);
        }
    else
        fbe_value.constraints.clear();
    fbe_current_size += constraints.fbe_size();

    if ((fbe_current_size + deferred.fbe_size()) <= fbe_struct_size)
        {
            deferred.get(fbe_value.deferred);
        }
    else
        fbe_value.deferred = false;
    fbe_current_size += deferred.fbe_size();
}

size_t FieldModel_pg_query_ConstraintsSetStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ConstraintsSetStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ConstraintsSetStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ConstraintsSetStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ConstraintsSetStmt& fbe_value = static_cast<const ::pg_query::ConstraintsSetStmt&>(base_fbe_value);
    constraints.set(fbe_value.constraints);
    deferred.set(fbe_value.deferred);
}

namespace pg_query {

bool ConstraintsSetStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ConstraintsSetStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ConstraintsSetStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ConstraintsSetStmtModel::serialize(const ::pg_query::ConstraintsSetStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ConstraintsSetStmtModel::deserialize(::pg_query::ConstraintsSetStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ReindexStmt::FieldModelPtr_pg_query_ReindexStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ReindexStmt::~FieldModelPtr_pg_query_ReindexStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ReindexStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ReindexStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ReindexStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ReindexStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ReindexStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ReindexStmt::get(::pg_query::ReindexStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ReindexStmt(_buffer, 0);

    ::pg_query::ReindexStmt *tempModel = new ::pg_query::ReindexStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ReindexStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ReindexStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ReindexStmt::set(const ::pg_query::ReindexStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ReindexStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ReindexStmt::FieldModel_pg_query_ReindexStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , relation(buffer, kind.fbe_offset() + kind.fbe_size())
    , name(buffer, relation.fbe_offset() + relation.fbe_size())
    , options(buffer, name.fbe_offset() + name.fbe_size())
    , concurrent(buffer, options.fbe_offset() + options.fbe_size())
{}

size_t FieldModel_pg_query_ReindexStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + relation.fbe_size()
        + name.fbe_size()
        + options.fbe_size()
        + concurrent.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ReindexStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + relation.fbe_extra()
        + name.fbe_extra()
        + options.fbe_extra()
        + concurrent.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ReindexStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ReindexStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + concurrent.fbe_size()) > fbe_struct_size)
        return true;
    if (!concurrent.verify())
        return false;
    fbe_current_size += concurrent.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ReindexStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ReindexStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ReindexStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ReindexStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ReindexStmt& fbe_value = static_cast<::pg_query::ReindexStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::ReindexObjectType();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options = (int32_t)0ll;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + concurrent.fbe_size()) <= fbe_struct_size)
        {
            concurrent.get(fbe_value.concurrent);
        }
    else
        fbe_value.concurrent = false;
    fbe_current_size += concurrent.fbe_size();
}

size_t FieldModel_pg_query_ReindexStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ReindexStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ReindexStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ReindexStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ReindexStmt& fbe_value = static_cast<const ::pg_query::ReindexStmt&>(base_fbe_value);
    kind.set(fbe_value.kind);
    relation.set(fbe_value.relation);
    name.set(fbe_value.name);
    options.set(fbe_value.options);
    concurrent.set(fbe_value.concurrent);
}

namespace pg_query {

bool ReindexStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ReindexStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ReindexStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ReindexStmtModel::serialize(const ::pg_query::ReindexStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ReindexStmtModel::deserialize(::pg_query::ReindexStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CheckPointStmt::FieldModelPtr_pg_query_CheckPointStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CheckPointStmt::~FieldModelPtr_pg_query_CheckPointStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CheckPointStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CheckPointStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CheckPointStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CheckPointStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CheckPointStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CheckPointStmt::get(::pg_query::CheckPointStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CheckPointStmt(_buffer, 0);

    ::pg_query::CheckPointStmt *tempModel = new ::pg_query::CheckPointStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CheckPointStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CheckPointStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CheckPointStmt::set(const ::pg_query::CheckPointStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CheckPointStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CheckPointStmt::FieldModel_pg_query_CheckPointStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FieldModel_pg_query_CheckPointStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CheckPointStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CheckPointStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CheckPointStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    return true;
}

size_t FieldModel_pg_query_CheckPointStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CheckPointStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CheckPointStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CheckPointStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
}

size_t FieldModel_pg_query_CheckPointStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CheckPointStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CheckPointStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CheckPointStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CheckPointStmt& fbe_value = static_cast<const ::pg_query::CheckPointStmt&>(base_fbe_value);
}

namespace pg_query {

bool CheckPointStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CheckPointStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CheckPointStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CheckPointStmtModel::serialize(const ::pg_query::CheckPointStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CheckPointStmtModel::deserialize(::pg_query::CheckPointStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateSchemaStmt::FieldModelPtr_pg_query_CreateSchemaStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateSchemaStmt::~FieldModelPtr_pg_query_CreateSchemaStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateSchemaStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateSchemaStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateSchemaStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateSchemaStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateSchemaStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateSchemaStmt::get(::pg_query::CreateSchemaStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateSchemaStmt(_buffer, 0);

    ::pg_query::CreateSchemaStmt *tempModel = new ::pg_query::CreateSchemaStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateSchemaStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateSchemaStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateSchemaStmt::set(const ::pg_query::CreateSchemaStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateSchemaStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateSchemaStmt::FieldModel_pg_query_CreateSchemaStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , schemaname(buffer, 4 + 4)
    , authrole(buffer, schemaname.fbe_offset() + schemaname.fbe_size())
    , schema_elts(buffer, authrole.fbe_offset() + authrole.fbe_size())
    , if_not_exists(buffer, schema_elts.fbe_offset() + schema_elts.fbe_size())
{}

size_t FieldModel_pg_query_CreateSchemaStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + schemaname.fbe_size()
        + authrole.fbe_size()
        + schema_elts.fbe_size()
        + if_not_exists.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateSchemaStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + schemaname.fbe_extra()
        + authrole.fbe_extra()
        + schema_elts.fbe_extra()
        + if_not_exists.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateSchemaStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateSchemaStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + schemaname.fbe_size()) > fbe_struct_size)
        return true;
    if (!schemaname.verify())
        return false;
    fbe_current_size += schemaname.fbe_size();

    if ((fbe_current_size + authrole.fbe_size()) > fbe_struct_size)
        return true;
    if (!authrole.verify())
        return false;
    fbe_current_size += authrole.fbe_size();

    if ((fbe_current_size + schema_elts.fbe_size()) > fbe_struct_size)
        return true;
    if (!schema_elts.verify())
        return false;
    fbe_current_size += schema_elts.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateSchemaStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateSchemaStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateSchemaStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateSchemaStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateSchemaStmt& fbe_value = static_cast<::pg_query::CreateSchemaStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + schemaname.fbe_size()) <= fbe_struct_size)
        {
            schemaname.get(fbe_value.schemaname);
        }
    else
        fbe_value.schemaname = "";
    fbe_current_size += schemaname.fbe_size();

    if ((fbe_current_size + authrole.fbe_size()) <= fbe_struct_size)
        {
            authrole.get(&fbe_value.authrole);
        }
    else
        fbe_value.authrole = nullptr;
    fbe_current_size += authrole.fbe_size();

    if ((fbe_current_size + schema_elts.fbe_size()) <= fbe_struct_size)
        {
            schema_elts.get(fbe_value.schema_elts);
        }
    else
        fbe_value.schema_elts.clear();
    fbe_current_size += schema_elts.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();
}

size_t FieldModel_pg_query_CreateSchemaStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateSchemaStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateSchemaStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateSchemaStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateSchemaStmt& fbe_value = static_cast<const ::pg_query::CreateSchemaStmt&>(base_fbe_value);
    schemaname.set(fbe_value.schemaname);
    authrole.set(fbe_value.authrole);
    schema_elts.set(fbe_value.schema_elts);
    if_not_exists.set(fbe_value.if_not_exists);
}

namespace pg_query {

bool CreateSchemaStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateSchemaStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateSchemaStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateSchemaStmtModel::serialize(const ::pg_query::CreateSchemaStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateSchemaStmtModel::deserialize(::pg_query::CreateSchemaStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterDatabaseStmt::FieldModelPtr_pg_query_AlterDatabaseStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterDatabaseStmt::~FieldModelPtr_pg_query_AlterDatabaseStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterDatabaseStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterDatabaseStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterDatabaseStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterDatabaseStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterDatabaseStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterDatabaseStmt::get(::pg_query::AlterDatabaseStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterDatabaseStmt(_buffer, 0);

    ::pg_query::AlterDatabaseStmt *tempModel = new ::pg_query::AlterDatabaseStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterDatabaseStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterDatabaseStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterDatabaseStmt::set(const ::pg_query::AlterDatabaseStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterDatabaseStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterDatabaseStmt::FieldModel_pg_query_AlterDatabaseStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , dbname(buffer, 4 + 4)
    , options(buffer, dbname.fbe_offset() + dbname.fbe_size())
{}

size_t FieldModel_pg_query_AlterDatabaseStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + dbname.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterDatabaseStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + dbname.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterDatabaseStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterDatabaseStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dbname.fbe_size()) > fbe_struct_size)
        return true;
    if (!dbname.verify())
        return false;
    fbe_current_size += dbname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterDatabaseStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterDatabaseStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterDatabaseStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterDatabaseStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterDatabaseStmt& fbe_value = static_cast<::pg_query::AlterDatabaseStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dbname.fbe_size()) <= fbe_struct_size)
        {
            dbname.get(fbe_value.dbname);
        }
    else
        fbe_value.dbname = "";
    fbe_current_size += dbname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_AlterDatabaseStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterDatabaseStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterDatabaseStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterDatabaseStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterDatabaseStmt& fbe_value = static_cast<const ::pg_query::AlterDatabaseStmt&>(base_fbe_value);
    dbname.set(fbe_value.dbname);
    options.set(fbe_value.options);
}

namespace pg_query {

bool AlterDatabaseStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterDatabaseStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterDatabaseStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterDatabaseStmtModel::serialize(const ::pg_query::AlterDatabaseStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterDatabaseStmtModel::deserialize(::pg_query::AlterDatabaseStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterDatabaseSetStmt::FieldModelPtr_pg_query_AlterDatabaseSetStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterDatabaseSetStmt::~FieldModelPtr_pg_query_AlterDatabaseSetStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterDatabaseSetStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterDatabaseSetStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterDatabaseSetStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterDatabaseSetStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterDatabaseSetStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterDatabaseSetStmt::get(::pg_query::AlterDatabaseSetStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterDatabaseSetStmt(_buffer, 0);

    ::pg_query::AlterDatabaseSetStmt *tempModel = new ::pg_query::AlterDatabaseSetStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterDatabaseSetStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterDatabaseSetStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterDatabaseSetStmt::set(const ::pg_query::AlterDatabaseSetStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterDatabaseSetStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterDatabaseSetStmt::FieldModel_pg_query_AlterDatabaseSetStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , dbname(buffer, 4 + 4)
    , setstmt(buffer, dbname.fbe_offset() + dbname.fbe_size())
{}

size_t FieldModel_pg_query_AlterDatabaseSetStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + dbname.fbe_size()
        + setstmt.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterDatabaseSetStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + dbname.fbe_extra()
        + setstmt.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterDatabaseSetStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterDatabaseSetStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dbname.fbe_size()) > fbe_struct_size)
        return true;
    if (!dbname.verify())
        return false;
    fbe_current_size += dbname.fbe_size();

    if ((fbe_current_size + setstmt.fbe_size()) > fbe_struct_size)
        return true;
    if (!setstmt.verify())
        return false;
    fbe_current_size += setstmt.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterDatabaseSetStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterDatabaseSetStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterDatabaseSetStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterDatabaseSetStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterDatabaseSetStmt& fbe_value = static_cast<::pg_query::AlterDatabaseSetStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dbname.fbe_size()) <= fbe_struct_size)
        {
            dbname.get(fbe_value.dbname);
        }
    else
        fbe_value.dbname = "";
    fbe_current_size += dbname.fbe_size();

    if ((fbe_current_size + setstmt.fbe_size()) <= fbe_struct_size)
        {
            setstmt.get(&fbe_value.setstmt);
        }
    else
        fbe_value.setstmt = nullptr;
    fbe_current_size += setstmt.fbe_size();
}

size_t FieldModel_pg_query_AlterDatabaseSetStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterDatabaseSetStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterDatabaseSetStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterDatabaseSetStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterDatabaseSetStmt& fbe_value = static_cast<const ::pg_query::AlterDatabaseSetStmt&>(base_fbe_value);
    dbname.set(fbe_value.dbname);
    setstmt.set(fbe_value.setstmt);
}

namespace pg_query {

bool AlterDatabaseSetStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterDatabaseSetStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterDatabaseSetStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterDatabaseSetStmtModel::serialize(const ::pg_query::AlterDatabaseSetStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterDatabaseSetStmtModel::deserialize(::pg_query::AlterDatabaseSetStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterRoleSetStmt::FieldModelPtr_pg_query_AlterRoleSetStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterRoleSetStmt::~FieldModelPtr_pg_query_AlterRoleSetStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterRoleSetStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterRoleSetStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterRoleSetStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterRoleSetStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterRoleSetStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterRoleSetStmt::get(::pg_query::AlterRoleSetStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterRoleSetStmt(_buffer, 0);

    ::pg_query::AlterRoleSetStmt *tempModel = new ::pg_query::AlterRoleSetStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterRoleSetStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterRoleSetStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterRoleSetStmt::set(const ::pg_query::AlterRoleSetStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterRoleSetStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterRoleSetStmt::FieldModel_pg_query_AlterRoleSetStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , role(buffer, 4 + 4)
    , database(buffer, role.fbe_offset() + role.fbe_size())
    , setstmt(buffer, database.fbe_offset() + database.fbe_size())
{}

size_t FieldModel_pg_query_AlterRoleSetStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + role.fbe_size()
        + database.fbe_size()
        + setstmt.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterRoleSetStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + role.fbe_extra()
        + database.fbe_extra()
        + setstmt.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterRoleSetStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterRoleSetStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + role.fbe_size()) > fbe_struct_size)
        return true;
    if (!role.verify())
        return false;
    fbe_current_size += role.fbe_size();

    if ((fbe_current_size + database.fbe_size()) > fbe_struct_size)
        return true;
    if (!database.verify())
        return false;
    fbe_current_size += database.fbe_size();

    if ((fbe_current_size + setstmt.fbe_size()) > fbe_struct_size)
        return true;
    if (!setstmt.verify())
        return false;
    fbe_current_size += setstmt.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterRoleSetStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterRoleSetStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterRoleSetStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterRoleSetStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterRoleSetStmt& fbe_value = static_cast<::pg_query::AlterRoleSetStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + role.fbe_size()) <= fbe_struct_size)
        {
            role.get(&fbe_value.role);
        }
    else
        fbe_value.role = nullptr;
    fbe_current_size += role.fbe_size();

    if ((fbe_current_size + database.fbe_size()) <= fbe_struct_size)
        {
            database.get(fbe_value.database);
        }
    else
        fbe_value.database = "";
    fbe_current_size += database.fbe_size();

    if ((fbe_current_size + setstmt.fbe_size()) <= fbe_struct_size)
        {
            setstmt.get(&fbe_value.setstmt);
        }
    else
        fbe_value.setstmt = nullptr;
    fbe_current_size += setstmt.fbe_size();
}

size_t FieldModel_pg_query_AlterRoleSetStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterRoleSetStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterRoleSetStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterRoleSetStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterRoleSetStmt& fbe_value = static_cast<const ::pg_query::AlterRoleSetStmt&>(base_fbe_value);
    role.set(fbe_value.role);
    database.set(fbe_value.database);
    setstmt.set(fbe_value.setstmt);
}

namespace pg_query {

bool AlterRoleSetStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterRoleSetStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterRoleSetStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterRoleSetStmtModel::serialize(const ::pg_query::AlterRoleSetStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterRoleSetStmtModel::deserialize(::pg_query::AlterRoleSetStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateConversionStmt::FieldModelPtr_pg_query_CreateConversionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateConversionStmt::~FieldModelPtr_pg_query_CreateConversionStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateConversionStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateConversionStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateConversionStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateConversionStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateConversionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateConversionStmt::get(::pg_query::CreateConversionStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateConversionStmt(_buffer, 0);

    ::pg_query::CreateConversionStmt *tempModel = new ::pg_query::CreateConversionStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateConversionStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateConversionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateConversionStmt::set(const ::pg_query::CreateConversionStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateConversionStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateConversionStmt::FieldModel_pg_query_CreateConversionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , conversion_name(buffer, 4 + 4)
    , for_encoding_name(buffer, conversion_name.fbe_offset() + conversion_name.fbe_size())
    , to_encoding_name(buffer, for_encoding_name.fbe_offset() + for_encoding_name.fbe_size())
    , func_name(buffer, to_encoding_name.fbe_offset() + to_encoding_name.fbe_size())
    , def(buffer, func_name.fbe_offset() + func_name.fbe_size())
{}

size_t FieldModel_pg_query_CreateConversionStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + conversion_name.fbe_size()
        + for_encoding_name.fbe_size()
        + to_encoding_name.fbe_size()
        + func_name.fbe_size()
        + def.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateConversionStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + conversion_name.fbe_extra()
        + for_encoding_name.fbe_extra()
        + to_encoding_name.fbe_extra()
        + func_name.fbe_extra()
        + def.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateConversionStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateConversionStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + conversion_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!conversion_name.verify())
        return false;
    fbe_current_size += conversion_name.fbe_size();

    if ((fbe_current_size + for_encoding_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!for_encoding_name.verify())
        return false;
    fbe_current_size += for_encoding_name.fbe_size();

    if ((fbe_current_size + to_encoding_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!to_encoding_name.verify())
        return false;
    fbe_current_size += to_encoding_name.fbe_size();

    if ((fbe_current_size + func_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!func_name.verify())
        return false;
    fbe_current_size += func_name.fbe_size();

    if ((fbe_current_size + def.fbe_size()) > fbe_struct_size)
        return true;
    if (!def.verify())
        return false;
    fbe_current_size += def.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateConversionStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateConversionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateConversionStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateConversionStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateConversionStmt& fbe_value = static_cast<::pg_query::CreateConversionStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + conversion_name.fbe_size()) <= fbe_struct_size)
        {
            conversion_name.get(fbe_value.conversion_name);
        }
    else
        fbe_value.conversion_name.clear();
    fbe_current_size += conversion_name.fbe_size();

    if ((fbe_current_size + for_encoding_name.fbe_size()) <= fbe_struct_size)
        {
            for_encoding_name.get(fbe_value.for_encoding_name);
        }
    else
        fbe_value.for_encoding_name = "";
    fbe_current_size += for_encoding_name.fbe_size();

    if ((fbe_current_size + to_encoding_name.fbe_size()) <= fbe_struct_size)
        {
            to_encoding_name.get(fbe_value.to_encoding_name);
        }
    else
        fbe_value.to_encoding_name = "";
    fbe_current_size += to_encoding_name.fbe_size();

    if ((fbe_current_size + func_name.fbe_size()) <= fbe_struct_size)
        {
            func_name.get(fbe_value.func_name);
        }
    else
        fbe_value.func_name.clear();
    fbe_current_size += func_name.fbe_size();

    if ((fbe_current_size + def.fbe_size()) <= fbe_struct_size)
        {
            def.get(fbe_value.def);
        }
    else
        fbe_value.def = false;
    fbe_current_size += def.fbe_size();
}

size_t FieldModel_pg_query_CreateConversionStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateConversionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateConversionStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateConversionStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateConversionStmt& fbe_value = static_cast<const ::pg_query::CreateConversionStmt&>(base_fbe_value);
    conversion_name.set(fbe_value.conversion_name);
    for_encoding_name.set(fbe_value.for_encoding_name);
    to_encoding_name.set(fbe_value.to_encoding_name);
    func_name.set(fbe_value.func_name);
    def.set(fbe_value.def);
}

namespace pg_query {

bool CreateConversionStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateConversionStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateConversionStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateConversionStmtModel::serialize(const ::pg_query::CreateConversionStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateConversionStmtModel::deserialize(::pg_query::CreateConversionStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateCastStmt::FieldModelPtr_pg_query_CreateCastStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateCastStmt::~FieldModelPtr_pg_query_CreateCastStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateCastStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateCastStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateCastStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateCastStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateCastStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateCastStmt::get(::pg_query::CreateCastStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateCastStmt(_buffer, 0);

    ::pg_query::CreateCastStmt *tempModel = new ::pg_query::CreateCastStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateCastStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateCastStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateCastStmt::set(const ::pg_query::CreateCastStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateCastStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateCastStmt::FieldModel_pg_query_CreateCastStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , sourcetype(buffer, 4 + 4)
    , targettype(buffer, sourcetype.fbe_offset() + sourcetype.fbe_size())
    , func(buffer, targettype.fbe_offset() + targettype.fbe_size())
    , context(buffer, func.fbe_offset() + func.fbe_size())
    , inout(buffer, context.fbe_offset() + context.fbe_size())
{}

size_t FieldModel_pg_query_CreateCastStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + sourcetype.fbe_size()
        + targettype.fbe_size()
        + func.fbe_size()
        + context.fbe_size()
        + inout.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateCastStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + sourcetype.fbe_extra()
        + targettype.fbe_extra()
        + func.fbe_extra()
        + context.fbe_extra()
        + inout.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateCastStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateCastStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + sourcetype.fbe_size()) > fbe_struct_size)
        return true;
    if (!sourcetype.verify())
        return false;
    fbe_current_size += sourcetype.fbe_size();

    if ((fbe_current_size + targettype.fbe_size()) > fbe_struct_size)
        return true;
    if (!targettype.verify())
        return false;
    fbe_current_size += targettype.fbe_size();

    if ((fbe_current_size + func.fbe_size()) > fbe_struct_size)
        return true;
    if (!func.verify())
        return false;
    fbe_current_size += func.fbe_size();

    if ((fbe_current_size + context.fbe_size()) > fbe_struct_size)
        return true;
    if (!context.verify())
        return false;
    fbe_current_size += context.fbe_size();

    if ((fbe_current_size + inout.fbe_size()) > fbe_struct_size)
        return true;
    if (!inout.verify())
        return false;
    fbe_current_size += inout.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateCastStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateCastStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateCastStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateCastStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateCastStmt& fbe_value = static_cast<::pg_query::CreateCastStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + sourcetype.fbe_size()) <= fbe_struct_size)
        {
            sourcetype.get(&fbe_value.sourcetype);
        }
    else
        fbe_value.sourcetype = nullptr;
    fbe_current_size += sourcetype.fbe_size();

    if ((fbe_current_size + targettype.fbe_size()) <= fbe_struct_size)
        {
            targettype.get(&fbe_value.targettype);
        }
    else
        fbe_value.targettype = nullptr;
    fbe_current_size += targettype.fbe_size();

    if ((fbe_current_size + func.fbe_size()) <= fbe_struct_size)
        {
            func.get(&fbe_value.func);
        }
    else
        fbe_value.func = nullptr;
    fbe_current_size += func.fbe_size();

    if ((fbe_current_size + context.fbe_size()) <= fbe_struct_size)
        {
            context.get(fbe_value.context);
        }
    else
        fbe_value.context = ::pg_query::CoercionContext();
    fbe_current_size += context.fbe_size();

    if ((fbe_current_size + inout.fbe_size()) <= fbe_struct_size)
        {
            inout.get(fbe_value.inout);
        }
    else
        fbe_value.inout = false;
    fbe_current_size += inout.fbe_size();
}

size_t FieldModel_pg_query_CreateCastStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateCastStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateCastStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateCastStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateCastStmt& fbe_value = static_cast<const ::pg_query::CreateCastStmt&>(base_fbe_value);
    sourcetype.set(fbe_value.sourcetype);
    targettype.set(fbe_value.targettype);
    func.set(fbe_value.func);
    context.set(fbe_value.context);
    inout.set(fbe_value.inout);
}

namespace pg_query {

bool CreateCastStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateCastStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateCastStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateCastStmtModel::serialize(const ::pg_query::CreateCastStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateCastStmtModel::deserialize(::pg_query::CreateCastStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateOpClassStmt::FieldModelPtr_pg_query_CreateOpClassStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateOpClassStmt::~FieldModelPtr_pg_query_CreateOpClassStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateOpClassStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateOpClassStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateOpClassStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateOpClassStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateOpClassStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateOpClassStmt::get(::pg_query::CreateOpClassStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateOpClassStmt(_buffer, 0);

    ::pg_query::CreateOpClassStmt *tempModel = new ::pg_query::CreateOpClassStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateOpClassStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateOpClassStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateOpClassStmt::set(const ::pg_query::CreateOpClassStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateOpClassStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateOpClassStmt::FieldModel_pg_query_CreateOpClassStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , opclassname(buffer, 4 + 4)
    , opfamilyname(buffer, opclassname.fbe_offset() + opclassname.fbe_size())
    , amname(buffer, opfamilyname.fbe_offset() + opfamilyname.fbe_size())
    , datatype(buffer, amname.fbe_offset() + amname.fbe_size())
    , items(buffer, datatype.fbe_offset() + datatype.fbe_size())
    , is_default(buffer, items.fbe_offset() + items.fbe_size())
{}

size_t FieldModel_pg_query_CreateOpClassStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + opclassname.fbe_size()
        + opfamilyname.fbe_size()
        + amname.fbe_size()
        + datatype.fbe_size()
        + items.fbe_size()
        + is_default.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateOpClassStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + opclassname.fbe_extra()
        + opfamilyname.fbe_extra()
        + amname.fbe_extra()
        + datatype.fbe_extra()
        + items.fbe_extra()
        + is_default.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateOpClassStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateOpClassStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + opclassname.fbe_size()) > fbe_struct_size)
        return true;
    if (!opclassname.verify())
        return false;
    fbe_current_size += opclassname.fbe_size();

    if ((fbe_current_size + opfamilyname.fbe_size()) > fbe_struct_size)
        return true;
    if (!opfamilyname.verify())
        return false;
    fbe_current_size += opfamilyname.fbe_size();

    if ((fbe_current_size + amname.fbe_size()) > fbe_struct_size)
        return true;
    if (!amname.verify())
        return false;
    fbe_current_size += amname.fbe_size();

    if ((fbe_current_size + datatype.fbe_size()) > fbe_struct_size)
        return true;
    if (!datatype.verify())
        return false;
    fbe_current_size += datatype.fbe_size();

    if ((fbe_current_size + items.fbe_size()) > fbe_struct_size)
        return true;
    if (!items.verify())
        return false;
    fbe_current_size += items.fbe_size();

    if ((fbe_current_size + is_default.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_default.verify())
        return false;
    fbe_current_size += is_default.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateOpClassStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateOpClassStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateOpClassStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateOpClassStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateOpClassStmt& fbe_value = static_cast<::pg_query::CreateOpClassStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + opclassname.fbe_size()) <= fbe_struct_size)
        {
            opclassname.get(fbe_value.opclassname);
        }
    else
        fbe_value.opclassname.clear();
    fbe_current_size += opclassname.fbe_size();

    if ((fbe_current_size + opfamilyname.fbe_size()) <= fbe_struct_size)
        {
            opfamilyname.get(fbe_value.opfamilyname);
        }
    else
        fbe_value.opfamilyname.clear();
    fbe_current_size += opfamilyname.fbe_size();

    if ((fbe_current_size + amname.fbe_size()) <= fbe_struct_size)
        {
            amname.get(fbe_value.amname);
        }
    else
        fbe_value.amname = "";
    fbe_current_size += amname.fbe_size();

    if ((fbe_current_size + datatype.fbe_size()) <= fbe_struct_size)
        {
            datatype.get(&fbe_value.datatype);
        }
    else
        fbe_value.datatype = nullptr;
    fbe_current_size += datatype.fbe_size();

    if ((fbe_current_size + items.fbe_size()) <= fbe_struct_size)
        {
            items.get(fbe_value.items);
        }
    else
        fbe_value.items.clear();
    fbe_current_size += items.fbe_size();

    if ((fbe_current_size + is_default.fbe_size()) <= fbe_struct_size)
        {
            is_default.get(fbe_value.is_default);
        }
    else
        fbe_value.is_default = false;
    fbe_current_size += is_default.fbe_size();
}

size_t FieldModel_pg_query_CreateOpClassStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateOpClassStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateOpClassStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateOpClassStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateOpClassStmt& fbe_value = static_cast<const ::pg_query::CreateOpClassStmt&>(base_fbe_value);
    opclassname.set(fbe_value.opclassname);
    opfamilyname.set(fbe_value.opfamilyname);
    amname.set(fbe_value.amname);
    datatype.set(fbe_value.datatype);
    items.set(fbe_value.items);
    is_default.set(fbe_value.is_default);
}

namespace pg_query {

bool CreateOpClassStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateOpClassStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateOpClassStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateOpClassStmtModel::serialize(const ::pg_query::CreateOpClassStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateOpClassStmtModel::deserialize(::pg_query::CreateOpClassStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateOpFamilyStmt::FieldModelPtr_pg_query_CreateOpFamilyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateOpFamilyStmt::~FieldModelPtr_pg_query_CreateOpFamilyStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateOpFamilyStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateOpFamilyStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateOpFamilyStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateOpFamilyStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateOpFamilyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateOpFamilyStmt::get(::pg_query::CreateOpFamilyStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateOpFamilyStmt(_buffer, 0);

    ::pg_query::CreateOpFamilyStmt *tempModel = new ::pg_query::CreateOpFamilyStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateOpFamilyStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateOpFamilyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateOpFamilyStmt::set(const ::pg_query::CreateOpFamilyStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateOpFamilyStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateOpFamilyStmt::FieldModel_pg_query_CreateOpFamilyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , opfamilyname(buffer, 4 + 4)
    , amname(buffer, opfamilyname.fbe_offset() + opfamilyname.fbe_size())
{}

size_t FieldModel_pg_query_CreateOpFamilyStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + opfamilyname.fbe_size()
        + amname.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateOpFamilyStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + opfamilyname.fbe_extra()
        + amname.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateOpFamilyStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateOpFamilyStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + opfamilyname.fbe_size()) > fbe_struct_size)
        return true;
    if (!opfamilyname.verify())
        return false;
    fbe_current_size += opfamilyname.fbe_size();

    if ((fbe_current_size + amname.fbe_size()) > fbe_struct_size)
        return true;
    if (!amname.verify())
        return false;
    fbe_current_size += amname.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateOpFamilyStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateOpFamilyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateOpFamilyStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateOpFamilyStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateOpFamilyStmt& fbe_value = static_cast<::pg_query::CreateOpFamilyStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + opfamilyname.fbe_size()) <= fbe_struct_size)
        {
            opfamilyname.get(fbe_value.opfamilyname);
        }
    else
        fbe_value.opfamilyname.clear();
    fbe_current_size += opfamilyname.fbe_size();

    if ((fbe_current_size + amname.fbe_size()) <= fbe_struct_size)
        {
            amname.get(fbe_value.amname);
        }
    else
        fbe_value.amname = "";
    fbe_current_size += amname.fbe_size();
}

size_t FieldModel_pg_query_CreateOpFamilyStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateOpFamilyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateOpFamilyStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateOpFamilyStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateOpFamilyStmt& fbe_value = static_cast<const ::pg_query::CreateOpFamilyStmt&>(base_fbe_value);
    opfamilyname.set(fbe_value.opfamilyname);
    amname.set(fbe_value.amname);
}

namespace pg_query {

bool CreateOpFamilyStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateOpFamilyStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateOpFamilyStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateOpFamilyStmtModel::serialize(const ::pg_query::CreateOpFamilyStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateOpFamilyStmtModel::deserialize(::pg_query::CreateOpFamilyStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterOpFamilyStmt::FieldModelPtr_pg_query_AlterOpFamilyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterOpFamilyStmt::~FieldModelPtr_pg_query_AlterOpFamilyStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterOpFamilyStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterOpFamilyStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterOpFamilyStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterOpFamilyStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterOpFamilyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterOpFamilyStmt::get(::pg_query::AlterOpFamilyStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterOpFamilyStmt(_buffer, 0);

    ::pg_query::AlterOpFamilyStmt *tempModel = new ::pg_query::AlterOpFamilyStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterOpFamilyStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterOpFamilyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterOpFamilyStmt::set(const ::pg_query::AlterOpFamilyStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterOpFamilyStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterOpFamilyStmt::FieldModel_pg_query_AlterOpFamilyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , opfamilyname(buffer, 4 + 4)
    , amname(buffer, opfamilyname.fbe_offset() + opfamilyname.fbe_size())
    , is_drop(buffer, amname.fbe_offset() + amname.fbe_size())
    , items(buffer, is_drop.fbe_offset() + is_drop.fbe_size())
{}

size_t FieldModel_pg_query_AlterOpFamilyStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + opfamilyname.fbe_size()
        + amname.fbe_size()
        + is_drop.fbe_size()
        + items.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterOpFamilyStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + opfamilyname.fbe_extra()
        + amname.fbe_extra()
        + is_drop.fbe_extra()
        + items.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterOpFamilyStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterOpFamilyStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + opfamilyname.fbe_size()) > fbe_struct_size)
        return true;
    if (!opfamilyname.verify())
        return false;
    fbe_current_size += opfamilyname.fbe_size();

    if ((fbe_current_size + amname.fbe_size()) > fbe_struct_size)
        return true;
    if (!amname.verify())
        return false;
    fbe_current_size += amname.fbe_size();

    if ((fbe_current_size + is_drop.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_drop.verify())
        return false;
    fbe_current_size += is_drop.fbe_size();

    if ((fbe_current_size + items.fbe_size()) > fbe_struct_size)
        return true;
    if (!items.verify())
        return false;
    fbe_current_size += items.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterOpFamilyStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterOpFamilyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterOpFamilyStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterOpFamilyStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterOpFamilyStmt& fbe_value = static_cast<::pg_query::AlterOpFamilyStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + opfamilyname.fbe_size()) <= fbe_struct_size)
        {
            opfamilyname.get(fbe_value.opfamilyname);
        }
    else
        fbe_value.opfamilyname.clear();
    fbe_current_size += opfamilyname.fbe_size();

    if ((fbe_current_size + amname.fbe_size()) <= fbe_struct_size)
        {
            amname.get(fbe_value.amname);
        }
    else
        fbe_value.amname = "";
    fbe_current_size += amname.fbe_size();

    if ((fbe_current_size + is_drop.fbe_size()) <= fbe_struct_size)
        {
            is_drop.get(fbe_value.is_drop);
        }
    else
        fbe_value.is_drop = false;
    fbe_current_size += is_drop.fbe_size();

    if ((fbe_current_size + items.fbe_size()) <= fbe_struct_size)
        {
            items.get(fbe_value.items);
        }
    else
        fbe_value.items.clear();
    fbe_current_size += items.fbe_size();
}

size_t FieldModel_pg_query_AlterOpFamilyStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterOpFamilyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterOpFamilyStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterOpFamilyStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterOpFamilyStmt& fbe_value = static_cast<const ::pg_query::AlterOpFamilyStmt&>(base_fbe_value);
    opfamilyname.set(fbe_value.opfamilyname);
    amname.set(fbe_value.amname);
    is_drop.set(fbe_value.is_drop);
    items.set(fbe_value.items);
}

namespace pg_query {

bool AlterOpFamilyStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterOpFamilyStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterOpFamilyStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterOpFamilyStmtModel::serialize(const ::pg_query::AlterOpFamilyStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterOpFamilyStmtModel::deserialize(::pg_query::AlterOpFamilyStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_PrepareStmt::FieldModelPtr_pg_query_PrepareStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_PrepareStmt::~FieldModelPtr_pg_query_PrepareStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_PrepareStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_PrepareStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_PrepareStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_PrepareStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PrepareStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PrepareStmt::get(::pg_query::PrepareStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_PrepareStmt(_buffer, 0);

    ::pg_query::PrepareStmt *tempModel = new ::pg_query::PrepareStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_PrepareStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PrepareStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PrepareStmt::set(const ::pg_query::PrepareStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_PrepareStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_PrepareStmt::FieldModel_pg_query_PrepareStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , argtypes(buffer, name.fbe_offset() + name.fbe_size())
    , query(buffer, argtypes.fbe_offset() + argtypes.fbe_size())
{}

size_t FieldModel_pg_query_PrepareStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + argtypes.fbe_size()
        + query.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_PrepareStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + argtypes.fbe_extra()
        + query.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_PrepareStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_PrepareStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + argtypes.fbe_size()) > fbe_struct_size)
        return true;
    if (!argtypes.verify())
        return false;
    fbe_current_size += argtypes.fbe_size();

    if ((fbe_current_size + query.fbe_size()) > fbe_struct_size)
        return true;
    if (!query.verify())
        return false;
    fbe_current_size += query.fbe_size();

    return true;
}

size_t FieldModel_pg_query_PrepareStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PrepareStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PrepareStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_PrepareStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::PrepareStmt& fbe_value = static_cast<::pg_query::PrepareStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + argtypes.fbe_size()) <= fbe_struct_size)
        {
            argtypes.get(fbe_value.argtypes);
        }
    else
        fbe_value.argtypes.clear();
    fbe_current_size += argtypes.fbe_size();

    if ((fbe_current_size + query.fbe_size()) <= fbe_struct_size)
        {
            query.get(fbe_value.query);
        }
    else
        fbe_value.query = ::pg_query::Node();
    fbe_current_size += query.fbe_size();
}

size_t FieldModel_pg_query_PrepareStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PrepareStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PrepareStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_PrepareStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::PrepareStmt& fbe_value = static_cast<const ::pg_query::PrepareStmt&>(base_fbe_value);
    name.set(fbe_value.name);
    argtypes.set(fbe_value.argtypes);
    query.set(fbe_value.query);
}

namespace pg_query {

bool PrepareStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t PrepareStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t PrepareStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t PrepareStmtModel::serialize(const ::pg_query::PrepareStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t PrepareStmtModel::deserialize(::pg_query::PrepareStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ExecuteStmt::FieldModelPtr_pg_query_ExecuteStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ExecuteStmt::~FieldModelPtr_pg_query_ExecuteStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ExecuteStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ExecuteStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ExecuteStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ExecuteStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ExecuteStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ExecuteStmt::get(::pg_query::ExecuteStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ExecuteStmt(_buffer, 0);

    ::pg_query::ExecuteStmt *tempModel = new ::pg_query::ExecuteStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ExecuteStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ExecuteStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ExecuteStmt::set(const ::pg_query::ExecuteStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ExecuteStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ExecuteStmt::FieldModel_pg_query_ExecuteStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , params(buffer, name.fbe_offset() + name.fbe_size())
{}

size_t FieldModel_pg_query_ExecuteStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + params.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ExecuteStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + params.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ExecuteStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ExecuteStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + params.fbe_size()) > fbe_struct_size)
        return true;
    if (!params.verify())
        return false;
    fbe_current_size += params.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ExecuteStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ExecuteStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ExecuteStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ExecuteStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ExecuteStmt& fbe_value = static_cast<::pg_query::ExecuteStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + params.fbe_size()) <= fbe_struct_size)
        {
            params.get(fbe_value.params);
        }
    else
        fbe_value.params.clear();
    fbe_current_size += params.fbe_size();
}

size_t FieldModel_pg_query_ExecuteStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ExecuteStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ExecuteStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ExecuteStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ExecuteStmt& fbe_value = static_cast<const ::pg_query::ExecuteStmt&>(base_fbe_value);
    name.set(fbe_value.name);
    params.set(fbe_value.params);
}

namespace pg_query {

bool ExecuteStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ExecuteStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ExecuteStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ExecuteStmtModel::serialize(const ::pg_query::ExecuteStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ExecuteStmtModel::deserialize(::pg_query::ExecuteStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DeallocateStmt::FieldModelPtr_pg_query_DeallocateStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DeallocateStmt::~FieldModelPtr_pg_query_DeallocateStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DeallocateStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DeallocateStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DeallocateStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DeallocateStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DeallocateStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DeallocateStmt::get(::pg_query::DeallocateStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DeallocateStmt(_buffer, 0);

    ::pg_query::DeallocateStmt *tempModel = new ::pg_query::DeallocateStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DeallocateStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DeallocateStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DeallocateStmt::set(const ::pg_query::DeallocateStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DeallocateStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DeallocateStmt::FieldModel_pg_query_DeallocateStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_DeallocateStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DeallocateStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DeallocateStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DeallocateStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DeallocateStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DeallocateStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DeallocateStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DeallocateStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DeallocateStmt& fbe_value = static_cast<::pg_query::DeallocateStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();
}

size_t FieldModel_pg_query_DeallocateStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DeallocateStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DeallocateStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DeallocateStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DeallocateStmt& fbe_value = static_cast<const ::pg_query::DeallocateStmt&>(base_fbe_value);
    name.set(fbe_value.name);
}

namespace pg_query {

bool DeallocateStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DeallocateStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DeallocateStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DeallocateStmtModel::serialize(const ::pg_query::DeallocateStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DeallocateStmtModel::deserialize(::pg_query::DeallocateStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DeclareCursorStmt::FieldModelPtr_pg_query_DeclareCursorStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DeclareCursorStmt::~FieldModelPtr_pg_query_DeclareCursorStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DeclareCursorStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DeclareCursorStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DeclareCursorStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DeclareCursorStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DeclareCursorStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DeclareCursorStmt::get(::pg_query::DeclareCursorStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DeclareCursorStmt(_buffer, 0);

    ::pg_query::DeclareCursorStmt *tempModel = new ::pg_query::DeclareCursorStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DeclareCursorStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DeclareCursorStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DeclareCursorStmt::set(const ::pg_query::DeclareCursorStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DeclareCursorStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DeclareCursorStmt::FieldModel_pg_query_DeclareCursorStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , portalname(buffer, 4 + 4)
    , options(buffer, portalname.fbe_offset() + portalname.fbe_size())
    , query(buffer, options.fbe_offset() + options.fbe_size())
{}

size_t FieldModel_pg_query_DeclareCursorStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + portalname.fbe_size()
        + options.fbe_size()
        + query.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DeclareCursorStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + portalname.fbe_extra()
        + options.fbe_extra()
        + query.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DeclareCursorStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DeclareCursorStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + portalname.fbe_size()) > fbe_struct_size)
        return true;
    if (!portalname.verify())
        return false;
    fbe_current_size += portalname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + query.fbe_size()) > fbe_struct_size)
        return true;
    if (!query.verify())
        return false;
    fbe_current_size += query.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DeclareCursorStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DeclareCursorStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DeclareCursorStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DeclareCursorStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DeclareCursorStmt& fbe_value = static_cast<::pg_query::DeclareCursorStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + portalname.fbe_size()) <= fbe_struct_size)
        {
            portalname.get(fbe_value.portalname);
        }
    else
        fbe_value.portalname = "";
    fbe_current_size += portalname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options = (int32_t)0ll;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + query.fbe_size()) <= fbe_struct_size)
        {
            query.get(fbe_value.query);
        }
    else
        fbe_value.query = ::pg_query::Node();
    fbe_current_size += query.fbe_size();
}

size_t FieldModel_pg_query_DeclareCursorStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DeclareCursorStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DeclareCursorStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DeclareCursorStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DeclareCursorStmt& fbe_value = static_cast<const ::pg_query::DeclareCursorStmt&>(base_fbe_value);
    portalname.set(fbe_value.portalname);
    options.set(fbe_value.options);
    query.set(fbe_value.query);
}

namespace pg_query {

bool DeclareCursorStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DeclareCursorStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DeclareCursorStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DeclareCursorStmtModel::serialize(const ::pg_query::DeclareCursorStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DeclareCursorStmtModel::deserialize(::pg_query::DeclareCursorStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateTableSpaceStmt::FieldModelPtr_pg_query_CreateTableSpaceStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateTableSpaceStmt::~FieldModelPtr_pg_query_CreateTableSpaceStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateTableSpaceStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateTableSpaceStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateTableSpaceStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateTableSpaceStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateTableSpaceStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateTableSpaceStmt::get(::pg_query::CreateTableSpaceStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateTableSpaceStmt(_buffer, 0);

    ::pg_query::CreateTableSpaceStmt *tempModel = new ::pg_query::CreateTableSpaceStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateTableSpaceStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateTableSpaceStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateTableSpaceStmt::set(const ::pg_query::CreateTableSpaceStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateTableSpaceStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateTableSpaceStmt::FieldModel_pg_query_CreateTableSpaceStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , tablespacename(buffer, 4 + 4)
    , owner(buffer, tablespacename.fbe_offset() + tablespacename.fbe_size())
    , location(buffer, owner.fbe_offset() + owner.fbe_size())
    , options(buffer, location.fbe_offset() + location.fbe_size())
{}

size_t FieldModel_pg_query_CreateTableSpaceStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + tablespacename.fbe_size()
        + owner.fbe_size()
        + location.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateTableSpaceStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + tablespacename.fbe_extra()
        + owner.fbe_extra()
        + location.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateTableSpaceStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateTableSpaceStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tablespacename.fbe_size()) > fbe_struct_size)
        return true;
    if (!tablespacename.verify())
        return false;
    fbe_current_size += tablespacename.fbe_size();

    if ((fbe_current_size + owner.fbe_size()) > fbe_struct_size)
        return true;
    if (!owner.verify())
        return false;
    fbe_current_size += owner.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateTableSpaceStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateTableSpaceStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateTableSpaceStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateTableSpaceStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateTableSpaceStmt& fbe_value = static_cast<::pg_query::CreateTableSpaceStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tablespacename.fbe_size()) <= fbe_struct_size)
        {
            tablespacename.get(fbe_value.tablespacename);
        }
    else
        fbe_value.tablespacename = "";
    fbe_current_size += tablespacename.fbe_size();

    if ((fbe_current_size + owner.fbe_size()) <= fbe_struct_size)
        {
            owner.get(&fbe_value.owner);
        }
    else
        fbe_value.owner = nullptr;
    fbe_current_size += owner.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = "";
    fbe_current_size += location.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreateTableSpaceStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateTableSpaceStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateTableSpaceStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateTableSpaceStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateTableSpaceStmt& fbe_value = static_cast<const ::pg_query::CreateTableSpaceStmt&>(base_fbe_value);
    tablespacename.set(fbe_value.tablespacename);
    owner.set(fbe_value.owner);
    location.set(fbe_value.location);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreateTableSpaceStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateTableSpaceStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateTableSpaceStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateTableSpaceStmtModel::serialize(const ::pg_query::CreateTableSpaceStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateTableSpaceStmtModel::deserialize(::pg_query::CreateTableSpaceStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DropTableSpaceStmt::FieldModelPtr_pg_query_DropTableSpaceStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DropTableSpaceStmt::~FieldModelPtr_pg_query_DropTableSpaceStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DropTableSpaceStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DropTableSpaceStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DropTableSpaceStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DropTableSpaceStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropTableSpaceStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropTableSpaceStmt::get(::pg_query::DropTableSpaceStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DropTableSpaceStmt(_buffer, 0);

    ::pg_query::DropTableSpaceStmt *tempModel = new ::pg_query::DropTableSpaceStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DropTableSpaceStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropTableSpaceStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropTableSpaceStmt::set(const ::pg_query::DropTableSpaceStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DropTableSpaceStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DropTableSpaceStmt::FieldModel_pg_query_DropTableSpaceStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , tablespacename(buffer, 4 + 4)
    , missing_ok(buffer, tablespacename.fbe_offset() + tablespacename.fbe_size())
{}

size_t FieldModel_pg_query_DropTableSpaceStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + tablespacename.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DropTableSpaceStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + tablespacename.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DropTableSpaceStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DropTableSpaceStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tablespacename.fbe_size()) > fbe_struct_size)
        return true;
    if (!tablespacename.verify())
        return false;
    fbe_current_size += tablespacename.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DropTableSpaceStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropTableSpaceStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropTableSpaceStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DropTableSpaceStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DropTableSpaceStmt& fbe_value = static_cast<::pg_query::DropTableSpaceStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tablespacename.fbe_size()) <= fbe_struct_size)
        {
            tablespacename.get(fbe_value.tablespacename);
        }
    else
        fbe_value.tablespacename = "";
    fbe_current_size += tablespacename.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_DropTableSpaceStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropTableSpaceStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropTableSpaceStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DropTableSpaceStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DropTableSpaceStmt& fbe_value = static_cast<const ::pg_query::DropTableSpaceStmt&>(base_fbe_value);
    tablespacename.set(fbe_value.tablespacename);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool DropTableSpaceStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DropTableSpaceStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DropTableSpaceStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DropTableSpaceStmtModel::serialize(const ::pg_query::DropTableSpaceStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DropTableSpaceStmtModel::deserialize(::pg_query::DropTableSpaceStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterObjectDependsStmt::FieldModelPtr_pg_query_AlterObjectDependsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterObjectDependsStmt::~FieldModelPtr_pg_query_AlterObjectDependsStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterObjectDependsStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterObjectDependsStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterObjectDependsStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterObjectDependsStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterObjectDependsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterObjectDependsStmt::get(::pg_query::AlterObjectDependsStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterObjectDependsStmt(_buffer, 0);

    ::pg_query::AlterObjectDependsStmt *tempModel = new ::pg_query::AlterObjectDependsStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterObjectDependsStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterObjectDependsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterObjectDependsStmt::set(const ::pg_query::AlterObjectDependsStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterObjectDependsStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterObjectDependsStmt::FieldModel_pg_query_AlterObjectDependsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , object_type(buffer, 4 + 4)
    , relation(buffer, object_type.fbe_offset() + object_type.fbe_size())
    , object(buffer, relation.fbe_offset() + relation.fbe_size())
    , extname(buffer, object.fbe_offset() + object.fbe_size())
    , remove(buffer, extname.fbe_offset() + extname.fbe_size())
{}

size_t FieldModel_pg_query_AlterObjectDependsStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + object_type.fbe_size()
        + relation.fbe_size()
        + object.fbe_size()
        + extname.fbe_size()
        + remove.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterObjectDependsStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + object_type.fbe_extra()
        + relation.fbe_extra()
        + object.fbe_extra()
        + extname.fbe_extra()
        + remove.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterObjectDependsStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterObjectDependsStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + object_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!object_type.verify())
        return false;
    fbe_current_size += object_type.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + object.fbe_size()) > fbe_struct_size)
        return true;
    if (!object.verify())
        return false;
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + extname.fbe_size()) > fbe_struct_size)
        return true;
    if (!extname.verify())
        return false;
    fbe_current_size += extname.fbe_size();

    if ((fbe_current_size + remove.fbe_size()) > fbe_struct_size)
        return true;
    if (!remove.verify())
        return false;
    fbe_current_size += remove.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterObjectDependsStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterObjectDependsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterObjectDependsStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterObjectDependsStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterObjectDependsStmt& fbe_value = static_cast<::pg_query::AlterObjectDependsStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + object_type.fbe_size()) <= fbe_struct_size)
        {
            object_type.get(fbe_value.object_type);
        }
    else
        fbe_value.object_type = ::pg_query::ObjectType();
    fbe_current_size += object_type.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + object.fbe_size()) <= fbe_struct_size)
        {
            object.get(fbe_value.object);
        }
    else
        fbe_value.object = ::pg_query::Node();
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + extname.fbe_size()) <= fbe_struct_size)
        {
            extname.get(fbe_value.extname);
        }
    else
        fbe_value.extname = ::pg_query::Node();
    fbe_current_size += extname.fbe_size();

    if ((fbe_current_size + remove.fbe_size()) <= fbe_struct_size)
        {
            remove.get(fbe_value.remove);
        }
    else
        fbe_value.remove = false;
    fbe_current_size += remove.fbe_size();
}

size_t FieldModel_pg_query_AlterObjectDependsStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterObjectDependsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterObjectDependsStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterObjectDependsStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterObjectDependsStmt& fbe_value = static_cast<const ::pg_query::AlterObjectDependsStmt&>(base_fbe_value);
    object_type.set(fbe_value.object_type);
    relation.set(fbe_value.relation);
    object.set(fbe_value.object);
    extname.set(fbe_value.extname);
    remove.set(fbe_value.remove);
}

namespace pg_query {

bool AlterObjectDependsStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterObjectDependsStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterObjectDependsStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterObjectDependsStmtModel::serialize(const ::pg_query::AlterObjectDependsStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterObjectDependsStmtModel::deserialize(::pg_query::AlterObjectDependsStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterObjectSchemaStmt::FieldModelPtr_pg_query_AlterObjectSchemaStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterObjectSchemaStmt::~FieldModelPtr_pg_query_AlterObjectSchemaStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterObjectSchemaStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterObjectSchemaStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterObjectSchemaStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterObjectSchemaStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterObjectSchemaStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterObjectSchemaStmt::get(::pg_query::AlterObjectSchemaStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterObjectSchemaStmt(_buffer, 0);

    ::pg_query::AlterObjectSchemaStmt *tempModel = new ::pg_query::AlterObjectSchemaStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterObjectSchemaStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterObjectSchemaStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterObjectSchemaStmt::set(const ::pg_query::AlterObjectSchemaStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterObjectSchemaStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterObjectSchemaStmt::FieldModel_pg_query_AlterObjectSchemaStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , object_type(buffer, 4 + 4)
    , relation(buffer, object_type.fbe_offset() + object_type.fbe_size())
    , object(buffer, relation.fbe_offset() + relation.fbe_size())
    , newschema(buffer, object.fbe_offset() + object.fbe_size())
    , missing_ok(buffer, newschema.fbe_offset() + newschema.fbe_size())
{}

size_t FieldModel_pg_query_AlterObjectSchemaStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + object_type.fbe_size()
        + relation.fbe_size()
        + object.fbe_size()
        + newschema.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterObjectSchemaStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + object_type.fbe_extra()
        + relation.fbe_extra()
        + object.fbe_extra()
        + newschema.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterObjectSchemaStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterObjectSchemaStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + object_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!object_type.verify())
        return false;
    fbe_current_size += object_type.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + object.fbe_size()) > fbe_struct_size)
        return true;
    if (!object.verify())
        return false;
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + newschema.fbe_size()) > fbe_struct_size)
        return true;
    if (!newschema.verify())
        return false;
    fbe_current_size += newschema.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterObjectSchemaStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterObjectSchemaStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterObjectSchemaStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterObjectSchemaStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterObjectSchemaStmt& fbe_value = static_cast<::pg_query::AlterObjectSchemaStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + object_type.fbe_size()) <= fbe_struct_size)
        {
            object_type.get(fbe_value.object_type);
        }
    else
        fbe_value.object_type = ::pg_query::ObjectType();
    fbe_current_size += object_type.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + object.fbe_size()) <= fbe_struct_size)
        {
            object.get(fbe_value.object);
        }
    else
        fbe_value.object = ::pg_query::Node();
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + newschema.fbe_size()) <= fbe_struct_size)
        {
            newschema.get(fbe_value.newschema);
        }
    else
        fbe_value.newschema = "";
    fbe_current_size += newschema.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_AlterObjectSchemaStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterObjectSchemaStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterObjectSchemaStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterObjectSchemaStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterObjectSchemaStmt& fbe_value = static_cast<const ::pg_query::AlterObjectSchemaStmt&>(base_fbe_value);
    object_type.set(fbe_value.object_type);
    relation.set(fbe_value.relation);
    object.set(fbe_value.object);
    newschema.set(fbe_value.newschema);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool AlterObjectSchemaStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterObjectSchemaStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterObjectSchemaStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterObjectSchemaStmtModel::serialize(const ::pg_query::AlterObjectSchemaStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterObjectSchemaStmtModel::deserialize(::pg_query::AlterObjectSchemaStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterOwnerStmt::FieldModelPtr_pg_query_AlterOwnerStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterOwnerStmt::~FieldModelPtr_pg_query_AlterOwnerStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterOwnerStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterOwnerStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterOwnerStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterOwnerStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterOwnerStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterOwnerStmt::get(::pg_query::AlterOwnerStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterOwnerStmt(_buffer, 0);

    ::pg_query::AlterOwnerStmt *tempModel = new ::pg_query::AlterOwnerStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterOwnerStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterOwnerStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterOwnerStmt::set(const ::pg_query::AlterOwnerStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterOwnerStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterOwnerStmt::FieldModel_pg_query_AlterOwnerStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , object_type(buffer, 4 + 4)
    , relation(buffer, object_type.fbe_offset() + object_type.fbe_size())
    , object(buffer, relation.fbe_offset() + relation.fbe_size())
    , newowner(buffer, object.fbe_offset() + object.fbe_size())
{}

size_t FieldModel_pg_query_AlterOwnerStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + object_type.fbe_size()
        + relation.fbe_size()
        + object.fbe_size()
        + newowner.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterOwnerStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + object_type.fbe_extra()
        + relation.fbe_extra()
        + object.fbe_extra()
        + newowner.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterOwnerStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterOwnerStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + object_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!object_type.verify())
        return false;
    fbe_current_size += object_type.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + object.fbe_size()) > fbe_struct_size)
        return true;
    if (!object.verify())
        return false;
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + newowner.fbe_size()) > fbe_struct_size)
        return true;
    if (!newowner.verify())
        return false;
    fbe_current_size += newowner.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterOwnerStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterOwnerStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterOwnerStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterOwnerStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterOwnerStmt& fbe_value = static_cast<::pg_query::AlterOwnerStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + object_type.fbe_size()) <= fbe_struct_size)
        {
            object_type.get(fbe_value.object_type);
        }
    else
        fbe_value.object_type = ::pg_query::ObjectType();
    fbe_current_size += object_type.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + object.fbe_size()) <= fbe_struct_size)
        {
            object.get(fbe_value.object);
        }
    else
        fbe_value.object = ::pg_query::Node();
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + newowner.fbe_size()) <= fbe_struct_size)
        {
            newowner.get(&fbe_value.newowner);
        }
    else
        fbe_value.newowner = nullptr;
    fbe_current_size += newowner.fbe_size();
}

size_t FieldModel_pg_query_AlterOwnerStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterOwnerStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterOwnerStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterOwnerStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterOwnerStmt& fbe_value = static_cast<const ::pg_query::AlterOwnerStmt&>(base_fbe_value);
    object_type.set(fbe_value.object_type);
    relation.set(fbe_value.relation);
    object.set(fbe_value.object);
    newowner.set(fbe_value.newowner);
}

namespace pg_query {

bool AlterOwnerStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterOwnerStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterOwnerStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterOwnerStmtModel::serialize(const ::pg_query::AlterOwnerStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterOwnerStmtModel::deserialize(::pg_query::AlterOwnerStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterOperatorStmt::FieldModelPtr_pg_query_AlterOperatorStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterOperatorStmt::~FieldModelPtr_pg_query_AlterOperatorStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterOperatorStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterOperatorStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterOperatorStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterOperatorStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterOperatorStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterOperatorStmt::get(::pg_query::AlterOperatorStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterOperatorStmt(_buffer, 0);

    ::pg_query::AlterOperatorStmt *tempModel = new ::pg_query::AlterOperatorStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterOperatorStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterOperatorStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterOperatorStmt::set(const ::pg_query::AlterOperatorStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterOperatorStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterOperatorStmt::FieldModel_pg_query_AlterOperatorStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , opername(buffer, 4 + 4)
    , options(buffer, opername.fbe_offset() + opername.fbe_size())
{}

size_t FieldModel_pg_query_AlterOperatorStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + opername.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterOperatorStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + opername.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterOperatorStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterOperatorStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + opername.fbe_size()) > fbe_struct_size)
        return true;
    if (!opername.verify())
        return false;
    fbe_current_size += opername.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterOperatorStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterOperatorStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterOperatorStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterOperatorStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterOperatorStmt& fbe_value = static_cast<::pg_query::AlterOperatorStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + opername.fbe_size()) <= fbe_struct_size)
        {
            opername.get(&fbe_value.opername);
        }
    else
        fbe_value.opername = nullptr;
    fbe_current_size += opername.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_AlterOperatorStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterOperatorStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterOperatorStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterOperatorStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterOperatorStmt& fbe_value = static_cast<const ::pg_query::AlterOperatorStmt&>(base_fbe_value);
    opername.set(fbe_value.opername);
    options.set(fbe_value.options);
}

namespace pg_query {

bool AlterOperatorStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterOperatorStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterOperatorStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterOperatorStmtModel::serialize(const ::pg_query::AlterOperatorStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterOperatorStmtModel::deserialize(::pg_query::AlterOperatorStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterTypeStmt::FieldModelPtr_pg_query_AlterTypeStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterTypeStmt::~FieldModelPtr_pg_query_AlterTypeStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterTypeStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTypeStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTypeStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterTypeStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTypeStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTypeStmt::get(::pg_query::AlterTypeStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterTypeStmt(_buffer, 0);

    ::pg_query::AlterTypeStmt *tempModel = new ::pg_query::AlterTypeStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterTypeStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTypeStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTypeStmt::set(const ::pg_query::AlterTypeStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterTypeStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterTypeStmt::FieldModel_pg_query_AlterTypeStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , type_name(buffer, 4 + 4)
    , options(buffer, type_name.fbe_offset() + type_name.fbe_size())
{}

size_t FieldModel_pg_query_AlterTypeStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + type_name.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterTypeStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + type_name.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterTypeStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterTypeStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterTypeStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTypeStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTypeStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterTypeStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterTypeStmt& fbe_value = static_cast<::pg_query::AlterTypeStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(fbe_value.type_name);
        }
    else
        fbe_value.type_name.clear();
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_AlterTypeStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTypeStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTypeStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterTypeStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterTypeStmt& fbe_value = static_cast<const ::pg_query::AlterTypeStmt&>(base_fbe_value);
    type_name.set(fbe_value.type_name);
    options.set(fbe_value.options);
}

namespace pg_query {

bool AlterTypeStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterTypeStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterTypeStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterTypeStmtModel::serialize(const ::pg_query::AlterTypeStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterTypeStmtModel::deserialize(::pg_query::AlterTypeStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DropOwnedStmt::FieldModelPtr_pg_query_DropOwnedStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DropOwnedStmt::~FieldModelPtr_pg_query_DropOwnedStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DropOwnedStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DropOwnedStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DropOwnedStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DropOwnedStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropOwnedStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropOwnedStmt::get(::pg_query::DropOwnedStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DropOwnedStmt(_buffer, 0);

    ::pg_query::DropOwnedStmt *tempModel = new ::pg_query::DropOwnedStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DropOwnedStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropOwnedStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropOwnedStmt::set(const ::pg_query::DropOwnedStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DropOwnedStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DropOwnedStmt::FieldModel_pg_query_DropOwnedStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , roles(buffer, 4 + 4)
    , behavior(buffer, roles.fbe_offset() + roles.fbe_size())
{}

size_t FieldModel_pg_query_DropOwnedStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + roles.fbe_size()
        + behavior.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DropOwnedStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + roles.fbe_extra()
        + behavior.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DropOwnedStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DropOwnedStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + roles.fbe_size()) > fbe_struct_size)
        return true;
    if (!roles.verify())
        return false;
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) > fbe_struct_size)
        return true;
    if (!behavior.verify())
        return false;
    fbe_current_size += behavior.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DropOwnedStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropOwnedStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropOwnedStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DropOwnedStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DropOwnedStmt& fbe_value = static_cast<::pg_query::DropOwnedStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + roles.fbe_size()) <= fbe_struct_size)
        {
            roles.get(fbe_value.roles);
        }
    else
        fbe_value.roles.clear();
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) <= fbe_struct_size)
        {
            behavior.get(fbe_value.behavior);
        }
    else
        fbe_value.behavior = ::pg_query::DropBehavior();
    fbe_current_size += behavior.fbe_size();
}

size_t FieldModel_pg_query_DropOwnedStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropOwnedStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropOwnedStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DropOwnedStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DropOwnedStmt& fbe_value = static_cast<const ::pg_query::DropOwnedStmt&>(base_fbe_value);
    roles.set(fbe_value.roles);
    behavior.set(fbe_value.behavior);
}

namespace pg_query {

bool DropOwnedStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DropOwnedStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DropOwnedStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DropOwnedStmtModel::serialize(const ::pg_query::DropOwnedStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DropOwnedStmtModel::deserialize(::pg_query::DropOwnedStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ReassignOwnedStmt::FieldModelPtr_pg_query_ReassignOwnedStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ReassignOwnedStmt::~FieldModelPtr_pg_query_ReassignOwnedStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ReassignOwnedStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ReassignOwnedStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ReassignOwnedStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ReassignOwnedStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ReassignOwnedStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ReassignOwnedStmt::get(::pg_query::ReassignOwnedStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ReassignOwnedStmt(_buffer, 0);

    ::pg_query::ReassignOwnedStmt *tempModel = new ::pg_query::ReassignOwnedStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ReassignOwnedStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ReassignOwnedStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ReassignOwnedStmt::set(const ::pg_query::ReassignOwnedStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ReassignOwnedStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ReassignOwnedStmt::FieldModel_pg_query_ReassignOwnedStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , roles(buffer, 4 + 4)
    , newrole(buffer, roles.fbe_offset() + roles.fbe_size())
{}

size_t FieldModel_pg_query_ReassignOwnedStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + roles.fbe_size()
        + newrole.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ReassignOwnedStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + roles.fbe_extra()
        + newrole.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ReassignOwnedStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ReassignOwnedStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + roles.fbe_size()) > fbe_struct_size)
        return true;
    if (!roles.verify())
        return false;
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + newrole.fbe_size()) > fbe_struct_size)
        return true;
    if (!newrole.verify())
        return false;
    fbe_current_size += newrole.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ReassignOwnedStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ReassignOwnedStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ReassignOwnedStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ReassignOwnedStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ReassignOwnedStmt& fbe_value = static_cast<::pg_query::ReassignOwnedStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + roles.fbe_size()) <= fbe_struct_size)
        {
            roles.get(fbe_value.roles);
        }
    else
        fbe_value.roles.clear();
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + newrole.fbe_size()) <= fbe_struct_size)
        {
            newrole.get(&fbe_value.newrole);
        }
    else
        fbe_value.newrole = nullptr;
    fbe_current_size += newrole.fbe_size();
}

size_t FieldModel_pg_query_ReassignOwnedStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ReassignOwnedStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ReassignOwnedStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ReassignOwnedStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ReassignOwnedStmt& fbe_value = static_cast<const ::pg_query::ReassignOwnedStmt&>(base_fbe_value);
    roles.set(fbe_value.roles);
    newrole.set(fbe_value.newrole);
}

namespace pg_query {

bool ReassignOwnedStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ReassignOwnedStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ReassignOwnedStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ReassignOwnedStmtModel::serialize(const ::pg_query::ReassignOwnedStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ReassignOwnedStmtModel::deserialize(::pg_query::ReassignOwnedStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CompositeTypeStmt::FieldModelPtr_pg_query_CompositeTypeStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CompositeTypeStmt::~FieldModelPtr_pg_query_CompositeTypeStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CompositeTypeStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CompositeTypeStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CompositeTypeStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CompositeTypeStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CompositeTypeStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CompositeTypeStmt::get(::pg_query::CompositeTypeStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CompositeTypeStmt(_buffer, 0);

    ::pg_query::CompositeTypeStmt *tempModel = new ::pg_query::CompositeTypeStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CompositeTypeStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CompositeTypeStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CompositeTypeStmt::set(const ::pg_query::CompositeTypeStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CompositeTypeStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CompositeTypeStmt::FieldModel_pg_query_CompositeTypeStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , typevar(buffer, 4 + 4)
    , coldeflist(buffer, typevar.fbe_offset() + typevar.fbe_size())
{}

size_t FieldModel_pg_query_CompositeTypeStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + typevar.fbe_size()
        + coldeflist.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CompositeTypeStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + typevar.fbe_extra()
        + coldeflist.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CompositeTypeStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CompositeTypeStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + typevar.fbe_size()) > fbe_struct_size)
        return true;
    if (!typevar.verify())
        return false;
    fbe_current_size += typevar.fbe_size();

    if ((fbe_current_size + coldeflist.fbe_size()) > fbe_struct_size)
        return true;
    if (!coldeflist.verify())
        return false;
    fbe_current_size += coldeflist.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CompositeTypeStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CompositeTypeStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CompositeTypeStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CompositeTypeStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CompositeTypeStmt& fbe_value = static_cast<::pg_query::CompositeTypeStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + typevar.fbe_size()) <= fbe_struct_size)
        {
            typevar.get(&fbe_value.typevar);
        }
    else
        fbe_value.typevar = nullptr;
    fbe_current_size += typevar.fbe_size();

    if ((fbe_current_size + coldeflist.fbe_size()) <= fbe_struct_size)
        {
            coldeflist.get(fbe_value.coldeflist);
        }
    else
        fbe_value.coldeflist.clear();
    fbe_current_size += coldeflist.fbe_size();
}

size_t FieldModel_pg_query_CompositeTypeStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CompositeTypeStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CompositeTypeStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CompositeTypeStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CompositeTypeStmt& fbe_value = static_cast<const ::pg_query::CompositeTypeStmt&>(base_fbe_value);
    typevar.set(fbe_value.typevar);
    coldeflist.set(fbe_value.coldeflist);
}

namespace pg_query {

bool CompositeTypeStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CompositeTypeStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CompositeTypeStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CompositeTypeStmtModel::serialize(const ::pg_query::CompositeTypeStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CompositeTypeStmtModel::deserialize(::pg_query::CompositeTypeStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateEnumStmt::FieldModelPtr_pg_query_CreateEnumStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateEnumStmt::~FieldModelPtr_pg_query_CreateEnumStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateEnumStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateEnumStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateEnumStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateEnumStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateEnumStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateEnumStmt::get(::pg_query::CreateEnumStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateEnumStmt(_buffer, 0);

    ::pg_query::CreateEnumStmt *tempModel = new ::pg_query::CreateEnumStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateEnumStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateEnumStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateEnumStmt::set(const ::pg_query::CreateEnumStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateEnumStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateEnumStmt::FieldModel_pg_query_CreateEnumStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , type_name(buffer, 4 + 4)
    , vals(buffer, type_name.fbe_offset() + type_name.fbe_size())
{}

size_t FieldModel_pg_query_CreateEnumStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + type_name.fbe_size()
        + vals.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateEnumStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + type_name.fbe_extra()
        + vals.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateEnumStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateEnumStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + vals.fbe_size()) > fbe_struct_size)
        return true;
    if (!vals.verify())
        return false;
    fbe_current_size += vals.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateEnumStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateEnumStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateEnumStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateEnumStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateEnumStmt& fbe_value = static_cast<::pg_query::CreateEnumStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(fbe_value.type_name);
        }
    else
        fbe_value.type_name.clear();
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + vals.fbe_size()) <= fbe_struct_size)
        {
            vals.get(fbe_value.vals);
        }
    else
        fbe_value.vals.clear();
    fbe_current_size += vals.fbe_size();
}

size_t FieldModel_pg_query_CreateEnumStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateEnumStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateEnumStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateEnumStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateEnumStmt& fbe_value = static_cast<const ::pg_query::CreateEnumStmt&>(base_fbe_value);
    type_name.set(fbe_value.type_name);
    vals.set(fbe_value.vals);
}

namespace pg_query {

bool CreateEnumStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateEnumStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateEnumStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateEnumStmtModel::serialize(const ::pg_query::CreateEnumStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateEnumStmtModel::deserialize(::pg_query::CreateEnumStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateRangeStmt::FieldModelPtr_pg_query_CreateRangeStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateRangeStmt::~FieldModelPtr_pg_query_CreateRangeStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateRangeStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateRangeStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateRangeStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateRangeStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateRangeStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateRangeStmt::get(::pg_query::CreateRangeStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateRangeStmt(_buffer, 0);

    ::pg_query::CreateRangeStmt *tempModel = new ::pg_query::CreateRangeStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateRangeStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateRangeStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateRangeStmt::set(const ::pg_query::CreateRangeStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateRangeStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateRangeStmt::FieldModel_pg_query_CreateRangeStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , type_name(buffer, 4 + 4)
    , params(buffer, type_name.fbe_offset() + type_name.fbe_size())
{}

size_t FieldModel_pg_query_CreateRangeStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + type_name.fbe_size()
        + params.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateRangeStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + type_name.fbe_extra()
        + params.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateRangeStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateRangeStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + params.fbe_size()) > fbe_struct_size)
        return true;
    if (!params.verify())
        return false;
    fbe_current_size += params.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateRangeStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateRangeStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateRangeStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateRangeStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateRangeStmt& fbe_value = static_cast<::pg_query::CreateRangeStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(fbe_value.type_name);
        }
    else
        fbe_value.type_name.clear();
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + params.fbe_size()) <= fbe_struct_size)
        {
            params.get(fbe_value.params);
        }
    else
        fbe_value.params.clear();
    fbe_current_size += params.fbe_size();
}

size_t FieldModel_pg_query_CreateRangeStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateRangeStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateRangeStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateRangeStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateRangeStmt& fbe_value = static_cast<const ::pg_query::CreateRangeStmt&>(base_fbe_value);
    type_name.set(fbe_value.type_name);
    params.set(fbe_value.params);
}

namespace pg_query {

bool CreateRangeStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateRangeStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateRangeStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateRangeStmtModel::serialize(const ::pg_query::CreateRangeStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateRangeStmtModel::deserialize(::pg_query::CreateRangeStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterEnumStmt::FieldModelPtr_pg_query_AlterEnumStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterEnumStmt::~FieldModelPtr_pg_query_AlterEnumStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterEnumStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterEnumStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterEnumStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterEnumStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterEnumStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterEnumStmt::get(::pg_query::AlterEnumStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterEnumStmt(_buffer, 0);

    ::pg_query::AlterEnumStmt *tempModel = new ::pg_query::AlterEnumStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterEnumStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterEnumStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterEnumStmt::set(const ::pg_query::AlterEnumStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterEnumStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterEnumStmt::FieldModel_pg_query_AlterEnumStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , type_name(buffer, 4 + 4)
    , old_val(buffer, type_name.fbe_offset() + type_name.fbe_size())
    , new_val(buffer, old_val.fbe_offset() + old_val.fbe_size())
    , new_val_neighbor(buffer, new_val.fbe_offset() + new_val.fbe_size())
    , new_val_is_after(buffer, new_val_neighbor.fbe_offset() + new_val_neighbor.fbe_size())
    , skip_if_new_val_exists(buffer, new_val_is_after.fbe_offset() + new_val_is_after.fbe_size())
{}

size_t FieldModel_pg_query_AlterEnumStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + type_name.fbe_size()
        + old_val.fbe_size()
        + new_val.fbe_size()
        + new_val_neighbor.fbe_size()
        + new_val_is_after.fbe_size()
        + skip_if_new_val_exists.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterEnumStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + type_name.fbe_extra()
        + old_val.fbe_extra()
        + new_val.fbe_extra()
        + new_val_neighbor.fbe_extra()
        + new_val_is_after.fbe_extra()
        + skip_if_new_val_exists.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterEnumStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterEnumStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + old_val.fbe_size()) > fbe_struct_size)
        return true;
    if (!old_val.verify())
        return false;
    fbe_current_size += old_val.fbe_size();

    if ((fbe_current_size + new_val.fbe_size()) > fbe_struct_size)
        return true;
    if (!new_val.verify())
        return false;
    fbe_current_size += new_val.fbe_size();

    if ((fbe_current_size + new_val_neighbor.fbe_size()) > fbe_struct_size)
        return true;
    if (!new_val_neighbor.verify())
        return false;
    fbe_current_size += new_val_neighbor.fbe_size();

    if ((fbe_current_size + new_val_is_after.fbe_size()) > fbe_struct_size)
        return true;
    if (!new_val_is_after.verify())
        return false;
    fbe_current_size += new_val_is_after.fbe_size();

    if ((fbe_current_size + skip_if_new_val_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!skip_if_new_val_exists.verify())
        return false;
    fbe_current_size += skip_if_new_val_exists.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterEnumStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterEnumStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterEnumStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterEnumStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterEnumStmt& fbe_value = static_cast<::pg_query::AlterEnumStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(fbe_value.type_name);
        }
    else
        fbe_value.type_name.clear();
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + old_val.fbe_size()) <= fbe_struct_size)
        {
            old_val.get(fbe_value.old_val);
        }
    else
        fbe_value.old_val = "";
    fbe_current_size += old_val.fbe_size();

    if ((fbe_current_size + new_val.fbe_size()) <= fbe_struct_size)
        {
            new_val.get(fbe_value.new_val);
        }
    else
        fbe_value.new_val = "";
    fbe_current_size += new_val.fbe_size();

    if ((fbe_current_size + new_val_neighbor.fbe_size()) <= fbe_struct_size)
        {
            new_val_neighbor.get(fbe_value.new_val_neighbor);
        }
    else
        fbe_value.new_val_neighbor = "";
    fbe_current_size += new_val_neighbor.fbe_size();

    if ((fbe_current_size + new_val_is_after.fbe_size()) <= fbe_struct_size)
        {
            new_val_is_after.get(fbe_value.new_val_is_after);
        }
    else
        fbe_value.new_val_is_after = false;
    fbe_current_size += new_val_is_after.fbe_size();

    if ((fbe_current_size + skip_if_new_val_exists.fbe_size()) <= fbe_struct_size)
        {
            skip_if_new_val_exists.get(fbe_value.skip_if_new_val_exists);
        }
    else
        fbe_value.skip_if_new_val_exists = false;
    fbe_current_size += skip_if_new_val_exists.fbe_size();
}

size_t FieldModel_pg_query_AlterEnumStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterEnumStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterEnumStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterEnumStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterEnumStmt& fbe_value = static_cast<const ::pg_query::AlterEnumStmt&>(base_fbe_value);
    type_name.set(fbe_value.type_name);
    old_val.set(fbe_value.old_val);
    new_val.set(fbe_value.new_val);
    new_val_neighbor.set(fbe_value.new_val_neighbor);
    new_val_is_after.set(fbe_value.new_val_is_after);
    skip_if_new_val_exists.set(fbe_value.skip_if_new_val_exists);
}

namespace pg_query {

bool AlterEnumStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterEnumStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterEnumStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterEnumStmtModel::serialize(const ::pg_query::AlterEnumStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterEnumStmtModel::deserialize(::pg_query::AlterEnumStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterTSDictionaryStmt::FieldModelPtr_pg_query_AlterTSDictionaryStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterTSDictionaryStmt::~FieldModelPtr_pg_query_AlterTSDictionaryStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterTSDictionaryStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTSDictionaryStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTSDictionaryStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterTSDictionaryStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTSDictionaryStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTSDictionaryStmt::get(::pg_query::AlterTSDictionaryStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterTSDictionaryStmt(_buffer, 0);

    ::pg_query::AlterTSDictionaryStmt *tempModel = new ::pg_query::AlterTSDictionaryStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterTSDictionaryStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTSDictionaryStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTSDictionaryStmt::set(const ::pg_query::AlterTSDictionaryStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterTSDictionaryStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterTSDictionaryStmt::FieldModel_pg_query_AlterTSDictionaryStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , dictname(buffer, 4 + 4)
    , options(buffer, dictname.fbe_offset() + dictname.fbe_size())
{}

size_t FieldModel_pg_query_AlterTSDictionaryStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + dictname.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterTSDictionaryStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + dictname.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterTSDictionaryStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterTSDictionaryStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dictname.fbe_size()) > fbe_struct_size)
        return true;
    if (!dictname.verify())
        return false;
    fbe_current_size += dictname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterTSDictionaryStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTSDictionaryStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTSDictionaryStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterTSDictionaryStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterTSDictionaryStmt& fbe_value = static_cast<::pg_query::AlterTSDictionaryStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + dictname.fbe_size()) <= fbe_struct_size)
        {
            dictname.get(fbe_value.dictname);
        }
    else
        fbe_value.dictname.clear();
    fbe_current_size += dictname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_AlterTSDictionaryStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTSDictionaryStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTSDictionaryStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterTSDictionaryStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterTSDictionaryStmt& fbe_value = static_cast<const ::pg_query::AlterTSDictionaryStmt&>(base_fbe_value);
    dictname.set(fbe_value.dictname);
    options.set(fbe_value.options);
}

namespace pg_query {

bool AlterTSDictionaryStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterTSDictionaryStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterTSDictionaryStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterTSDictionaryStmtModel::serialize(const ::pg_query::AlterTSDictionaryStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterTSDictionaryStmtModel::deserialize(::pg_query::AlterTSDictionaryStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterTSConfigurationStmt::FieldModelPtr_pg_query_AlterTSConfigurationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterTSConfigurationStmt::~FieldModelPtr_pg_query_AlterTSConfigurationStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterTSConfigurationStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTSConfigurationStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTSConfigurationStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterTSConfigurationStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTSConfigurationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTSConfigurationStmt::get(::pg_query::AlterTSConfigurationStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterTSConfigurationStmt(_buffer, 0);

    ::pg_query::AlterTSConfigurationStmt *tempModel = new ::pg_query::AlterTSConfigurationStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterTSConfigurationStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTSConfigurationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTSConfigurationStmt::set(const ::pg_query::AlterTSConfigurationStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterTSConfigurationStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterTSConfigurationStmt::FieldModel_pg_query_AlterTSConfigurationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , cfgname(buffer, kind.fbe_offset() + kind.fbe_size())
    , tokentype(buffer, cfgname.fbe_offset() + cfgname.fbe_size())
    , dicts(buffer, tokentype.fbe_offset() + tokentype.fbe_size())
    , override(buffer, dicts.fbe_offset() + dicts.fbe_size())
    , replace(buffer, override.fbe_offset() + override.fbe_size())
    , missing_ok(buffer, replace.fbe_offset() + replace.fbe_size())
{}

size_t FieldModel_pg_query_AlterTSConfigurationStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + cfgname.fbe_size()
        + tokentype.fbe_size()
        + dicts.fbe_size()
        + override.fbe_size()
        + replace.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterTSConfigurationStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + cfgname.fbe_extra()
        + tokentype.fbe_extra()
        + dicts.fbe_extra()
        + override.fbe_extra()
        + replace.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterTSConfigurationStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterTSConfigurationStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + cfgname.fbe_size()) > fbe_struct_size)
        return true;
    if (!cfgname.verify())
        return false;
    fbe_current_size += cfgname.fbe_size();

    if ((fbe_current_size + tokentype.fbe_size()) > fbe_struct_size)
        return true;
    if (!tokentype.verify())
        return false;
    fbe_current_size += tokentype.fbe_size();

    if ((fbe_current_size + dicts.fbe_size()) > fbe_struct_size)
        return true;
    if (!dicts.verify())
        return false;
    fbe_current_size += dicts.fbe_size();

    if ((fbe_current_size + override.fbe_size()) > fbe_struct_size)
        return true;
    if (!override.verify())
        return false;
    fbe_current_size += override.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) > fbe_struct_size)
        return true;
    if (!replace.verify())
        return false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterTSConfigurationStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTSConfigurationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTSConfigurationStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterTSConfigurationStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterTSConfigurationStmt& fbe_value = static_cast<::pg_query::AlterTSConfigurationStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::AlterTSConfigType();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + cfgname.fbe_size()) <= fbe_struct_size)
        {
            cfgname.get(fbe_value.cfgname);
        }
    else
        fbe_value.cfgname.clear();
    fbe_current_size += cfgname.fbe_size();

    if ((fbe_current_size + tokentype.fbe_size()) <= fbe_struct_size)
        {
            tokentype.get(fbe_value.tokentype);
        }
    else
        fbe_value.tokentype.clear();
    fbe_current_size += tokentype.fbe_size();

    if ((fbe_current_size + dicts.fbe_size()) <= fbe_struct_size)
        {
            dicts.get(fbe_value.dicts);
        }
    else
        fbe_value.dicts.clear();
    fbe_current_size += dicts.fbe_size();

    if ((fbe_current_size + override.fbe_size()) <= fbe_struct_size)
        {
            override.get(fbe_value.override);
        }
    else
        fbe_value.override = false;
    fbe_current_size += override.fbe_size();

    if ((fbe_current_size + replace.fbe_size()) <= fbe_struct_size)
        {
            replace.get(fbe_value.replace);
        }
    else
        fbe_value.replace = false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_AlterTSConfigurationStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTSConfigurationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTSConfigurationStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterTSConfigurationStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterTSConfigurationStmt& fbe_value = static_cast<const ::pg_query::AlterTSConfigurationStmt&>(base_fbe_value);
    kind.set(fbe_value.kind);
    cfgname.set(fbe_value.cfgname);
    tokentype.set(fbe_value.tokentype);
    dicts.set(fbe_value.dicts);
    override.set(fbe_value.override);
    replace.set(fbe_value.replace);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool AlterTSConfigurationStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterTSConfigurationStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterTSConfigurationStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterTSConfigurationStmtModel::serialize(const ::pg_query::AlterTSConfigurationStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterTSConfigurationStmtModel::deserialize(::pg_query::AlterTSConfigurationStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateFdwStmt::FieldModelPtr_pg_query_CreateFdwStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateFdwStmt::~FieldModelPtr_pg_query_CreateFdwStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateFdwStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateFdwStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateFdwStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateFdwStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateFdwStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateFdwStmt::get(::pg_query::CreateFdwStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateFdwStmt(_buffer, 0);

    ::pg_query::CreateFdwStmt *tempModel = new ::pg_query::CreateFdwStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateFdwStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateFdwStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateFdwStmt::set(const ::pg_query::CreateFdwStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateFdwStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateFdwStmt::FieldModel_pg_query_CreateFdwStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , fdwname(buffer, 4 + 4)
    , func_options(buffer, fdwname.fbe_offset() + fdwname.fbe_size())
    , options(buffer, func_options.fbe_offset() + func_options.fbe_size())
{}

size_t FieldModel_pg_query_CreateFdwStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + fdwname.fbe_size()
        + func_options.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateFdwStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + fdwname.fbe_extra()
        + func_options.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateFdwStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateFdwStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + fdwname.fbe_size()) > fbe_struct_size)
        return true;
    if (!fdwname.verify())
        return false;
    fbe_current_size += fdwname.fbe_size();

    if ((fbe_current_size + func_options.fbe_size()) > fbe_struct_size)
        return true;
    if (!func_options.verify())
        return false;
    fbe_current_size += func_options.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateFdwStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateFdwStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateFdwStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateFdwStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateFdwStmt& fbe_value = static_cast<::pg_query::CreateFdwStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + fdwname.fbe_size()) <= fbe_struct_size)
        {
            fdwname.get(fbe_value.fdwname);
        }
    else
        fbe_value.fdwname = "";
    fbe_current_size += fdwname.fbe_size();

    if ((fbe_current_size + func_options.fbe_size()) <= fbe_struct_size)
        {
            func_options.get(fbe_value.func_options);
        }
    else
        fbe_value.func_options.clear();
    fbe_current_size += func_options.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreateFdwStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateFdwStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateFdwStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateFdwStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateFdwStmt& fbe_value = static_cast<const ::pg_query::CreateFdwStmt&>(base_fbe_value);
    fdwname.set(fbe_value.fdwname);
    func_options.set(fbe_value.func_options);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreateFdwStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateFdwStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateFdwStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateFdwStmtModel::serialize(const ::pg_query::CreateFdwStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateFdwStmtModel::deserialize(::pg_query::CreateFdwStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterFdwStmt::FieldModelPtr_pg_query_AlterFdwStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterFdwStmt::~FieldModelPtr_pg_query_AlterFdwStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterFdwStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterFdwStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterFdwStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterFdwStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterFdwStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterFdwStmt::get(::pg_query::AlterFdwStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterFdwStmt(_buffer, 0);

    ::pg_query::AlterFdwStmt *tempModel = new ::pg_query::AlterFdwStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterFdwStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterFdwStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterFdwStmt::set(const ::pg_query::AlterFdwStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterFdwStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterFdwStmt::FieldModel_pg_query_AlterFdwStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , fdwname(buffer, 4 + 4)
    , func_options(buffer, fdwname.fbe_offset() + fdwname.fbe_size())
    , options(buffer, func_options.fbe_offset() + func_options.fbe_size())
{}

size_t FieldModel_pg_query_AlterFdwStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + fdwname.fbe_size()
        + func_options.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterFdwStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + fdwname.fbe_extra()
        + func_options.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterFdwStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterFdwStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + fdwname.fbe_size()) > fbe_struct_size)
        return true;
    if (!fdwname.verify())
        return false;
    fbe_current_size += fdwname.fbe_size();

    if ((fbe_current_size + func_options.fbe_size()) > fbe_struct_size)
        return true;
    if (!func_options.verify())
        return false;
    fbe_current_size += func_options.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterFdwStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterFdwStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterFdwStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterFdwStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterFdwStmt& fbe_value = static_cast<::pg_query::AlterFdwStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + fdwname.fbe_size()) <= fbe_struct_size)
        {
            fdwname.get(fbe_value.fdwname);
        }
    else
        fbe_value.fdwname = "";
    fbe_current_size += fdwname.fbe_size();

    if ((fbe_current_size + func_options.fbe_size()) <= fbe_struct_size)
        {
            func_options.get(fbe_value.func_options);
        }
    else
        fbe_value.func_options.clear();
    fbe_current_size += func_options.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_AlterFdwStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterFdwStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterFdwStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterFdwStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterFdwStmt& fbe_value = static_cast<const ::pg_query::AlterFdwStmt&>(base_fbe_value);
    fdwname.set(fbe_value.fdwname);
    func_options.set(fbe_value.func_options);
    options.set(fbe_value.options);
}

namespace pg_query {

bool AlterFdwStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterFdwStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterFdwStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterFdwStmtModel::serialize(const ::pg_query::AlterFdwStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterFdwStmtModel::deserialize(::pg_query::AlterFdwStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateForeignServerStmt::FieldModelPtr_pg_query_CreateForeignServerStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateForeignServerStmt::~FieldModelPtr_pg_query_CreateForeignServerStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateForeignServerStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateForeignServerStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateForeignServerStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateForeignServerStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateForeignServerStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateForeignServerStmt::get(::pg_query::CreateForeignServerStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateForeignServerStmt(_buffer, 0);

    ::pg_query::CreateForeignServerStmt *tempModel = new ::pg_query::CreateForeignServerStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateForeignServerStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateForeignServerStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateForeignServerStmt::set(const ::pg_query::CreateForeignServerStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateForeignServerStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateForeignServerStmt::FieldModel_pg_query_CreateForeignServerStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , servername(buffer, 4 + 4)
    , servertype(buffer, servername.fbe_offset() + servername.fbe_size())
    , version(buffer, servertype.fbe_offset() + servertype.fbe_size())
    , fdwname(buffer, version.fbe_offset() + version.fbe_size())
    , if_not_exists(buffer, fdwname.fbe_offset() + fdwname.fbe_size())
    , options(buffer, if_not_exists.fbe_offset() + if_not_exists.fbe_size())
{}

size_t FieldModel_pg_query_CreateForeignServerStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + servername.fbe_size()
        + servertype.fbe_size()
        + version.fbe_size()
        + fdwname.fbe_size()
        + if_not_exists.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateForeignServerStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + servername.fbe_extra()
        + servertype.fbe_extra()
        + version.fbe_extra()
        + fdwname.fbe_extra()
        + if_not_exists.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateForeignServerStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateForeignServerStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + servername.fbe_size()) > fbe_struct_size)
        return true;
    if (!servername.verify())
        return false;
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + servertype.fbe_size()) > fbe_struct_size)
        return true;
    if (!servertype.verify())
        return false;
    fbe_current_size += servertype.fbe_size();

    if ((fbe_current_size + version.fbe_size()) > fbe_struct_size)
        return true;
    if (!version.verify())
        return false;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + fdwname.fbe_size()) > fbe_struct_size)
        return true;
    if (!fdwname.verify())
        return false;
    fbe_current_size += fdwname.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateForeignServerStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateForeignServerStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateForeignServerStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateForeignServerStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateForeignServerStmt& fbe_value = static_cast<::pg_query::CreateForeignServerStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + servername.fbe_size()) <= fbe_struct_size)
        {
            servername.get(fbe_value.servername);
        }
    else
        fbe_value.servername = "";
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + servertype.fbe_size()) <= fbe_struct_size)
        {
            servertype.get(fbe_value.servertype);
        }
    else
        fbe_value.servertype = "";
    fbe_current_size += servertype.fbe_size();

    if ((fbe_current_size + version.fbe_size()) <= fbe_struct_size)
        {
            version.get(fbe_value.version);
        }
    else
        fbe_value.version = "";
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + fdwname.fbe_size()) <= fbe_struct_size)
        {
            fdwname.get(fbe_value.fdwname);
        }
    else
        fbe_value.fdwname = "";
    fbe_current_size += fdwname.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreateForeignServerStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateForeignServerStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateForeignServerStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateForeignServerStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateForeignServerStmt& fbe_value = static_cast<const ::pg_query::CreateForeignServerStmt&>(base_fbe_value);
    servername.set(fbe_value.servername);
    servertype.set(fbe_value.servertype);
    version.set(fbe_value.version);
    fdwname.set(fbe_value.fdwname);
    if_not_exists.set(fbe_value.if_not_exists);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreateForeignServerStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateForeignServerStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateForeignServerStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateForeignServerStmtModel::serialize(const ::pg_query::CreateForeignServerStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateForeignServerStmtModel::deserialize(::pg_query::CreateForeignServerStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterForeignServerStmt::FieldModelPtr_pg_query_AlterForeignServerStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterForeignServerStmt::~FieldModelPtr_pg_query_AlterForeignServerStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterForeignServerStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterForeignServerStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterForeignServerStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterForeignServerStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterForeignServerStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterForeignServerStmt::get(::pg_query::AlterForeignServerStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterForeignServerStmt(_buffer, 0);

    ::pg_query::AlterForeignServerStmt *tempModel = new ::pg_query::AlterForeignServerStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterForeignServerStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterForeignServerStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterForeignServerStmt::set(const ::pg_query::AlterForeignServerStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterForeignServerStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterForeignServerStmt::FieldModel_pg_query_AlterForeignServerStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , servername(buffer, 4 + 4)
    , version(buffer, servername.fbe_offset() + servername.fbe_size())
    , options(buffer, version.fbe_offset() + version.fbe_size())
    , has_version(buffer, options.fbe_offset() + options.fbe_size())
{}

size_t FieldModel_pg_query_AlterForeignServerStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + servername.fbe_size()
        + version.fbe_size()
        + options.fbe_size()
        + has_version.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterForeignServerStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + servername.fbe_extra()
        + version.fbe_extra()
        + options.fbe_extra()
        + has_version.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterForeignServerStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterForeignServerStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + servername.fbe_size()) > fbe_struct_size)
        return true;
    if (!servername.verify())
        return false;
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + version.fbe_size()) > fbe_struct_size)
        return true;
    if (!version.verify())
        return false;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + has_version.fbe_size()) > fbe_struct_size)
        return true;
    if (!has_version.verify())
        return false;
    fbe_current_size += has_version.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterForeignServerStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterForeignServerStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterForeignServerStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterForeignServerStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterForeignServerStmt& fbe_value = static_cast<::pg_query::AlterForeignServerStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + servername.fbe_size()) <= fbe_struct_size)
        {
            servername.get(fbe_value.servername);
        }
    else
        fbe_value.servername = "";
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + version.fbe_size()) <= fbe_struct_size)
        {
            version.get(fbe_value.version);
        }
    else
        fbe_value.version = "";
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + has_version.fbe_size()) <= fbe_struct_size)
        {
            has_version.get(fbe_value.has_version);
        }
    else
        fbe_value.has_version = false;
    fbe_current_size += has_version.fbe_size();
}

size_t FieldModel_pg_query_AlterForeignServerStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterForeignServerStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterForeignServerStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterForeignServerStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterForeignServerStmt& fbe_value = static_cast<const ::pg_query::AlterForeignServerStmt&>(base_fbe_value);
    servername.set(fbe_value.servername);
    version.set(fbe_value.version);
    options.set(fbe_value.options);
    has_version.set(fbe_value.has_version);
}

namespace pg_query {

bool AlterForeignServerStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterForeignServerStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterForeignServerStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterForeignServerStmtModel::serialize(const ::pg_query::AlterForeignServerStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterForeignServerStmtModel::deserialize(::pg_query::AlterForeignServerStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateUserMappingStmt::FieldModelPtr_pg_query_CreateUserMappingStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateUserMappingStmt::~FieldModelPtr_pg_query_CreateUserMappingStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateUserMappingStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateUserMappingStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateUserMappingStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateUserMappingStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateUserMappingStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateUserMappingStmt::get(::pg_query::CreateUserMappingStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateUserMappingStmt(_buffer, 0);

    ::pg_query::CreateUserMappingStmt *tempModel = new ::pg_query::CreateUserMappingStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateUserMappingStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateUserMappingStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateUserMappingStmt::set(const ::pg_query::CreateUserMappingStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateUserMappingStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateUserMappingStmt::FieldModel_pg_query_CreateUserMappingStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , user(buffer, 4 + 4)
    , servername(buffer, user.fbe_offset() + user.fbe_size())
    , if_not_exists(buffer, servername.fbe_offset() + servername.fbe_size())
    , options(buffer, if_not_exists.fbe_offset() + if_not_exists.fbe_size())
{}

size_t FieldModel_pg_query_CreateUserMappingStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + user.fbe_size()
        + servername.fbe_size()
        + if_not_exists.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateUserMappingStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + user.fbe_extra()
        + servername.fbe_extra()
        + if_not_exists.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateUserMappingStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateUserMappingStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + user.fbe_size()) > fbe_struct_size)
        return true;
    if (!user.verify())
        return false;
    fbe_current_size += user.fbe_size();

    if ((fbe_current_size + servername.fbe_size()) > fbe_struct_size)
        return true;
    if (!servername.verify())
        return false;
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateUserMappingStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateUserMappingStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateUserMappingStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateUserMappingStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateUserMappingStmt& fbe_value = static_cast<::pg_query::CreateUserMappingStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + user.fbe_size()) <= fbe_struct_size)
        {
            user.get(&fbe_value.user);
        }
    else
        fbe_value.user = nullptr;
    fbe_current_size += user.fbe_size();

    if ((fbe_current_size + servername.fbe_size()) <= fbe_struct_size)
        {
            servername.get(fbe_value.servername);
        }
    else
        fbe_value.servername = "";
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreateUserMappingStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateUserMappingStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateUserMappingStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateUserMappingStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateUserMappingStmt& fbe_value = static_cast<const ::pg_query::CreateUserMappingStmt&>(base_fbe_value);
    user.set(fbe_value.user);
    servername.set(fbe_value.servername);
    if_not_exists.set(fbe_value.if_not_exists);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreateUserMappingStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateUserMappingStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateUserMappingStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateUserMappingStmtModel::serialize(const ::pg_query::CreateUserMappingStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateUserMappingStmtModel::deserialize(::pg_query::CreateUserMappingStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterUserMappingStmt::FieldModelPtr_pg_query_AlterUserMappingStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterUserMappingStmt::~FieldModelPtr_pg_query_AlterUserMappingStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterUserMappingStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterUserMappingStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterUserMappingStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterUserMappingStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterUserMappingStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterUserMappingStmt::get(::pg_query::AlterUserMappingStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterUserMappingStmt(_buffer, 0);

    ::pg_query::AlterUserMappingStmt *tempModel = new ::pg_query::AlterUserMappingStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterUserMappingStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterUserMappingStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterUserMappingStmt::set(const ::pg_query::AlterUserMappingStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterUserMappingStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterUserMappingStmt::FieldModel_pg_query_AlterUserMappingStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , user(buffer, 4 + 4)
    , servername(buffer, user.fbe_offset() + user.fbe_size())
    , options(buffer, servername.fbe_offset() + servername.fbe_size())
{}

size_t FieldModel_pg_query_AlterUserMappingStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + user.fbe_size()
        + servername.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterUserMappingStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + user.fbe_extra()
        + servername.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterUserMappingStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterUserMappingStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + user.fbe_size()) > fbe_struct_size)
        return true;
    if (!user.verify())
        return false;
    fbe_current_size += user.fbe_size();

    if ((fbe_current_size + servername.fbe_size()) > fbe_struct_size)
        return true;
    if (!servername.verify())
        return false;
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterUserMappingStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterUserMappingStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterUserMappingStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterUserMappingStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterUserMappingStmt& fbe_value = static_cast<::pg_query::AlterUserMappingStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + user.fbe_size()) <= fbe_struct_size)
        {
            user.get(&fbe_value.user);
        }
    else
        fbe_value.user = nullptr;
    fbe_current_size += user.fbe_size();

    if ((fbe_current_size + servername.fbe_size()) <= fbe_struct_size)
        {
            servername.get(fbe_value.servername);
        }
    else
        fbe_value.servername = "";
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_AlterUserMappingStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterUserMappingStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterUserMappingStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterUserMappingStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterUserMappingStmt& fbe_value = static_cast<const ::pg_query::AlterUserMappingStmt&>(base_fbe_value);
    user.set(fbe_value.user);
    servername.set(fbe_value.servername);
    options.set(fbe_value.options);
}

namespace pg_query {

bool AlterUserMappingStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterUserMappingStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterUserMappingStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterUserMappingStmtModel::serialize(const ::pg_query::AlterUserMappingStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterUserMappingStmtModel::deserialize(::pg_query::AlterUserMappingStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DropUserMappingStmt::FieldModelPtr_pg_query_DropUserMappingStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DropUserMappingStmt::~FieldModelPtr_pg_query_DropUserMappingStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DropUserMappingStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DropUserMappingStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DropUserMappingStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DropUserMappingStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropUserMappingStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropUserMappingStmt::get(::pg_query::DropUserMappingStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DropUserMappingStmt(_buffer, 0);

    ::pg_query::DropUserMappingStmt *tempModel = new ::pg_query::DropUserMappingStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DropUserMappingStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropUserMappingStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropUserMappingStmt::set(const ::pg_query::DropUserMappingStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DropUserMappingStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DropUserMappingStmt::FieldModel_pg_query_DropUserMappingStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , user(buffer, 4 + 4)
    , servername(buffer, user.fbe_offset() + user.fbe_size())
    , missing_ok(buffer, servername.fbe_offset() + servername.fbe_size())
{}

size_t FieldModel_pg_query_DropUserMappingStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + user.fbe_size()
        + servername.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DropUserMappingStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + user.fbe_extra()
        + servername.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DropUserMappingStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DropUserMappingStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + user.fbe_size()) > fbe_struct_size)
        return true;
    if (!user.verify())
        return false;
    fbe_current_size += user.fbe_size();

    if ((fbe_current_size + servername.fbe_size()) > fbe_struct_size)
        return true;
    if (!servername.verify())
        return false;
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DropUserMappingStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropUserMappingStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropUserMappingStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DropUserMappingStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DropUserMappingStmt& fbe_value = static_cast<::pg_query::DropUserMappingStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + user.fbe_size()) <= fbe_struct_size)
        {
            user.get(&fbe_value.user);
        }
    else
        fbe_value.user = nullptr;
    fbe_current_size += user.fbe_size();

    if ((fbe_current_size + servername.fbe_size()) <= fbe_struct_size)
        {
            servername.get(fbe_value.servername);
        }
    else
        fbe_value.servername = "";
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_DropUserMappingStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropUserMappingStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropUserMappingStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DropUserMappingStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DropUserMappingStmt& fbe_value = static_cast<const ::pg_query::DropUserMappingStmt&>(base_fbe_value);
    user.set(fbe_value.user);
    servername.set(fbe_value.servername);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool DropUserMappingStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DropUserMappingStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DropUserMappingStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DropUserMappingStmtModel::serialize(const ::pg_query::DropUserMappingStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DropUserMappingStmtModel::deserialize(::pg_query::DropUserMappingStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::~FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::get(::pg_query::AlterTableSpaceOptionsStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterTableSpaceOptionsStmt(_buffer, 0);

    ::pg_query::AlterTableSpaceOptionsStmt *tempModel = new ::pg_query::AlterTableSpaceOptionsStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTableSpaceOptionsStmt::set(const ::pg_query::AlterTableSpaceOptionsStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterTableSpaceOptionsStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterTableSpaceOptionsStmt::FieldModel_pg_query_AlterTableSpaceOptionsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , tablespacename(buffer, 4 + 4)
    , options(buffer, tablespacename.fbe_offset() + tablespacename.fbe_size())
    , is_reset(buffer, options.fbe_offset() + options.fbe_size())
{}

size_t FieldModel_pg_query_AlterTableSpaceOptionsStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + tablespacename.fbe_size()
        + options.fbe_size()
        + is_reset.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterTableSpaceOptionsStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + tablespacename.fbe_extra()
        + options.fbe_extra()
        + is_reset.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterTableSpaceOptionsStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterTableSpaceOptionsStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tablespacename.fbe_size()) > fbe_struct_size)
        return true;
    if (!tablespacename.verify())
        return false;
    fbe_current_size += tablespacename.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + is_reset.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_reset.verify())
        return false;
    fbe_current_size += is_reset.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterTableSpaceOptionsStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTableSpaceOptionsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTableSpaceOptionsStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterTableSpaceOptionsStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterTableSpaceOptionsStmt& fbe_value = static_cast<::pg_query::AlterTableSpaceOptionsStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tablespacename.fbe_size()) <= fbe_struct_size)
        {
            tablespacename.get(fbe_value.tablespacename);
        }
    else
        fbe_value.tablespacename = "";
    fbe_current_size += tablespacename.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + is_reset.fbe_size()) <= fbe_struct_size)
        {
            is_reset.get(fbe_value.is_reset);
        }
    else
        fbe_value.is_reset = false;
    fbe_current_size += is_reset.fbe_size();
}

size_t FieldModel_pg_query_AlterTableSpaceOptionsStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTableSpaceOptionsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTableSpaceOptionsStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterTableSpaceOptionsStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterTableSpaceOptionsStmt& fbe_value = static_cast<const ::pg_query::AlterTableSpaceOptionsStmt&>(base_fbe_value);
    tablespacename.set(fbe_value.tablespacename);
    options.set(fbe_value.options);
    is_reset.set(fbe_value.is_reset);
}

namespace pg_query {

bool AlterTableSpaceOptionsStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterTableSpaceOptionsStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterTableSpaceOptionsStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterTableSpaceOptionsStmtModel::serialize(const ::pg_query::AlterTableSpaceOptionsStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterTableSpaceOptionsStmtModel::deserialize(::pg_query::AlterTableSpaceOptionsStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterTableMoveAllStmt::FieldModelPtr_pg_query_AlterTableMoveAllStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterTableMoveAllStmt::~FieldModelPtr_pg_query_AlterTableMoveAllStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterTableMoveAllStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTableMoveAllStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterTableMoveAllStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterTableMoveAllStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTableMoveAllStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTableMoveAllStmt::get(::pg_query::AlterTableMoveAllStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterTableMoveAllStmt(_buffer, 0);

    ::pg_query::AlterTableMoveAllStmt *tempModel = new ::pg_query::AlterTableMoveAllStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterTableMoveAllStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterTableMoveAllStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterTableMoveAllStmt::set(const ::pg_query::AlterTableMoveAllStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterTableMoveAllStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterTableMoveAllStmt::FieldModel_pg_query_AlterTableMoveAllStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , orig_tablespacename(buffer, 4 + 4)
    , objtype(buffer, orig_tablespacename.fbe_offset() + orig_tablespacename.fbe_size())
    , roles(buffer, objtype.fbe_offset() + objtype.fbe_size())
    , new_tablespacename(buffer, roles.fbe_offset() + roles.fbe_size())
    , nowait(buffer, new_tablespacename.fbe_offset() + new_tablespacename.fbe_size())
{}

size_t FieldModel_pg_query_AlterTableMoveAllStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + orig_tablespacename.fbe_size()
        + objtype.fbe_size()
        + roles.fbe_size()
        + new_tablespacename.fbe_size()
        + nowait.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterTableMoveAllStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + orig_tablespacename.fbe_extra()
        + objtype.fbe_extra()
        + roles.fbe_extra()
        + new_tablespacename.fbe_extra()
        + nowait.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterTableMoveAllStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterTableMoveAllStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + orig_tablespacename.fbe_size()) > fbe_struct_size)
        return true;
    if (!orig_tablespacename.verify())
        return false;
    fbe_current_size += orig_tablespacename.fbe_size();

    if ((fbe_current_size + objtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!objtype.verify())
        return false;
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + roles.fbe_size()) > fbe_struct_size)
        return true;
    if (!roles.verify())
        return false;
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + new_tablespacename.fbe_size()) > fbe_struct_size)
        return true;
    if (!new_tablespacename.verify())
        return false;
    fbe_current_size += new_tablespacename.fbe_size();

    if ((fbe_current_size + nowait.fbe_size()) > fbe_struct_size)
        return true;
    if (!nowait.verify())
        return false;
    fbe_current_size += nowait.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterTableMoveAllStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTableMoveAllStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTableMoveAllStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterTableMoveAllStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterTableMoveAllStmt& fbe_value = static_cast<::pg_query::AlterTableMoveAllStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + orig_tablespacename.fbe_size()) <= fbe_struct_size)
        {
            orig_tablespacename.get(fbe_value.orig_tablespacename);
        }
    else
        fbe_value.orig_tablespacename = "";
    fbe_current_size += orig_tablespacename.fbe_size();

    if ((fbe_current_size + objtype.fbe_size()) <= fbe_struct_size)
        {
            objtype.get(fbe_value.objtype);
        }
    else
        fbe_value.objtype = ::pg_query::ObjectType();
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + roles.fbe_size()) <= fbe_struct_size)
        {
            roles.get(fbe_value.roles);
        }
    else
        fbe_value.roles.clear();
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + new_tablespacename.fbe_size()) <= fbe_struct_size)
        {
            new_tablespacename.get(fbe_value.new_tablespacename);
        }
    else
        fbe_value.new_tablespacename = "";
    fbe_current_size += new_tablespacename.fbe_size();

    if ((fbe_current_size + nowait.fbe_size()) <= fbe_struct_size)
        {
            nowait.get(fbe_value.nowait);
        }
    else
        fbe_value.nowait = false;
    fbe_current_size += nowait.fbe_size();
}

size_t FieldModel_pg_query_AlterTableMoveAllStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterTableMoveAllStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterTableMoveAllStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterTableMoveAllStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterTableMoveAllStmt& fbe_value = static_cast<const ::pg_query::AlterTableMoveAllStmt&>(base_fbe_value);
    orig_tablespacename.set(fbe_value.orig_tablespacename);
    objtype.set(fbe_value.objtype);
    roles.set(fbe_value.roles);
    new_tablespacename.set(fbe_value.new_tablespacename);
    nowait.set(fbe_value.nowait);
}

namespace pg_query {

bool AlterTableMoveAllStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterTableMoveAllStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterTableMoveAllStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterTableMoveAllStmtModel::serialize(const ::pg_query::AlterTableMoveAllStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterTableMoveAllStmtModel::deserialize(::pg_query::AlterTableMoveAllStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SecLabelStmt::FieldModelPtr_pg_query_SecLabelStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SecLabelStmt::~FieldModelPtr_pg_query_SecLabelStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SecLabelStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SecLabelStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SecLabelStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SecLabelStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SecLabelStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SecLabelStmt::get(::pg_query::SecLabelStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SecLabelStmt(_buffer, 0);

    ::pg_query::SecLabelStmt *tempModel = new ::pg_query::SecLabelStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SecLabelStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SecLabelStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SecLabelStmt::set(const ::pg_query::SecLabelStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SecLabelStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SecLabelStmt::FieldModel_pg_query_SecLabelStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , objtype(buffer, 4 + 4)
    , object(buffer, objtype.fbe_offset() + objtype.fbe_size())
    , provider(buffer, object.fbe_offset() + object.fbe_size())
    , label(buffer, provider.fbe_offset() + provider.fbe_size())
{}

size_t FieldModel_pg_query_SecLabelStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + objtype.fbe_size()
        + object.fbe_size()
        + provider.fbe_size()
        + label.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SecLabelStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + objtype.fbe_extra()
        + object.fbe_extra()
        + provider.fbe_extra()
        + label.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SecLabelStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SecLabelStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!objtype.verify())
        return false;
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + object.fbe_size()) > fbe_struct_size)
        return true;
    if (!object.verify())
        return false;
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + provider.fbe_size()) > fbe_struct_size)
        return true;
    if (!provider.verify())
        return false;
    fbe_current_size += provider.fbe_size();

    if ((fbe_current_size + label.fbe_size()) > fbe_struct_size)
        return true;
    if (!label.verify())
        return false;
    fbe_current_size += label.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SecLabelStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SecLabelStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SecLabelStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SecLabelStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SecLabelStmt& fbe_value = static_cast<::pg_query::SecLabelStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objtype.fbe_size()) <= fbe_struct_size)
        {
            objtype.get(fbe_value.objtype);
        }
    else
        fbe_value.objtype = ::pg_query::ObjectType();
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + object.fbe_size()) <= fbe_struct_size)
        {
            object.get(fbe_value.object);
        }
    else
        fbe_value.object = ::pg_query::Node();
    fbe_current_size += object.fbe_size();

    if ((fbe_current_size + provider.fbe_size()) <= fbe_struct_size)
        {
            provider.get(fbe_value.provider);
        }
    else
        fbe_value.provider = "";
    fbe_current_size += provider.fbe_size();

    if ((fbe_current_size + label.fbe_size()) <= fbe_struct_size)
        {
            label.get(fbe_value.label);
        }
    else
        fbe_value.label = "";
    fbe_current_size += label.fbe_size();
}

size_t FieldModel_pg_query_SecLabelStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SecLabelStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SecLabelStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SecLabelStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SecLabelStmt& fbe_value = static_cast<const ::pg_query::SecLabelStmt&>(base_fbe_value);
    objtype.set(fbe_value.objtype);
    object.set(fbe_value.object);
    provider.set(fbe_value.provider);
    label.set(fbe_value.label);
}

namespace pg_query {

bool SecLabelStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SecLabelStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SecLabelStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SecLabelStmtModel::serialize(const ::pg_query::SecLabelStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SecLabelStmtModel::deserialize(::pg_query::SecLabelStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateForeignTableStmt::FieldModelPtr_pg_query_CreateForeignTableStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateForeignTableStmt::~FieldModelPtr_pg_query_CreateForeignTableStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateForeignTableStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateForeignTableStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateForeignTableStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateForeignTableStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateForeignTableStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateForeignTableStmt::get(::pg_query::CreateForeignTableStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateForeignTableStmt(_buffer, 0);

    ::pg_query::CreateForeignTableStmt *tempModel = new ::pg_query::CreateForeignTableStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateForeignTableStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateForeignTableStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateForeignTableStmt::set(const ::pg_query::CreateForeignTableStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateForeignTableStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateForeignTableStmt::FieldModel_pg_query_CreateForeignTableStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , base_stmt(buffer, 4 + 4)
    , servername(buffer, base_stmt.fbe_offset() + base_stmt.fbe_size())
    , options(buffer, servername.fbe_offset() + servername.fbe_size())
{}

size_t FieldModel_pg_query_CreateForeignTableStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + base_stmt.fbe_size()
        + servername.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateForeignTableStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + base_stmt.fbe_extra()
        + servername.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateForeignTableStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateForeignTableStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + base_stmt.fbe_size()) > fbe_struct_size)
        return true;
    if (!base_stmt.verify())
        return false;
    fbe_current_size += base_stmt.fbe_size();

    if ((fbe_current_size + servername.fbe_size()) > fbe_struct_size)
        return true;
    if (!servername.verify())
        return false;
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateForeignTableStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateForeignTableStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateForeignTableStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateForeignTableStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateForeignTableStmt& fbe_value = static_cast<::pg_query::CreateForeignTableStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + base_stmt.fbe_size()) <= fbe_struct_size)
        {
            base_stmt.get(fbe_value.base_stmt);
        }
    else
        fbe_value.base_stmt = ::pg_query::CreateStmt();
    fbe_current_size += base_stmt.fbe_size();

    if ((fbe_current_size + servername.fbe_size()) <= fbe_struct_size)
        {
            servername.get(fbe_value.servername);
        }
    else
        fbe_value.servername = "";
    fbe_current_size += servername.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreateForeignTableStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateForeignTableStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateForeignTableStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateForeignTableStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateForeignTableStmt& fbe_value = static_cast<const ::pg_query::CreateForeignTableStmt&>(base_fbe_value);
    base_stmt.set(static_cast<const ::pg_query::CreateStmt&>(fbe_value.base_stmt));
    servername.set(fbe_value.servername);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreateForeignTableStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateForeignTableStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateForeignTableStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateForeignTableStmtModel::serialize(const ::pg_query::CreateForeignTableStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateForeignTableStmtModel::deserialize(::pg_query::CreateForeignTableStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ImportForeignSchemaStmt::FieldModelPtr_pg_query_ImportForeignSchemaStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ImportForeignSchemaStmt::~FieldModelPtr_pg_query_ImportForeignSchemaStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ImportForeignSchemaStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ImportForeignSchemaStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ImportForeignSchemaStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ImportForeignSchemaStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ImportForeignSchemaStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ImportForeignSchemaStmt::get(::pg_query::ImportForeignSchemaStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ImportForeignSchemaStmt(_buffer, 0);

    ::pg_query::ImportForeignSchemaStmt *tempModel = new ::pg_query::ImportForeignSchemaStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ImportForeignSchemaStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ImportForeignSchemaStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ImportForeignSchemaStmt::set(const ::pg_query::ImportForeignSchemaStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ImportForeignSchemaStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ImportForeignSchemaStmt::FieldModel_pg_query_ImportForeignSchemaStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , server_name(buffer, 4 + 4)
    , remote_schema(buffer, server_name.fbe_offset() + server_name.fbe_size())
    , local_schema(buffer, remote_schema.fbe_offset() + remote_schema.fbe_size())
    , list_type(buffer, local_schema.fbe_offset() + local_schema.fbe_size())
    , table_list(buffer, list_type.fbe_offset() + list_type.fbe_size())
    , options(buffer, table_list.fbe_offset() + table_list.fbe_size())
{}

size_t FieldModel_pg_query_ImportForeignSchemaStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + server_name.fbe_size()
        + remote_schema.fbe_size()
        + local_schema.fbe_size()
        + list_type.fbe_size()
        + table_list.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ImportForeignSchemaStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + server_name.fbe_extra()
        + remote_schema.fbe_extra()
        + local_schema.fbe_extra()
        + list_type.fbe_extra()
        + table_list.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ImportForeignSchemaStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ImportForeignSchemaStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + server_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!server_name.verify())
        return false;
    fbe_current_size += server_name.fbe_size();

    if ((fbe_current_size + remote_schema.fbe_size()) > fbe_struct_size)
        return true;
    if (!remote_schema.verify())
        return false;
    fbe_current_size += remote_schema.fbe_size();

    if ((fbe_current_size + local_schema.fbe_size()) > fbe_struct_size)
        return true;
    if (!local_schema.verify())
        return false;
    fbe_current_size += local_schema.fbe_size();

    if ((fbe_current_size + list_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!list_type.verify())
        return false;
    fbe_current_size += list_type.fbe_size();

    if ((fbe_current_size + table_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!table_list.verify())
        return false;
    fbe_current_size += table_list.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ImportForeignSchemaStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ImportForeignSchemaStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ImportForeignSchemaStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ImportForeignSchemaStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ImportForeignSchemaStmt& fbe_value = static_cast<::pg_query::ImportForeignSchemaStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + server_name.fbe_size()) <= fbe_struct_size)
        {
            server_name.get(fbe_value.server_name);
        }
    else
        fbe_value.server_name = "";
    fbe_current_size += server_name.fbe_size();

    if ((fbe_current_size + remote_schema.fbe_size()) <= fbe_struct_size)
        {
            remote_schema.get(fbe_value.remote_schema);
        }
    else
        fbe_value.remote_schema = "";
    fbe_current_size += remote_schema.fbe_size();

    if ((fbe_current_size + local_schema.fbe_size()) <= fbe_struct_size)
        {
            local_schema.get(fbe_value.local_schema);
        }
    else
        fbe_value.local_schema = "";
    fbe_current_size += local_schema.fbe_size();

    if ((fbe_current_size + list_type.fbe_size()) <= fbe_struct_size)
        {
            list_type.get(fbe_value.list_type);
        }
    else
        fbe_value.list_type = ::pg_query::ImportForeignSchemaType();
    fbe_current_size += list_type.fbe_size();

    if ((fbe_current_size + table_list.fbe_size()) <= fbe_struct_size)
        {
            table_list.get(fbe_value.table_list);
        }
    else
        fbe_value.table_list.clear();
    fbe_current_size += table_list.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_ImportForeignSchemaStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ImportForeignSchemaStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ImportForeignSchemaStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ImportForeignSchemaStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ImportForeignSchemaStmt& fbe_value = static_cast<const ::pg_query::ImportForeignSchemaStmt&>(base_fbe_value);
    server_name.set(fbe_value.server_name);
    remote_schema.set(fbe_value.remote_schema);
    local_schema.set(fbe_value.local_schema);
    list_type.set(fbe_value.list_type);
    table_list.set(fbe_value.table_list);
    options.set(fbe_value.options);
}

namespace pg_query {

bool ImportForeignSchemaStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ImportForeignSchemaStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ImportForeignSchemaStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ImportForeignSchemaStmtModel::serialize(const ::pg_query::ImportForeignSchemaStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ImportForeignSchemaStmtModel::deserialize(::pg_query::ImportForeignSchemaStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateExtensionStmt::FieldModelPtr_pg_query_CreateExtensionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateExtensionStmt::~FieldModelPtr_pg_query_CreateExtensionStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateExtensionStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateExtensionStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateExtensionStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateExtensionStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateExtensionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateExtensionStmt::get(::pg_query::CreateExtensionStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateExtensionStmt(_buffer, 0);

    ::pg_query::CreateExtensionStmt *tempModel = new ::pg_query::CreateExtensionStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateExtensionStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateExtensionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateExtensionStmt::set(const ::pg_query::CreateExtensionStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateExtensionStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateExtensionStmt::FieldModel_pg_query_CreateExtensionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , extname(buffer, 4 + 4)
    , if_not_exists(buffer, extname.fbe_offset() + extname.fbe_size())
    , options(buffer, if_not_exists.fbe_offset() + if_not_exists.fbe_size())
{}

size_t FieldModel_pg_query_CreateExtensionStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + extname.fbe_size()
        + if_not_exists.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateExtensionStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + extname.fbe_extra()
        + if_not_exists.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateExtensionStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateExtensionStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + extname.fbe_size()) > fbe_struct_size)
        return true;
    if (!extname.verify())
        return false;
    fbe_current_size += extname.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateExtensionStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateExtensionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateExtensionStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateExtensionStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateExtensionStmt& fbe_value = static_cast<::pg_query::CreateExtensionStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + extname.fbe_size()) <= fbe_struct_size)
        {
            extname.get(fbe_value.extname);
        }
    else
        fbe_value.extname = "";
    fbe_current_size += extname.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreateExtensionStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateExtensionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateExtensionStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateExtensionStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateExtensionStmt& fbe_value = static_cast<const ::pg_query::CreateExtensionStmt&>(base_fbe_value);
    extname.set(fbe_value.extname);
    if_not_exists.set(fbe_value.if_not_exists);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreateExtensionStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateExtensionStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateExtensionStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateExtensionStmtModel::serialize(const ::pg_query::CreateExtensionStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateExtensionStmtModel::deserialize(::pg_query::CreateExtensionStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterExtensionStmt::FieldModelPtr_pg_query_AlterExtensionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterExtensionStmt::~FieldModelPtr_pg_query_AlterExtensionStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterExtensionStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterExtensionStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterExtensionStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterExtensionStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterExtensionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterExtensionStmt::get(::pg_query::AlterExtensionStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterExtensionStmt(_buffer, 0);

    ::pg_query::AlterExtensionStmt *tempModel = new ::pg_query::AlterExtensionStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterExtensionStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterExtensionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterExtensionStmt::set(const ::pg_query::AlterExtensionStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterExtensionStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterExtensionStmt::FieldModel_pg_query_AlterExtensionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , extname(buffer, 4 + 4)
    , options(buffer, extname.fbe_offset() + extname.fbe_size())
{}

size_t FieldModel_pg_query_AlterExtensionStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + extname.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterExtensionStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + extname.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterExtensionStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterExtensionStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + extname.fbe_size()) > fbe_struct_size)
        return true;
    if (!extname.verify())
        return false;
    fbe_current_size += extname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterExtensionStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterExtensionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterExtensionStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterExtensionStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterExtensionStmt& fbe_value = static_cast<::pg_query::AlterExtensionStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + extname.fbe_size()) <= fbe_struct_size)
        {
            extname.get(fbe_value.extname);
        }
    else
        fbe_value.extname = "";
    fbe_current_size += extname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_AlterExtensionStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterExtensionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterExtensionStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterExtensionStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterExtensionStmt& fbe_value = static_cast<const ::pg_query::AlterExtensionStmt&>(base_fbe_value);
    extname.set(fbe_value.extname);
    options.set(fbe_value.options);
}

namespace pg_query {

bool AlterExtensionStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterExtensionStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterExtensionStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterExtensionStmtModel::serialize(const ::pg_query::AlterExtensionStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterExtensionStmtModel::deserialize(::pg_query::AlterExtensionStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterExtensionContentsStmt::FieldModelPtr_pg_query_AlterExtensionContentsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterExtensionContentsStmt::~FieldModelPtr_pg_query_AlterExtensionContentsStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterExtensionContentsStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterExtensionContentsStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterExtensionContentsStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterExtensionContentsStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterExtensionContentsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterExtensionContentsStmt::get(::pg_query::AlterExtensionContentsStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterExtensionContentsStmt(_buffer, 0);

    ::pg_query::AlterExtensionContentsStmt *tempModel = new ::pg_query::AlterExtensionContentsStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterExtensionContentsStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterExtensionContentsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterExtensionContentsStmt::set(const ::pg_query::AlterExtensionContentsStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterExtensionContentsStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterExtensionContentsStmt::FieldModel_pg_query_AlterExtensionContentsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , extname(buffer, 4 + 4)
    , action(buffer, extname.fbe_offset() + extname.fbe_size())
    , objtype(buffer, action.fbe_offset() + action.fbe_size())
    , object(buffer, objtype.fbe_offset() + objtype.fbe_size())
{}

size_t FieldModel_pg_query_AlterExtensionContentsStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + extname.fbe_size()
        + action.fbe_size()
        + objtype.fbe_size()
        + object.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterExtensionContentsStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + extname.fbe_extra()
        + action.fbe_extra()
        + objtype.fbe_extra()
        + object.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterExtensionContentsStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterExtensionContentsStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + extname.fbe_size()) > fbe_struct_size)
        return true;
    if (!extname.verify())
        return false;
    fbe_current_size += extname.fbe_size();

    if ((fbe_current_size + action.fbe_size()) > fbe_struct_size)
        return true;
    if (!action.verify())
        return false;
    fbe_current_size += action.fbe_size();

    if ((fbe_current_size + objtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!objtype.verify())
        return false;
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + object.fbe_size()) > fbe_struct_size)
        return true;
    if (!object.verify())
        return false;
    fbe_current_size += object.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterExtensionContentsStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterExtensionContentsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterExtensionContentsStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterExtensionContentsStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterExtensionContentsStmt& fbe_value = static_cast<::pg_query::AlterExtensionContentsStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + extname.fbe_size()) <= fbe_struct_size)
        {
            extname.get(fbe_value.extname);
        }
    else
        fbe_value.extname = "";
    fbe_current_size += extname.fbe_size();

    if ((fbe_current_size + action.fbe_size()) <= fbe_struct_size)
        {
            action.get(fbe_value.action);
        }
    else
        fbe_value.action = (int32_t)0ll;
    fbe_current_size += action.fbe_size();

    if ((fbe_current_size + objtype.fbe_size()) <= fbe_struct_size)
        {
            objtype.get(fbe_value.objtype);
        }
    else
        fbe_value.objtype = ::pg_query::ObjectType();
    fbe_current_size += objtype.fbe_size();

    if ((fbe_current_size + object.fbe_size()) <= fbe_struct_size)
        {
            object.get(fbe_value.object);
        }
    else
        fbe_value.object = ::pg_query::Node();
    fbe_current_size += object.fbe_size();
}

size_t FieldModel_pg_query_AlterExtensionContentsStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterExtensionContentsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterExtensionContentsStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterExtensionContentsStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterExtensionContentsStmt& fbe_value = static_cast<const ::pg_query::AlterExtensionContentsStmt&>(base_fbe_value);
    extname.set(fbe_value.extname);
    action.set(fbe_value.action);
    objtype.set(fbe_value.objtype);
    object.set(fbe_value.object);
}

namespace pg_query {

bool AlterExtensionContentsStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterExtensionContentsStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterExtensionContentsStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterExtensionContentsStmtModel::serialize(const ::pg_query::AlterExtensionContentsStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterExtensionContentsStmtModel::deserialize(::pg_query::AlterExtensionContentsStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateEventTrigStmt::FieldModelPtr_pg_query_CreateEventTrigStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateEventTrigStmt::~FieldModelPtr_pg_query_CreateEventTrigStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateEventTrigStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateEventTrigStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateEventTrigStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateEventTrigStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateEventTrigStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateEventTrigStmt::get(::pg_query::CreateEventTrigStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateEventTrigStmt(_buffer, 0);

    ::pg_query::CreateEventTrigStmt *tempModel = new ::pg_query::CreateEventTrigStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateEventTrigStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateEventTrigStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateEventTrigStmt::set(const ::pg_query::CreateEventTrigStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateEventTrigStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateEventTrigStmt::FieldModel_pg_query_CreateEventTrigStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , trigname(buffer, 4 + 4)
    , eventname(buffer, trigname.fbe_offset() + trigname.fbe_size())
    , whenclause(buffer, eventname.fbe_offset() + eventname.fbe_size())
    , funcname(buffer, whenclause.fbe_offset() + whenclause.fbe_size())
{}

size_t FieldModel_pg_query_CreateEventTrigStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + trigname.fbe_size()
        + eventname.fbe_size()
        + whenclause.fbe_size()
        + funcname.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateEventTrigStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + trigname.fbe_extra()
        + eventname.fbe_extra()
        + whenclause.fbe_extra()
        + funcname.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateEventTrigStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateEventTrigStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + trigname.fbe_size()) > fbe_struct_size)
        return true;
    if (!trigname.verify())
        return false;
    fbe_current_size += trigname.fbe_size();

    if ((fbe_current_size + eventname.fbe_size()) > fbe_struct_size)
        return true;
    if (!eventname.verify())
        return false;
    fbe_current_size += eventname.fbe_size();

    if ((fbe_current_size + whenclause.fbe_size()) > fbe_struct_size)
        return true;
    if (!whenclause.verify())
        return false;
    fbe_current_size += whenclause.fbe_size();

    if ((fbe_current_size + funcname.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcname.verify())
        return false;
    fbe_current_size += funcname.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateEventTrigStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateEventTrigStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateEventTrigStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateEventTrigStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateEventTrigStmt& fbe_value = static_cast<::pg_query::CreateEventTrigStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + trigname.fbe_size()) <= fbe_struct_size)
        {
            trigname.get(fbe_value.trigname);
        }
    else
        fbe_value.trigname = "";
    fbe_current_size += trigname.fbe_size();

    if ((fbe_current_size + eventname.fbe_size()) <= fbe_struct_size)
        {
            eventname.get(fbe_value.eventname);
        }
    else
        fbe_value.eventname = "";
    fbe_current_size += eventname.fbe_size();

    if ((fbe_current_size + whenclause.fbe_size()) <= fbe_struct_size)
        {
            whenclause.get(fbe_value.whenclause);
        }
    else
        fbe_value.whenclause.clear();
    fbe_current_size += whenclause.fbe_size();

    if ((fbe_current_size + funcname.fbe_size()) <= fbe_struct_size)
        {
            funcname.get(fbe_value.funcname);
        }
    else
        fbe_value.funcname.clear();
    fbe_current_size += funcname.fbe_size();
}

size_t FieldModel_pg_query_CreateEventTrigStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateEventTrigStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateEventTrigStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateEventTrigStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateEventTrigStmt& fbe_value = static_cast<const ::pg_query::CreateEventTrigStmt&>(base_fbe_value);
    trigname.set(fbe_value.trigname);
    eventname.set(fbe_value.eventname);
    whenclause.set(fbe_value.whenclause);
    funcname.set(fbe_value.funcname);
}

namespace pg_query {

bool CreateEventTrigStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateEventTrigStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateEventTrigStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateEventTrigStmtModel::serialize(const ::pg_query::CreateEventTrigStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateEventTrigStmtModel::deserialize(::pg_query::CreateEventTrigStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterEventTrigStmt::FieldModelPtr_pg_query_AlterEventTrigStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterEventTrigStmt::~FieldModelPtr_pg_query_AlterEventTrigStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterEventTrigStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterEventTrigStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterEventTrigStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterEventTrigStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterEventTrigStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterEventTrigStmt::get(::pg_query::AlterEventTrigStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterEventTrigStmt(_buffer, 0);

    ::pg_query::AlterEventTrigStmt *tempModel = new ::pg_query::AlterEventTrigStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterEventTrigStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterEventTrigStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterEventTrigStmt::set(const ::pg_query::AlterEventTrigStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterEventTrigStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterEventTrigStmt::FieldModel_pg_query_AlterEventTrigStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , trigname(buffer, 4 + 4)
    , tgenabled(buffer, trigname.fbe_offset() + trigname.fbe_size())
{}

size_t FieldModel_pg_query_AlterEventTrigStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + trigname.fbe_size()
        + tgenabled.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterEventTrigStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + trigname.fbe_extra()
        + tgenabled.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterEventTrigStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterEventTrigStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + trigname.fbe_size()) > fbe_struct_size)
        return true;
    if (!trigname.verify())
        return false;
    fbe_current_size += trigname.fbe_size();

    if ((fbe_current_size + tgenabled.fbe_size()) > fbe_struct_size)
        return true;
    if (!tgenabled.verify())
        return false;
    fbe_current_size += tgenabled.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterEventTrigStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterEventTrigStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterEventTrigStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterEventTrigStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterEventTrigStmt& fbe_value = static_cast<::pg_query::AlterEventTrigStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + trigname.fbe_size()) <= fbe_struct_size)
        {
            trigname.get(fbe_value.trigname);
        }
    else
        fbe_value.trigname = "";
    fbe_current_size += trigname.fbe_size();

    if ((fbe_current_size + tgenabled.fbe_size()) <= fbe_struct_size)
        {
            tgenabled.get(fbe_value.tgenabled);
        }
    else
        fbe_value.tgenabled = "";
    fbe_current_size += tgenabled.fbe_size();
}

size_t FieldModel_pg_query_AlterEventTrigStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterEventTrigStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterEventTrigStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterEventTrigStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterEventTrigStmt& fbe_value = static_cast<const ::pg_query::AlterEventTrigStmt&>(base_fbe_value);
    trigname.set(fbe_value.trigname);
    tgenabled.set(fbe_value.tgenabled);
}

namespace pg_query {

bool AlterEventTrigStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterEventTrigStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterEventTrigStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterEventTrigStmtModel::serialize(const ::pg_query::AlterEventTrigStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterEventTrigStmtModel::deserialize(::pg_query::AlterEventTrigStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RefreshMatViewStmt::FieldModelPtr_pg_query_RefreshMatViewStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RefreshMatViewStmt::~FieldModelPtr_pg_query_RefreshMatViewStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RefreshMatViewStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RefreshMatViewStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RefreshMatViewStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RefreshMatViewStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RefreshMatViewStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RefreshMatViewStmt::get(::pg_query::RefreshMatViewStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RefreshMatViewStmt(_buffer, 0);

    ::pg_query::RefreshMatViewStmt *tempModel = new ::pg_query::RefreshMatViewStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RefreshMatViewStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RefreshMatViewStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RefreshMatViewStmt::set(const ::pg_query::RefreshMatViewStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RefreshMatViewStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RefreshMatViewStmt::FieldModel_pg_query_RefreshMatViewStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , concurrent(buffer, 4 + 4)
    , skip_data(buffer, concurrent.fbe_offset() + concurrent.fbe_size())
    , relation(buffer, skip_data.fbe_offset() + skip_data.fbe_size())
{}

size_t FieldModel_pg_query_RefreshMatViewStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + concurrent.fbe_size()
        + skip_data.fbe_size()
        + relation.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RefreshMatViewStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + concurrent.fbe_extra()
        + skip_data.fbe_extra()
        + relation.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RefreshMatViewStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RefreshMatViewStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + concurrent.fbe_size()) > fbe_struct_size)
        return true;
    if (!concurrent.verify())
        return false;
    fbe_current_size += concurrent.fbe_size();

    if ((fbe_current_size + skip_data.fbe_size()) > fbe_struct_size)
        return true;
    if (!skip_data.verify())
        return false;
    fbe_current_size += skip_data.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RefreshMatViewStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RefreshMatViewStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RefreshMatViewStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RefreshMatViewStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RefreshMatViewStmt& fbe_value = static_cast<::pg_query::RefreshMatViewStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + concurrent.fbe_size()) <= fbe_struct_size)
        {
            concurrent.get(fbe_value.concurrent);
        }
    else
        fbe_value.concurrent = false;
    fbe_current_size += concurrent.fbe_size();

    if ((fbe_current_size + skip_data.fbe_size()) <= fbe_struct_size)
        {
            skip_data.get(fbe_value.skip_data);
        }
    else
        fbe_value.skip_data = false;
    fbe_current_size += skip_data.fbe_size();

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();
}

size_t FieldModel_pg_query_RefreshMatViewStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RefreshMatViewStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RefreshMatViewStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RefreshMatViewStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RefreshMatViewStmt& fbe_value = static_cast<const ::pg_query::RefreshMatViewStmt&>(base_fbe_value);
    concurrent.set(fbe_value.concurrent);
    skip_data.set(fbe_value.skip_data);
    relation.set(fbe_value.relation);
}

namespace pg_query {

bool RefreshMatViewStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RefreshMatViewStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RefreshMatViewStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RefreshMatViewStmtModel::serialize(const ::pg_query::RefreshMatViewStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RefreshMatViewStmtModel::deserialize(::pg_query::RefreshMatViewStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ReplicaIdentityStmt::FieldModelPtr_pg_query_ReplicaIdentityStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ReplicaIdentityStmt::~FieldModelPtr_pg_query_ReplicaIdentityStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ReplicaIdentityStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ReplicaIdentityStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ReplicaIdentityStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ReplicaIdentityStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ReplicaIdentityStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ReplicaIdentityStmt::get(::pg_query::ReplicaIdentityStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ReplicaIdentityStmt(_buffer, 0);

    ::pg_query::ReplicaIdentityStmt *tempModel = new ::pg_query::ReplicaIdentityStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ReplicaIdentityStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ReplicaIdentityStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ReplicaIdentityStmt::set(const ::pg_query::ReplicaIdentityStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ReplicaIdentityStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ReplicaIdentityStmt::FieldModel_pg_query_ReplicaIdentityStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , identity_type(buffer, 4 + 4)
    , name(buffer, identity_type.fbe_offset() + identity_type.fbe_size())
{}

size_t FieldModel_pg_query_ReplicaIdentityStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + identity_type.fbe_size()
        + name.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ReplicaIdentityStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + identity_type.fbe_extra()
        + name.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ReplicaIdentityStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ReplicaIdentityStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + identity_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!identity_type.verify())
        return false;
    fbe_current_size += identity_type.fbe_size();

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ReplicaIdentityStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ReplicaIdentityStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ReplicaIdentityStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ReplicaIdentityStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ReplicaIdentityStmt& fbe_value = static_cast<::pg_query::ReplicaIdentityStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + identity_type.fbe_size()) <= fbe_struct_size)
        {
            identity_type.get(fbe_value.identity_type);
        }
    else
        fbe_value.identity_type = "";
    fbe_current_size += identity_type.fbe_size();

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();
}

size_t FieldModel_pg_query_ReplicaIdentityStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ReplicaIdentityStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ReplicaIdentityStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ReplicaIdentityStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ReplicaIdentityStmt& fbe_value = static_cast<const ::pg_query::ReplicaIdentityStmt&>(base_fbe_value);
    identity_type.set(fbe_value.identity_type);
    name.set(fbe_value.name);
}

namespace pg_query {

bool ReplicaIdentityStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ReplicaIdentityStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ReplicaIdentityStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ReplicaIdentityStmtModel::serialize(const ::pg_query::ReplicaIdentityStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ReplicaIdentityStmtModel::deserialize(::pg_query::ReplicaIdentityStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterSystemStmt::FieldModelPtr_pg_query_AlterSystemStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterSystemStmt::~FieldModelPtr_pg_query_AlterSystemStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterSystemStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterSystemStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterSystemStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterSystemStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterSystemStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterSystemStmt::get(::pg_query::AlterSystemStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterSystemStmt(_buffer, 0);

    ::pg_query::AlterSystemStmt *tempModel = new ::pg_query::AlterSystemStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterSystemStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterSystemStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterSystemStmt::set(const ::pg_query::AlterSystemStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterSystemStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterSystemStmt::FieldModel_pg_query_AlterSystemStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , setstmt(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_AlterSystemStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + setstmt.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterSystemStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + setstmt.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterSystemStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterSystemStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + setstmt.fbe_size()) > fbe_struct_size)
        return true;
    if (!setstmt.verify())
        return false;
    fbe_current_size += setstmt.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterSystemStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterSystemStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterSystemStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterSystemStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterSystemStmt& fbe_value = static_cast<::pg_query::AlterSystemStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + setstmt.fbe_size()) <= fbe_struct_size)
        {
            setstmt.get(&fbe_value.setstmt);
        }
    else
        fbe_value.setstmt = nullptr;
    fbe_current_size += setstmt.fbe_size();
}

size_t FieldModel_pg_query_AlterSystemStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterSystemStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterSystemStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterSystemStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterSystemStmt& fbe_value = static_cast<const ::pg_query::AlterSystemStmt&>(base_fbe_value);
    setstmt.set(fbe_value.setstmt);
}

namespace pg_query {

bool AlterSystemStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterSystemStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterSystemStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterSystemStmtModel::serialize(const ::pg_query::AlterSystemStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterSystemStmtModel::deserialize(::pg_query::AlterSystemStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreatePolicyStmt::FieldModelPtr_pg_query_CreatePolicyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreatePolicyStmt::~FieldModelPtr_pg_query_CreatePolicyStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreatePolicyStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreatePolicyStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreatePolicyStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreatePolicyStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreatePolicyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreatePolicyStmt::get(::pg_query::CreatePolicyStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreatePolicyStmt(_buffer, 0);

    ::pg_query::CreatePolicyStmt *tempModel = new ::pg_query::CreatePolicyStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreatePolicyStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreatePolicyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreatePolicyStmt::set(const ::pg_query::CreatePolicyStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreatePolicyStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreatePolicyStmt::FieldModel_pg_query_CreatePolicyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , policy_name(buffer, 4 + 4)
    , table(buffer, policy_name.fbe_offset() + policy_name.fbe_size())
    , cmd_name(buffer, table.fbe_offset() + table.fbe_size())
    , permissive(buffer, cmd_name.fbe_offset() + cmd_name.fbe_size())
    , roles(buffer, permissive.fbe_offset() + permissive.fbe_size())
    , qual(buffer, roles.fbe_offset() + roles.fbe_size())
    , with_check(buffer, qual.fbe_offset() + qual.fbe_size())
{}

size_t FieldModel_pg_query_CreatePolicyStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + policy_name.fbe_size()
        + table.fbe_size()
        + cmd_name.fbe_size()
        + permissive.fbe_size()
        + roles.fbe_size()
        + qual.fbe_size()
        + with_check.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreatePolicyStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + policy_name.fbe_extra()
        + table.fbe_extra()
        + cmd_name.fbe_extra()
        + permissive.fbe_extra()
        + roles.fbe_extra()
        + qual.fbe_extra()
        + with_check.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreatePolicyStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreatePolicyStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + policy_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!policy_name.verify())
        return false;
    fbe_current_size += policy_name.fbe_size();

    if ((fbe_current_size + table.fbe_size()) > fbe_struct_size)
        return true;
    if (!table.verify())
        return false;
    fbe_current_size += table.fbe_size();

    if ((fbe_current_size + cmd_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!cmd_name.verify())
        return false;
    fbe_current_size += cmd_name.fbe_size();

    if ((fbe_current_size + permissive.fbe_size()) > fbe_struct_size)
        return true;
    if (!permissive.verify())
        return false;
    fbe_current_size += permissive.fbe_size();

    if ((fbe_current_size + roles.fbe_size()) > fbe_struct_size)
        return true;
    if (!roles.verify())
        return false;
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + qual.fbe_size()) > fbe_struct_size)
        return true;
    if (!qual.verify())
        return false;
    fbe_current_size += qual.fbe_size();

    if ((fbe_current_size + with_check.fbe_size()) > fbe_struct_size)
        return true;
    if (!with_check.verify())
        return false;
    fbe_current_size += with_check.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreatePolicyStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreatePolicyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreatePolicyStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreatePolicyStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreatePolicyStmt& fbe_value = static_cast<::pg_query::CreatePolicyStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + policy_name.fbe_size()) <= fbe_struct_size)
        {
            policy_name.get(fbe_value.policy_name);
        }
    else
        fbe_value.policy_name = "";
    fbe_current_size += policy_name.fbe_size();

    if ((fbe_current_size + table.fbe_size()) <= fbe_struct_size)
        {
            table.get(&fbe_value.table);
        }
    else
        fbe_value.table = nullptr;
    fbe_current_size += table.fbe_size();

    if ((fbe_current_size + cmd_name.fbe_size()) <= fbe_struct_size)
        {
            cmd_name.get(fbe_value.cmd_name);
        }
    else
        fbe_value.cmd_name = "";
    fbe_current_size += cmd_name.fbe_size();

    if ((fbe_current_size + permissive.fbe_size()) <= fbe_struct_size)
        {
            permissive.get(fbe_value.permissive);
        }
    else
        fbe_value.permissive = false;
    fbe_current_size += permissive.fbe_size();

    if ((fbe_current_size + roles.fbe_size()) <= fbe_struct_size)
        {
            roles.get(fbe_value.roles);
        }
    else
        fbe_value.roles.clear();
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + qual.fbe_size()) <= fbe_struct_size)
        {
            qual.get(fbe_value.qual);
        }
    else
        fbe_value.qual = ::pg_query::Node();
    fbe_current_size += qual.fbe_size();

    if ((fbe_current_size + with_check.fbe_size()) <= fbe_struct_size)
        {
            with_check.get(fbe_value.with_check);
        }
    else
        fbe_value.with_check = ::pg_query::Node();
    fbe_current_size += with_check.fbe_size();
}

size_t FieldModel_pg_query_CreatePolicyStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreatePolicyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreatePolicyStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreatePolicyStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreatePolicyStmt& fbe_value = static_cast<const ::pg_query::CreatePolicyStmt&>(base_fbe_value);
    policy_name.set(fbe_value.policy_name);
    table.set(fbe_value.table);
    cmd_name.set(fbe_value.cmd_name);
    permissive.set(fbe_value.permissive);
    roles.set(fbe_value.roles);
    qual.set(fbe_value.qual);
    with_check.set(fbe_value.with_check);
}

namespace pg_query {

bool CreatePolicyStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreatePolicyStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreatePolicyStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreatePolicyStmtModel::serialize(const ::pg_query::CreatePolicyStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreatePolicyStmtModel::deserialize(::pg_query::CreatePolicyStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterPolicyStmt::FieldModelPtr_pg_query_AlterPolicyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterPolicyStmt::~FieldModelPtr_pg_query_AlterPolicyStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterPolicyStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterPolicyStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterPolicyStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterPolicyStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterPolicyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterPolicyStmt::get(::pg_query::AlterPolicyStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterPolicyStmt(_buffer, 0);

    ::pg_query::AlterPolicyStmt *tempModel = new ::pg_query::AlterPolicyStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterPolicyStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterPolicyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterPolicyStmt::set(const ::pg_query::AlterPolicyStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterPolicyStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterPolicyStmt::FieldModel_pg_query_AlterPolicyStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , policy_name(buffer, 4 + 4)
    , table(buffer, policy_name.fbe_offset() + policy_name.fbe_size())
    , roles(buffer, table.fbe_offset() + table.fbe_size())
    , qual(buffer, roles.fbe_offset() + roles.fbe_size())
    , with_check(buffer, qual.fbe_offset() + qual.fbe_size())
{}

size_t FieldModel_pg_query_AlterPolicyStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + policy_name.fbe_size()
        + table.fbe_size()
        + roles.fbe_size()
        + qual.fbe_size()
        + with_check.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterPolicyStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + policy_name.fbe_extra()
        + table.fbe_extra()
        + roles.fbe_extra()
        + qual.fbe_extra()
        + with_check.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterPolicyStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterPolicyStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + policy_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!policy_name.verify())
        return false;
    fbe_current_size += policy_name.fbe_size();

    if ((fbe_current_size + table.fbe_size()) > fbe_struct_size)
        return true;
    if (!table.verify())
        return false;
    fbe_current_size += table.fbe_size();

    if ((fbe_current_size + roles.fbe_size()) > fbe_struct_size)
        return true;
    if (!roles.verify())
        return false;
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + qual.fbe_size()) > fbe_struct_size)
        return true;
    if (!qual.verify())
        return false;
    fbe_current_size += qual.fbe_size();

    if ((fbe_current_size + with_check.fbe_size()) > fbe_struct_size)
        return true;
    if (!with_check.verify())
        return false;
    fbe_current_size += with_check.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterPolicyStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterPolicyStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterPolicyStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterPolicyStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterPolicyStmt& fbe_value = static_cast<::pg_query::AlterPolicyStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + policy_name.fbe_size()) <= fbe_struct_size)
        {
            policy_name.get(fbe_value.policy_name);
        }
    else
        fbe_value.policy_name = "";
    fbe_current_size += policy_name.fbe_size();

    if ((fbe_current_size + table.fbe_size()) <= fbe_struct_size)
        {
            table.get(&fbe_value.table);
        }
    else
        fbe_value.table = nullptr;
    fbe_current_size += table.fbe_size();

    if ((fbe_current_size + roles.fbe_size()) <= fbe_struct_size)
        {
            roles.get(fbe_value.roles);
        }
    else
        fbe_value.roles.clear();
    fbe_current_size += roles.fbe_size();

    if ((fbe_current_size + qual.fbe_size()) <= fbe_struct_size)
        {
            qual.get(fbe_value.qual);
        }
    else
        fbe_value.qual = ::pg_query::Node();
    fbe_current_size += qual.fbe_size();

    if ((fbe_current_size + with_check.fbe_size()) <= fbe_struct_size)
        {
            with_check.get(fbe_value.with_check);
        }
    else
        fbe_value.with_check = ::pg_query::Node();
    fbe_current_size += with_check.fbe_size();
}

size_t FieldModel_pg_query_AlterPolicyStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterPolicyStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterPolicyStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterPolicyStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterPolicyStmt& fbe_value = static_cast<const ::pg_query::AlterPolicyStmt&>(base_fbe_value);
    policy_name.set(fbe_value.policy_name);
    table.set(fbe_value.table);
    roles.set(fbe_value.roles);
    qual.set(fbe_value.qual);
    with_check.set(fbe_value.with_check);
}

namespace pg_query {

bool AlterPolicyStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterPolicyStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterPolicyStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterPolicyStmtModel::serialize(const ::pg_query::AlterPolicyStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterPolicyStmtModel::deserialize(::pg_query::AlterPolicyStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateTransformStmt::FieldModelPtr_pg_query_CreateTransformStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateTransformStmt::~FieldModelPtr_pg_query_CreateTransformStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateTransformStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateTransformStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateTransformStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateTransformStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateTransformStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateTransformStmt::get(::pg_query::CreateTransformStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateTransformStmt(_buffer, 0);

    ::pg_query::CreateTransformStmt *tempModel = new ::pg_query::CreateTransformStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateTransformStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateTransformStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateTransformStmt::set(const ::pg_query::CreateTransformStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateTransformStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateTransformStmt::FieldModel_pg_query_CreateTransformStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , replace(buffer, 4 + 4)
    , type_name(buffer, replace.fbe_offset() + replace.fbe_size())
    , lang(buffer, type_name.fbe_offset() + type_name.fbe_size())
    , fromsql(buffer, lang.fbe_offset() + lang.fbe_size())
    , tosql(buffer, fromsql.fbe_offset() + fromsql.fbe_size())
{}

size_t FieldModel_pg_query_CreateTransformStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + replace.fbe_size()
        + type_name.fbe_size()
        + lang.fbe_size()
        + fromsql.fbe_size()
        + tosql.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateTransformStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + replace.fbe_extra()
        + type_name.fbe_extra()
        + lang.fbe_extra()
        + fromsql.fbe_extra()
        + tosql.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateTransformStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateTransformStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + replace.fbe_size()) > fbe_struct_size)
        return true;
    if (!replace.verify())
        return false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + lang.fbe_size()) > fbe_struct_size)
        return true;
    if (!lang.verify())
        return false;
    fbe_current_size += lang.fbe_size();

    if ((fbe_current_size + fromsql.fbe_size()) > fbe_struct_size)
        return true;
    if (!fromsql.verify())
        return false;
    fbe_current_size += fromsql.fbe_size();

    if ((fbe_current_size + tosql.fbe_size()) > fbe_struct_size)
        return true;
    if (!tosql.verify())
        return false;
    fbe_current_size += tosql.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateTransformStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateTransformStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateTransformStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateTransformStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateTransformStmt& fbe_value = static_cast<::pg_query::CreateTransformStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + replace.fbe_size()) <= fbe_struct_size)
        {
            replace.get(fbe_value.replace);
        }
    else
        fbe_value.replace = false;
    fbe_current_size += replace.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(&fbe_value.type_name);
        }
    else
        fbe_value.type_name = nullptr;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + lang.fbe_size()) <= fbe_struct_size)
        {
            lang.get(fbe_value.lang);
        }
    else
        fbe_value.lang = "";
    fbe_current_size += lang.fbe_size();

    if ((fbe_current_size + fromsql.fbe_size()) <= fbe_struct_size)
        {
            fromsql.get(&fbe_value.fromsql);
        }
    else
        fbe_value.fromsql = nullptr;
    fbe_current_size += fromsql.fbe_size();

    if ((fbe_current_size + tosql.fbe_size()) <= fbe_struct_size)
        {
            tosql.get(&fbe_value.tosql);
        }
    else
        fbe_value.tosql = nullptr;
    fbe_current_size += tosql.fbe_size();
}

size_t FieldModel_pg_query_CreateTransformStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateTransformStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateTransformStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateTransformStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateTransformStmt& fbe_value = static_cast<const ::pg_query::CreateTransformStmt&>(base_fbe_value);
    replace.set(fbe_value.replace);
    type_name.set(fbe_value.type_name);
    lang.set(fbe_value.lang);
    fromsql.set(fbe_value.fromsql);
    tosql.set(fbe_value.tosql);
}

namespace pg_query {

bool CreateTransformStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateTransformStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateTransformStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateTransformStmtModel::serialize(const ::pg_query::CreateTransformStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateTransformStmtModel::deserialize(::pg_query::CreateTransformStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateAmStmt::FieldModelPtr_pg_query_CreateAmStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateAmStmt::~FieldModelPtr_pg_query_CreateAmStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateAmStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateAmStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateAmStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateAmStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateAmStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateAmStmt::get(::pg_query::CreateAmStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateAmStmt(_buffer, 0);

    ::pg_query::CreateAmStmt *tempModel = new ::pg_query::CreateAmStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateAmStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateAmStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateAmStmt::set(const ::pg_query::CreateAmStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateAmStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateAmStmt::FieldModel_pg_query_CreateAmStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , amname(buffer, 4 + 4)
    , handler_name(buffer, amname.fbe_offset() + amname.fbe_size())
    , amtype(buffer, handler_name.fbe_offset() + handler_name.fbe_size())
{}

size_t FieldModel_pg_query_CreateAmStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + amname.fbe_size()
        + handler_name.fbe_size()
        + amtype.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateAmStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + amname.fbe_extra()
        + handler_name.fbe_extra()
        + amtype.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateAmStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateAmStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + amname.fbe_size()) > fbe_struct_size)
        return true;
    if (!amname.verify())
        return false;
    fbe_current_size += amname.fbe_size();

    if ((fbe_current_size + handler_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!handler_name.verify())
        return false;
    fbe_current_size += handler_name.fbe_size();

    if ((fbe_current_size + amtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!amtype.verify())
        return false;
    fbe_current_size += amtype.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateAmStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateAmStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateAmStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateAmStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateAmStmt& fbe_value = static_cast<::pg_query::CreateAmStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + amname.fbe_size()) <= fbe_struct_size)
        {
            amname.get(fbe_value.amname);
        }
    else
        fbe_value.amname = "";
    fbe_current_size += amname.fbe_size();

    if ((fbe_current_size + handler_name.fbe_size()) <= fbe_struct_size)
        {
            handler_name.get(fbe_value.handler_name);
        }
    else
        fbe_value.handler_name.clear();
    fbe_current_size += handler_name.fbe_size();

    if ((fbe_current_size + amtype.fbe_size()) <= fbe_struct_size)
        {
            amtype.get(fbe_value.amtype);
        }
    else
        fbe_value.amtype = "";
    fbe_current_size += amtype.fbe_size();
}

size_t FieldModel_pg_query_CreateAmStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateAmStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateAmStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateAmStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateAmStmt& fbe_value = static_cast<const ::pg_query::CreateAmStmt&>(base_fbe_value);
    amname.set(fbe_value.amname);
    handler_name.set(fbe_value.handler_name);
    amtype.set(fbe_value.amtype);
}

namespace pg_query {

bool CreateAmStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateAmStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateAmStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateAmStmtModel::serialize(const ::pg_query::CreateAmStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateAmStmtModel::deserialize(::pg_query::CreateAmStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreatePublicationStmt::FieldModelPtr_pg_query_CreatePublicationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreatePublicationStmt::~FieldModelPtr_pg_query_CreatePublicationStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreatePublicationStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreatePublicationStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreatePublicationStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreatePublicationStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreatePublicationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreatePublicationStmt::get(::pg_query::CreatePublicationStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreatePublicationStmt(_buffer, 0);

    ::pg_query::CreatePublicationStmt *tempModel = new ::pg_query::CreatePublicationStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreatePublicationStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreatePublicationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreatePublicationStmt::set(const ::pg_query::CreatePublicationStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreatePublicationStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreatePublicationStmt::FieldModel_pg_query_CreatePublicationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , pubname(buffer, 4 + 4)
    , options(buffer, pubname.fbe_offset() + pubname.fbe_size())
    , tables(buffer, options.fbe_offset() + options.fbe_size())
    , for_all_tables(buffer, tables.fbe_offset() + tables.fbe_size())
{}

size_t FieldModel_pg_query_CreatePublicationStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + pubname.fbe_size()
        + options.fbe_size()
        + tables.fbe_size()
        + for_all_tables.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreatePublicationStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + pubname.fbe_extra()
        + options.fbe_extra()
        + tables.fbe_extra()
        + for_all_tables.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreatePublicationStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreatePublicationStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + pubname.fbe_size()) > fbe_struct_size)
        return true;
    if (!pubname.verify())
        return false;
    fbe_current_size += pubname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + tables.fbe_size()) > fbe_struct_size)
        return true;
    if (!tables.verify())
        return false;
    fbe_current_size += tables.fbe_size();

    if ((fbe_current_size + for_all_tables.fbe_size()) > fbe_struct_size)
        return true;
    if (!for_all_tables.verify())
        return false;
    fbe_current_size += for_all_tables.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreatePublicationStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreatePublicationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreatePublicationStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreatePublicationStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreatePublicationStmt& fbe_value = static_cast<::pg_query::CreatePublicationStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + pubname.fbe_size()) <= fbe_struct_size)
        {
            pubname.get(fbe_value.pubname);
        }
    else
        fbe_value.pubname = "";
    fbe_current_size += pubname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + tables.fbe_size()) <= fbe_struct_size)
        {
            tables.get(fbe_value.tables);
        }
    else
        fbe_value.tables.clear();
    fbe_current_size += tables.fbe_size();

    if ((fbe_current_size + for_all_tables.fbe_size()) <= fbe_struct_size)
        {
            for_all_tables.get(fbe_value.for_all_tables);
        }
    else
        fbe_value.for_all_tables = false;
    fbe_current_size += for_all_tables.fbe_size();
}

size_t FieldModel_pg_query_CreatePublicationStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreatePublicationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreatePublicationStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreatePublicationStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreatePublicationStmt& fbe_value = static_cast<const ::pg_query::CreatePublicationStmt&>(base_fbe_value);
    pubname.set(fbe_value.pubname);
    options.set(fbe_value.options);
    tables.set(fbe_value.tables);
    for_all_tables.set(fbe_value.for_all_tables);
}

namespace pg_query {

bool CreatePublicationStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreatePublicationStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreatePublicationStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreatePublicationStmtModel::serialize(const ::pg_query::CreatePublicationStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreatePublicationStmtModel::deserialize(::pg_query::CreatePublicationStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterPublicationStmt::FieldModelPtr_pg_query_AlterPublicationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterPublicationStmt::~FieldModelPtr_pg_query_AlterPublicationStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterPublicationStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterPublicationStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterPublicationStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterPublicationStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterPublicationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterPublicationStmt::get(::pg_query::AlterPublicationStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterPublicationStmt(_buffer, 0);

    ::pg_query::AlterPublicationStmt *tempModel = new ::pg_query::AlterPublicationStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterPublicationStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterPublicationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterPublicationStmt::set(const ::pg_query::AlterPublicationStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterPublicationStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterPublicationStmt::FieldModel_pg_query_AlterPublicationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , pubname(buffer, 4 + 4)
    , options(buffer, pubname.fbe_offset() + pubname.fbe_size())
    , tables(buffer, options.fbe_offset() + options.fbe_size())
    , for_all_tables(buffer, tables.fbe_offset() + tables.fbe_size())
    , table_action(buffer, for_all_tables.fbe_offset() + for_all_tables.fbe_size())
{}

size_t FieldModel_pg_query_AlterPublicationStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + pubname.fbe_size()
        + options.fbe_size()
        + tables.fbe_size()
        + for_all_tables.fbe_size()
        + table_action.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterPublicationStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + pubname.fbe_extra()
        + options.fbe_extra()
        + tables.fbe_extra()
        + for_all_tables.fbe_extra()
        + table_action.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterPublicationStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterPublicationStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + pubname.fbe_size()) > fbe_struct_size)
        return true;
    if (!pubname.verify())
        return false;
    fbe_current_size += pubname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + tables.fbe_size()) > fbe_struct_size)
        return true;
    if (!tables.verify())
        return false;
    fbe_current_size += tables.fbe_size();

    if ((fbe_current_size + for_all_tables.fbe_size()) > fbe_struct_size)
        return true;
    if (!for_all_tables.verify())
        return false;
    fbe_current_size += for_all_tables.fbe_size();

    if ((fbe_current_size + table_action.fbe_size()) > fbe_struct_size)
        return true;
    if (!table_action.verify())
        return false;
    fbe_current_size += table_action.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterPublicationStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterPublicationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterPublicationStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterPublicationStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterPublicationStmt& fbe_value = static_cast<::pg_query::AlterPublicationStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + pubname.fbe_size()) <= fbe_struct_size)
        {
            pubname.get(fbe_value.pubname);
        }
    else
        fbe_value.pubname = "";
    fbe_current_size += pubname.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + tables.fbe_size()) <= fbe_struct_size)
        {
            tables.get(fbe_value.tables);
        }
    else
        fbe_value.tables.clear();
    fbe_current_size += tables.fbe_size();

    if ((fbe_current_size + for_all_tables.fbe_size()) <= fbe_struct_size)
        {
            for_all_tables.get(fbe_value.for_all_tables);
        }
    else
        fbe_value.for_all_tables = false;
    fbe_current_size += for_all_tables.fbe_size();

    if ((fbe_current_size + table_action.fbe_size()) <= fbe_struct_size)
        {
            table_action.get(fbe_value.table_action);
        }
    else
        fbe_value.table_action = ::pg_query::DefElemAction();
    fbe_current_size += table_action.fbe_size();
}

size_t FieldModel_pg_query_AlterPublicationStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterPublicationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterPublicationStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterPublicationStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterPublicationStmt& fbe_value = static_cast<const ::pg_query::AlterPublicationStmt&>(base_fbe_value);
    pubname.set(fbe_value.pubname);
    options.set(fbe_value.options);
    tables.set(fbe_value.tables);
    for_all_tables.set(fbe_value.for_all_tables);
    table_action.set(fbe_value.table_action);
}

namespace pg_query {

bool AlterPublicationStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterPublicationStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterPublicationStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterPublicationStmtModel::serialize(const ::pg_query::AlterPublicationStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterPublicationStmtModel::deserialize(::pg_query::AlterPublicationStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateSubscriptionStmt::FieldModelPtr_pg_query_CreateSubscriptionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateSubscriptionStmt::~FieldModelPtr_pg_query_CreateSubscriptionStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateSubscriptionStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateSubscriptionStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateSubscriptionStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateSubscriptionStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateSubscriptionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateSubscriptionStmt::get(::pg_query::CreateSubscriptionStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateSubscriptionStmt(_buffer, 0);

    ::pg_query::CreateSubscriptionStmt *tempModel = new ::pg_query::CreateSubscriptionStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateSubscriptionStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateSubscriptionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateSubscriptionStmt::set(const ::pg_query::CreateSubscriptionStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateSubscriptionStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateSubscriptionStmt::FieldModel_pg_query_CreateSubscriptionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , subname(buffer, 4 + 4)
    , conninfo(buffer, subname.fbe_offset() + subname.fbe_size())
    , publication(buffer, conninfo.fbe_offset() + conninfo.fbe_size())
    , options(buffer, publication.fbe_offset() + publication.fbe_size())
{}

size_t FieldModel_pg_query_CreateSubscriptionStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + subname.fbe_size()
        + conninfo.fbe_size()
        + publication.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateSubscriptionStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + subname.fbe_extra()
        + conninfo.fbe_extra()
        + publication.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateSubscriptionStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateSubscriptionStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + subname.fbe_size()) > fbe_struct_size)
        return true;
    if (!subname.verify())
        return false;
    fbe_current_size += subname.fbe_size();

    if ((fbe_current_size + conninfo.fbe_size()) > fbe_struct_size)
        return true;
    if (!conninfo.verify())
        return false;
    fbe_current_size += conninfo.fbe_size();

    if ((fbe_current_size + publication.fbe_size()) > fbe_struct_size)
        return true;
    if (!publication.verify())
        return false;
    fbe_current_size += publication.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateSubscriptionStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateSubscriptionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateSubscriptionStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateSubscriptionStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateSubscriptionStmt& fbe_value = static_cast<::pg_query::CreateSubscriptionStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + subname.fbe_size()) <= fbe_struct_size)
        {
            subname.get(fbe_value.subname);
        }
    else
        fbe_value.subname = "";
    fbe_current_size += subname.fbe_size();

    if ((fbe_current_size + conninfo.fbe_size()) <= fbe_struct_size)
        {
            conninfo.get(fbe_value.conninfo);
        }
    else
        fbe_value.conninfo = "";
    fbe_current_size += conninfo.fbe_size();

    if ((fbe_current_size + publication.fbe_size()) <= fbe_struct_size)
        {
            publication.get(fbe_value.publication);
        }
    else
        fbe_value.publication.clear();
    fbe_current_size += publication.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_CreateSubscriptionStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateSubscriptionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateSubscriptionStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateSubscriptionStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateSubscriptionStmt& fbe_value = static_cast<const ::pg_query::CreateSubscriptionStmt&>(base_fbe_value);
    subname.set(fbe_value.subname);
    conninfo.set(fbe_value.conninfo);
    publication.set(fbe_value.publication);
    options.set(fbe_value.options);
}

namespace pg_query {

bool CreateSubscriptionStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateSubscriptionStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateSubscriptionStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateSubscriptionStmtModel::serialize(const ::pg_query::CreateSubscriptionStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateSubscriptionStmtModel::deserialize(::pg_query::CreateSubscriptionStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterSubscriptionStmt::FieldModelPtr_pg_query_AlterSubscriptionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterSubscriptionStmt::~FieldModelPtr_pg_query_AlterSubscriptionStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterSubscriptionStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterSubscriptionStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterSubscriptionStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterSubscriptionStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterSubscriptionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterSubscriptionStmt::get(::pg_query::AlterSubscriptionStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterSubscriptionStmt(_buffer, 0);

    ::pg_query::AlterSubscriptionStmt *tempModel = new ::pg_query::AlterSubscriptionStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterSubscriptionStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterSubscriptionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterSubscriptionStmt::set(const ::pg_query::AlterSubscriptionStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterSubscriptionStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterSubscriptionStmt::FieldModel_pg_query_AlterSubscriptionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , subname(buffer, kind.fbe_offset() + kind.fbe_size())
    , conninfo(buffer, subname.fbe_offset() + subname.fbe_size())
    , publication(buffer, conninfo.fbe_offset() + conninfo.fbe_size())
    , options(buffer, publication.fbe_offset() + publication.fbe_size())
{}

size_t FieldModel_pg_query_AlterSubscriptionStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + subname.fbe_size()
        + conninfo.fbe_size()
        + publication.fbe_size()
        + options.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterSubscriptionStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + subname.fbe_extra()
        + conninfo.fbe_extra()
        + publication.fbe_extra()
        + options.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterSubscriptionStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterSubscriptionStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + subname.fbe_size()) > fbe_struct_size)
        return true;
    if (!subname.verify())
        return false;
    fbe_current_size += subname.fbe_size();

    if ((fbe_current_size + conninfo.fbe_size()) > fbe_struct_size)
        return true;
    if (!conninfo.verify())
        return false;
    fbe_current_size += conninfo.fbe_size();

    if ((fbe_current_size + publication.fbe_size()) > fbe_struct_size)
        return true;
    if (!publication.verify())
        return false;
    fbe_current_size += publication.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterSubscriptionStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterSubscriptionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterSubscriptionStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterSubscriptionStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterSubscriptionStmt& fbe_value = static_cast<::pg_query::AlterSubscriptionStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::AlterSubscriptionType();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + subname.fbe_size()) <= fbe_struct_size)
        {
            subname.get(fbe_value.subname);
        }
    else
        fbe_value.subname = "";
    fbe_current_size += subname.fbe_size();

    if ((fbe_current_size + conninfo.fbe_size()) <= fbe_struct_size)
        {
            conninfo.get(fbe_value.conninfo);
        }
    else
        fbe_value.conninfo = "";
    fbe_current_size += conninfo.fbe_size();

    if ((fbe_current_size + publication.fbe_size()) <= fbe_struct_size)
        {
            publication.get(fbe_value.publication);
        }
    else
        fbe_value.publication.clear();
    fbe_current_size += publication.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();
}

size_t FieldModel_pg_query_AlterSubscriptionStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterSubscriptionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterSubscriptionStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterSubscriptionStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterSubscriptionStmt& fbe_value = static_cast<const ::pg_query::AlterSubscriptionStmt&>(base_fbe_value);
    kind.set(fbe_value.kind);
    subname.set(fbe_value.subname);
    conninfo.set(fbe_value.conninfo);
    publication.set(fbe_value.publication);
    options.set(fbe_value.options);
}

namespace pg_query {

bool AlterSubscriptionStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterSubscriptionStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterSubscriptionStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterSubscriptionStmtModel::serialize(const ::pg_query::AlterSubscriptionStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterSubscriptionStmtModel::deserialize(::pg_query::AlterSubscriptionStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DropSubscriptionStmt::FieldModelPtr_pg_query_DropSubscriptionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DropSubscriptionStmt::~FieldModelPtr_pg_query_DropSubscriptionStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DropSubscriptionStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DropSubscriptionStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DropSubscriptionStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DropSubscriptionStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropSubscriptionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropSubscriptionStmt::get(::pg_query::DropSubscriptionStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DropSubscriptionStmt(_buffer, 0);

    ::pg_query::DropSubscriptionStmt *tempModel = new ::pg_query::DropSubscriptionStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DropSubscriptionStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DropSubscriptionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DropSubscriptionStmt::set(const ::pg_query::DropSubscriptionStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DropSubscriptionStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DropSubscriptionStmt::FieldModel_pg_query_DropSubscriptionStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , subname(buffer, 4 + 4)
    , missing_ok(buffer, subname.fbe_offset() + subname.fbe_size())
    , behavior(buffer, missing_ok.fbe_offset() + missing_ok.fbe_size())
{}

size_t FieldModel_pg_query_DropSubscriptionStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + subname.fbe_size()
        + missing_ok.fbe_size()
        + behavior.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DropSubscriptionStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + subname.fbe_extra()
        + missing_ok.fbe_extra()
        + behavior.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DropSubscriptionStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DropSubscriptionStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + subname.fbe_size()) > fbe_struct_size)
        return true;
    if (!subname.verify())
        return false;
    fbe_current_size += subname.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) > fbe_struct_size)
        return true;
    if (!behavior.verify())
        return false;
    fbe_current_size += behavior.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DropSubscriptionStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropSubscriptionStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropSubscriptionStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DropSubscriptionStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DropSubscriptionStmt& fbe_value = static_cast<::pg_query::DropSubscriptionStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + subname.fbe_size()) <= fbe_struct_size)
        {
            subname.get(fbe_value.subname);
        }
    else
        fbe_value.subname = "";
    fbe_current_size += subname.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();

    if ((fbe_current_size + behavior.fbe_size()) <= fbe_struct_size)
        {
            behavior.get(fbe_value.behavior);
        }
    else
        fbe_value.behavior = ::pg_query::DropBehavior();
    fbe_current_size += behavior.fbe_size();
}

size_t FieldModel_pg_query_DropSubscriptionStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DropSubscriptionStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DropSubscriptionStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DropSubscriptionStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DropSubscriptionStmt& fbe_value = static_cast<const ::pg_query::DropSubscriptionStmt&>(base_fbe_value);
    subname.set(fbe_value.subname);
    missing_ok.set(fbe_value.missing_ok);
    behavior.set(fbe_value.behavior);
}

namespace pg_query {

bool DropSubscriptionStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DropSubscriptionStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DropSubscriptionStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DropSubscriptionStmtModel::serialize(const ::pg_query::DropSubscriptionStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DropSubscriptionStmtModel::deserialize(::pg_query::DropSubscriptionStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateStatsStmt::FieldModelPtr_pg_query_CreateStatsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateStatsStmt::~FieldModelPtr_pg_query_CreateStatsStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateStatsStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateStatsStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateStatsStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateStatsStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateStatsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateStatsStmt::get(::pg_query::CreateStatsStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateStatsStmt(_buffer, 0);

    ::pg_query::CreateStatsStmt *tempModel = new ::pg_query::CreateStatsStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateStatsStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateStatsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateStatsStmt::set(const ::pg_query::CreateStatsStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateStatsStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateStatsStmt::FieldModel_pg_query_CreateStatsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , defnames(buffer, 4 + 4)
    , stat_types(buffer, defnames.fbe_offset() + defnames.fbe_size())
    , exprs(buffer, stat_types.fbe_offset() + stat_types.fbe_size())
    , relations(buffer, exprs.fbe_offset() + exprs.fbe_size())
    , stxcomment(buffer, relations.fbe_offset() + relations.fbe_size())
    , if_not_exists(buffer, stxcomment.fbe_offset() + stxcomment.fbe_size())
{}

size_t FieldModel_pg_query_CreateStatsStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + defnames.fbe_size()
        + stat_types.fbe_size()
        + exprs.fbe_size()
        + relations.fbe_size()
        + stxcomment.fbe_size()
        + if_not_exists.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateStatsStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + defnames.fbe_extra()
        + stat_types.fbe_extra()
        + exprs.fbe_extra()
        + relations.fbe_extra()
        + stxcomment.fbe_extra()
        + if_not_exists.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateStatsStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateStatsStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + defnames.fbe_size()) > fbe_struct_size)
        return true;
    if (!defnames.verify())
        return false;
    fbe_current_size += defnames.fbe_size();

    if ((fbe_current_size + stat_types.fbe_size()) > fbe_struct_size)
        return true;
    if (!stat_types.verify())
        return false;
    fbe_current_size += stat_types.fbe_size();

    if ((fbe_current_size + exprs.fbe_size()) > fbe_struct_size)
        return true;
    if (!exprs.verify())
        return false;
    fbe_current_size += exprs.fbe_size();

    if ((fbe_current_size + relations.fbe_size()) > fbe_struct_size)
        return true;
    if (!relations.verify())
        return false;
    fbe_current_size += relations.fbe_size();

    if ((fbe_current_size + stxcomment.fbe_size()) > fbe_struct_size)
        return true;
    if (!stxcomment.verify())
        return false;
    fbe_current_size += stxcomment.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) > fbe_struct_size)
        return true;
    if (!if_not_exists.verify())
        return false;
    fbe_current_size += if_not_exists.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateStatsStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateStatsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateStatsStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateStatsStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateStatsStmt& fbe_value = static_cast<::pg_query::CreateStatsStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + defnames.fbe_size()) <= fbe_struct_size)
        {
            defnames.get(fbe_value.defnames);
        }
    else
        fbe_value.defnames.clear();
    fbe_current_size += defnames.fbe_size();

    if ((fbe_current_size + stat_types.fbe_size()) <= fbe_struct_size)
        {
            stat_types.get(fbe_value.stat_types);
        }
    else
        fbe_value.stat_types.clear();
    fbe_current_size += stat_types.fbe_size();

    if ((fbe_current_size + exprs.fbe_size()) <= fbe_struct_size)
        {
            exprs.get(fbe_value.exprs);
        }
    else
        fbe_value.exprs.clear();
    fbe_current_size += exprs.fbe_size();

    if ((fbe_current_size + relations.fbe_size()) <= fbe_struct_size)
        {
            relations.get(fbe_value.relations);
        }
    else
        fbe_value.relations.clear();
    fbe_current_size += relations.fbe_size();

    if ((fbe_current_size + stxcomment.fbe_size()) <= fbe_struct_size)
        {
            stxcomment.get(fbe_value.stxcomment);
        }
    else
        fbe_value.stxcomment = "";
    fbe_current_size += stxcomment.fbe_size();

    if ((fbe_current_size + if_not_exists.fbe_size()) <= fbe_struct_size)
        {
            if_not_exists.get(fbe_value.if_not_exists);
        }
    else
        fbe_value.if_not_exists = false;
    fbe_current_size += if_not_exists.fbe_size();
}

size_t FieldModel_pg_query_CreateStatsStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateStatsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateStatsStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateStatsStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateStatsStmt& fbe_value = static_cast<const ::pg_query::CreateStatsStmt&>(base_fbe_value);
    defnames.set(fbe_value.defnames);
    stat_types.set(fbe_value.stat_types);
    exprs.set(fbe_value.exprs);
    relations.set(fbe_value.relations);
    stxcomment.set(fbe_value.stxcomment);
    if_not_exists.set(fbe_value.if_not_exists);
}

namespace pg_query {

bool CreateStatsStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateStatsStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateStatsStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateStatsStmtModel::serialize(const ::pg_query::CreateStatsStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateStatsStmtModel::deserialize(::pg_query::CreateStatsStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterCollationStmt::FieldModelPtr_pg_query_AlterCollationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterCollationStmt::~FieldModelPtr_pg_query_AlterCollationStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterCollationStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterCollationStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterCollationStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterCollationStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterCollationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterCollationStmt::get(::pg_query::AlterCollationStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterCollationStmt(_buffer, 0);

    ::pg_query::AlterCollationStmt *tempModel = new ::pg_query::AlterCollationStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterCollationStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterCollationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterCollationStmt::set(const ::pg_query::AlterCollationStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterCollationStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterCollationStmt::FieldModel_pg_query_AlterCollationStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , collname(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_AlterCollationStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + collname.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterCollationStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + collname.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterCollationStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterCollationStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + collname.fbe_size()) > fbe_struct_size)
        return true;
    if (!collname.verify())
        return false;
    fbe_current_size += collname.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterCollationStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterCollationStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterCollationStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterCollationStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterCollationStmt& fbe_value = static_cast<::pg_query::AlterCollationStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + collname.fbe_size()) <= fbe_struct_size)
        {
            collname.get(fbe_value.collname);
        }
    else
        fbe_value.collname.clear();
    fbe_current_size += collname.fbe_size();
}

size_t FieldModel_pg_query_AlterCollationStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterCollationStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterCollationStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterCollationStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterCollationStmt& fbe_value = static_cast<const ::pg_query::AlterCollationStmt&>(base_fbe_value);
    collname.set(fbe_value.collname);
}

namespace pg_query {

bool AlterCollationStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterCollationStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterCollationStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterCollationStmtModel::serialize(const ::pg_query::AlterCollationStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterCollationStmtModel::deserialize(::pg_query::AlterCollationStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CallStmt::FieldModelPtr_pg_query_CallStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CallStmt::~FieldModelPtr_pg_query_CallStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CallStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CallStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CallStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CallStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CallStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CallStmt::get(::pg_query::CallStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CallStmt(_buffer, 0);

    ::pg_query::CallStmt *tempModel = new ::pg_query::CallStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CallStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CallStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CallStmt::set(const ::pg_query::CallStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CallStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CallStmt::FieldModel_pg_query_CallStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , funccall(buffer, 4 + 4)
    , funcexpr(buffer, funccall.fbe_offset() + funccall.fbe_size())
{}

size_t FieldModel_pg_query_CallStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + funccall.fbe_size()
        + funcexpr.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CallStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + funccall.fbe_extra()
        + funcexpr.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CallStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CallStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + funccall.fbe_size()) > fbe_struct_size)
        return true;
    if (!funccall.verify())
        return false;
    fbe_current_size += funccall.fbe_size();

    if ((fbe_current_size + funcexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcexpr.verify())
        return false;
    fbe_current_size += funcexpr.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CallStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CallStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CallStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CallStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CallStmt& fbe_value = static_cast<::pg_query::CallStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + funccall.fbe_size()) <= fbe_struct_size)
        {
            funccall.get(&fbe_value.funccall);
        }
    else
        fbe_value.funccall = nullptr;
    fbe_current_size += funccall.fbe_size();

    if ((fbe_current_size + funcexpr.fbe_size()) <= fbe_struct_size)
        {
            funcexpr.get(&fbe_value.funcexpr);
        }
    else
        fbe_value.funcexpr = nullptr;
    fbe_current_size += funcexpr.fbe_size();
}

size_t FieldModel_pg_query_CallStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CallStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CallStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CallStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CallStmt& fbe_value = static_cast<const ::pg_query::CallStmt&>(base_fbe_value);
    funccall.set(fbe_value.funccall);
    funcexpr.set(fbe_value.funcexpr);
}

namespace pg_query {

bool CallStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CallStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CallStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CallStmtModel::serialize(const ::pg_query::CallStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CallStmtModel::deserialize(::pg_query::CallStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AlterStatsStmt::FieldModelPtr_pg_query_AlterStatsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AlterStatsStmt::~FieldModelPtr_pg_query_AlterStatsStmt()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AlterStatsStmt::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterStatsStmt::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AlterStatsStmt::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AlterStatsStmt::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterStatsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterStatsStmt::get(::pg_query::AlterStatsStmt** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AlterStatsStmt(_buffer, 0);

    ::pg_query::AlterStatsStmt *tempModel = new ::pg_query::AlterStatsStmt();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AlterStatsStmt::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AlterStatsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AlterStatsStmt::set(const ::pg_query::AlterStatsStmt* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AlterStatsStmt(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AlterStatsStmt::FieldModel_pg_query_AlterStatsStmt(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , defnames(buffer, 4 + 4)
    , stxstattarget(buffer, defnames.fbe_offset() + defnames.fbe_size())
    , missing_ok(buffer, stxstattarget.fbe_offset() + stxstattarget.fbe_size())
{}

size_t FieldModel_pg_query_AlterStatsStmt::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + defnames.fbe_size()
        + stxstattarget.fbe_size()
        + missing_ok.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AlterStatsStmt::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + defnames.fbe_extra()
        + stxstattarget.fbe_extra()
        + missing_ok.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AlterStatsStmt::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AlterStatsStmt::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + defnames.fbe_size()) > fbe_struct_size)
        return true;
    if (!defnames.verify())
        return false;
    fbe_current_size += defnames.fbe_size();

    if ((fbe_current_size + stxstattarget.fbe_size()) > fbe_struct_size)
        return true;
    if (!stxstattarget.verify())
        return false;
    fbe_current_size += stxstattarget.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) > fbe_struct_size)
        return true;
    if (!missing_ok.verify())
        return false;
    fbe_current_size += missing_ok.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AlterStatsStmt::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterStatsStmt::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterStatsStmt::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AlterStatsStmt::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AlterStatsStmt& fbe_value = static_cast<::pg_query::AlterStatsStmt&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + defnames.fbe_size()) <= fbe_struct_size)
        {
            defnames.get(fbe_value.defnames);
        }
    else
        fbe_value.defnames.clear();
    fbe_current_size += defnames.fbe_size();

    if ((fbe_current_size + stxstattarget.fbe_size()) <= fbe_struct_size)
        {
            stxstattarget.get(fbe_value.stxstattarget);
        }
    else
        fbe_value.stxstattarget = (int32_t)0ll;
    fbe_current_size += stxstattarget.fbe_size();

    if ((fbe_current_size + missing_ok.fbe_size()) <= fbe_struct_size)
        {
            missing_ok.get(fbe_value.missing_ok);
        }
    else
        fbe_value.missing_ok = false;
    fbe_current_size += missing_ok.fbe_size();
}

size_t FieldModel_pg_query_AlterStatsStmt::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AlterStatsStmt::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AlterStatsStmt::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AlterStatsStmt::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AlterStatsStmt& fbe_value = static_cast<const ::pg_query::AlterStatsStmt&>(base_fbe_value);
    defnames.set(fbe_value.defnames);
    stxstattarget.set(fbe_value.stxstattarget);
    missing_ok.set(fbe_value.missing_ok);
}

namespace pg_query {

bool AlterStatsStmtModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AlterStatsStmtModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AlterStatsStmtModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AlterStatsStmtModel::serialize(const ::pg_query::AlterStatsStmt& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AlterStatsStmtModel::deserialize(::pg_query::AlterStatsStmt& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_A_Expr::FieldModelPtr_pg_query_A_Expr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_A_Expr::~FieldModelPtr_pg_query_A_Expr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_A_Expr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Expr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Expr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_A_Expr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Expr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Expr::get(::pg_query::A_Expr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_A_Expr(_buffer, 0);

    ::pg_query::A_Expr *tempModel = new ::pg_query::A_Expr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_A_Expr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Expr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Expr::set(const ::pg_query::A_Expr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_A_Expr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_A_Expr::FieldModel_pg_query_A_Expr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , name(buffer, kind.fbe_offset() + kind.fbe_size())
    , lexpr(buffer, name.fbe_offset() + name.fbe_size())
    , rexpr(buffer, lexpr.fbe_offset() + lexpr.fbe_size())
    , location(buffer, rexpr.fbe_offset() + rexpr.fbe_size())
{}

size_t FieldModel_pg_query_A_Expr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + name.fbe_size()
        + lexpr.fbe_size()
        + rexpr.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_A_Expr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + name.fbe_extra()
        + lexpr.fbe_extra()
        + rexpr.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_A_Expr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_A_Expr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + lexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!lexpr.verify())
        return false;
    fbe_current_size += lexpr.fbe_size();

    if ((fbe_current_size + rexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!rexpr.verify())
        return false;
    fbe_current_size += rexpr.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_A_Expr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Expr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Expr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_A_Expr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::A_Expr& fbe_value = static_cast<::pg_query::A_Expr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::A_Expr_Kind();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name.clear();
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + lexpr.fbe_size()) <= fbe_struct_size)
        {
            lexpr.get(fbe_value.lexpr);
        }
    else
        fbe_value.lexpr = ::pg_query::Node();
    fbe_current_size += lexpr.fbe_size();

    if ((fbe_current_size + rexpr.fbe_size()) <= fbe_struct_size)
        {
            rexpr.get(fbe_value.rexpr);
        }
    else
        fbe_value.rexpr = ::pg_query::Node();
    fbe_current_size += rexpr.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_A_Expr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Expr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Expr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_A_Expr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::A_Expr& fbe_value = static_cast<const ::pg_query::A_Expr&>(base_fbe_value);
    kind.set(fbe_value.kind);
    name.set(fbe_value.name);
    lexpr.set(fbe_value.lexpr);
    rexpr.set(fbe_value.rexpr);
    location.set(fbe_value.location);
}

namespace pg_query {

bool A_ExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t A_ExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t A_ExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t A_ExprModel::serialize(const ::pg_query::A_Expr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t A_ExprModel::deserialize(::pg_query::A_Expr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ColumnRef::FieldModelPtr_pg_query_ColumnRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ColumnRef::~FieldModelPtr_pg_query_ColumnRef()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ColumnRef::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ColumnRef::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ColumnRef::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ColumnRef::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ColumnRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ColumnRef::get(::pg_query::ColumnRef** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ColumnRef(_buffer, 0);

    ::pg_query::ColumnRef *tempModel = new ::pg_query::ColumnRef();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ColumnRef::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ColumnRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ColumnRef::set(const ::pg_query::ColumnRef* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ColumnRef(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ColumnRef::FieldModel_pg_query_ColumnRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , fields(buffer, 4 + 4)
    , location(buffer, fields.fbe_offset() + fields.fbe_size())
{}

size_t FieldModel_pg_query_ColumnRef::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + fields.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ColumnRef::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + fields.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ColumnRef::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ColumnRef::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + fields.fbe_size()) > fbe_struct_size)
        return true;
    if (!fields.verify())
        return false;
    fbe_current_size += fields.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ColumnRef::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ColumnRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ColumnRef::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ColumnRef::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ColumnRef& fbe_value = static_cast<::pg_query::ColumnRef&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + fields.fbe_size()) <= fbe_struct_size)
        {
            fields.get(fbe_value.fields);
        }
    else
        fbe_value.fields.clear();
    fbe_current_size += fields.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_ColumnRef::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ColumnRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ColumnRef::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ColumnRef::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ColumnRef& fbe_value = static_cast<const ::pg_query::ColumnRef&>(base_fbe_value);
    fields.set(fbe_value.fields);
    location.set(fbe_value.location);
}

namespace pg_query {

bool ColumnRefModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ColumnRefModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ColumnRefModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ColumnRefModel::serialize(const ::pg_query::ColumnRef& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ColumnRefModel::deserialize(::pg_query::ColumnRef& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ParamRef::FieldModelPtr_pg_query_ParamRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ParamRef::~FieldModelPtr_pg_query_ParamRef()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ParamRef::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ParamRef::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ParamRef::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ParamRef::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ParamRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ParamRef::get(::pg_query::ParamRef** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ParamRef(_buffer, 0);

    ::pg_query::ParamRef *tempModel = new ::pg_query::ParamRef();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ParamRef::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ParamRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ParamRef::set(const ::pg_query::ParamRef* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ParamRef(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ParamRef::FieldModel_pg_query_ParamRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , number(buffer, 4 + 4)
    , location(buffer, number.fbe_offset() + number.fbe_size())
{}

size_t FieldModel_pg_query_ParamRef::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + number.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ParamRef::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + number.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ParamRef::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ParamRef::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + number.fbe_size()) > fbe_struct_size)
        return true;
    if (!number.verify())
        return false;
    fbe_current_size += number.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ParamRef::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ParamRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ParamRef::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ParamRef::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ParamRef& fbe_value = static_cast<::pg_query::ParamRef&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + number.fbe_size()) <= fbe_struct_size)
        {
            number.get(fbe_value.number);
        }
    else
        fbe_value.number = (int32_t)0ll;
    fbe_current_size += number.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_ParamRef::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ParamRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ParamRef::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ParamRef::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ParamRef& fbe_value = static_cast<const ::pg_query::ParamRef&>(base_fbe_value);
    number.set(fbe_value.number);
    location.set(fbe_value.location);
}

namespace pg_query {

bool ParamRefModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ParamRefModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ParamRefModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ParamRefModel::serialize(const ::pg_query::ParamRef& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ParamRefModel::deserialize(::pg_query::ParamRef& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_A_Const::FieldModelPtr_pg_query_A_Const(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_A_Const::~FieldModelPtr_pg_query_A_Const()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_A_Const::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Const::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Const::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_A_Const::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Const::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Const::get(::pg_query::A_Const** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_A_Const(_buffer, 0);

    ::pg_query::A_Const *tempModel = new ::pg_query::A_Const();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_A_Const::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Const::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Const::set(const ::pg_query::A_Const* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_A_Const(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_A_Const::FieldModel_pg_query_A_Const(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , val(buffer, 4 + 4)
    , location(buffer, val.fbe_offset() + val.fbe_size())
{}

size_t FieldModel_pg_query_A_Const::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + val.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_A_Const::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + val.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_A_Const::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_A_Const::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + val.fbe_size()) > fbe_struct_size)
        return true;
    if (!val.verify())
        return false;
    fbe_current_size += val.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_A_Const::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Const::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Const::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_A_Const::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::A_Const& fbe_value = static_cast<::pg_query::A_Const&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + val.fbe_size()) <= fbe_struct_size)
        {
            val.get(fbe_value.val);
        }
    else
        fbe_value.val = ::pg_query::Node();
    fbe_current_size += val.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_A_Const::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Const::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Const::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_A_Const::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::A_Const& fbe_value = static_cast<const ::pg_query::A_Const&>(base_fbe_value);
    val.set(fbe_value.val);
    location.set(fbe_value.location);
}

namespace pg_query {

bool A_ConstModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t A_ConstModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t A_ConstModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t A_ConstModel::serialize(const ::pg_query::A_Const& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t A_ConstModel::deserialize(::pg_query::A_Const& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_FuncCall::FieldModelPtr_pg_query_FuncCall(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_FuncCall::~FieldModelPtr_pg_query_FuncCall()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_FuncCall::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_FuncCall::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_FuncCall::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_FuncCall::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FuncCall::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FuncCall::get(::pg_query::FuncCall** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_FuncCall(_buffer, 0);

    ::pg_query::FuncCall *tempModel = new ::pg_query::FuncCall();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_FuncCall::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FuncCall::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FuncCall::set(const ::pg_query::FuncCall* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_FuncCall(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_FuncCall::FieldModel_pg_query_FuncCall(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , funcname(buffer, 4 + 4)
    , args(buffer, funcname.fbe_offset() + funcname.fbe_size())
    , agg_order(buffer, args.fbe_offset() + args.fbe_size())
    , agg_filter(buffer, agg_order.fbe_offset() + agg_order.fbe_size())
    , agg_within_group(buffer, agg_filter.fbe_offset() + agg_filter.fbe_size())
    , agg_star(buffer, agg_within_group.fbe_offset() + agg_within_group.fbe_size())
    , agg_distinct(buffer, agg_star.fbe_offset() + agg_star.fbe_size())
    , func_variadic(buffer, agg_distinct.fbe_offset() + agg_distinct.fbe_size())
    , over(buffer, func_variadic.fbe_offset() + func_variadic.fbe_size())
    , location(buffer, over.fbe_offset() + over.fbe_size())
{}

size_t FieldModel_pg_query_FuncCall::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + funcname.fbe_size()
        + args.fbe_size()
        + agg_order.fbe_size()
        + agg_filter.fbe_size()
        + agg_within_group.fbe_size()
        + agg_star.fbe_size()
        + agg_distinct.fbe_size()
        + func_variadic.fbe_size()
        + over.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_FuncCall::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + funcname.fbe_extra()
        + args.fbe_extra()
        + agg_order.fbe_extra()
        + agg_filter.fbe_extra()
        + agg_within_group.fbe_extra()
        + agg_star.fbe_extra()
        + agg_distinct.fbe_extra()
        + func_variadic.fbe_extra()
        + over.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_FuncCall::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_FuncCall::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + funcname.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcname.verify())
        return false;
    fbe_current_size += funcname.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + agg_order.fbe_size()) > fbe_struct_size)
        return true;
    if (!agg_order.verify())
        return false;
    fbe_current_size += agg_order.fbe_size();

    if ((fbe_current_size + agg_filter.fbe_size()) > fbe_struct_size)
        return true;
    if (!agg_filter.verify())
        return false;
    fbe_current_size += agg_filter.fbe_size();

    if ((fbe_current_size + agg_within_group.fbe_size()) > fbe_struct_size)
        return true;
    if (!agg_within_group.verify())
        return false;
    fbe_current_size += agg_within_group.fbe_size();

    if ((fbe_current_size + agg_star.fbe_size()) > fbe_struct_size)
        return true;
    if (!agg_star.verify())
        return false;
    fbe_current_size += agg_star.fbe_size();

    if ((fbe_current_size + agg_distinct.fbe_size()) > fbe_struct_size)
        return true;
    if (!agg_distinct.verify())
        return false;
    fbe_current_size += agg_distinct.fbe_size();

    if ((fbe_current_size + func_variadic.fbe_size()) > fbe_struct_size)
        return true;
    if (!func_variadic.verify())
        return false;
    fbe_current_size += func_variadic.fbe_size();

    if ((fbe_current_size + over.fbe_size()) > fbe_struct_size)
        return true;
    if (!over.verify())
        return false;
    fbe_current_size += over.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_FuncCall::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FuncCall::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FuncCall::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_FuncCall::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::FuncCall& fbe_value = static_cast<::pg_query::FuncCall&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + funcname.fbe_size()) <= fbe_struct_size)
        {
            funcname.get(fbe_value.funcname);
        }
    else
        fbe_value.funcname.clear();
    fbe_current_size += funcname.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + agg_order.fbe_size()) <= fbe_struct_size)
        {
            agg_order.get(fbe_value.agg_order);
        }
    else
        fbe_value.agg_order.clear();
    fbe_current_size += agg_order.fbe_size();

    if ((fbe_current_size + agg_filter.fbe_size()) <= fbe_struct_size)
        {
            agg_filter.get(fbe_value.agg_filter);
        }
    else
        fbe_value.agg_filter = ::pg_query::Node();
    fbe_current_size += agg_filter.fbe_size();

    if ((fbe_current_size + agg_within_group.fbe_size()) <= fbe_struct_size)
        {
            agg_within_group.get(fbe_value.agg_within_group);
        }
    else
        fbe_value.agg_within_group = false;
    fbe_current_size += agg_within_group.fbe_size();

    if ((fbe_current_size + agg_star.fbe_size()) <= fbe_struct_size)
        {
            agg_star.get(fbe_value.agg_star);
        }
    else
        fbe_value.agg_star = false;
    fbe_current_size += agg_star.fbe_size();

    if ((fbe_current_size + agg_distinct.fbe_size()) <= fbe_struct_size)
        {
            agg_distinct.get(fbe_value.agg_distinct);
        }
    else
        fbe_value.agg_distinct = false;
    fbe_current_size += agg_distinct.fbe_size();

    if ((fbe_current_size + func_variadic.fbe_size()) <= fbe_struct_size)
        {
            func_variadic.get(fbe_value.func_variadic);
        }
    else
        fbe_value.func_variadic = false;
    fbe_current_size += func_variadic.fbe_size();

    if ((fbe_current_size + over.fbe_size()) <= fbe_struct_size)
        {
            over.get(&fbe_value.over);
        }
    else
        fbe_value.over = nullptr;
    fbe_current_size += over.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_FuncCall::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FuncCall::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FuncCall::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_FuncCall::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::FuncCall& fbe_value = static_cast<const ::pg_query::FuncCall&>(base_fbe_value);
    funcname.set(fbe_value.funcname);
    args.set(fbe_value.args);
    agg_order.set(fbe_value.agg_order);
    agg_filter.set(fbe_value.agg_filter);
    agg_within_group.set(fbe_value.agg_within_group);
    agg_star.set(fbe_value.agg_star);
    agg_distinct.set(fbe_value.agg_distinct);
    func_variadic.set(fbe_value.func_variadic);
    over.set(fbe_value.over);
    location.set(fbe_value.location);
}

namespace pg_query {

bool FuncCallModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t FuncCallModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t FuncCallModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t FuncCallModel::serialize(const ::pg_query::FuncCall& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t FuncCallModel::deserialize(::pg_query::FuncCall& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_A_Star::FieldModelPtr_pg_query_A_Star(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_A_Star::~FieldModelPtr_pg_query_A_Star()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_A_Star::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Star::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Star::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_A_Star::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Star::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Star::get(::pg_query::A_Star** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_A_Star(_buffer, 0);

    ::pg_query::A_Star *tempModel = new ::pg_query::A_Star();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_A_Star::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Star::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Star::set(const ::pg_query::A_Star* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_A_Star(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_A_Star::FieldModel_pg_query_A_Star(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FieldModel_pg_query_A_Star::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_A_Star::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_A_Star::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_A_Star::verify_fields(size_t fbe_struct_size) const noexcept
{
    return true;
}

size_t FieldModel_pg_query_A_Star::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Star::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Star::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_A_Star::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
}

size_t FieldModel_pg_query_A_Star::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Star::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Star::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_A_Star::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::A_Star& fbe_value = static_cast<const ::pg_query::A_Star&>(base_fbe_value);
}

namespace pg_query {

bool A_StarModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t A_StarModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t A_StarModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t A_StarModel::serialize(const ::pg_query::A_Star& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t A_StarModel::deserialize(::pg_query::A_Star& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_A_Indices::FieldModelPtr_pg_query_A_Indices(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_A_Indices::~FieldModelPtr_pg_query_A_Indices()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_A_Indices::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Indices::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Indices::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_A_Indices::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Indices::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Indices::get(::pg_query::A_Indices** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_A_Indices(_buffer, 0);

    ::pg_query::A_Indices *tempModel = new ::pg_query::A_Indices();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_A_Indices::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Indices::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Indices::set(const ::pg_query::A_Indices* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_A_Indices(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_A_Indices::FieldModel_pg_query_A_Indices(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , is_slice(buffer, 4 + 4)
    , lidx(buffer, is_slice.fbe_offset() + is_slice.fbe_size())
    , uidx(buffer, lidx.fbe_offset() + lidx.fbe_size())
{}

size_t FieldModel_pg_query_A_Indices::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + is_slice.fbe_size()
        + lidx.fbe_size()
        + uidx.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_A_Indices::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + is_slice.fbe_extra()
        + lidx.fbe_extra()
        + uidx.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_A_Indices::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_A_Indices::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + is_slice.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_slice.verify())
        return false;
    fbe_current_size += is_slice.fbe_size();

    if ((fbe_current_size + lidx.fbe_size()) > fbe_struct_size)
        return true;
    if (!lidx.verify())
        return false;
    fbe_current_size += lidx.fbe_size();

    if ((fbe_current_size + uidx.fbe_size()) > fbe_struct_size)
        return true;
    if (!uidx.verify())
        return false;
    fbe_current_size += uidx.fbe_size();

    return true;
}

size_t FieldModel_pg_query_A_Indices::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Indices::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Indices::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_A_Indices::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::A_Indices& fbe_value = static_cast<::pg_query::A_Indices&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + is_slice.fbe_size()) <= fbe_struct_size)
        {
            is_slice.get(fbe_value.is_slice);
        }
    else
        fbe_value.is_slice = false;
    fbe_current_size += is_slice.fbe_size();

    if ((fbe_current_size + lidx.fbe_size()) <= fbe_struct_size)
        {
            lidx.get(fbe_value.lidx);
        }
    else
        fbe_value.lidx = ::pg_query::Node();
    fbe_current_size += lidx.fbe_size();

    if ((fbe_current_size + uidx.fbe_size()) <= fbe_struct_size)
        {
            uidx.get(fbe_value.uidx);
        }
    else
        fbe_value.uidx = ::pg_query::Node();
    fbe_current_size += uidx.fbe_size();
}

size_t FieldModel_pg_query_A_Indices::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Indices::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Indices::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_A_Indices::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::A_Indices& fbe_value = static_cast<const ::pg_query::A_Indices&>(base_fbe_value);
    is_slice.set(fbe_value.is_slice);
    lidx.set(fbe_value.lidx);
    uidx.set(fbe_value.uidx);
}

namespace pg_query {

bool A_IndicesModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t A_IndicesModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t A_IndicesModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t A_IndicesModel::serialize(const ::pg_query::A_Indices& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t A_IndicesModel::deserialize(::pg_query::A_Indices& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_A_Indirection::FieldModelPtr_pg_query_A_Indirection(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_A_Indirection::~FieldModelPtr_pg_query_A_Indirection()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_A_Indirection::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Indirection::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_A_Indirection::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_A_Indirection::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Indirection::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Indirection::get(::pg_query::A_Indirection** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_A_Indirection(_buffer, 0);

    ::pg_query::A_Indirection *tempModel = new ::pg_query::A_Indirection();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_A_Indirection::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_Indirection::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_Indirection::set(const ::pg_query::A_Indirection* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_A_Indirection(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_A_Indirection::FieldModel_pg_query_A_Indirection(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , arg(buffer, 4 + 4)
    , indirection(buffer, arg.fbe_offset() + arg.fbe_size())
{}

size_t FieldModel_pg_query_A_Indirection::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + arg.fbe_size()
        + indirection.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_A_Indirection::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + arg.fbe_extra()
        + indirection.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_A_Indirection::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_A_Indirection::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + indirection.fbe_size()) > fbe_struct_size)
        return true;
    if (!indirection.verify())
        return false;
    fbe_current_size += indirection.fbe_size();

    return true;
}

size_t FieldModel_pg_query_A_Indirection::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Indirection::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Indirection::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_A_Indirection::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::A_Indirection& fbe_value = static_cast<::pg_query::A_Indirection&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + indirection.fbe_size()) <= fbe_struct_size)
        {
            indirection.get(fbe_value.indirection);
        }
    else
        fbe_value.indirection.clear();
    fbe_current_size += indirection.fbe_size();
}

size_t FieldModel_pg_query_A_Indirection::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_Indirection::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_Indirection::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_A_Indirection::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::A_Indirection& fbe_value = static_cast<const ::pg_query::A_Indirection&>(base_fbe_value);
    arg.set(fbe_value.arg);
    indirection.set(fbe_value.indirection);
}

namespace pg_query {

bool A_IndirectionModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t A_IndirectionModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t A_IndirectionModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t A_IndirectionModel::serialize(const ::pg_query::A_Indirection& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t A_IndirectionModel::deserialize(::pg_query::A_Indirection& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_A_ArrayExpr::FieldModelPtr_pg_query_A_ArrayExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_A_ArrayExpr::~FieldModelPtr_pg_query_A_ArrayExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_A_ArrayExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_A_ArrayExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_A_ArrayExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_A_ArrayExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_ArrayExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_ArrayExpr::get(::pg_query::A_ArrayExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_A_ArrayExpr(_buffer, 0);

    ::pg_query::A_ArrayExpr *tempModel = new ::pg_query::A_ArrayExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_A_ArrayExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_A_ArrayExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_A_ArrayExpr::set(const ::pg_query::A_ArrayExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_A_ArrayExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_A_ArrayExpr::FieldModel_pg_query_A_ArrayExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , elements(buffer, 4 + 4)
    , location(buffer, elements.fbe_offset() + elements.fbe_size())
{}

size_t FieldModel_pg_query_A_ArrayExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + elements.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_A_ArrayExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + elements.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_A_ArrayExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_A_ArrayExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + elements.fbe_size()) > fbe_struct_size)
        return true;
    if (!elements.verify())
        return false;
    fbe_current_size += elements.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_A_ArrayExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_ArrayExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_ArrayExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_A_ArrayExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::A_ArrayExpr& fbe_value = static_cast<::pg_query::A_ArrayExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + elements.fbe_size()) <= fbe_struct_size)
        {
            elements.get(fbe_value.elements);
        }
    else
        fbe_value.elements.clear();
    fbe_current_size += elements.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_A_ArrayExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_A_ArrayExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_A_ArrayExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_A_ArrayExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::A_ArrayExpr& fbe_value = static_cast<const ::pg_query::A_ArrayExpr&>(base_fbe_value);
    elements.set(fbe_value.elements);
    location.set(fbe_value.location);
}

namespace pg_query {

bool A_ArrayExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t A_ArrayExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t A_ArrayExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t A_ArrayExprModel::serialize(const ::pg_query::A_ArrayExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t A_ArrayExprModel::deserialize(::pg_query::A_ArrayExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ResTarget::FieldModelPtr_pg_query_ResTarget(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ResTarget::~FieldModelPtr_pg_query_ResTarget()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ResTarget::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ResTarget::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ResTarget::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ResTarget::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ResTarget::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ResTarget::get(::pg_query::ResTarget** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ResTarget(_buffer, 0);

    ::pg_query::ResTarget *tempModel = new ::pg_query::ResTarget();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ResTarget::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ResTarget::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ResTarget::set(const ::pg_query::ResTarget* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ResTarget(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ResTarget::FieldModel_pg_query_ResTarget(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , indirection(buffer, name.fbe_offset() + name.fbe_size())
    , val(buffer, indirection.fbe_offset() + indirection.fbe_size())
    , location(buffer, val.fbe_offset() + val.fbe_size())
{}

size_t FieldModel_pg_query_ResTarget::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + indirection.fbe_size()
        + val.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ResTarget::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + indirection.fbe_extra()
        + val.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ResTarget::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ResTarget::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + indirection.fbe_size()) > fbe_struct_size)
        return true;
    if (!indirection.verify())
        return false;
    fbe_current_size += indirection.fbe_size();

    if ((fbe_current_size + val.fbe_size()) > fbe_struct_size)
        return true;
    if (!val.verify())
        return false;
    fbe_current_size += val.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ResTarget::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ResTarget::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ResTarget::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ResTarget::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ResTarget& fbe_value = static_cast<::pg_query::ResTarget&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + indirection.fbe_size()) <= fbe_struct_size)
        {
            indirection.get(fbe_value.indirection);
        }
    else
        fbe_value.indirection.clear();
    fbe_current_size += indirection.fbe_size();

    if ((fbe_current_size + val.fbe_size()) <= fbe_struct_size)
        {
            val.get(fbe_value.val);
        }
    else
        fbe_value.val = ::pg_query::Node();
    fbe_current_size += val.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_ResTarget::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ResTarget::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ResTarget::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ResTarget::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ResTarget& fbe_value = static_cast<const ::pg_query::ResTarget&>(base_fbe_value);
    name.set(fbe_value.name);
    indirection.set(fbe_value.indirection);
    val.set(fbe_value.val);
    location.set(fbe_value.location);
}

namespace pg_query {

bool ResTargetModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ResTargetModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ResTargetModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ResTargetModel::serialize(const ::pg_query::ResTarget& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ResTargetModel::deserialize(::pg_query::ResTarget& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_MultiAssignRef::FieldModelPtr_pg_query_MultiAssignRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_MultiAssignRef::~FieldModelPtr_pg_query_MultiAssignRef()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_MultiAssignRef::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_MultiAssignRef::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_MultiAssignRef::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_MultiAssignRef::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_MultiAssignRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_MultiAssignRef::get(::pg_query::MultiAssignRef** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_MultiAssignRef(_buffer, 0);

    ::pg_query::MultiAssignRef *tempModel = new ::pg_query::MultiAssignRef();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_MultiAssignRef::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_MultiAssignRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_MultiAssignRef::set(const ::pg_query::MultiAssignRef* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_MultiAssignRef(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_MultiAssignRef::FieldModel_pg_query_MultiAssignRef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , source(buffer, 4 + 4)
    , colno(buffer, source.fbe_offset() + source.fbe_size())
    , ncolumns(buffer, colno.fbe_offset() + colno.fbe_size())
{}

size_t FieldModel_pg_query_MultiAssignRef::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + source.fbe_size()
        + colno.fbe_size()
        + ncolumns.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_MultiAssignRef::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + source.fbe_extra()
        + colno.fbe_extra()
        + ncolumns.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_MultiAssignRef::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_MultiAssignRef::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + source.fbe_size()) > fbe_struct_size)
        return true;
    if (!source.verify())
        return false;
    fbe_current_size += source.fbe_size();

    if ((fbe_current_size + colno.fbe_size()) > fbe_struct_size)
        return true;
    if (!colno.verify())
        return false;
    fbe_current_size += colno.fbe_size();

    if ((fbe_current_size + ncolumns.fbe_size()) > fbe_struct_size)
        return true;
    if (!ncolumns.verify())
        return false;
    fbe_current_size += ncolumns.fbe_size();

    return true;
}

size_t FieldModel_pg_query_MultiAssignRef::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_MultiAssignRef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_MultiAssignRef::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_MultiAssignRef::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::MultiAssignRef& fbe_value = static_cast<::pg_query::MultiAssignRef&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + source.fbe_size()) <= fbe_struct_size)
        {
            source.get(fbe_value.source);
        }
    else
        fbe_value.source = ::pg_query::Node();
    fbe_current_size += source.fbe_size();

    if ((fbe_current_size + colno.fbe_size()) <= fbe_struct_size)
        {
            colno.get(fbe_value.colno);
        }
    else
        fbe_value.colno = (int32_t)0ll;
    fbe_current_size += colno.fbe_size();

    if ((fbe_current_size + ncolumns.fbe_size()) <= fbe_struct_size)
        {
            ncolumns.get(fbe_value.ncolumns);
        }
    else
        fbe_value.ncolumns = (int32_t)0ll;
    fbe_current_size += ncolumns.fbe_size();
}

size_t FieldModel_pg_query_MultiAssignRef::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_MultiAssignRef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_MultiAssignRef::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_MultiAssignRef::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::MultiAssignRef& fbe_value = static_cast<const ::pg_query::MultiAssignRef&>(base_fbe_value);
    source.set(fbe_value.source);
    colno.set(fbe_value.colno);
    ncolumns.set(fbe_value.ncolumns);
}

namespace pg_query {

bool MultiAssignRefModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t MultiAssignRefModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t MultiAssignRefModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t MultiAssignRefModel::serialize(const ::pg_query::MultiAssignRef& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t MultiAssignRefModel::deserialize(::pg_query::MultiAssignRef& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_TypeCast::FieldModelPtr_pg_query_TypeCast(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_TypeCast::~FieldModelPtr_pg_query_TypeCast()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_TypeCast::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_TypeCast::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_TypeCast::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_TypeCast::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TypeCast::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TypeCast::get(::pg_query::TypeCast** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_TypeCast(_buffer, 0);

    ::pg_query::TypeCast *tempModel = new ::pg_query::TypeCast();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_TypeCast::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TypeCast::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TypeCast::set(const ::pg_query::TypeCast* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_TypeCast(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_TypeCast::FieldModel_pg_query_TypeCast(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , arg(buffer, 4 + 4)
    , type_name(buffer, arg.fbe_offset() + arg.fbe_size())
    , location(buffer, type_name.fbe_offset() + type_name.fbe_size())
{}

size_t FieldModel_pg_query_TypeCast::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + arg.fbe_size()
        + type_name.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_TypeCast::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + arg.fbe_extra()
        + type_name.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_TypeCast::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_TypeCast::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_TypeCast::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TypeCast::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TypeCast::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_TypeCast::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::TypeCast& fbe_value = static_cast<::pg_query::TypeCast&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(&fbe_value.type_name);
        }
    else
        fbe_value.type_name = nullptr;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_TypeCast::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TypeCast::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TypeCast::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_TypeCast::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::TypeCast& fbe_value = static_cast<const ::pg_query::TypeCast&>(base_fbe_value);
    arg.set(fbe_value.arg);
    type_name.set(fbe_value.type_name);
    location.set(fbe_value.location);
}

namespace pg_query {

bool TypeCastModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TypeCastModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TypeCastModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TypeCastModel::serialize(const ::pg_query::TypeCast& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TypeCastModel::deserialize(::pg_query::TypeCast& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CollateClause::FieldModelPtr_pg_query_CollateClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CollateClause::~FieldModelPtr_pg_query_CollateClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CollateClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CollateClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CollateClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CollateClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CollateClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CollateClause::get(::pg_query::CollateClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CollateClause(_buffer, 0);

    ::pg_query::CollateClause *tempModel = new ::pg_query::CollateClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CollateClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CollateClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CollateClause::set(const ::pg_query::CollateClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CollateClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CollateClause::FieldModel_pg_query_CollateClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , arg(buffer, 4 + 4)
    , collname(buffer, arg.fbe_offset() + arg.fbe_size())
    , location(buffer, collname.fbe_offset() + collname.fbe_size())
{}

size_t FieldModel_pg_query_CollateClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + arg.fbe_size()
        + collname.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CollateClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + arg.fbe_extra()
        + collname.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CollateClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CollateClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + collname.fbe_size()) > fbe_struct_size)
        return true;
    if (!collname.verify())
        return false;
    fbe_current_size += collname.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CollateClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CollateClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CollateClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CollateClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CollateClause& fbe_value = static_cast<::pg_query::CollateClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + collname.fbe_size()) <= fbe_struct_size)
        {
            collname.get(fbe_value.collname);
        }
    else
        fbe_value.collname.clear();
    fbe_current_size += collname.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_CollateClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CollateClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CollateClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CollateClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CollateClause& fbe_value = static_cast<const ::pg_query::CollateClause&>(base_fbe_value);
    arg.set(fbe_value.arg);
    collname.set(fbe_value.collname);
    location.set(fbe_value.location);
}

namespace pg_query {

bool CollateClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CollateClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CollateClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CollateClauseModel::serialize(const ::pg_query::CollateClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CollateClauseModel::deserialize(::pg_query::CollateClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SortBy::FieldModelPtr_pg_query_SortBy(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SortBy::~FieldModelPtr_pg_query_SortBy()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SortBy::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SortBy::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SortBy::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SortBy::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SortBy::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SortBy::get(::pg_query::SortBy** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SortBy(_buffer, 0);

    ::pg_query::SortBy *tempModel = new ::pg_query::SortBy();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SortBy::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SortBy::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SortBy::set(const ::pg_query::SortBy* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SortBy(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SortBy::FieldModel_pg_query_SortBy(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , node(buffer, 4 + 4)
    , sortby_dir(buffer, node.fbe_offset() + node.fbe_size())
    , sortby_nulls(buffer, sortby_dir.fbe_offset() + sortby_dir.fbe_size())
    , use_op(buffer, sortby_nulls.fbe_offset() + sortby_nulls.fbe_size())
    , location(buffer, use_op.fbe_offset() + use_op.fbe_size())
{}

size_t FieldModel_pg_query_SortBy::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + node.fbe_size()
        + sortby_dir.fbe_size()
        + sortby_nulls.fbe_size()
        + use_op.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SortBy::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + node.fbe_extra()
        + sortby_dir.fbe_extra()
        + sortby_nulls.fbe_extra()
        + use_op.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SortBy::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SortBy::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + node.fbe_size()) > fbe_struct_size)
        return true;
    if (!node.verify())
        return false;
    fbe_current_size += node.fbe_size();

    if ((fbe_current_size + sortby_dir.fbe_size()) > fbe_struct_size)
        return true;
    if (!sortby_dir.verify())
        return false;
    fbe_current_size += sortby_dir.fbe_size();

    if ((fbe_current_size + sortby_nulls.fbe_size()) > fbe_struct_size)
        return true;
    if (!sortby_nulls.verify())
        return false;
    fbe_current_size += sortby_nulls.fbe_size();

    if ((fbe_current_size + use_op.fbe_size()) > fbe_struct_size)
        return true;
    if (!use_op.verify())
        return false;
    fbe_current_size += use_op.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SortBy::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SortBy::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SortBy::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SortBy::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SortBy& fbe_value = static_cast<::pg_query::SortBy&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + node.fbe_size()) <= fbe_struct_size)
        {
            node.get(fbe_value.node);
        }
    else
        fbe_value.node = ::pg_query::Node();
    fbe_current_size += node.fbe_size();

    if ((fbe_current_size + sortby_dir.fbe_size()) <= fbe_struct_size)
        {
            sortby_dir.get(fbe_value.sortby_dir);
        }
    else
        fbe_value.sortby_dir = ::pg_query::SortByDir();
    fbe_current_size += sortby_dir.fbe_size();

    if ((fbe_current_size + sortby_nulls.fbe_size()) <= fbe_struct_size)
        {
            sortby_nulls.get(fbe_value.sortby_nulls);
        }
    else
        fbe_value.sortby_nulls = ::pg_query::SortByNulls();
    fbe_current_size += sortby_nulls.fbe_size();

    if ((fbe_current_size + use_op.fbe_size()) <= fbe_struct_size)
        {
            use_op.get(fbe_value.use_op);
        }
    else
        fbe_value.use_op.clear();
    fbe_current_size += use_op.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_SortBy::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SortBy::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SortBy::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SortBy::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SortBy& fbe_value = static_cast<const ::pg_query::SortBy&>(base_fbe_value);
    node.set(fbe_value.node);
    sortby_dir.set(fbe_value.sortby_dir);
    sortby_nulls.set(fbe_value.sortby_nulls);
    use_op.set(fbe_value.use_op);
    location.set(fbe_value.location);
}

namespace pg_query {

bool SortByModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SortByModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SortByModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SortByModel::serialize(const ::pg_query::SortBy& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SortByModel::deserialize(::pg_query::SortBy& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_WindowDef::FieldModelPtr_pg_query_WindowDef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_WindowDef::~FieldModelPtr_pg_query_WindowDef()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_WindowDef::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_WindowDef::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_WindowDef::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_WindowDef::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WindowDef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WindowDef::get(::pg_query::WindowDef** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_WindowDef(_buffer, 0);

    ::pg_query::WindowDef *tempModel = new ::pg_query::WindowDef();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_WindowDef::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WindowDef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WindowDef::set(const ::pg_query::WindowDef* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_WindowDef(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_WindowDef::FieldModel_pg_query_WindowDef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , refname(buffer, name.fbe_offset() + name.fbe_size())
    , partition_clause(buffer, refname.fbe_offset() + refname.fbe_size())
    , order_clause(buffer, partition_clause.fbe_offset() + partition_clause.fbe_size())
    , frame_options(buffer, order_clause.fbe_offset() + order_clause.fbe_size())
    , start_offset(buffer, frame_options.fbe_offset() + frame_options.fbe_size())
    , end_offset(buffer, start_offset.fbe_offset() + start_offset.fbe_size())
    , location(buffer, end_offset.fbe_offset() + end_offset.fbe_size())
{}

size_t FieldModel_pg_query_WindowDef::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + refname.fbe_size()
        + partition_clause.fbe_size()
        + order_clause.fbe_size()
        + frame_options.fbe_size()
        + start_offset.fbe_size()
        + end_offset.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_WindowDef::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + refname.fbe_extra()
        + partition_clause.fbe_extra()
        + order_clause.fbe_extra()
        + frame_options.fbe_extra()
        + start_offset.fbe_extra()
        + end_offset.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_WindowDef::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_WindowDef::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + refname.fbe_size()) > fbe_struct_size)
        return true;
    if (!refname.verify())
        return false;
    fbe_current_size += refname.fbe_size();

    if ((fbe_current_size + partition_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!partition_clause.verify())
        return false;
    fbe_current_size += partition_clause.fbe_size();

    if ((fbe_current_size + order_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!order_clause.verify())
        return false;
    fbe_current_size += order_clause.fbe_size();

    if ((fbe_current_size + frame_options.fbe_size()) > fbe_struct_size)
        return true;
    if (!frame_options.verify())
        return false;
    fbe_current_size += frame_options.fbe_size();

    if ((fbe_current_size + start_offset.fbe_size()) > fbe_struct_size)
        return true;
    if (!start_offset.verify())
        return false;
    fbe_current_size += start_offset.fbe_size();

    if ((fbe_current_size + end_offset.fbe_size()) > fbe_struct_size)
        return true;
    if (!end_offset.verify())
        return false;
    fbe_current_size += end_offset.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_WindowDef::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WindowDef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WindowDef::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_WindowDef::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::WindowDef& fbe_value = static_cast<::pg_query::WindowDef&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + refname.fbe_size()) <= fbe_struct_size)
        {
            refname.get(fbe_value.refname);
        }
    else
        fbe_value.refname = "";
    fbe_current_size += refname.fbe_size();

    if ((fbe_current_size + partition_clause.fbe_size()) <= fbe_struct_size)
        {
            partition_clause.get(fbe_value.partition_clause);
        }
    else
        fbe_value.partition_clause.clear();
    fbe_current_size += partition_clause.fbe_size();

    if ((fbe_current_size + order_clause.fbe_size()) <= fbe_struct_size)
        {
            order_clause.get(fbe_value.order_clause);
        }
    else
        fbe_value.order_clause.clear();
    fbe_current_size += order_clause.fbe_size();

    if ((fbe_current_size + frame_options.fbe_size()) <= fbe_struct_size)
        {
            frame_options.get(fbe_value.frame_options);
        }
    else
        fbe_value.frame_options = (int32_t)0ll;
    fbe_current_size += frame_options.fbe_size();

    if ((fbe_current_size + start_offset.fbe_size()) <= fbe_struct_size)
        {
            start_offset.get(fbe_value.start_offset);
        }
    else
        fbe_value.start_offset = ::pg_query::Node();
    fbe_current_size += start_offset.fbe_size();

    if ((fbe_current_size + end_offset.fbe_size()) <= fbe_struct_size)
        {
            end_offset.get(fbe_value.end_offset);
        }
    else
        fbe_value.end_offset = ::pg_query::Node();
    fbe_current_size += end_offset.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_WindowDef::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WindowDef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WindowDef::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_WindowDef::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::WindowDef& fbe_value = static_cast<const ::pg_query::WindowDef&>(base_fbe_value);
    name.set(fbe_value.name);
    refname.set(fbe_value.refname);
    partition_clause.set(fbe_value.partition_clause);
    order_clause.set(fbe_value.order_clause);
    frame_options.set(fbe_value.frame_options);
    start_offset.set(fbe_value.start_offset);
    end_offset.set(fbe_value.end_offset);
    location.set(fbe_value.location);
}

namespace pg_query {

bool WindowDefModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t WindowDefModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t WindowDefModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t WindowDefModel::serialize(const ::pg_query::WindowDef& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t WindowDefModel::deserialize(::pg_query::WindowDef& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RangeSubselect::FieldModelPtr_pg_query_RangeSubselect(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RangeSubselect::~FieldModelPtr_pg_query_RangeSubselect()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RangeSubselect::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeSubselect::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeSubselect::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RangeSubselect::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeSubselect::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeSubselect::get(::pg_query::RangeSubselect** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RangeSubselect(_buffer, 0);

    ::pg_query::RangeSubselect *tempModel = new ::pg_query::RangeSubselect();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RangeSubselect::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeSubselect::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeSubselect::set(const ::pg_query::RangeSubselect* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RangeSubselect(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RangeSubselect::FieldModel_pg_query_RangeSubselect(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , lateral(buffer, 4 + 4)
    , subquery(buffer, lateral.fbe_offset() + lateral.fbe_size())
    , alias(buffer, subquery.fbe_offset() + subquery.fbe_size())
{}

size_t FieldModel_pg_query_RangeSubselect::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + lateral.fbe_size()
        + subquery.fbe_size()
        + alias.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RangeSubselect::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + lateral.fbe_extra()
        + subquery.fbe_extra()
        + alias.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RangeSubselect::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RangeSubselect::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + lateral.fbe_size()) > fbe_struct_size)
        return true;
    if (!lateral.verify())
        return false;
    fbe_current_size += lateral.fbe_size();

    if ((fbe_current_size + subquery.fbe_size()) > fbe_struct_size)
        return true;
    if (!subquery.verify())
        return false;
    fbe_current_size += subquery.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) > fbe_struct_size)
        return true;
    if (!alias.verify())
        return false;
    fbe_current_size += alias.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RangeSubselect::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeSubselect::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeSubselect::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RangeSubselect::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RangeSubselect& fbe_value = static_cast<::pg_query::RangeSubselect&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + lateral.fbe_size()) <= fbe_struct_size)
        {
            lateral.get(fbe_value.lateral);
        }
    else
        fbe_value.lateral = false;
    fbe_current_size += lateral.fbe_size();

    if ((fbe_current_size + subquery.fbe_size()) <= fbe_struct_size)
        {
            subquery.get(fbe_value.subquery);
        }
    else
        fbe_value.subquery = ::pg_query::Node();
    fbe_current_size += subquery.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) <= fbe_struct_size)
        {
            alias.get(&fbe_value.alias);
        }
    else
        fbe_value.alias = nullptr;
    fbe_current_size += alias.fbe_size();
}

size_t FieldModel_pg_query_RangeSubselect::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeSubselect::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeSubselect::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RangeSubselect::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RangeSubselect& fbe_value = static_cast<const ::pg_query::RangeSubselect&>(base_fbe_value);
    lateral.set(fbe_value.lateral);
    subquery.set(fbe_value.subquery);
    alias.set(fbe_value.alias);
}

namespace pg_query {

bool RangeSubselectModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RangeSubselectModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RangeSubselectModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RangeSubselectModel::serialize(const ::pg_query::RangeSubselect& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RangeSubselectModel::deserialize(::pg_query::RangeSubselect& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RangeFunction::FieldModelPtr_pg_query_RangeFunction(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RangeFunction::~FieldModelPtr_pg_query_RangeFunction()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RangeFunction::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeFunction::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeFunction::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RangeFunction::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeFunction::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeFunction::get(::pg_query::RangeFunction** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RangeFunction(_buffer, 0);

    ::pg_query::RangeFunction *tempModel = new ::pg_query::RangeFunction();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RangeFunction::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeFunction::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeFunction::set(const ::pg_query::RangeFunction* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RangeFunction(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RangeFunction::FieldModel_pg_query_RangeFunction(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , lateral(buffer, 4 + 4)
    , ordinality(buffer, lateral.fbe_offset() + lateral.fbe_size())
    , is_rowsfrom(buffer, ordinality.fbe_offset() + ordinality.fbe_size())
    , functions(buffer, is_rowsfrom.fbe_offset() + is_rowsfrom.fbe_size())
    , alias(buffer, functions.fbe_offset() + functions.fbe_size())
    , coldeflist(buffer, alias.fbe_offset() + alias.fbe_size())
{}

size_t FieldModel_pg_query_RangeFunction::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + lateral.fbe_size()
        + ordinality.fbe_size()
        + is_rowsfrom.fbe_size()
        + functions.fbe_size()
        + alias.fbe_size()
        + coldeflist.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RangeFunction::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + lateral.fbe_extra()
        + ordinality.fbe_extra()
        + is_rowsfrom.fbe_extra()
        + functions.fbe_extra()
        + alias.fbe_extra()
        + coldeflist.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RangeFunction::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RangeFunction::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + lateral.fbe_size()) > fbe_struct_size)
        return true;
    if (!lateral.verify())
        return false;
    fbe_current_size += lateral.fbe_size();

    if ((fbe_current_size + ordinality.fbe_size()) > fbe_struct_size)
        return true;
    if (!ordinality.verify())
        return false;
    fbe_current_size += ordinality.fbe_size();

    if ((fbe_current_size + is_rowsfrom.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_rowsfrom.verify())
        return false;
    fbe_current_size += is_rowsfrom.fbe_size();

    if ((fbe_current_size + functions.fbe_size()) > fbe_struct_size)
        return true;
    if (!functions.verify())
        return false;
    fbe_current_size += functions.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) > fbe_struct_size)
        return true;
    if (!alias.verify())
        return false;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + coldeflist.fbe_size()) > fbe_struct_size)
        return true;
    if (!coldeflist.verify())
        return false;
    fbe_current_size += coldeflist.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RangeFunction::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeFunction::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeFunction::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RangeFunction::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RangeFunction& fbe_value = static_cast<::pg_query::RangeFunction&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + lateral.fbe_size()) <= fbe_struct_size)
        {
            lateral.get(fbe_value.lateral);
        }
    else
        fbe_value.lateral = false;
    fbe_current_size += lateral.fbe_size();

    if ((fbe_current_size + ordinality.fbe_size()) <= fbe_struct_size)
        {
            ordinality.get(fbe_value.ordinality);
        }
    else
        fbe_value.ordinality = false;
    fbe_current_size += ordinality.fbe_size();

    if ((fbe_current_size + is_rowsfrom.fbe_size()) <= fbe_struct_size)
        {
            is_rowsfrom.get(fbe_value.is_rowsfrom);
        }
    else
        fbe_value.is_rowsfrom = false;
    fbe_current_size += is_rowsfrom.fbe_size();

    if ((fbe_current_size + functions.fbe_size()) <= fbe_struct_size)
        {
            functions.get(fbe_value.functions);
        }
    else
        fbe_value.functions.clear();
    fbe_current_size += functions.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) <= fbe_struct_size)
        {
            alias.get(&fbe_value.alias);
        }
    else
        fbe_value.alias = nullptr;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + coldeflist.fbe_size()) <= fbe_struct_size)
        {
            coldeflist.get(fbe_value.coldeflist);
        }
    else
        fbe_value.coldeflist.clear();
    fbe_current_size += coldeflist.fbe_size();
}

size_t FieldModel_pg_query_RangeFunction::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeFunction::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeFunction::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RangeFunction::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RangeFunction& fbe_value = static_cast<const ::pg_query::RangeFunction&>(base_fbe_value);
    lateral.set(fbe_value.lateral);
    ordinality.set(fbe_value.ordinality);
    is_rowsfrom.set(fbe_value.is_rowsfrom);
    functions.set(fbe_value.functions);
    alias.set(fbe_value.alias);
    coldeflist.set(fbe_value.coldeflist);
}

namespace pg_query {

bool RangeFunctionModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RangeFunctionModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RangeFunctionModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RangeFunctionModel::serialize(const ::pg_query::RangeFunction& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RangeFunctionModel::deserialize(::pg_query::RangeFunction& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RangeTableSample::FieldModelPtr_pg_query_RangeTableSample(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RangeTableSample::~FieldModelPtr_pg_query_RangeTableSample()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RangeTableSample::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTableSample::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTableSample::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RangeTableSample::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTableSample::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTableSample::get(::pg_query::RangeTableSample** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RangeTableSample(_buffer, 0);

    ::pg_query::RangeTableSample *tempModel = new ::pg_query::RangeTableSample();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RangeTableSample::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTableSample::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTableSample::set(const ::pg_query::RangeTableSample* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RangeTableSample(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RangeTableSample::FieldModel_pg_query_RangeTableSample(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , method(buffer, relation.fbe_offset() + relation.fbe_size())
    , args(buffer, method.fbe_offset() + method.fbe_size())
    , repeatable(buffer, args.fbe_offset() + args.fbe_size())
    , location(buffer, repeatable.fbe_offset() + repeatable.fbe_size())
{}

size_t FieldModel_pg_query_RangeTableSample::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + method.fbe_size()
        + args.fbe_size()
        + repeatable.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RangeTableSample::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + method.fbe_extra()
        + args.fbe_extra()
        + repeatable.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RangeTableSample::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RangeTableSample::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + method.fbe_size()) > fbe_struct_size)
        return true;
    if (!method.verify())
        return false;
    fbe_current_size += method.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + repeatable.fbe_size()) > fbe_struct_size)
        return true;
    if (!repeatable.verify())
        return false;
    fbe_current_size += repeatable.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RangeTableSample::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTableSample::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTableSample::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RangeTableSample::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RangeTableSample& fbe_value = static_cast<::pg_query::RangeTableSample&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(fbe_value.relation);
        }
    else
        fbe_value.relation = ::pg_query::Node();
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + method.fbe_size()) <= fbe_struct_size)
        {
            method.get(fbe_value.method);
        }
    else
        fbe_value.method.clear();
    fbe_current_size += method.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + repeatable.fbe_size()) <= fbe_struct_size)
        {
            repeatable.get(fbe_value.repeatable);
        }
    else
        fbe_value.repeatable = ::pg_query::Node();
    fbe_current_size += repeatable.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_RangeTableSample::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTableSample::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTableSample::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RangeTableSample::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RangeTableSample& fbe_value = static_cast<const ::pg_query::RangeTableSample&>(base_fbe_value);
    relation.set(fbe_value.relation);
    method.set(fbe_value.method);
    args.set(fbe_value.args);
    repeatable.set(fbe_value.repeatable);
    location.set(fbe_value.location);
}

namespace pg_query {

bool RangeTableSampleModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RangeTableSampleModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RangeTableSampleModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RangeTableSampleModel::serialize(const ::pg_query::RangeTableSample& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RangeTableSampleModel::deserialize(::pg_query::RangeTableSample& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RangeTableFunc::FieldModelPtr_pg_query_RangeTableFunc(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RangeTableFunc::~FieldModelPtr_pg_query_RangeTableFunc()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RangeTableFunc::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTableFunc::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTableFunc::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RangeTableFunc::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTableFunc::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTableFunc::get(::pg_query::RangeTableFunc** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RangeTableFunc(_buffer, 0);

    ::pg_query::RangeTableFunc *tempModel = new ::pg_query::RangeTableFunc();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RangeTableFunc::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTableFunc::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTableFunc::set(const ::pg_query::RangeTableFunc* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RangeTableFunc(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RangeTableFunc::FieldModel_pg_query_RangeTableFunc(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , lateral(buffer, 4 + 4)
    , docexpr(buffer, lateral.fbe_offset() + lateral.fbe_size())
    , rowexpr(buffer, docexpr.fbe_offset() + docexpr.fbe_size())
    , namespaces(buffer, rowexpr.fbe_offset() + rowexpr.fbe_size())
    , columns(buffer, namespaces.fbe_offset() + namespaces.fbe_size())
    , alias(buffer, columns.fbe_offset() + columns.fbe_size())
    , location(buffer, alias.fbe_offset() + alias.fbe_size())
{}

size_t FieldModel_pg_query_RangeTableFunc::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + lateral.fbe_size()
        + docexpr.fbe_size()
        + rowexpr.fbe_size()
        + namespaces.fbe_size()
        + columns.fbe_size()
        + alias.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RangeTableFunc::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + lateral.fbe_extra()
        + docexpr.fbe_extra()
        + rowexpr.fbe_extra()
        + namespaces.fbe_extra()
        + columns.fbe_extra()
        + alias.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RangeTableFunc::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RangeTableFunc::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + lateral.fbe_size()) > fbe_struct_size)
        return true;
    if (!lateral.verify())
        return false;
    fbe_current_size += lateral.fbe_size();

    if ((fbe_current_size + docexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!docexpr.verify())
        return false;
    fbe_current_size += docexpr.fbe_size();

    if ((fbe_current_size + rowexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!rowexpr.verify())
        return false;
    fbe_current_size += rowexpr.fbe_size();

    if ((fbe_current_size + namespaces.fbe_size()) > fbe_struct_size)
        return true;
    if (!namespaces.verify())
        return false;
    fbe_current_size += namespaces.fbe_size();

    if ((fbe_current_size + columns.fbe_size()) > fbe_struct_size)
        return true;
    if (!columns.verify())
        return false;
    fbe_current_size += columns.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) > fbe_struct_size)
        return true;
    if (!alias.verify())
        return false;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RangeTableFunc::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTableFunc::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTableFunc::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RangeTableFunc::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RangeTableFunc& fbe_value = static_cast<::pg_query::RangeTableFunc&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + lateral.fbe_size()) <= fbe_struct_size)
        {
            lateral.get(fbe_value.lateral);
        }
    else
        fbe_value.lateral = false;
    fbe_current_size += lateral.fbe_size();

    if ((fbe_current_size + docexpr.fbe_size()) <= fbe_struct_size)
        {
            docexpr.get(fbe_value.docexpr);
        }
    else
        fbe_value.docexpr = ::pg_query::Node();
    fbe_current_size += docexpr.fbe_size();

    if ((fbe_current_size + rowexpr.fbe_size()) <= fbe_struct_size)
        {
            rowexpr.get(fbe_value.rowexpr);
        }
    else
        fbe_value.rowexpr = ::pg_query::Node();
    fbe_current_size += rowexpr.fbe_size();

    if ((fbe_current_size + namespaces.fbe_size()) <= fbe_struct_size)
        {
            namespaces.get(fbe_value.namespaces);
        }
    else
        fbe_value.namespaces.clear();
    fbe_current_size += namespaces.fbe_size();

    if ((fbe_current_size + columns.fbe_size()) <= fbe_struct_size)
        {
            columns.get(fbe_value.columns);
        }
    else
        fbe_value.columns.clear();
    fbe_current_size += columns.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) <= fbe_struct_size)
        {
            alias.get(&fbe_value.alias);
        }
    else
        fbe_value.alias = nullptr;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_RangeTableFunc::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTableFunc::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTableFunc::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RangeTableFunc::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RangeTableFunc& fbe_value = static_cast<const ::pg_query::RangeTableFunc&>(base_fbe_value);
    lateral.set(fbe_value.lateral);
    docexpr.set(fbe_value.docexpr);
    rowexpr.set(fbe_value.rowexpr);
    namespaces.set(fbe_value.namespaces);
    columns.set(fbe_value.columns);
    alias.set(fbe_value.alias);
    location.set(fbe_value.location);
}

namespace pg_query {

bool RangeTableFuncModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RangeTableFuncModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RangeTableFuncModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RangeTableFuncModel::serialize(const ::pg_query::RangeTableFunc& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RangeTableFuncModel::deserialize(::pg_query::RangeTableFunc& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RangeTableFuncCol::FieldModelPtr_pg_query_RangeTableFuncCol(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RangeTableFuncCol::~FieldModelPtr_pg_query_RangeTableFuncCol()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RangeTableFuncCol::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTableFuncCol::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTableFuncCol::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RangeTableFuncCol::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTableFuncCol::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTableFuncCol::get(::pg_query::RangeTableFuncCol** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RangeTableFuncCol(_buffer, 0);

    ::pg_query::RangeTableFuncCol *tempModel = new ::pg_query::RangeTableFuncCol();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RangeTableFuncCol::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTableFuncCol::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTableFuncCol::set(const ::pg_query::RangeTableFuncCol* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RangeTableFuncCol(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RangeTableFuncCol::FieldModel_pg_query_RangeTableFuncCol(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , colname(buffer, 4 + 4)
    , type_name(buffer, colname.fbe_offset() + colname.fbe_size())
    , for_ordinality(buffer, type_name.fbe_offset() + type_name.fbe_size())
    , is_not_null(buffer, for_ordinality.fbe_offset() + for_ordinality.fbe_size())
    , colexpr(buffer, is_not_null.fbe_offset() + is_not_null.fbe_size())
    , coldefexpr(buffer, colexpr.fbe_offset() + colexpr.fbe_size())
    , location(buffer, coldefexpr.fbe_offset() + coldefexpr.fbe_size())
{}

size_t FieldModel_pg_query_RangeTableFuncCol::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + colname.fbe_size()
        + type_name.fbe_size()
        + for_ordinality.fbe_size()
        + is_not_null.fbe_size()
        + colexpr.fbe_size()
        + coldefexpr.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RangeTableFuncCol::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + colname.fbe_extra()
        + type_name.fbe_extra()
        + for_ordinality.fbe_extra()
        + is_not_null.fbe_extra()
        + colexpr.fbe_extra()
        + coldefexpr.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RangeTableFuncCol::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RangeTableFuncCol::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + colname.fbe_size()) > fbe_struct_size)
        return true;
    if (!colname.verify())
        return false;
    fbe_current_size += colname.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + for_ordinality.fbe_size()) > fbe_struct_size)
        return true;
    if (!for_ordinality.verify())
        return false;
    fbe_current_size += for_ordinality.fbe_size();

    if ((fbe_current_size + is_not_null.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_not_null.verify())
        return false;
    fbe_current_size += is_not_null.fbe_size();

    if ((fbe_current_size + colexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!colexpr.verify())
        return false;
    fbe_current_size += colexpr.fbe_size();

    if ((fbe_current_size + coldefexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!coldefexpr.verify())
        return false;
    fbe_current_size += coldefexpr.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RangeTableFuncCol::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTableFuncCol::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTableFuncCol::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RangeTableFuncCol::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RangeTableFuncCol& fbe_value = static_cast<::pg_query::RangeTableFuncCol&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + colname.fbe_size()) <= fbe_struct_size)
        {
            colname.get(fbe_value.colname);
        }
    else
        fbe_value.colname = "";
    fbe_current_size += colname.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(&fbe_value.type_name);
        }
    else
        fbe_value.type_name = nullptr;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + for_ordinality.fbe_size()) <= fbe_struct_size)
        {
            for_ordinality.get(fbe_value.for_ordinality);
        }
    else
        fbe_value.for_ordinality = false;
    fbe_current_size += for_ordinality.fbe_size();

    if ((fbe_current_size + is_not_null.fbe_size()) <= fbe_struct_size)
        {
            is_not_null.get(fbe_value.is_not_null);
        }
    else
        fbe_value.is_not_null = false;
    fbe_current_size += is_not_null.fbe_size();

    if ((fbe_current_size + colexpr.fbe_size()) <= fbe_struct_size)
        {
            colexpr.get(fbe_value.colexpr);
        }
    else
        fbe_value.colexpr = ::pg_query::Node();
    fbe_current_size += colexpr.fbe_size();

    if ((fbe_current_size + coldefexpr.fbe_size()) <= fbe_struct_size)
        {
            coldefexpr.get(fbe_value.coldefexpr);
        }
    else
        fbe_value.coldefexpr = ::pg_query::Node();
    fbe_current_size += coldefexpr.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_RangeTableFuncCol::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTableFuncCol::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTableFuncCol::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RangeTableFuncCol::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RangeTableFuncCol& fbe_value = static_cast<const ::pg_query::RangeTableFuncCol&>(base_fbe_value);
    colname.set(fbe_value.colname);
    type_name.set(fbe_value.type_name);
    for_ordinality.set(fbe_value.for_ordinality);
    is_not_null.set(fbe_value.is_not_null);
    colexpr.set(fbe_value.colexpr);
    coldefexpr.set(fbe_value.coldefexpr);
    location.set(fbe_value.location);
}

namespace pg_query {

bool RangeTableFuncColModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RangeTableFuncColModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RangeTableFuncColModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RangeTableFuncColModel::serialize(const ::pg_query::RangeTableFuncCol& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RangeTableFuncColModel::deserialize(::pg_query::RangeTableFuncCol& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_TypeName::FieldModelPtr_pg_query_TypeName(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_TypeName::~FieldModelPtr_pg_query_TypeName()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_TypeName::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_TypeName::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_TypeName::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_TypeName::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TypeName::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TypeName::get(::pg_query::TypeName** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_TypeName(_buffer, 0);

    ::pg_query::TypeName *tempModel = new ::pg_query::TypeName();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_TypeName::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TypeName::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TypeName::set(const ::pg_query::TypeName* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_TypeName(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_TypeName::FieldModel_pg_query_TypeName(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , names(buffer, 4 + 4)
    , type_oid(buffer, names.fbe_offset() + names.fbe_size())
    , setof(buffer, type_oid.fbe_offset() + type_oid.fbe_size())
    , pct_type(buffer, setof.fbe_offset() + setof.fbe_size())
    , typmods(buffer, pct_type.fbe_offset() + pct_type.fbe_size())
    , typemod(buffer, typmods.fbe_offset() + typmods.fbe_size())
    , array_bounds(buffer, typemod.fbe_offset() + typemod.fbe_size())
    , location(buffer, array_bounds.fbe_offset() + array_bounds.fbe_size())
{}

size_t FieldModel_pg_query_TypeName::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + names.fbe_size()
        + type_oid.fbe_size()
        + setof.fbe_size()
        + pct_type.fbe_size()
        + typmods.fbe_size()
        + typemod.fbe_size()
        + array_bounds.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_TypeName::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + names.fbe_extra()
        + type_oid.fbe_extra()
        + setof.fbe_extra()
        + pct_type.fbe_extra()
        + typmods.fbe_extra()
        + typemod.fbe_extra()
        + array_bounds.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_TypeName::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_TypeName::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + names.fbe_size()) > fbe_struct_size)
        return true;
    if (!names.verify())
        return false;
    fbe_current_size += names.fbe_size();

    if ((fbe_current_size + type_oid.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_oid.verify())
        return false;
    fbe_current_size += type_oid.fbe_size();

    if ((fbe_current_size + setof.fbe_size()) > fbe_struct_size)
        return true;
    if (!setof.verify())
        return false;
    fbe_current_size += setof.fbe_size();

    if ((fbe_current_size + pct_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!pct_type.verify())
        return false;
    fbe_current_size += pct_type.fbe_size();

    if ((fbe_current_size + typmods.fbe_size()) > fbe_struct_size)
        return true;
    if (!typmods.verify())
        return false;
    fbe_current_size += typmods.fbe_size();

    if ((fbe_current_size + typemod.fbe_size()) > fbe_struct_size)
        return true;
    if (!typemod.verify())
        return false;
    fbe_current_size += typemod.fbe_size();

    if ((fbe_current_size + array_bounds.fbe_size()) > fbe_struct_size)
        return true;
    if (!array_bounds.verify())
        return false;
    fbe_current_size += array_bounds.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_TypeName::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TypeName::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TypeName::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_TypeName::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::TypeName& fbe_value = static_cast<::pg_query::TypeName&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + names.fbe_size()) <= fbe_struct_size)
        {
            names.get(fbe_value.names);
        }
    else
        fbe_value.names.clear();
    fbe_current_size += names.fbe_size();

    if ((fbe_current_size + type_oid.fbe_size()) <= fbe_struct_size)
        {
            type_oid.get(fbe_value.type_oid);
        }
    else
        fbe_value.type_oid = (uint32_t)0ull;
    fbe_current_size += type_oid.fbe_size();

    if ((fbe_current_size + setof.fbe_size()) <= fbe_struct_size)
        {
            setof.get(fbe_value.setof);
        }
    else
        fbe_value.setof = false;
    fbe_current_size += setof.fbe_size();

    if ((fbe_current_size + pct_type.fbe_size()) <= fbe_struct_size)
        {
            pct_type.get(fbe_value.pct_type);
        }
    else
        fbe_value.pct_type = false;
    fbe_current_size += pct_type.fbe_size();

    if ((fbe_current_size + typmods.fbe_size()) <= fbe_struct_size)
        {
            typmods.get(fbe_value.typmods);
        }
    else
        fbe_value.typmods.clear();
    fbe_current_size += typmods.fbe_size();

    if ((fbe_current_size + typemod.fbe_size()) <= fbe_struct_size)
        {
            typemod.get(fbe_value.typemod);
        }
    else
        fbe_value.typemod = (int32_t)0ll;
    fbe_current_size += typemod.fbe_size();

    if ((fbe_current_size + array_bounds.fbe_size()) <= fbe_struct_size)
        {
            array_bounds.get(fbe_value.array_bounds);
        }
    else
        fbe_value.array_bounds.clear();
    fbe_current_size += array_bounds.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_TypeName::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TypeName::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TypeName::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_TypeName::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::TypeName& fbe_value = static_cast<const ::pg_query::TypeName&>(base_fbe_value);
    names.set(fbe_value.names);
    type_oid.set(fbe_value.type_oid);
    setof.set(fbe_value.setof);
    pct_type.set(fbe_value.pct_type);
    typmods.set(fbe_value.typmods);
    typemod.set(fbe_value.typemod);
    array_bounds.set(fbe_value.array_bounds);
    location.set(fbe_value.location);
}

namespace pg_query {

bool TypeNameModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TypeNameModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TypeNameModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TypeNameModel::serialize(const ::pg_query::TypeName& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TypeNameModel::deserialize(::pg_query::TypeName& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ColumnDef::FieldModelPtr_pg_query_ColumnDef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ColumnDef::~FieldModelPtr_pg_query_ColumnDef()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ColumnDef::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ColumnDef::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ColumnDef::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ColumnDef::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ColumnDef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ColumnDef::get(::pg_query::ColumnDef** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ColumnDef(_buffer, 0);

    ::pg_query::ColumnDef *tempModel = new ::pg_query::ColumnDef();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ColumnDef::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ColumnDef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ColumnDef::set(const ::pg_query::ColumnDef* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ColumnDef(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ColumnDef::FieldModel_pg_query_ColumnDef(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , colname(buffer, 4 + 4)
    , type_name(buffer, colname.fbe_offset() + colname.fbe_size())
    , inhcount(buffer, type_name.fbe_offset() + type_name.fbe_size())
    , is_local(buffer, inhcount.fbe_offset() + inhcount.fbe_size())
    , is_not_null(buffer, is_local.fbe_offset() + is_local.fbe_size())
    , is_from_type(buffer, is_not_null.fbe_offset() + is_not_null.fbe_size())
    , storage(buffer, is_from_type.fbe_offset() + is_from_type.fbe_size())
    , raw_default(buffer, storage.fbe_offset() + storage.fbe_size())
    , cooked_default(buffer, raw_default.fbe_offset() + raw_default.fbe_size())
    , identity(buffer, cooked_default.fbe_offset() + cooked_default.fbe_size())
    , identity_sequence(buffer, identity.fbe_offset() + identity.fbe_size())
    , generated(buffer, identity_sequence.fbe_offset() + identity_sequence.fbe_size())
    , coll_clause(buffer, generated.fbe_offset() + generated.fbe_size())
    , coll_oid(buffer, coll_clause.fbe_offset() + coll_clause.fbe_size())
    , constraints(buffer, coll_oid.fbe_offset() + coll_oid.fbe_size())
    , fdwoptions(buffer, constraints.fbe_offset() + constraints.fbe_size())
    , location(buffer, fdwoptions.fbe_offset() + fdwoptions.fbe_size())
{}

size_t FieldModel_pg_query_ColumnDef::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + colname.fbe_size()
        + type_name.fbe_size()
        + inhcount.fbe_size()
        + is_local.fbe_size()
        + is_not_null.fbe_size()
        + is_from_type.fbe_size()
        + storage.fbe_size()
        + raw_default.fbe_size()
        + cooked_default.fbe_size()
        + identity.fbe_size()
        + identity_sequence.fbe_size()
        + generated.fbe_size()
        + coll_clause.fbe_size()
        + coll_oid.fbe_size()
        + constraints.fbe_size()
        + fdwoptions.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ColumnDef::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + colname.fbe_extra()
        + type_name.fbe_extra()
        + inhcount.fbe_extra()
        + is_local.fbe_extra()
        + is_not_null.fbe_extra()
        + is_from_type.fbe_extra()
        + storage.fbe_extra()
        + raw_default.fbe_extra()
        + cooked_default.fbe_extra()
        + identity.fbe_extra()
        + identity_sequence.fbe_extra()
        + generated.fbe_extra()
        + coll_clause.fbe_extra()
        + coll_oid.fbe_extra()
        + constraints.fbe_extra()
        + fdwoptions.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ColumnDef::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ColumnDef::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + colname.fbe_size()) > fbe_struct_size)
        return true;
    if (!colname.verify())
        return false;
    fbe_current_size += colname.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + inhcount.fbe_size()) > fbe_struct_size)
        return true;
    if (!inhcount.verify())
        return false;
    fbe_current_size += inhcount.fbe_size();

    if ((fbe_current_size + is_local.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_local.verify())
        return false;
    fbe_current_size += is_local.fbe_size();

    if ((fbe_current_size + is_not_null.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_not_null.verify())
        return false;
    fbe_current_size += is_not_null.fbe_size();

    if ((fbe_current_size + is_from_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_from_type.verify())
        return false;
    fbe_current_size += is_from_type.fbe_size();

    if ((fbe_current_size + storage.fbe_size()) > fbe_struct_size)
        return true;
    if (!storage.verify())
        return false;
    fbe_current_size += storage.fbe_size();

    if ((fbe_current_size + raw_default.fbe_size()) > fbe_struct_size)
        return true;
    if (!raw_default.verify())
        return false;
    fbe_current_size += raw_default.fbe_size();

    if ((fbe_current_size + cooked_default.fbe_size()) > fbe_struct_size)
        return true;
    if (!cooked_default.verify())
        return false;
    fbe_current_size += cooked_default.fbe_size();

    if ((fbe_current_size + identity.fbe_size()) > fbe_struct_size)
        return true;
    if (!identity.verify())
        return false;
    fbe_current_size += identity.fbe_size();

    if ((fbe_current_size + identity_sequence.fbe_size()) > fbe_struct_size)
        return true;
    if (!identity_sequence.verify())
        return false;
    fbe_current_size += identity_sequence.fbe_size();

    if ((fbe_current_size + generated.fbe_size()) > fbe_struct_size)
        return true;
    if (!generated.verify())
        return false;
    fbe_current_size += generated.fbe_size();

    if ((fbe_current_size + coll_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!coll_clause.verify())
        return false;
    fbe_current_size += coll_clause.fbe_size();

    if ((fbe_current_size + coll_oid.fbe_size()) > fbe_struct_size)
        return true;
    if (!coll_oid.verify())
        return false;
    fbe_current_size += coll_oid.fbe_size();

    if ((fbe_current_size + constraints.fbe_size()) > fbe_struct_size)
        return true;
    if (!constraints.verify())
        return false;
    fbe_current_size += constraints.fbe_size();

    if ((fbe_current_size + fdwoptions.fbe_size()) > fbe_struct_size)
        return true;
    if (!fdwoptions.verify())
        return false;
    fbe_current_size += fdwoptions.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ColumnDef::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ColumnDef::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ColumnDef::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ColumnDef::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ColumnDef& fbe_value = static_cast<::pg_query::ColumnDef&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + colname.fbe_size()) <= fbe_struct_size)
        {
            colname.get(fbe_value.colname);
        }
    else
        fbe_value.colname = "";
    fbe_current_size += colname.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(&fbe_value.type_name);
        }
    else
        fbe_value.type_name = nullptr;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + inhcount.fbe_size()) <= fbe_struct_size)
        {
            inhcount.get(fbe_value.inhcount);
        }
    else
        fbe_value.inhcount = (int32_t)0ll;
    fbe_current_size += inhcount.fbe_size();

    if ((fbe_current_size + is_local.fbe_size()) <= fbe_struct_size)
        {
            is_local.get(fbe_value.is_local);
        }
    else
        fbe_value.is_local = false;
    fbe_current_size += is_local.fbe_size();

    if ((fbe_current_size + is_not_null.fbe_size()) <= fbe_struct_size)
        {
            is_not_null.get(fbe_value.is_not_null);
        }
    else
        fbe_value.is_not_null = false;
    fbe_current_size += is_not_null.fbe_size();

    if ((fbe_current_size + is_from_type.fbe_size()) <= fbe_struct_size)
        {
            is_from_type.get(fbe_value.is_from_type);
        }
    else
        fbe_value.is_from_type = false;
    fbe_current_size += is_from_type.fbe_size();

    if ((fbe_current_size + storage.fbe_size()) <= fbe_struct_size)
        {
            storage.get(fbe_value.storage);
        }
    else
        fbe_value.storage = "";
    fbe_current_size += storage.fbe_size();

    if ((fbe_current_size + raw_default.fbe_size()) <= fbe_struct_size)
        {
            raw_default.get(fbe_value.raw_default);
        }
    else
        fbe_value.raw_default = ::pg_query::Node();
    fbe_current_size += raw_default.fbe_size();

    if ((fbe_current_size + cooked_default.fbe_size()) <= fbe_struct_size)
        {
            cooked_default.get(fbe_value.cooked_default);
        }
    else
        fbe_value.cooked_default = ::pg_query::Node();
    fbe_current_size += cooked_default.fbe_size();

    if ((fbe_current_size + identity.fbe_size()) <= fbe_struct_size)
        {
            identity.get(fbe_value.identity);
        }
    else
        fbe_value.identity = "";
    fbe_current_size += identity.fbe_size();

    if ((fbe_current_size + identity_sequence.fbe_size()) <= fbe_struct_size)
        {
            identity_sequence.get(&fbe_value.identity_sequence);
        }
    else
        fbe_value.identity_sequence = nullptr;
    fbe_current_size += identity_sequence.fbe_size();

    if ((fbe_current_size + generated.fbe_size()) <= fbe_struct_size)
        {
            generated.get(fbe_value.generated);
        }
    else
        fbe_value.generated = "";
    fbe_current_size += generated.fbe_size();

    if ((fbe_current_size + coll_clause.fbe_size()) <= fbe_struct_size)
        {
            coll_clause.get(&fbe_value.coll_clause);
        }
    else
        fbe_value.coll_clause = nullptr;
    fbe_current_size += coll_clause.fbe_size();

    if ((fbe_current_size + coll_oid.fbe_size()) <= fbe_struct_size)
        {
            coll_oid.get(fbe_value.coll_oid);
        }
    else
        fbe_value.coll_oid = (uint32_t)0ull;
    fbe_current_size += coll_oid.fbe_size();

    if ((fbe_current_size + constraints.fbe_size()) <= fbe_struct_size)
        {
            constraints.get(fbe_value.constraints);
        }
    else
        fbe_value.constraints.clear();
    fbe_current_size += constraints.fbe_size();

    if ((fbe_current_size + fdwoptions.fbe_size()) <= fbe_struct_size)
        {
            fdwoptions.get(fbe_value.fdwoptions);
        }
    else
        fbe_value.fdwoptions.clear();
    fbe_current_size += fdwoptions.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_ColumnDef::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ColumnDef::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ColumnDef::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ColumnDef::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ColumnDef& fbe_value = static_cast<const ::pg_query::ColumnDef&>(base_fbe_value);
    colname.set(fbe_value.colname);
    type_name.set(fbe_value.type_name);
    inhcount.set(fbe_value.inhcount);
    is_local.set(fbe_value.is_local);
    is_not_null.set(fbe_value.is_not_null);
    is_from_type.set(fbe_value.is_from_type);
    storage.set(fbe_value.storage);
    raw_default.set(fbe_value.raw_default);
    cooked_default.set(fbe_value.cooked_default);
    identity.set(fbe_value.identity);
    identity_sequence.set(fbe_value.identity_sequence);
    generated.set(fbe_value.generated);
    coll_clause.set(fbe_value.coll_clause);
    coll_oid.set(fbe_value.coll_oid);
    constraints.set(fbe_value.constraints);
    fdwoptions.set(fbe_value.fdwoptions);
    location.set(fbe_value.location);
}

namespace pg_query {

bool ColumnDefModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ColumnDefModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ColumnDefModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ColumnDefModel::serialize(const ::pg_query::ColumnDef& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ColumnDefModel::deserialize(::pg_query::ColumnDef& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_IndexElem::FieldModelPtr_pg_query_IndexElem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_IndexElem::~FieldModelPtr_pg_query_IndexElem()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_IndexElem::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_IndexElem::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_IndexElem::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_IndexElem::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_IndexElem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_IndexElem::get(::pg_query::IndexElem** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_IndexElem(_buffer, 0);

    ::pg_query::IndexElem *tempModel = new ::pg_query::IndexElem();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_IndexElem::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_IndexElem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_IndexElem::set(const ::pg_query::IndexElem* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_IndexElem(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_IndexElem::FieldModel_pg_query_IndexElem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , expr(buffer, name.fbe_offset() + name.fbe_size())
    , indexcolname(buffer, expr.fbe_offset() + expr.fbe_size())
    , collation(buffer, indexcolname.fbe_offset() + indexcolname.fbe_size())
    , opclass(buffer, collation.fbe_offset() + collation.fbe_size())
    , opclassopts(buffer, opclass.fbe_offset() + opclass.fbe_size())
    , ordering(buffer, opclassopts.fbe_offset() + opclassopts.fbe_size())
    , nulls_ordering(buffer, ordering.fbe_offset() + ordering.fbe_size())
{}

size_t FieldModel_pg_query_IndexElem::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + expr.fbe_size()
        + indexcolname.fbe_size()
        + collation.fbe_size()
        + opclass.fbe_size()
        + opclassopts.fbe_size()
        + ordering.fbe_size()
        + nulls_ordering.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_IndexElem::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + expr.fbe_extra()
        + indexcolname.fbe_extra()
        + collation.fbe_extra()
        + opclass.fbe_extra()
        + opclassopts.fbe_extra()
        + ordering.fbe_extra()
        + nulls_ordering.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_IndexElem::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_IndexElem::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) > fbe_struct_size)
        return true;
    if (!expr.verify())
        return false;
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + indexcolname.fbe_size()) > fbe_struct_size)
        return true;
    if (!indexcolname.verify())
        return false;
    fbe_current_size += indexcolname.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) > fbe_struct_size)
        return true;
    if (!collation.verify())
        return false;
    fbe_current_size += collation.fbe_size();

    if ((fbe_current_size + opclass.fbe_size()) > fbe_struct_size)
        return true;
    if (!opclass.verify())
        return false;
    fbe_current_size += opclass.fbe_size();

    if ((fbe_current_size + opclassopts.fbe_size()) > fbe_struct_size)
        return true;
    if (!opclassopts.verify())
        return false;
    fbe_current_size += opclassopts.fbe_size();

    if ((fbe_current_size + ordering.fbe_size()) > fbe_struct_size)
        return true;
    if (!ordering.verify())
        return false;
    fbe_current_size += ordering.fbe_size();

    if ((fbe_current_size + nulls_ordering.fbe_size()) > fbe_struct_size)
        return true;
    if (!nulls_ordering.verify())
        return false;
    fbe_current_size += nulls_ordering.fbe_size();

    return true;
}

size_t FieldModel_pg_query_IndexElem::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_IndexElem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_IndexElem::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_IndexElem::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::IndexElem& fbe_value = static_cast<::pg_query::IndexElem&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) <= fbe_struct_size)
        {
            expr.get(fbe_value.expr);
        }
    else
        fbe_value.expr = ::pg_query::Node();
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + indexcolname.fbe_size()) <= fbe_struct_size)
        {
            indexcolname.get(fbe_value.indexcolname);
        }
    else
        fbe_value.indexcolname = "";
    fbe_current_size += indexcolname.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) <= fbe_struct_size)
        {
            collation.get(fbe_value.collation);
        }
    else
        fbe_value.collation.clear();
    fbe_current_size += collation.fbe_size();

    if ((fbe_current_size + opclass.fbe_size()) <= fbe_struct_size)
        {
            opclass.get(fbe_value.opclass);
        }
    else
        fbe_value.opclass.clear();
    fbe_current_size += opclass.fbe_size();

    if ((fbe_current_size + opclassopts.fbe_size()) <= fbe_struct_size)
        {
            opclassopts.get(fbe_value.opclassopts);
        }
    else
        fbe_value.opclassopts.clear();
    fbe_current_size += opclassopts.fbe_size();

    if ((fbe_current_size + ordering.fbe_size()) <= fbe_struct_size)
        {
            ordering.get(fbe_value.ordering);
        }
    else
        fbe_value.ordering = ::pg_query::SortByDir();
    fbe_current_size += ordering.fbe_size();

    if ((fbe_current_size + nulls_ordering.fbe_size()) <= fbe_struct_size)
        {
            nulls_ordering.get(fbe_value.nulls_ordering);
        }
    else
        fbe_value.nulls_ordering = ::pg_query::SortByNulls();
    fbe_current_size += nulls_ordering.fbe_size();
}

size_t FieldModel_pg_query_IndexElem::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_IndexElem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_IndexElem::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_IndexElem::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::IndexElem& fbe_value = static_cast<const ::pg_query::IndexElem&>(base_fbe_value);
    name.set(fbe_value.name);
    expr.set(fbe_value.expr);
    indexcolname.set(fbe_value.indexcolname);
    collation.set(fbe_value.collation);
    opclass.set(fbe_value.opclass);
    opclassopts.set(fbe_value.opclassopts);
    ordering.set(fbe_value.ordering);
    nulls_ordering.set(fbe_value.nulls_ordering);
}

namespace pg_query {

bool IndexElemModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t IndexElemModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t IndexElemModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t IndexElemModel::serialize(const ::pg_query::IndexElem& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t IndexElemModel::deserialize(::pg_query::IndexElem& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_Constraint::FieldModelPtr_pg_query_Constraint(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_Constraint::~FieldModelPtr_pg_query_Constraint()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_Constraint::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_Constraint::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_Constraint::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_Constraint::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Constraint::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Constraint::get(::pg_query::Constraint** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_Constraint(_buffer, 0);

    ::pg_query::Constraint *tempModel = new ::pg_query::Constraint();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_Constraint::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_Constraint::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_Constraint::set(const ::pg_query::Constraint* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_Constraint(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_Constraint::FieldModel_pg_query_Constraint(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , contype(buffer, 4 + 4)
    , conname(buffer, contype.fbe_offset() + contype.fbe_size())
    , deferrable(buffer, conname.fbe_offset() + conname.fbe_size())
    , initdeferred(buffer, deferrable.fbe_offset() + deferrable.fbe_size())
    , location(buffer, initdeferred.fbe_offset() + initdeferred.fbe_size())
    , is_no_inherit(buffer, location.fbe_offset() + location.fbe_size())
    , raw_expr(buffer, is_no_inherit.fbe_offset() + is_no_inherit.fbe_size())
    , cooked_expr(buffer, raw_expr.fbe_offset() + raw_expr.fbe_size())
    , generated_when(buffer, cooked_expr.fbe_offset() + cooked_expr.fbe_size())
    , keys(buffer, generated_when.fbe_offset() + generated_when.fbe_size())
    , including(buffer, keys.fbe_offset() + keys.fbe_size())
    , exclusions(buffer, including.fbe_offset() + including.fbe_size())
    , options(buffer, exclusions.fbe_offset() + exclusions.fbe_size())
    , indexname(buffer, options.fbe_offset() + options.fbe_size())
    , indexspace(buffer, indexname.fbe_offset() + indexname.fbe_size())
    , reset_default_tblspc(buffer, indexspace.fbe_offset() + indexspace.fbe_size())
    , access_method(buffer, reset_default_tblspc.fbe_offset() + reset_default_tblspc.fbe_size())
    , where_clause(buffer, access_method.fbe_offset() + access_method.fbe_size())
    , pktable(buffer, where_clause.fbe_offset() + where_clause.fbe_size())
    , fk_attrs(buffer, pktable.fbe_offset() + pktable.fbe_size())
    , pk_attrs(buffer, fk_attrs.fbe_offset() + fk_attrs.fbe_size())
    , fk_matchtype(buffer, pk_attrs.fbe_offset() + pk_attrs.fbe_size())
    , fk_upd_action(buffer, fk_matchtype.fbe_offset() + fk_matchtype.fbe_size())
    , fk_del_action(buffer, fk_upd_action.fbe_offset() + fk_upd_action.fbe_size())
    , old_conpfeqop(buffer, fk_del_action.fbe_offset() + fk_del_action.fbe_size())
    , old_pktable_oid(buffer, old_conpfeqop.fbe_offset() + old_conpfeqop.fbe_size())
    , skip_validation(buffer, old_pktable_oid.fbe_offset() + old_pktable_oid.fbe_size())
    , initially_valid(buffer, skip_validation.fbe_offset() + skip_validation.fbe_size())
{}

size_t FieldModel_pg_query_Constraint::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + contype.fbe_size()
        + conname.fbe_size()
        + deferrable.fbe_size()
        + initdeferred.fbe_size()
        + location.fbe_size()
        + is_no_inherit.fbe_size()
        + raw_expr.fbe_size()
        + cooked_expr.fbe_size()
        + generated_when.fbe_size()
        + keys.fbe_size()
        + including.fbe_size()
        + exclusions.fbe_size()
        + options.fbe_size()
        + indexname.fbe_size()
        + indexspace.fbe_size()
        + reset_default_tblspc.fbe_size()
        + access_method.fbe_size()
        + where_clause.fbe_size()
        + pktable.fbe_size()
        + fk_attrs.fbe_size()
        + pk_attrs.fbe_size()
        + fk_matchtype.fbe_size()
        + fk_upd_action.fbe_size()
        + fk_del_action.fbe_size()
        + old_conpfeqop.fbe_size()
        + old_pktable_oid.fbe_size()
        + skip_validation.fbe_size()
        + initially_valid.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_Constraint::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + contype.fbe_extra()
        + conname.fbe_extra()
        + deferrable.fbe_extra()
        + initdeferred.fbe_extra()
        + location.fbe_extra()
        + is_no_inherit.fbe_extra()
        + raw_expr.fbe_extra()
        + cooked_expr.fbe_extra()
        + generated_when.fbe_extra()
        + keys.fbe_extra()
        + including.fbe_extra()
        + exclusions.fbe_extra()
        + options.fbe_extra()
        + indexname.fbe_extra()
        + indexspace.fbe_extra()
        + reset_default_tblspc.fbe_extra()
        + access_method.fbe_extra()
        + where_clause.fbe_extra()
        + pktable.fbe_extra()
        + fk_attrs.fbe_extra()
        + pk_attrs.fbe_extra()
        + fk_matchtype.fbe_extra()
        + fk_upd_action.fbe_extra()
        + fk_del_action.fbe_extra()
        + old_conpfeqop.fbe_extra()
        + old_pktable_oid.fbe_extra()
        + skip_validation.fbe_extra()
        + initially_valid.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_Constraint::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_Constraint::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + contype.fbe_size()) > fbe_struct_size)
        return true;
    if (!contype.verify())
        return false;
    fbe_current_size += contype.fbe_size();

    if ((fbe_current_size + conname.fbe_size()) > fbe_struct_size)
        return true;
    if (!conname.verify())
        return false;
    fbe_current_size += conname.fbe_size();

    if ((fbe_current_size + deferrable.fbe_size()) > fbe_struct_size)
        return true;
    if (!deferrable.verify())
        return false;
    fbe_current_size += deferrable.fbe_size();

    if ((fbe_current_size + initdeferred.fbe_size()) > fbe_struct_size)
        return true;
    if (!initdeferred.verify())
        return false;
    fbe_current_size += initdeferred.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    if ((fbe_current_size + is_no_inherit.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_no_inherit.verify())
        return false;
    fbe_current_size += is_no_inherit.fbe_size();

    if ((fbe_current_size + raw_expr.fbe_size()) > fbe_struct_size)
        return true;
    if (!raw_expr.verify())
        return false;
    fbe_current_size += raw_expr.fbe_size();

    if ((fbe_current_size + cooked_expr.fbe_size()) > fbe_struct_size)
        return true;
    if (!cooked_expr.verify())
        return false;
    fbe_current_size += cooked_expr.fbe_size();

    if ((fbe_current_size + generated_when.fbe_size()) > fbe_struct_size)
        return true;
    if (!generated_when.verify())
        return false;
    fbe_current_size += generated_when.fbe_size();

    if ((fbe_current_size + keys.fbe_size()) > fbe_struct_size)
        return true;
    if (!keys.verify())
        return false;
    fbe_current_size += keys.fbe_size();

    if ((fbe_current_size + including.fbe_size()) > fbe_struct_size)
        return true;
    if (!including.verify())
        return false;
    fbe_current_size += including.fbe_size();

    if ((fbe_current_size + exclusions.fbe_size()) > fbe_struct_size)
        return true;
    if (!exclusions.verify())
        return false;
    fbe_current_size += exclusions.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + indexname.fbe_size()) > fbe_struct_size)
        return true;
    if (!indexname.verify())
        return false;
    fbe_current_size += indexname.fbe_size();

    if ((fbe_current_size + indexspace.fbe_size()) > fbe_struct_size)
        return true;
    if (!indexspace.verify())
        return false;
    fbe_current_size += indexspace.fbe_size();

    if ((fbe_current_size + reset_default_tblspc.fbe_size()) > fbe_struct_size)
        return true;
    if (!reset_default_tblspc.verify())
        return false;
    fbe_current_size += reset_default_tblspc.fbe_size();

    if ((fbe_current_size + access_method.fbe_size()) > fbe_struct_size)
        return true;
    if (!access_method.verify())
        return false;
    fbe_current_size += access_method.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!where_clause.verify())
        return false;
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + pktable.fbe_size()) > fbe_struct_size)
        return true;
    if (!pktable.verify())
        return false;
    fbe_current_size += pktable.fbe_size();

    if ((fbe_current_size + fk_attrs.fbe_size()) > fbe_struct_size)
        return true;
    if (!fk_attrs.verify())
        return false;
    fbe_current_size += fk_attrs.fbe_size();

    if ((fbe_current_size + pk_attrs.fbe_size()) > fbe_struct_size)
        return true;
    if (!pk_attrs.verify())
        return false;
    fbe_current_size += pk_attrs.fbe_size();

    if ((fbe_current_size + fk_matchtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!fk_matchtype.verify())
        return false;
    fbe_current_size += fk_matchtype.fbe_size();

    if ((fbe_current_size + fk_upd_action.fbe_size()) > fbe_struct_size)
        return true;
    if (!fk_upd_action.verify())
        return false;
    fbe_current_size += fk_upd_action.fbe_size();

    if ((fbe_current_size + fk_del_action.fbe_size()) > fbe_struct_size)
        return true;
    if (!fk_del_action.verify())
        return false;
    fbe_current_size += fk_del_action.fbe_size();

    if ((fbe_current_size + old_conpfeqop.fbe_size()) > fbe_struct_size)
        return true;
    if (!old_conpfeqop.verify())
        return false;
    fbe_current_size += old_conpfeqop.fbe_size();

    if ((fbe_current_size + old_pktable_oid.fbe_size()) > fbe_struct_size)
        return true;
    if (!old_pktable_oid.verify())
        return false;
    fbe_current_size += old_pktable_oid.fbe_size();

    if ((fbe_current_size + skip_validation.fbe_size()) > fbe_struct_size)
        return true;
    if (!skip_validation.verify())
        return false;
    fbe_current_size += skip_validation.fbe_size();

    if ((fbe_current_size + initially_valid.fbe_size()) > fbe_struct_size)
        return true;
    if (!initially_valid.verify())
        return false;
    fbe_current_size += initially_valid.fbe_size();

    return true;
}

size_t FieldModel_pg_query_Constraint::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Constraint::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Constraint::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_Constraint::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::Constraint& fbe_value = static_cast<::pg_query::Constraint&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + contype.fbe_size()) <= fbe_struct_size)
        {
            contype.get(fbe_value.contype);
        }
    else
        fbe_value.contype = ::pg_query::ConstrType();
    fbe_current_size += contype.fbe_size();

    if ((fbe_current_size + conname.fbe_size()) <= fbe_struct_size)
        {
            conname.get(fbe_value.conname);
        }
    else
        fbe_value.conname = "";
    fbe_current_size += conname.fbe_size();

    if ((fbe_current_size + deferrable.fbe_size()) <= fbe_struct_size)
        {
            deferrable.get(fbe_value.deferrable);
        }
    else
        fbe_value.deferrable = false;
    fbe_current_size += deferrable.fbe_size();

    if ((fbe_current_size + initdeferred.fbe_size()) <= fbe_struct_size)
        {
            initdeferred.get(fbe_value.initdeferred);
        }
    else
        fbe_value.initdeferred = false;
    fbe_current_size += initdeferred.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();

    if ((fbe_current_size + is_no_inherit.fbe_size()) <= fbe_struct_size)
        {
            is_no_inherit.get(fbe_value.is_no_inherit);
        }
    else
        fbe_value.is_no_inherit = false;
    fbe_current_size += is_no_inherit.fbe_size();

    if ((fbe_current_size + raw_expr.fbe_size()) <= fbe_struct_size)
        {
            raw_expr.get(fbe_value.raw_expr);
        }
    else
        fbe_value.raw_expr = ::pg_query::Node();
    fbe_current_size += raw_expr.fbe_size();

    if ((fbe_current_size + cooked_expr.fbe_size()) <= fbe_struct_size)
        {
            cooked_expr.get(fbe_value.cooked_expr);
        }
    else
        fbe_value.cooked_expr = "";
    fbe_current_size += cooked_expr.fbe_size();

    if ((fbe_current_size + generated_when.fbe_size()) <= fbe_struct_size)
        {
            generated_when.get(fbe_value.generated_when);
        }
    else
        fbe_value.generated_when = "";
    fbe_current_size += generated_when.fbe_size();

    if ((fbe_current_size + keys.fbe_size()) <= fbe_struct_size)
        {
            keys.get(fbe_value.keys);
        }
    else
        fbe_value.keys.clear();
    fbe_current_size += keys.fbe_size();

    if ((fbe_current_size + including.fbe_size()) <= fbe_struct_size)
        {
            including.get(fbe_value.including);
        }
    else
        fbe_value.including.clear();
    fbe_current_size += including.fbe_size();

    if ((fbe_current_size + exclusions.fbe_size()) <= fbe_struct_size)
        {
            exclusions.get(fbe_value.exclusions);
        }
    else
        fbe_value.exclusions.clear();
    fbe_current_size += exclusions.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options.clear();
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + indexname.fbe_size()) <= fbe_struct_size)
        {
            indexname.get(fbe_value.indexname);
        }
    else
        fbe_value.indexname = "";
    fbe_current_size += indexname.fbe_size();

    if ((fbe_current_size + indexspace.fbe_size()) <= fbe_struct_size)
        {
            indexspace.get(fbe_value.indexspace);
        }
    else
        fbe_value.indexspace = "";
    fbe_current_size += indexspace.fbe_size();

    if ((fbe_current_size + reset_default_tblspc.fbe_size()) <= fbe_struct_size)
        {
            reset_default_tblspc.get(fbe_value.reset_default_tblspc);
        }
    else
        fbe_value.reset_default_tblspc = false;
    fbe_current_size += reset_default_tblspc.fbe_size();

    if ((fbe_current_size + access_method.fbe_size()) <= fbe_struct_size)
        {
            access_method.get(fbe_value.access_method);
        }
    else
        fbe_value.access_method = "";
    fbe_current_size += access_method.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) <= fbe_struct_size)
        {
            where_clause.get(fbe_value.where_clause);
        }
    else
        fbe_value.where_clause = ::pg_query::Node();
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + pktable.fbe_size()) <= fbe_struct_size)
        {
            pktable.get(&fbe_value.pktable);
        }
    else
        fbe_value.pktable = nullptr;
    fbe_current_size += pktable.fbe_size();

    if ((fbe_current_size + fk_attrs.fbe_size()) <= fbe_struct_size)
        {
            fk_attrs.get(fbe_value.fk_attrs);
        }
    else
        fbe_value.fk_attrs.clear();
    fbe_current_size += fk_attrs.fbe_size();

    if ((fbe_current_size + pk_attrs.fbe_size()) <= fbe_struct_size)
        {
            pk_attrs.get(fbe_value.pk_attrs);
        }
    else
        fbe_value.pk_attrs.clear();
    fbe_current_size += pk_attrs.fbe_size();

    if ((fbe_current_size + fk_matchtype.fbe_size()) <= fbe_struct_size)
        {
            fk_matchtype.get(fbe_value.fk_matchtype);
        }
    else
        fbe_value.fk_matchtype = "";
    fbe_current_size += fk_matchtype.fbe_size();

    if ((fbe_current_size + fk_upd_action.fbe_size()) <= fbe_struct_size)
        {
            fk_upd_action.get(fbe_value.fk_upd_action);
        }
    else
        fbe_value.fk_upd_action = "";
    fbe_current_size += fk_upd_action.fbe_size();

    if ((fbe_current_size + fk_del_action.fbe_size()) <= fbe_struct_size)
        {
            fk_del_action.get(fbe_value.fk_del_action);
        }
    else
        fbe_value.fk_del_action = "";
    fbe_current_size += fk_del_action.fbe_size();

    if ((fbe_current_size + old_conpfeqop.fbe_size()) <= fbe_struct_size)
        {
            old_conpfeqop.get(fbe_value.old_conpfeqop);
        }
    else
        fbe_value.old_conpfeqop.clear();
    fbe_current_size += old_conpfeqop.fbe_size();

    if ((fbe_current_size + old_pktable_oid.fbe_size()) <= fbe_struct_size)
        {
            old_pktable_oid.get(fbe_value.old_pktable_oid);
        }
    else
        fbe_value.old_pktable_oid = (uint32_t)0ull;
    fbe_current_size += old_pktable_oid.fbe_size();

    if ((fbe_current_size + skip_validation.fbe_size()) <= fbe_struct_size)
        {
            skip_validation.get(fbe_value.skip_validation);
        }
    else
        fbe_value.skip_validation = false;
    fbe_current_size += skip_validation.fbe_size();

    if ((fbe_current_size + initially_valid.fbe_size()) <= fbe_struct_size)
        {
            initially_valid.get(fbe_value.initially_valid);
        }
    else
        fbe_value.initially_valid = false;
    fbe_current_size += initially_valid.fbe_size();
}

size_t FieldModel_pg_query_Constraint::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_Constraint::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_Constraint::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_Constraint::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::Constraint& fbe_value = static_cast<const ::pg_query::Constraint&>(base_fbe_value);
    contype.set(fbe_value.contype);
    conname.set(fbe_value.conname);
    deferrable.set(fbe_value.deferrable);
    initdeferred.set(fbe_value.initdeferred);
    location.set(fbe_value.location);
    is_no_inherit.set(fbe_value.is_no_inherit);
    raw_expr.set(fbe_value.raw_expr);
    cooked_expr.set(fbe_value.cooked_expr);
    generated_when.set(fbe_value.generated_when);
    keys.set(fbe_value.keys);
    including.set(fbe_value.including);
    exclusions.set(fbe_value.exclusions);
    options.set(fbe_value.options);
    indexname.set(fbe_value.indexname);
    indexspace.set(fbe_value.indexspace);
    reset_default_tblspc.set(fbe_value.reset_default_tblspc);
    access_method.set(fbe_value.access_method);
    where_clause.set(fbe_value.where_clause);
    pktable.set(fbe_value.pktable);
    fk_attrs.set(fbe_value.fk_attrs);
    pk_attrs.set(fbe_value.pk_attrs);
    fk_matchtype.set(fbe_value.fk_matchtype);
    fk_upd_action.set(fbe_value.fk_upd_action);
    fk_del_action.set(fbe_value.fk_del_action);
    old_conpfeqop.set(fbe_value.old_conpfeqop);
    old_pktable_oid.set(fbe_value.old_pktable_oid);
    skip_validation.set(fbe_value.skip_validation);
    initially_valid.set(fbe_value.initially_valid);
}

namespace pg_query {

bool ConstraintModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ConstraintModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ConstraintModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ConstraintModel::serialize(const ::pg_query::Constraint& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ConstraintModel::deserialize(::pg_query::Constraint& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_DefElem::FieldModelPtr_pg_query_DefElem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_DefElem::~FieldModelPtr_pg_query_DefElem()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_DefElem::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_DefElem::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_DefElem::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_DefElem::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DefElem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DefElem::get(::pg_query::DefElem** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_DefElem(_buffer, 0);

    ::pg_query::DefElem *tempModel = new ::pg_query::DefElem();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_DefElem::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_DefElem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_DefElem::set(const ::pg_query::DefElem* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_DefElem(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_DefElem::FieldModel_pg_query_DefElem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , defnamespace(buffer, 4 + 4)
    , defname(buffer, defnamespace.fbe_offset() + defnamespace.fbe_size())
    , arg(buffer, defname.fbe_offset() + defname.fbe_size())
    , defaction(buffer, arg.fbe_offset() + arg.fbe_size())
    , location(buffer, defaction.fbe_offset() + defaction.fbe_size())
{}

size_t FieldModel_pg_query_DefElem::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + defnamespace.fbe_size()
        + defname.fbe_size()
        + arg.fbe_size()
        + defaction.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_DefElem::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + defnamespace.fbe_extra()
        + defname.fbe_extra()
        + arg.fbe_extra()
        + defaction.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_DefElem::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_DefElem::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + defnamespace.fbe_size()) > fbe_struct_size)
        return true;
    if (!defnamespace.verify())
        return false;
    fbe_current_size += defnamespace.fbe_size();

    if ((fbe_current_size + defname.fbe_size()) > fbe_struct_size)
        return true;
    if (!defname.verify())
        return false;
    fbe_current_size += defname.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg.verify())
        return false;
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + defaction.fbe_size()) > fbe_struct_size)
        return true;
    if (!defaction.verify())
        return false;
    fbe_current_size += defaction.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_DefElem::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DefElem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DefElem::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_DefElem::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::DefElem& fbe_value = static_cast<::pg_query::DefElem&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + defnamespace.fbe_size()) <= fbe_struct_size)
        {
            defnamespace.get(fbe_value.defnamespace);
        }
    else
        fbe_value.defnamespace = "";
    fbe_current_size += defnamespace.fbe_size();

    if ((fbe_current_size + defname.fbe_size()) <= fbe_struct_size)
        {
            defname.get(fbe_value.defname);
        }
    else
        fbe_value.defname = "";
    fbe_current_size += defname.fbe_size();

    if ((fbe_current_size + arg.fbe_size()) <= fbe_struct_size)
        {
            arg.get(fbe_value.arg);
        }
    else
        fbe_value.arg = ::pg_query::Node();
    fbe_current_size += arg.fbe_size();

    if ((fbe_current_size + defaction.fbe_size()) <= fbe_struct_size)
        {
            defaction.get(fbe_value.defaction);
        }
    else
        fbe_value.defaction = ::pg_query::DefElemAction();
    fbe_current_size += defaction.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_DefElem::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_DefElem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_DefElem::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_DefElem::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::DefElem& fbe_value = static_cast<const ::pg_query::DefElem&>(base_fbe_value);
    defnamespace.set(fbe_value.defnamespace);
    defname.set(fbe_value.defname);
    arg.set(fbe_value.arg);
    defaction.set(fbe_value.defaction);
    location.set(fbe_value.location);
}

namespace pg_query {

bool DefElemModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DefElemModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DefElemModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DefElemModel::serialize(const ::pg_query::DefElem& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DefElemModel::deserialize(::pg_query::DefElem& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RangeTblEntry::FieldModelPtr_pg_query_RangeTblEntry(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RangeTblEntry::~FieldModelPtr_pg_query_RangeTblEntry()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RangeTblEntry::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTblEntry::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTblEntry::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RangeTblEntry::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTblEntry::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTblEntry::get(::pg_query::RangeTblEntry** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RangeTblEntry(_buffer, 0);

    ::pg_query::RangeTblEntry *tempModel = new ::pg_query::RangeTblEntry();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RangeTblEntry::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTblEntry::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTblEntry::set(const ::pg_query::RangeTblEntry* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RangeTblEntry(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RangeTblEntry::FieldModel_pg_query_RangeTblEntry(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , rtekind(buffer, 4 + 4)
    , relid(buffer, rtekind.fbe_offset() + rtekind.fbe_size())
    , relkind(buffer, relid.fbe_offset() + relid.fbe_size())
    , rellockmode(buffer, relkind.fbe_offset() + relkind.fbe_size())
    , tablesample(buffer, rellockmode.fbe_offset() + rellockmode.fbe_size())
    , subquery(buffer, tablesample.fbe_offset() + tablesample.fbe_size())
    , security_barrier(buffer, subquery.fbe_offset() + subquery.fbe_size())
    , jointype(buffer, security_barrier.fbe_offset() + security_barrier.fbe_size())
    , joinmergedcols(buffer, jointype.fbe_offset() + jointype.fbe_size())
    , joinaliasvars(buffer, joinmergedcols.fbe_offset() + joinmergedcols.fbe_size())
    , joinleftcols(buffer, joinaliasvars.fbe_offset() + joinaliasvars.fbe_size())
    , joinrightcols(buffer, joinleftcols.fbe_offset() + joinleftcols.fbe_size())
    , functions(buffer, joinrightcols.fbe_offset() + joinrightcols.fbe_size())
    , funcordinality(buffer, functions.fbe_offset() + functions.fbe_size())
    , tablefunc(buffer, funcordinality.fbe_offset() + funcordinality.fbe_size())
    , values_lists(buffer, tablefunc.fbe_offset() + tablefunc.fbe_size())
    , ctename(buffer, values_lists.fbe_offset() + values_lists.fbe_size())
    , ctelevelsup(buffer, ctename.fbe_offset() + ctename.fbe_size())
    , self_reference(buffer, ctelevelsup.fbe_offset() + ctelevelsup.fbe_size())
    , coltypes(buffer, self_reference.fbe_offset() + self_reference.fbe_size())
    , coltypmods(buffer, coltypes.fbe_offset() + coltypes.fbe_size())
    , colcollations(buffer, coltypmods.fbe_offset() + coltypmods.fbe_size())
    , enrname(buffer, colcollations.fbe_offset() + colcollations.fbe_size())
    , enrtuples(buffer, enrname.fbe_offset() + enrname.fbe_size())
    , alias(buffer, enrtuples.fbe_offset() + enrtuples.fbe_size())
    , eref(buffer, alias.fbe_offset() + alias.fbe_size())
    , lateral(buffer, eref.fbe_offset() + eref.fbe_size())
    , inh(buffer, lateral.fbe_offset() + lateral.fbe_size())
    , in_from_cl(buffer, inh.fbe_offset() + inh.fbe_size())
    , required_perms(buffer, in_from_cl.fbe_offset() + in_from_cl.fbe_size())
    , check_as_user(buffer, required_perms.fbe_offset() + required_perms.fbe_size())
    , selected_cols(buffer, check_as_user.fbe_offset() + check_as_user.fbe_size())
    , inserted_cols(buffer, selected_cols.fbe_offset() + selected_cols.fbe_size())
    , updated_cols(buffer, inserted_cols.fbe_offset() + inserted_cols.fbe_size())
    , extra_updated_cols(buffer, updated_cols.fbe_offset() + updated_cols.fbe_size())
    , security_quals(buffer, extra_updated_cols.fbe_offset() + extra_updated_cols.fbe_size())
{}

size_t FieldModel_pg_query_RangeTblEntry::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + rtekind.fbe_size()
        + relid.fbe_size()
        + relkind.fbe_size()
        + rellockmode.fbe_size()
        + tablesample.fbe_size()
        + subquery.fbe_size()
        + security_barrier.fbe_size()
        + jointype.fbe_size()
        + joinmergedcols.fbe_size()
        + joinaliasvars.fbe_size()
        + joinleftcols.fbe_size()
        + joinrightcols.fbe_size()
        + functions.fbe_size()
        + funcordinality.fbe_size()
        + tablefunc.fbe_size()
        + values_lists.fbe_size()
        + ctename.fbe_size()
        + ctelevelsup.fbe_size()
        + self_reference.fbe_size()
        + coltypes.fbe_size()
        + coltypmods.fbe_size()
        + colcollations.fbe_size()
        + enrname.fbe_size()
        + enrtuples.fbe_size()
        + alias.fbe_size()
        + eref.fbe_size()
        + lateral.fbe_size()
        + inh.fbe_size()
        + in_from_cl.fbe_size()
        + required_perms.fbe_size()
        + check_as_user.fbe_size()
        + selected_cols.fbe_size()
        + inserted_cols.fbe_size()
        + updated_cols.fbe_size()
        + extra_updated_cols.fbe_size()
        + security_quals.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RangeTblEntry::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + rtekind.fbe_extra()
        + relid.fbe_extra()
        + relkind.fbe_extra()
        + rellockmode.fbe_extra()
        + tablesample.fbe_extra()
        + subquery.fbe_extra()
        + security_barrier.fbe_extra()
        + jointype.fbe_extra()
        + joinmergedcols.fbe_extra()
        + joinaliasvars.fbe_extra()
        + joinleftcols.fbe_extra()
        + joinrightcols.fbe_extra()
        + functions.fbe_extra()
        + funcordinality.fbe_extra()
        + tablefunc.fbe_extra()
        + values_lists.fbe_extra()
        + ctename.fbe_extra()
        + ctelevelsup.fbe_extra()
        + self_reference.fbe_extra()
        + coltypes.fbe_extra()
        + coltypmods.fbe_extra()
        + colcollations.fbe_extra()
        + enrname.fbe_extra()
        + enrtuples.fbe_extra()
        + alias.fbe_extra()
        + eref.fbe_extra()
        + lateral.fbe_extra()
        + inh.fbe_extra()
        + in_from_cl.fbe_extra()
        + required_perms.fbe_extra()
        + check_as_user.fbe_extra()
        + selected_cols.fbe_extra()
        + inserted_cols.fbe_extra()
        + updated_cols.fbe_extra()
        + extra_updated_cols.fbe_extra()
        + security_quals.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RangeTblEntry::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RangeTblEntry::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rtekind.fbe_size()) > fbe_struct_size)
        return true;
    if (!rtekind.verify())
        return false;
    fbe_current_size += rtekind.fbe_size();

    if ((fbe_current_size + relid.fbe_size()) > fbe_struct_size)
        return true;
    if (!relid.verify())
        return false;
    fbe_current_size += relid.fbe_size();

    if ((fbe_current_size + relkind.fbe_size()) > fbe_struct_size)
        return true;
    if (!relkind.verify())
        return false;
    fbe_current_size += relkind.fbe_size();

    if ((fbe_current_size + rellockmode.fbe_size()) > fbe_struct_size)
        return true;
    if (!rellockmode.verify())
        return false;
    fbe_current_size += rellockmode.fbe_size();

    if ((fbe_current_size + tablesample.fbe_size()) > fbe_struct_size)
        return true;
    if (!tablesample.verify())
        return false;
    fbe_current_size += tablesample.fbe_size();

    if ((fbe_current_size + subquery.fbe_size()) > fbe_struct_size)
        return true;
    if (!subquery.verify())
        return false;
    fbe_current_size += subquery.fbe_size();

    if ((fbe_current_size + security_barrier.fbe_size()) > fbe_struct_size)
        return true;
    if (!security_barrier.verify())
        return false;
    fbe_current_size += security_barrier.fbe_size();

    if ((fbe_current_size + jointype.fbe_size()) > fbe_struct_size)
        return true;
    if (!jointype.verify())
        return false;
    fbe_current_size += jointype.fbe_size();

    if ((fbe_current_size + joinmergedcols.fbe_size()) > fbe_struct_size)
        return true;
    if (!joinmergedcols.verify())
        return false;
    fbe_current_size += joinmergedcols.fbe_size();

    if ((fbe_current_size + joinaliasvars.fbe_size()) > fbe_struct_size)
        return true;
    if (!joinaliasvars.verify())
        return false;
    fbe_current_size += joinaliasvars.fbe_size();

    if ((fbe_current_size + joinleftcols.fbe_size()) > fbe_struct_size)
        return true;
    if (!joinleftcols.verify())
        return false;
    fbe_current_size += joinleftcols.fbe_size();

    if ((fbe_current_size + joinrightcols.fbe_size()) > fbe_struct_size)
        return true;
    if (!joinrightcols.verify())
        return false;
    fbe_current_size += joinrightcols.fbe_size();

    if ((fbe_current_size + functions.fbe_size()) > fbe_struct_size)
        return true;
    if (!functions.verify())
        return false;
    fbe_current_size += functions.fbe_size();

    if ((fbe_current_size + funcordinality.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcordinality.verify())
        return false;
    fbe_current_size += funcordinality.fbe_size();

    if ((fbe_current_size + tablefunc.fbe_size()) > fbe_struct_size)
        return true;
    if (!tablefunc.verify())
        return false;
    fbe_current_size += tablefunc.fbe_size();

    if ((fbe_current_size + values_lists.fbe_size()) > fbe_struct_size)
        return true;
    if (!values_lists.verify())
        return false;
    fbe_current_size += values_lists.fbe_size();

    if ((fbe_current_size + ctename.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctename.verify())
        return false;
    fbe_current_size += ctename.fbe_size();

    if ((fbe_current_size + ctelevelsup.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctelevelsup.verify())
        return false;
    fbe_current_size += ctelevelsup.fbe_size();

    if ((fbe_current_size + self_reference.fbe_size()) > fbe_struct_size)
        return true;
    if (!self_reference.verify())
        return false;
    fbe_current_size += self_reference.fbe_size();

    if ((fbe_current_size + coltypes.fbe_size()) > fbe_struct_size)
        return true;
    if (!coltypes.verify())
        return false;
    fbe_current_size += coltypes.fbe_size();

    if ((fbe_current_size + coltypmods.fbe_size()) > fbe_struct_size)
        return true;
    if (!coltypmods.verify())
        return false;
    fbe_current_size += coltypmods.fbe_size();

    if ((fbe_current_size + colcollations.fbe_size()) > fbe_struct_size)
        return true;
    if (!colcollations.verify())
        return false;
    fbe_current_size += colcollations.fbe_size();

    if ((fbe_current_size + enrname.fbe_size()) > fbe_struct_size)
        return true;
    if (!enrname.verify())
        return false;
    fbe_current_size += enrname.fbe_size();

    if ((fbe_current_size + enrtuples.fbe_size()) > fbe_struct_size)
        return true;
    if (!enrtuples.verify())
        return false;
    fbe_current_size += enrtuples.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) > fbe_struct_size)
        return true;
    if (!alias.verify())
        return false;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + eref.fbe_size()) > fbe_struct_size)
        return true;
    if (!eref.verify())
        return false;
    fbe_current_size += eref.fbe_size();

    if ((fbe_current_size + lateral.fbe_size()) > fbe_struct_size)
        return true;
    if (!lateral.verify())
        return false;
    fbe_current_size += lateral.fbe_size();

    if ((fbe_current_size + inh.fbe_size()) > fbe_struct_size)
        return true;
    if (!inh.verify())
        return false;
    fbe_current_size += inh.fbe_size();

    if ((fbe_current_size + in_from_cl.fbe_size()) > fbe_struct_size)
        return true;
    if (!in_from_cl.verify())
        return false;
    fbe_current_size += in_from_cl.fbe_size();

    if ((fbe_current_size + required_perms.fbe_size()) > fbe_struct_size)
        return true;
    if (!required_perms.verify())
        return false;
    fbe_current_size += required_perms.fbe_size();

    if ((fbe_current_size + check_as_user.fbe_size()) > fbe_struct_size)
        return true;
    if (!check_as_user.verify())
        return false;
    fbe_current_size += check_as_user.fbe_size();

    if ((fbe_current_size + selected_cols.fbe_size()) > fbe_struct_size)
        return true;
    if (!selected_cols.verify())
        return false;
    fbe_current_size += selected_cols.fbe_size();

    if ((fbe_current_size + inserted_cols.fbe_size()) > fbe_struct_size)
        return true;
    if (!inserted_cols.verify())
        return false;
    fbe_current_size += inserted_cols.fbe_size();

    if ((fbe_current_size + updated_cols.fbe_size()) > fbe_struct_size)
        return true;
    if (!updated_cols.verify())
        return false;
    fbe_current_size += updated_cols.fbe_size();

    if ((fbe_current_size + extra_updated_cols.fbe_size()) > fbe_struct_size)
        return true;
    if (!extra_updated_cols.verify())
        return false;
    fbe_current_size += extra_updated_cols.fbe_size();

    if ((fbe_current_size + security_quals.fbe_size()) > fbe_struct_size)
        return true;
    if (!security_quals.verify())
        return false;
    fbe_current_size += security_quals.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RangeTblEntry::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTblEntry::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTblEntry::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RangeTblEntry::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RangeTblEntry& fbe_value = static_cast<::pg_query::RangeTblEntry&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rtekind.fbe_size()) <= fbe_struct_size)
        {
            rtekind.get(fbe_value.rtekind);
        }
    else
        fbe_value.rtekind = ::pg_query::RTEKind();
    fbe_current_size += rtekind.fbe_size();

    if ((fbe_current_size + relid.fbe_size()) <= fbe_struct_size)
        {
            relid.get(fbe_value.relid);
        }
    else
        fbe_value.relid = (uint32_t)0ull;
    fbe_current_size += relid.fbe_size();

    if ((fbe_current_size + relkind.fbe_size()) <= fbe_struct_size)
        {
            relkind.get(fbe_value.relkind);
        }
    else
        fbe_value.relkind = "";
    fbe_current_size += relkind.fbe_size();

    if ((fbe_current_size + rellockmode.fbe_size()) <= fbe_struct_size)
        {
            rellockmode.get(fbe_value.rellockmode);
        }
    else
        fbe_value.rellockmode = (int32_t)0ll;
    fbe_current_size += rellockmode.fbe_size();

    if ((fbe_current_size + tablesample.fbe_size()) <= fbe_struct_size)
        {
            tablesample.get(&fbe_value.tablesample);
        }
    else
        fbe_value.tablesample = nullptr;
    fbe_current_size += tablesample.fbe_size();

    if ((fbe_current_size + subquery.fbe_size()) <= fbe_struct_size)
        {
            subquery.get(&fbe_value.subquery);
        }
    else
        fbe_value.subquery = nullptr;
    fbe_current_size += subquery.fbe_size();

    if ((fbe_current_size + security_barrier.fbe_size()) <= fbe_struct_size)
        {
            security_barrier.get(fbe_value.security_barrier);
        }
    else
        fbe_value.security_barrier = false;
    fbe_current_size += security_barrier.fbe_size();

    if ((fbe_current_size + jointype.fbe_size()) <= fbe_struct_size)
        {
            jointype.get(fbe_value.jointype);
        }
    else
        fbe_value.jointype = ::pg_query::JoinType();
    fbe_current_size += jointype.fbe_size();

    if ((fbe_current_size + joinmergedcols.fbe_size()) <= fbe_struct_size)
        {
            joinmergedcols.get(fbe_value.joinmergedcols);
        }
    else
        fbe_value.joinmergedcols = (int32_t)0ll;
    fbe_current_size += joinmergedcols.fbe_size();

    if ((fbe_current_size + joinaliasvars.fbe_size()) <= fbe_struct_size)
        {
            joinaliasvars.get(fbe_value.joinaliasvars);
        }
    else
        fbe_value.joinaliasvars.clear();
    fbe_current_size += joinaliasvars.fbe_size();

    if ((fbe_current_size + joinleftcols.fbe_size()) <= fbe_struct_size)
        {
            joinleftcols.get(fbe_value.joinleftcols);
        }
    else
        fbe_value.joinleftcols.clear();
    fbe_current_size += joinleftcols.fbe_size();

    if ((fbe_current_size + joinrightcols.fbe_size()) <= fbe_struct_size)
        {
            joinrightcols.get(fbe_value.joinrightcols);
        }
    else
        fbe_value.joinrightcols.clear();
    fbe_current_size += joinrightcols.fbe_size();

    if ((fbe_current_size + functions.fbe_size()) <= fbe_struct_size)
        {
            functions.get(fbe_value.functions);
        }
    else
        fbe_value.functions.clear();
    fbe_current_size += functions.fbe_size();

    if ((fbe_current_size + funcordinality.fbe_size()) <= fbe_struct_size)
        {
            funcordinality.get(fbe_value.funcordinality);
        }
    else
        fbe_value.funcordinality = false;
    fbe_current_size += funcordinality.fbe_size();

    if ((fbe_current_size + tablefunc.fbe_size()) <= fbe_struct_size)
        {
            tablefunc.get(&fbe_value.tablefunc);
        }
    else
        fbe_value.tablefunc = nullptr;
    fbe_current_size += tablefunc.fbe_size();

    if ((fbe_current_size + values_lists.fbe_size()) <= fbe_struct_size)
        {
            values_lists.get(fbe_value.values_lists);
        }
    else
        fbe_value.values_lists.clear();
    fbe_current_size += values_lists.fbe_size();

    if ((fbe_current_size + ctename.fbe_size()) <= fbe_struct_size)
        {
            ctename.get(fbe_value.ctename);
        }
    else
        fbe_value.ctename = "";
    fbe_current_size += ctename.fbe_size();

    if ((fbe_current_size + ctelevelsup.fbe_size()) <= fbe_struct_size)
        {
            ctelevelsup.get(fbe_value.ctelevelsup);
        }
    else
        fbe_value.ctelevelsup = (uint32_t)0ull;
    fbe_current_size += ctelevelsup.fbe_size();

    if ((fbe_current_size + self_reference.fbe_size()) <= fbe_struct_size)
        {
            self_reference.get(fbe_value.self_reference);
        }
    else
        fbe_value.self_reference = false;
    fbe_current_size += self_reference.fbe_size();

    if ((fbe_current_size + coltypes.fbe_size()) <= fbe_struct_size)
        {
            coltypes.get(fbe_value.coltypes);
        }
    else
        fbe_value.coltypes.clear();
    fbe_current_size += coltypes.fbe_size();

    if ((fbe_current_size + coltypmods.fbe_size()) <= fbe_struct_size)
        {
            coltypmods.get(fbe_value.coltypmods);
        }
    else
        fbe_value.coltypmods.clear();
    fbe_current_size += coltypmods.fbe_size();

    if ((fbe_current_size + colcollations.fbe_size()) <= fbe_struct_size)
        {
            colcollations.get(fbe_value.colcollations);
        }
    else
        fbe_value.colcollations.clear();
    fbe_current_size += colcollations.fbe_size();

    if ((fbe_current_size + enrname.fbe_size()) <= fbe_struct_size)
        {
            enrname.get(fbe_value.enrname);
        }
    else
        fbe_value.enrname = "";
    fbe_current_size += enrname.fbe_size();

    if ((fbe_current_size + enrtuples.fbe_size()) <= fbe_struct_size)
        {
            enrtuples.get(fbe_value.enrtuples);
        }
    else
        fbe_value.enrtuples = 0.0;
    fbe_current_size += enrtuples.fbe_size();

    if ((fbe_current_size + alias.fbe_size()) <= fbe_struct_size)
        {
            alias.get(&fbe_value.alias);
        }
    else
        fbe_value.alias = nullptr;
    fbe_current_size += alias.fbe_size();

    if ((fbe_current_size + eref.fbe_size()) <= fbe_struct_size)
        {
            eref.get(&fbe_value.eref);
        }
    else
        fbe_value.eref = nullptr;
    fbe_current_size += eref.fbe_size();

    if ((fbe_current_size + lateral.fbe_size()) <= fbe_struct_size)
        {
            lateral.get(fbe_value.lateral);
        }
    else
        fbe_value.lateral = false;
    fbe_current_size += lateral.fbe_size();

    if ((fbe_current_size + inh.fbe_size()) <= fbe_struct_size)
        {
            inh.get(fbe_value.inh);
        }
    else
        fbe_value.inh = false;
    fbe_current_size += inh.fbe_size();

    if ((fbe_current_size + in_from_cl.fbe_size()) <= fbe_struct_size)
        {
            in_from_cl.get(fbe_value.in_from_cl);
        }
    else
        fbe_value.in_from_cl = false;
    fbe_current_size += in_from_cl.fbe_size();

    if ((fbe_current_size + required_perms.fbe_size()) <= fbe_struct_size)
        {
            required_perms.get(fbe_value.required_perms);
        }
    else
        fbe_value.required_perms = (uint32_t)0ull;
    fbe_current_size += required_perms.fbe_size();

    if ((fbe_current_size + check_as_user.fbe_size()) <= fbe_struct_size)
        {
            check_as_user.get(fbe_value.check_as_user);
        }
    else
        fbe_value.check_as_user = (uint32_t)0ull;
    fbe_current_size += check_as_user.fbe_size();

    if ((fbe_current_size + selected_cols.fbe_size()) <= fbe_struct_size)
        {
            selected_cols.get(fbe_value.selected_cols);
        }
    else
        fbe_value.selected_cols.clear();
    fbe_current_size += selected_cols.fbe_size();

    if ((fbe_current_size + inserted_cols.fbe_size()) <= fbe_struct_size)
        {
            inserted_cols.get(fbe_value.inserted_cols);
        }
    else
        fbe_value.inserted_cols.clear();
    fbe_current_size += inserted_cols.fbe_size();

    if ((fbe_current_size + updated_cols.fbe_size()) <= fbe_struct_size)
        {
            updated_cols.get(fbe_value.updated_cols);
        }
    else
        fbe_value.updated_cols.clear();
    fbe_current_size += updated_cols.fbe_size();

    if ((fbe_current_size + extra_updated_cols.fbe_size()) <= fbe_struct_size)
        {
            extra_updated_cols.get(fbe_value.extra_updated_cols);
        }
    else
        fbe_value.extra_updated_cols.clear();
    fbe_current_size += extra_updated_cols.fbe_size();

    if ((fbe_current_size + security_quals.fbe_size()) <= fbe_struct_size)
        {
            security_quals.get(fbe_value.security_quals);
        }
    else
        fbe_value.security_quals.clear();
    fbe_current_size += security_quals.fbe_size();
}

size_t FieldModel_pg_query_RangeTblEntry::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTblEntry::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTblEntry::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RangeTblEntry::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RangeTblEntry& fbe_value = static_cast<const ::pg_query::RangeTblEntry&>(base_fbe_value);
    rtekind.set(fbe_value.rtekind);
    relid.set(fbe_value.relid);
    relkind.set(fbe_value.relkind);
    rellockmode.set(fbe_value.rellockmode);
    tablesample.set(fbe_value.tablesample);
    subquery.set(fbe_value.subquery);
    security_barrier.set(fbe_value.security_barrier);
    jointype.set(fbe_value.jointype);
    joinmergedcols.set(fbe_value.joinmergedcols);
    joinaliasvars.set(fbe_value.joinaliasvars);
    joinleftcols.set(fbe_value.joinleftcols);
    joinrightcols.set(fbe_value.joinrightcols);
    functions.set(fbe_value.functions);
    funcordinality.set(fbe_value.funcordinality);
    tablefunc.set(fbe_value.tablefunc);
    values_lists.set(fbe_value.values_lists);
    ctename.set(fbe_value.ctename);
    ctelevelsup.set(fbe_value.ctelevelsup);
    self_reference.set(fbe_value.self_reference);
    coltypes.set(fbe_value.coltypes);
    coltypmods.set(fbe_value.coltypmods);
    colcollations.set(fbe_value.colcollations);
    enrname.set(fbe_value.enrname);
    enrtuples.set(fbe_value.enrtuples);
    alias.set(fbe_value.alias);
    eref.set(fbe_value.eref);
    lateral.set(fbe_value.lateral);
    inh.set(fbe_value.inh);
    in_from_cl.set(fbe_value.in_from_cl);
    required_perms.set(fbe_value.required_perms);
    check_as_user.set(fbe_value.check_as_user);
    selected_cols.set(fbe_value.selected_cols);
    inserted_cols.set(fbe_value.inserted_cols);
    updated_cols.set(fbe_value.updated_cols);
    extra_updated_cols.set(fbe_value.extra_updated_cols);
    security_quals.set(fbe_value.security_quals);
}

namespace pg_query {

bool RangeTblEntryModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RangeTblEntryModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RangeTblEntryModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RangeTblEntryModel::serialize(const ::pg_query::RangeTblEntry& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RangeTblEntryModel::deserialize(::pg_query::RangeTblEntry& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RangeTblFunction::FieldModelPtr_pg_query_RangeTblFunction(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RangeTblFunction::~FieldModelPtr_pg_query_RangeTblFunction()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RangeTblFunction::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTblFunction::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RangeTblFunction::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RangeTblFunction::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTblFunction::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTblFunction::get(::pg_query::RangeTblFunction** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RangeTblFunction(_buffer, 0);

    ::pg_query::RangeTblFunction *tempModel = new ::pg_query::RangeTblFunction();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RangeTblFunction::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RangeTblFunction::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RangeTblFunction::set(const ::pg_query::RangeTblFunction* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RangeTblFunction(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RangeTblFunction::FieldModel_pg_query_RangeTblFunction(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , funcexpr(buffer, 4 + 4)
    , funccolcount(buffer, funcexpr.fbe_offset() + funcexpr.fbe_size())
    , funccolnames(buffer, funccolcount.fbe_offset() + funccolcount.fbe_size())
    , funccoltypes(buffer, funccolnames.fbe_offset() + funccolnames.fbe_size())
    , funccoltypmods(buffer, funccoltypes.fbe_offset() + funccoltypes.fbe_size())
    , funccolcollations(buffer, funccoltypmods.fbe_offset() + funccoltypmods.fbe_size())
    , funcparams(buffer, funccolcollations.fbe_offset() + funccolcollations.fbe_size())
{}

size_t FieldModel_pg_query_RangeTblFunction::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + funcexpr.fbe_size()
        + funccolcount.fbe_size()
        + funccolnames.fbe_size()
        + funccoltypes.fbe_size()
        + funccoltypmods.fbe_size()
        + funccolcollations.fbe_size()
        + funcparams.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RangeTblFunction::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + funcexpr.fbe_extra()
        + funccolcount.fbe_extra()
        + funccolnames.fbe_extra()
        + funccoltypes.fbe_extra()
        + funccoltypmods.fbe_extra()
        + funccolcollations.fbe_extra()
        + funcparams.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RangeTblFunction::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RangeTblFunction::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + funcexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcexpr.verify())
        return false;
    fbe_current_size += funcexpr.fbe_size();

    if ((fbe_current_size + funccolcount.fbe_size()) > fbe_struct_size)
        return true;
    if (!funccolcount.verify())
        return false;
    fbe_current_size += funccolcount.fbe_size();

    if ((fbe_current_size + funccolnames.fbe_size()) > fbe_struct_size)
        return true;
    if (!funccolnames.verify())
        return false;
    fbe_current_size += funccolnames.fbe_size();

    if ((fbe_current_size + funccoltypes.fbe_size()) > fbe_struct_size)
        return true;
    if (!funccoltypes.verify())
        return false;
    fbe_current_size += funccoltypes.fbe_size();

    if ((fbe_current_size + funccoltypmods.fbe_size()) > fbe_struct_size)
        return true;
    if (!funccoltypmods.verify())
        return false;
    fbe_current_size += funccoltypmods.fbe_size();

    if ((fbe_current_size + funccolcollations.fbe_size()) > fbe_struct_size)
        return true;
    if (!funccolcollations.verify())
        return false;
    fbe_current_size += funccolcollations.fbe_size();

    if ((fbe_current_size + funcparams.fbe_size()) > fbe_struct_size)
        return true;
    if (!funcparams.verify())
        return false;
    fbe_current_size += funcparams.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RangeTblFunction::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTblFunction::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTblFunction::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RangeTblFunction::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RangeTblFunction& fbe_value = static_cast<::pg_query::RangeTblFunction&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + funcexpr.fbe_size()) <= fbe_struct_size)
        {
            funcexpr.get(fbe_value.funcexpr);
        }
    else
        fbe_value.funcexpr = ::pg_query::Node();
    fbe_current_size += funcexpr.fbe_size();

    if ((fbe_current_size + funccolcount.fbe_size()) <= fbe_struct_size)
        {
            funccolcount.get(fbe_value.funccolcount);
        }
    else
        fbe_value.funccolcount = (int32_t)0ll;
    fbe_current_size += funccolcount.fbe_size();

    if ((fbe_current_size + funccolnames.fbe_size()) <= fbe_struct_size)
        {
            funccolnames.get(fbe_value.funccolnames);
        }
    else
        fbe_value.funccolnames.clear();
    fbe_current_size += funccolnames.fbe_size();

    if ((fbe_current_size + funccoltypes.fbe_size()) <= fbe_struct_size)
        {
            funccoltypes.get(fbe_value.funccoltypes);
        }
    else
        fbe_value.funccoltypes.clear();
    fbe_current_size += funccoltypes.fbe_size();

    if ((fbe_current_size + funccoltypmods.fbe_size()) <= fbe_struct_size)
        {
            funccoltypmods.get(fbe_value.funccoltypmods);
        }
    else
        fbe_value.funccoltypmods.clear();
    fbe_current_size += funccoltypmods.fbe_size();

    if ((fbe_current_size + funccolcollations.fbe_size()) <= fbe_struct_size)
        {
            funccolcollations.get(fbe_value.funccolcollations);
        }
    else
        fbe_value.funccolcollations.clear();
    fbe_current_size += funccolcollations.fbe_size();

    if ((fbe_current_size + funcparams.fbe_size()) <= fbe_struct_size)
        {
            funcparams.get(fbe_value.funcparams);
        }
    else
        fbe_value.funcparams.clear();
    fbe_current_size += funcparams.fbe_size();
}

size_t FieldModel_pg_query_RangeTblFunction::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RangeTblFunction::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RangeTblFunction::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RangeTblFunction::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RangeTblFunction& fbe_value = static_cast<const ::pg_query::RangeTblFunction&>(base_fbe_value);
    funcexpr.set(fbe_value.funcexpr);
    funccolcount.set(fbe_value.funccolcount);
    funccolnames.set(fbe_value.funccolnames);
    funccoltypes.set(fbe_value.funccoltypes);
    funccoltypmods.set(fbe_value.funccoltypmods);
    funccolcollations.set(fbe_value.funccolcollations);
    funcparams.set(fbe_value.funcparams);
}

namespace pg_query {

bool RangeTblFunctionModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RangeTblFunctionModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RangeTblFunctionModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RangeTblFunctionModel::serialize(const ::pg_query::RangeTblFunction& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RangeTblFunctionModel::deserialize(::pg_query::RangeTblFunction& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_TableSampleClause::FieldModelPtr_pg_query_TableSampleClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_TableSampleClause::~FieldModelPtr_pg_query_TableSampleClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_TableSampleClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_TableSampleClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_TableSampleClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_TableSampleClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TableSampleClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TableSampleClause::get(::pg_query::TableSampleClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_TableSampleClause(_buffer, 0);

    ::pg_query::TableSampleClause *tempModel = new ::pg_query::TableSampleClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_TableSampleClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TableSampleClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TableSampleClause::set(const ::pg_query::TableSampleClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_TableSampleClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_TableSampleClause::FieldModel_pg_query_TableSampleClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , tsmhandler(buffer, 4 + 4)
    , args(buffer, tsmhandler.fbe_offset() + tsmhandler.fbe_size())
    , repeatable(buffer, args.fbe_offset() + args.fbe_size())
{}

size_t FieldModel_pg_query_TableSampleClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + tsmhandler.fbe_size()
        + args.fbe_size()
        + repeatable.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_TableSampleClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + tsmhandler.fbe_extra()
        + args.fbe_extra()
        + repeatable.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_TableSampleClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_TableSampleClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tsmhandler.fbe_size()) > fbe_struct_size)
        return true;
    if (!tsmhandler.verify())
        return false;
    fbe_current_size += tsmhandler.fbe_size();

    if ((fbe_current_size + args.fbe_size()) > fbe_struct_size)
        return true;
    if (!args.verify())
        return false;
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + repeatable.fbe_size()) > fbe_struct_size)
        return true;
    if (!repeatable.verify())
        return false;
    fbe_current_size += repeatable.fbe_size();

    return true;
}

size_t FieldModel_pg_query_TableSampleClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TableSampleClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TableSampleClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_TableSampleClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::TableSampleClause& fbe_value = static_cast<::pg_query::TableSampleClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tsmhandler.fbe_size()) <= fbe_struct_size)
        {
            tsmhandler.get(fbe_value.tsmhandler);
        }
    else
        fbe_value.tsmhandler = (uint32_t)0ull;
    fbe_current_size += tsmhandler.fbe_size();

    if ((fbe_current_size + args.fbe_size()) <= fbe_struct_size)
        {
            args.get(fbe_value.args);
        }
    else
        fbe_value.args.clear();
    fbe_current_size += args.fbe_size();

    if ((fbe_current_size + repeatable.fbe_size()) <= fbe_struct_size)
        {
            repeatable.get(fbe_value.repeatable);
        }
    else
        fbe_value.repeatable = ::pg_query::Node();
    fbe_current_size += repeatable.fbe_size();
}

size_t FieldModel_pg_query_TableSampleClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TableSampleClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TableSampleClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_TableSampleClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::TableSampleClause& fbe_value = static_cast<const ::pg_query::TableSampleClause&>(base_fbe_value);
    tsmhandler.set(fbe_value.tsmhandler);
    args.set(fbe_value.args);
    repeatable.set(fbe_value.repeatable);
}

namespace pg_query {

bool TableSampleClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TableSampleClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TableSampleClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TableSampleClauseModel::serialize(const ::pg_query::TableSampleClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TableSampleClauseModel::deserialize(::pg_query::TableSampleClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_WithCheckOption::FieldModelPtr_pg_query_WithCheckOption(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_WithCheckOption::~FieldModelPtr_pg_query_WithCheckOption()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_WithCheckOption::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_WithCheckOption::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_WithCheckOption::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_WithCheckOption::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WithCheckOption::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WithCheckOption::get(::pg_query::WithCheckOption** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_WithCheckOption(_buffer, 0);

    ::pg_query::WithCheckOption *tempModel = new ::pg_query::WithCheckOption();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_WithCheckOption::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WithCheckOption::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WithCheckOption::set(const ::pg_query::WithCheckOption* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_WithCheckOption(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_WithCheckOption::FieldModel_pg_query_WithCheckOption(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , relname(buffer, kind.fbe_offset() + kind.fbe_size())
    , polname(buffer, relname.fbe_offset() + relname.fbe_size())
    , qual(buffer, polname.fbe_offset() + polname.fbe_size())
    , cascaded(buffer, qual.fbe_offset() + qual.fbe_size())
{}

size_t FieldModel_pg_query_WithCheckOption::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + relname.fbe_size()
        + polname.fbe_size()
        + qual.fbe_size()
        + cascaded.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_WithCheckOption::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + relname.fbe_extra()
        + polname.fbe_extra()
        + qual.fbe_extra()
        + cascaded.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_WithCheckOption::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_WithCheckOption::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + relname.fbe_size()) > fbe_struct_size)
        return true;
    if (!relname.verify())
        return false;
    fbe_current_size += relname.fbe_size();

    if ((fbe_current_size + polname.fbe_size()) > fbe_struct_size)
        return true;
    if (!polname.verify())
        return false;
    fbe_current_size += polname.fbe_size();

    if ((fbe_current_size + qual.fbe_size()) > fbe_struct_size)
        return true;
    if (!qual.verify())
        return false;
    fbe_current_size += qual.fbe_size();

    if ((fbe_current_size + cascaded.fbe_size()) > fbe_struct_size)
        return true;
    if (!cascaded.verify())
        return false;
    fbe_current_size += cascaded.fbe_size();

    return true;
}

size_t FieldModel_pg_query_WithCheckOption::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WithCheckOption::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WithCheckOption::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_WithCheckOption::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::WithCheckOption& fbe_value = static_cast<::pg_query::WithCheckOption&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::WCOKind();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + relname.fbe_size()) <= fbe_struct_size)
        {
            relname.get(fbe_value.relname);
        }
    else
        fbe_value.relname = "";
    fbe_current_size += relname.fbe_size();

    if ((fbe_current_size + polname.fbe_size()) <= fbe_struct_size)
        {
            polname.get(fbe_value.polname);
        }
    else
        fbe_value.polname = "";
    fbe_current_size += polname.fbe_size();

    if ((fbe_current_size + qual.fbe_size()) <= fbe_struct_size)
        {
            qual.get(fbe_value.qual);
        }
    else
        fbe_value.qual = ::pg_query::Node();
    fbe_current_size += qual.fbe_size();

    if ((fbe_current_size + cascaded.fbe_size()) <= fbe_struct_size)
        {
            cascaded.get(fbe_value.cascaded);
        }
    else
        fbe_value.cascaded = false;
    fbe_current_size += cascaded.fbe_size();
}

size_t FieldModel_pg_query_WithCheckOption::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WithCheckOption::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WithCheckOption::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_WithCheckOption::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::WithCheckOption& fbe_value = static_cast<const ::pg_query::WithCheckOption&>(base_fbe_value);
    kind.set(fbe_value.kind);
    relname.set(fbe_value.relname);
    polname.set(fbe_value.polname);
    qual.set(fbe_value.qual);
    cascaded.set(fbe_value.cascaded);
}

namespace pg_query {

bool WithCheckOptionModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t WithCheckOptionModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t WithCheckOptionModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t WithCheckOptionModel::serialize(const ::pg_query::WithCheckOption& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t WithCheckOptionModel::deserialize(::pg_query::WithCheckOption& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_SortGroupClause::FieldModelPtr_pg_query_SortGroupClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_SortGroupClause::~FieldModelPtr_pg_query_SortGroupClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_SortGroupClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_SortGroupClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_SortGroupClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_SortGroupClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SortGroupClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SortGroupClause::get(::pg_query::SortGroupClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_SortGroupClause(_buffer, 0);

    ::pg_query::SortGroupClause *tempModel = new ::pg_query::SortGroupClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_SortGroupClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_SortGroupClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_SortGroupClause::set(const ::pg_query::SortGroupClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_SortGroupClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_SortGroupClause::FieldModel_pg_query_SortGroupClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , tle_sort_group_ref(buffer, 4 + 4)
    , eqop(buffer, tle_sort_group_ref.fbe_offset() + tle_sort_group_ref.fbe_size())
    , sortop(buffer, eqop.fbe_offset() + eqop.fbe_size())
    , nulls_first(buffer, sortop.fbe_offset() + sortop.fbe_size())
    , hashable(buffer, nulls_first.fbe_offset() + nulls_first.fbe_size())
{}

size_t FieldModel_pg_query_SortGroupClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + tle_sort_group_ref.fbe_size()
        + eqop.fbe_size()
        + sortop.fbe_size()
        + nulls_first.fbe_size()
        + hashable.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_SortGroupClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + tle_sort_group_ref.fbe_extra()
        + eqop.fbe_extra()
        + sortop.fbe_extra()
        + nulls_first.fbe_extra()
        + hashable.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_SortGroupClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_SortGroupClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tle_sort_group_ref.fbe_size()) > fbe_struct_size)
        return true;
    if (!tle_sort_group_ref.verify())
        return false;
    fbe_current_size += tle_sort_group_ref.fbe_size();

    if ((fbe_current_size + eqop.fbe_size()) > fbe_struct_size)
        return true;
    if (!eqop.verify())
        return false;
    fbe_current_size += eqop.fbe_size();

    if ((fbe_current_size + sortop.fbe_size()) > fbe_struct_size)
        return true;
    if (!sortop.verify())
        return false;
    fbe_current_size += sortop.fbe_size();

    if ((fbe_current_size + nulls_first.fbe_size()) > fbe_struct_size)
        return true;
    if (!nulls_first.verify())
        return false;
    fbe_current_size += nulls_first.fbe_size();

    if ((fbe_current_size + hashable.fbe_size()) > fbe_struct_size)
        return true;
    if (!hashable.verify())
        return false;
    fbe_current_size += hashable.fbe_size();

    return true;
}

size_t FieldModel_pg_query_SortGroupClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SortGroupClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SortGroupClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_SortGroupClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::SortGroupClause& fbe_value = static_cast<::pg_query::SortGroupClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + tle_sort_group_ref.fbe_size()) <= fbe_struct_size)
        {
            tle_sort_group_ref.get(fbe_value.tle_sort_group_ref);
        }
    else
        fbe_value.tle_sort_group_ref = (uint32_t)0ull;
    fbe_current_size += tle_sort_group_ref.fbe_size();

    if ((fbe_current_size + eqop.fbe_size()) <= fbe_struct_size)
        {
            eqop.get(fbe_value.eqop);
        }
    else
        fbe_value.eqop = (uint32_t)0ull;
    fbe_current_size += eqop.fbe_size();

    if ((fbe_current_size + sortop.fbe_size()) <= fbe_struct_size)
        {
            sortop.get(fbe_value.sortop);
        }
    else
        fbe_value.sortop = (uint32_t)0ull;
    fbe_current_size += sortop.fbe_size();

    if ((fbe_current_size + nulls_first.fbe_size()) <= fbe_struct_size)
        {
            nulls_first.get(fbe_value.nulls_first);
        }
    else
        fbe_value.nulls_first = false;
    fbe_current_size += nulls_first.fbe_size();

    if ((fbe_current_size + hashable.fbe_size()) <= fbe_struct_size)
        {
            hashable.get(fbe_value.hashable);
        }
    else
        fbe_value.hashable = false;
    fbe_current_size += hashable.fbe_size();
}

size_t FieldModel_pg_query_SortGroupClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_SortGroupClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_SortGroupClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_SortGroupClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::SortGroupClause& fbe_value = static_cast<const ::pg_query::SortGroupClause&>(base_fbe_value);
    tle_sort_group_ref.set(fbe_value.tle_sort_group_ref);
    eqop.set(fbe_value.eqop);
    sortop.set(fbe_value.sortop);
    nulls_first.set(fbe_value.nulls_first);
    hashable.set(fbe_value.hashable);
}

namespace pg_query {

bool SortGroupClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SortGroupClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SortGroupClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SortGroupClauseModel::serialize(const ::pg_query::SortGroupClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SortGroupClauseModel::deserialize(::pg_query::SortGroupClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_GroupingSet::FieldModelPtr_pg_query_GroupingSet(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_GroupingSet::~FieldModelPtr_pg_query_GroupingSet()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_GroupingSet::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_GroupingSet::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_GroupingSet::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_GroupingSet::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_GroupingSet::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_GroupingSet::get(::pg_query::GroupingSet** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_GroupingSet(_buffer, 0);

    ::pg_query::GroupingSet *tempModel = new ::pg_query::GroupingSet();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_GroupingSet::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_GroupingSet::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_GroupingSet::set(const ::pg_query::GroupingSet* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_GroupingSet(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_GroupingSet::FieldModel_pg_query_GroupingSet(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , content(buffer, kind.fbe_offset() + kind.fbe_size())
    , location(buffer, content.fbe_offset() + content.fbe_size())
{}

size_t FieldModel_pg_query_GroupingSet::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + content.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_GroupingSet::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + content.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_GroupingSet::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_GroupingSet::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + content.fbe_size()) > fbe_struct_size)
        return true;
    if (!content.verify())
        return false;
    fbe_current_size += content.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_GroupingSet::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_GroupingSet::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_GroupingSet::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_GroupingSet::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::GroupingSet& fbe_value = static_cast<::pg_query::GroupingSet&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::GroupingSetKind();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + content.fbe_size()) <= fbe_struct_size)
        {
            content.get(fbe_value.content);
        }
    else
        fbe_value.content.clear();
    fbe_current_size += content.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_GroupingSet::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_GroupingSet::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_GroupingSet::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_GroupingSet::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::GroupingSet& fbe_value = static_cast<const ::pg_query::GroupingSet&>(base_fbe_value);
    kind.set(fbe_value.kind);
    content.set(fbe_value.content);
    location.set(fbe_value.location);
}

namespace pg_query {

bool GroupingSetModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t GroupingSetModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t GroupingSetModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t GroupingSetModel::serialize(const ::pg_query::GroupingSet& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t GroupingSetModel::deserialize(::pg_query::GroupingSet& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_WindowClause::FieldModelPtr_pg_query_WindowClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_WindowClause::~FieldModelPtr_pg_query_WindowClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_WindowClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_WindowClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_WindowClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_WindowClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WindowClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WindowClause::get(::pg_query::WindowClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_WindowClause(_buffer, 0);

    ::pg_query::WindowClause *tempModel = new ::pg_query::WindowClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_WindowClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WindowClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WindowClause::set(const ::pg_query::WindowClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_WindowClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_WindowClause::FieldModel_pg_query_WindowClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , refname(buffer, name.fbe_offset() + name.fbe_size())
    , partition_clause(buffer, refname.fbe_offset() + refname.fbe_size())
    , order_clause(buffer, partition_clause.fbe_offset() + partition_clause.fbe_size())
    , frame_options(buffer, order_clause.fbe_offset() + order_clause.fbe_size())
    , start_offset(buffer, frame_options.fbe_offset() + frame_options.fbe_size())
    , end_offset(buffer, start_offset.fbe_offset() + start_offset.fbe_size())
    , start_in_range_func(buffer, end_offset.fbe_offset() + end_offset.fbe_size())
    , end_in_range_func(buffer, start_in_range_func.fbe_offset() + start_in_range_func.fbe_size())
    , in_range_coll(buffer, end_in_range_func.fbe_offset() + end_in_range_func.fbe_size())
    , in_range_asc(buffer, in_range_coll.fbe_offset() + in_range_coll.fbe_size())
    , in_range_nulls_first(buffer, in_range_asc.fbe_offset() + in_range_asc.fbe_size())
    , winref(buffer, in_range_nulls_first.fbe_offset() + in_range_nulls_first.fbe_size())
    , copied_order(buffer, winref.fbe_offset() + winref.fbe_size())
{}

size_t FieldModel_pg_query_WindowClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + refname.fbe_size()
        + partition_clause.fbe_size()
        + order_clause.fbe_size()
        + frame_options.fbe_size()
        + start_offset.fbe_size()
        + end_offset.fbe_size()
        + start_in_range_func.fbe_size()
        + end_in_range_func.fbe_size()
        + in_range_coll.fbe_size()
        + in_range_asc.fbe_size()
        + in_range_nulls_first.fbe_size()
        + winref.fbe_size()
        + copied_order.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_WindowClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + refname.fbe_extra()
        + partition_clause.fbe_extra()
        + order_clause.fbe_extra()
        + frame_options.fbe_extra()
        + start_offset.fbe_extra()
        + end_offset.fbe_extra()
        + start_in_range_func.fbe_extra()
        + end_in_range_func.fbe_extra()
        + in_range_coll.fbe_extra()
        + in_range_asc.fbe_extra()
        + in_range_nulls_first.fbe_extra()
        + winref.fbe_extra()
        + copied_order.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_WindowClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_WindowClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + refname.fbe_size()) > fbe_struct_size)
        return true;
    if (!refname.verify())
        return false;
    fbe_current_size += refname.fbe_size();

    if ((fbe_current_size + partition_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!partition_clause.verify())
        return false;
    fbe_current_size += partition_clause.fbe_size();

    if ((fbe_current_size + order_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!order_clause.verify())
        return false;
    fbe_current_size += order_clause.fbe_size();

    if ((fbe_current_size + frame_options.fbe_size()) > fbe_struct_size)
        return true;
    if (!frame_options.verify())
        return false;
    fbe_current_size += frame_options.fbe_size();

    if ((fbe_current_size + start_offset.fbe_size()) > fbe_struct_size)
        return true;
    if (!start_offset.verify())
        return false;
    fbe_current_size += start_offset.fbe_size();

    if ((fbe_current_size + end_offset.fbe_size()) > fbe_struct_size)
        return true;
    if (!end_offset.verify())
        return false;
    fbe_current_size += end_offset.fbe_size();

    if ((fbe_current_size + start_in_range_func.fbe_size()) > fbe_struct_size)
        return true;
    if (!start_in_range_func.verify())
        return false;
    fbe_current_size += start_in_range_func.fbe_size();

    if ((fbe_current_size + end_in_range_func.fbe_size()) > fbe_struct_size)
        return true;
    if (!end_in_range_func.verify())
        return false;
    fbe_current_size += end_in_range_func.fbe_size();

    if ((fbe_current_size + in_range_coll.fbe_size()) > fbe_struct_size)
        return true;
    if (!in_range_coll.verify())
        return false;
    fbe_current_size += in_range_coll.fbe_size();

    if ((fbe_current_size + in_range_asc.fbe_size()) > fbe_struct_size)
        return true;
    if (!in_range_asc.verify())
        return false;
    fbe_current_size += in_range_asc.fbe_size();

    if ((fbe_current_size + in_range_nulls_first.fbe_size()) > fbe_struct_size)
        return true;
    if (!in_range_nulls_first.verify())
        return false;
    fbe_current_size += in_range_nulls_first.fbe_size();

    if ((fbe_current_size + winref.fbe_size()) > fbe_struct_size)
        return true;
    if (!winref.verify())
        return false;
    fbe_current_size += winref.fbe_size();

    if ((fbe_current_size + copied_order.fbe_size()) > fbe_struct_size)
        return true;
    if (!copied_order.verify())
        return false;
    fbe_current_size += copied_order.fbe_size();

    return true;
}

size_t FieldModel_pg_query_WindowClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WindowClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WindowClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_WindowClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::WindowClause& fbe_value = static_cast<::pg_query::WindowClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + refname.fbe_size()) <= fbe_struct_size)
        {
            refname.get(fbe_value.refname);
        }
    else
        fbe_value.refname = "";
    fbe_current_size += refname.fbe_size();

    if ((fbe_current_size + partition_clause.fbe_size()) <= fbe_struct_size)
        {
            partition_clause.get(fbe_value.partition_clause);
        }
    else
        fbe_value.partition_clause.clear();
    fbe_current_size += partition_clause.fbe_size();

    if ((fbe_current_size + order_clause.fbe_size()) <= fbe_struct_size)
        {
            order_clause.get(fbe_value.order_clause);
        }
    else
        fbe_value.order_clause.clear();
    fbe_current_size += order_clause.fbe_size();

    if ((fbe_current_size + frame_options.fbe_size()) <= fbe_struct_size)
        {
            frame_options.get(fbe_value.frame_options);
        }
    else
        fbe_value.frame_options = (int32_t)0ll;
    fbe_current_size += frame_options.fbe_size();

    if ((fbe_current_size + start_offset.fbe_size()) <= fbe_struct_size)
        {
            start_offset.get(fbe_value.start_offset);
        }
    else
        fbe_value.start_offset = ::pg_query::Node();
    fbe_current_size += start_offset.fbe_size();

    if ((fbe_current_size + end_offset.fbe_size()) <= fbe_struct_size)
        {
            end_offset.get(fbe_value.end_offset);
        }
    else
        fbe_value.end_offset = ::pg_query::Node();
    fbe_current_size += end_offset.fbe_size();

    if ((fbe_current_size + start_in_range_func.fbe_size()) <= fbe_struct_size)
        {
            start_in_range_func.get(fbe_value.start_in_range_func);
        }
    else
        fbe_value.start_in_range_func = (uint32_t)0ull;
    fbe_current_size += start_in_range_func.fbe_size();

    if ((fbe_current_size + end_in_range_func.fbe_size()) <= fbe_struct_size)
        {
            end_in_range_func.get(fbe_value.end_in_range_func);
        }
    else
        fbe_value.end_in_range_func = (uint32_t)0ull;
    fbe_current_size += end_in_range_func.fbe_size();

    if ((fbe_current_size + in_range_coll.fbe_size()) <= fbe_struct_size)
        {
            in_range_coll.get(fbe_value.in_range_coll);
        }
    else
        fbe_value.in_range_coll = (uint32_t)0ull;
    fbe_current_size += in_range_coll.fbe_size();

    if ((fbe_current_size + in_range_asc.fbe_size()) <= fbe_struct_size)
        {
            in_range_asc.get(fbe_value.in_range_asc);
        }
    else
        fbe_value.in_range_asc = false;
    fbe_current_size += in_range_asc.fbe_size();

    if ((fbe_current_size + in_range_nulls_first.fbe_size()) <= fbe_struct_size)
        {
            in_range_nulls_first.get(fbe_value.in_range_nulls_first);
        }
    else
        fbe_value.in_range_nulls_first = false;
    fbe_current_size += in_range_nulls_first.fbe_size();

    if ((fbe_current_size + winref.fbe_size()) <= fbe_struct_size)
        {
            winref.get(fbe_value.winref);
        }
    else
        fbe_value.winref = (uint32_t)0ull;
    fbe_current_size += winref.fbe_size();

    if ((fbe_current_size + copied_order.fbe_size()) <= fbe_struct_size)
        {
            copied_order.get(fbe_value.copied_order);
        }
    else
        fbe_value.copied_order = false;
    fbe_current_size += copied_order.fbe_size();
}

size_t FieldModel_pg_query_WindowClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WindowClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WindowClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_WindowClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::WindowClause& fbe_value = static_cast<const ::pg_query::WindowClause&>(base_fbe_value);
    name.set(fbe_value.name);
    refname.set(fbe_value.refname);
    partition_clause.set(fbe_value.partition_clause);
    order_clause.set(fbe_value.order_clause);
    frame_options.set(fbe_value.frame_options);
    start_offset.set(fbe_value.start_offset);
    end_offset.set(fbe_value.end_offset);
    start_in_range_func.set(fbe_value.start_in_range_func);
    end_in_range_func.set(fbe_value.end_in_range_func);
    in_range_coll.set(fbe_value.in_range_coll);
    in_range_asc.set(fbe_value.in_range_asc);
    in_range_nulls_first.set(fbe_value.in_range_nulls_first);
    winref.set(fbe_value.winref);
    copied_order.set(fbe_value.copied_order);
}

namespace pg_query {

bool WindowClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t WindowClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t WindowClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t WindowClauseModel::serialize(const ::pg_query::WindowClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t WindowClauseModel::deserialize(::pg_query::WindowClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ObjectWithArgs::FieldModelPtr_pg_query_ObjectWithArgs(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ObjectWithArgs::~FieldModelPtr_pg_query_ObjectWithArgs()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ObjectWithArgs::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ObjectWithArgs::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ObjectWithArgs::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ObjectWithArgs::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ObjectWithArgs::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ObjectWithArgs::get(::pg_query::ObjectWithArgs** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ObjectWithArgs(_buffer, 0);

    ::pg_query::ObjectWithArgs *tempModel = new ::pg_query::ObjectWithArgs();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ObjectWithArgs::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ObjectWithArgs::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ObjectWithArgs::set(const ::pg_query::ObjectWithArgs* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ObjectWithArgs(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ObjectWithArgs::FieldModel_pg_query_ObjectWithArgs(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , objname(buffer, 4 + 4)
    , objargs(buffer, objname.fbe_offset() + objname.fbe_size())
    , args_unspecified(buffer, objargs.fbe_offset() + objargs.fbe_size())
{}

size_t FieldModel_pg_query_ObjectWithArgs::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + objname.fbe_size()
        + objargs.fbe_size()
        + args_unspecified.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ObjectWithArgs::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + objname.fbe_extra()
        + objargs.fbe_extra()
        + args_unspecified.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ObjectWithArgs::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ObjectWithArgs::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objname.fbe_size()) > fbe_struct_size)
        return true;
    if (!objname.verify())
        return false;
    fbe_current_size += objname.fbe_size();

    if ((fbe_current_size + objargs.fbe_size()) > fbe_struct_size)
        return true;
    if (!objargs.verify())
        return false;
    fbe_current_size += objargs.fbe_size();

    if ((fbe_current_size + args_unspecified.fbe_size()) > fbe_struct_size)
        return true;
    if (!args_unspecified.verify())
        return false;
    fbe_current_size += args_unspecified.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ObjectWithArgs::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ObjectWithArgs::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ObjectWithArgs::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ObjectWithArgs::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ObjectWithArgs& fbe_value = static_cast<::pg_query::ObjectWithArgs&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + objname.fbe_size()) <= fbe_struct_size)
        {
            objname.get(fbe_value.objname);
        }
    else
        fbe_value.objname.clear();
    fbe_current_size += objname.fbe_size();

    if ((fbe_current_size + objargs.fbe_size()) <= fbe_struct_size)
        {
            objargs.get(fbe_value.objargs);
        }
    else
        fbe_value.objargs.clear();
    fbe_current_size += objargs.fbe_size();

    if ((fbe_current_size + args_unspecified.fbe_size()) <= fbe_struct_size)
        {
            args_unspecified.get(fbe_value.args_unspecified);
        }
    else
        fbe_value.args_unspecified = false;
    fbe_current_size += args_unspecified.fbe_size();
}

size_t FieldModel_pg_query_ObjectWithArgs::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ObjectWithArgs::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ObjectWithArgs::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ObjectWithArgs::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ObjectWithArgs& fbe_value = static_cast<const ::pg_query::ObjectWithArgs&>(base_fbe_value);
    objname.set(fbe_value.objname);
    objargs.set(fbe_value.objargs);
    args_unspecified.set(fbe_value.args_unspecified);
}

namespace pg_query {

bool ObjectWithArgsModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ObjectWithArgsModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ObjectWithArgsModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ObjectWithArgsModel::serialize(const ::pg_query::ObjectWithArgs& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ObjectWithArgsModel::deserialize(::pg_query::ObjectWithArgs& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_AccessPriv::FieldModelPtr_pg_query_AccessPriv(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_AccessPriv::~FieldModelPtr_pg_query_AccessPriv()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_AccessPriv::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_AccessPriv::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_AccessPriv::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_AccessPriv::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AccessPriv::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AccessPriv::get(::pg_query::AccessPriv** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_AccessPriv(_buffer, 0);

    ::pg_query::AccessPriv *tempModel = new ::pg_query::AccessPriv();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_AccessPriv::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_AccessPriv::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_AccessPriv::set(const ::pg_query::AccessPriv* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_AccessPriv(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_AccessPriv::FieldModel_pg_query_AccessPriv(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , priv_name(buffer, 4 + 4)
    , cols(buffer, priv_name.fbe_offset() + priv_name.fbe_size())
{}

size_t FieldModel_pg_query_AccessPriv::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + priv_name.fbe_size()
        + cols.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_AccessPriv::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + priv_name.fbe_extra()
        + cols.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_AccessPriv::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_AccessPriv::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + priv_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!priv_name.verify())
        return false;
    fbe_current_size += priv_name.fbe_size();

    if ((fbe_current_size + cols.fbe_size()) > fbe_struct_size)
        return true;
    if (!cols.verify())
        return false;
    fbe_current_size += cols.fbe_size();

    return true;
}

size_t FieldModel_pg_query_AccessPriv::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AccessPriv::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AccessPriv::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_AccessPriv::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::AccessPriv& fbe_value = static_cast<::pg_query::AccessPriv&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + priv_name.fbe_size()) <= fbe_struct_size)
        {
            priv_name.get(fbe_value.priv_name);
        }
    else
        fbe_value.priv_name = "";
    fbe_current_size += priv_name.fbe_size();

    if ((fbe_current_size + cols.fbe_size()) <= fbe_struct_size)
        {
            cols.get(fbe_value.cols);
        }
    else
        fbe_value.cols.clear();
    fbe_current_size += cols.fbe_size();
}

size_t FieldModel_pg_query_AccessPriv::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_AccessPriv::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_AccessPriv::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_AccessPriv::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::AccessPriv& fbe_value = static_cast<const ::pg_query::AccessPriv&>(base_fbe_value);
    priv_name.set(fbe_value.priv_name);
    cols.set(fbe_value.cols);
}

namespace pg_query {

bool AccessPrivModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t AccessPrivModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t AccessPrivModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t AccessPrivModel::serialize(const ::pg_query::AccessPriv& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t AccessPrivModel::deserialize(::pg_query::AccessPriv& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CreateOpClassItem::FieldModelPtr_pg_query_CreateOpClassItem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CreateOpClassItem::~FieldModelPtr_pg_query_CreateOpClassItem()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CreateOpClassItem::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateOpClassItem::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CreateOpClassItem::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CreateOpClassItem::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateOpClassItem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateOpClassItem::get(::pg_query::CreateOpClassItem** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CreateOpClassItem(_buffer, 0);

    ::pg_query::CreateOpClassItem *tempModel = new ::pg_query::CreateOpClassItem();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CreateOpClassItem::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CreateOpClassItem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CreateOpClassItem::set(const ::pg_query::CreateOpClassItem* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CreateOpClassItem(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CreateOpClassItem::FieldModel_pg_query_CreateOpClassItem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , itemtype(buffer, 4 + 4)
    , name(buffer, itemtype.fbe_offset() + itemtype.fbe_size())
    , number(buffer, name.fbe_offset() + name.fbe_size())
    , order_family(buffer, number.fbe_offset() + number.fbe_size())
    , class_args(buffer, order_family.fbe_offset() + order_family.fbe_size())
    , storedtype(buffer, class_args.fbe_offset() + class_args.fbe_size())
{}

size_t FieldModel_pg_query_CreateOpClassItem::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + itemtype.fbe_size()
        + name.fbe_size()
        + number.fbe_size()
        + order_family.fbe_size()
        + class_args.fbe_size()
        + storedtype.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CreateOpClassItem::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + itemtype.fbe_extra()
        + name.fbe_extra()
        + number.fbe_extra()
        + order_family.fbe_extra()
        + class_args.fbe_extra()
        + storedtype.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CreateOpClassItem::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CreateOpClassItem::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + itemtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!itemtype.verify())
        return false;
    fbe_current_size += itemtype.fbe_size();

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + number.fbe_size()) > fbe_struct_size)
        return true;
    if (!number.verify())
        return false;
    fbe_current_size += number.fbe_size();

    if ((fbe_current_size + order_family.fbe_size()) > fbe_struct_size)
        return true;
    if (!order_family.verify())
        return false;
    fbe_current_size += order_family.fbe_size();

    if ((fbe_current_size + class_args.fbe_size()) > fbe_struct_size)
        return true;
    if (!class_args.verify())
        return false;
    fbe_current_size += class_args.fbe_size();

    if ((fbe_current_size + storedtype.fbe_size()) > fbe_struct_size)
        return true;
    if (!storedtype.verify())
        return false;
    fbe_current_size += storedtype.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CreateOpClassItem::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateOpClassItem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateOpClassItem::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CreateOpClassItem::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CreateOpClassItem& fbe_value = static_cast<::pg_query::CreateOpClassItem&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + itemtype.fbe_size()) <= fbe_struct_size)
        {
            itemtype.get(fbe_value.itemtype);
        }
    else
        fbe_value.itemtype = (int32_t)0ll;
    fbe_current_size += itemtype.fbe_size();

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(&fbe_value.name);
        }
    else
        fbe_value.name = nullptr;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + number.fbe_size()) <= fbe_struct_size)
        {
            number.get(fbe_value.number);
        }
    else
        fbe_value.number = (int32_t)0ll;
    fbe_current_size += number.fbe_size();

    if ((fbe_current_size + order_family.fbe_size()) <= fbe_struct_size)
        {
            order_family.get(fbe_value.order_family);
        }
    else
        fbe_value.order_family.clear();
    fbe_current_size += order_family.fbe_size();

    if ((fbe_current_size + class_args.fbe_size()) <= fbe_struct_size)
        {
            class_args.get(fbe_value.class_args);
        }
    else
        fbe_value.class_args.clear();
    fbe_current_size += class_args.fbe_size();

    if ((fbe_current_size + storedtype.fbe_size()) <= fbe_struct_size)
        {
            storedtype.get(&fbe_value.storedtype);
        }
    else
        fbe_value.storedtype = nullptr;
    fbe_current_size += storedtype.fbe_size();
}

size_t FieldModel_pg_query_CreateOpClassItem::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CreateOpClassItem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CreateOpClassItem::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CreateOpClassItem::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CreateOpClassItem& fbe_value = static_cast<const ::pg_query::CreateOpClassItem&>(base_fbe_value);
    itemtype.set(fbe_value.itemtype);
    name.set(fbe_value.name);
    number.set(fbe_value.number);
    order_family.set(fbe_value.order_family);
    class_args.set(fbe_value.class_args);
    storedtype.set(fbe_value.storedtype);
}

namespace pg_query {

bool CreateOpClassItemModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CreateOpClassItemModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CreateOpClassItemModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CreateOpClassItemModel::serialize(const ::pg_query::CreateOpClassItem& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CreateOpClassItemModel::deserialize(::pg_query::CreateOpClassItem& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_TableLikeClause::FieldModelPtr_pg_query_TableLikeClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_TableLikeClause::~FieldModelPtr_pg_query_TableLikeClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_TableLikeClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_TableLikeClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_TableLikeClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_TableLikeClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TableLikeClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TableLikeClause::get(::pg_query::TableLikeClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_TableLikeClause(_buffer, 0);

    ::pg_query::TableLikeClause *tempModel = new ::pg_query::TableLikeClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_TableLikeClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TableLikeClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TableLikeClause::set(const ::pg_query::TableLikeClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_TableLikeClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_TableLikeClause::FieldModel_pg_query_TableLikeClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , options(buffer, relation.fbe_offset() + relation.fbe_size())
    , relation_oid(buffer, options.fbe_offset() + options.fbe_size())
{}

size_t FieldModel_pg_query_TableLikeClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + options.fbe_size()
        + relation_oid.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_TableLikeClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + options.fbe_extra()
        + relation_oid.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_TableLikeClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_TableLikeClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + options.fbe_size()) > fbe_struct_size)
        return true;
    if (!options.verify())
        return false;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + relation_oid.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation_oid.verify())
        return false;
    fbe_current_size += relation_oid.fbe_size();

    return true;
}

size_t FieldModel_pg_query_TableLikeClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TableLikeClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TableLikeClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_TableLikeClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::TableLikeClause& fbe_value = static_cast<::pg_query::TableLikeClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + options.fbe_size()) <= fbe_struct_size)
        {
            options.get(fbe_value.options);
        }
    else
        fbe_value.options = (uint32_t)0ull;
    fbe_current_size += options.fbe_size();

    if ((fbe_current_size + relation_oid.fbe_size()) <= fbe_struct_size)
        {
            relation_oid.get(fbe_value.relation_oid);
        }
    else
        fbe_value.relation_oid = (uint32_t)0ull;
    fbe_current_size += relation_oid.fbe_size();
}

size_t FieldModel_pg_query_TableLikeClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TableLikeClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TableLikeClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_TableLikeClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::TableLikeClause& fbe_value = static_cast<const ::pg_query::TableLikeClause&>(base_fbe_value);
    relation.set(fbe_value.relation);
    options.set(fbe_value.options);
    relation_oid.set(fbe_value.relation_oid);
}

namespace pg_query {

bool TableLikeClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TableLikeClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TableLikeClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TableLikeClauseModel::serialize(const ::pg_query::TableLikeClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TableLikeClauseModel::deserialize(::pg_query::TableLikeClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_FunctionParameter::FieldModelPtr_pg_query_FunctionParameter(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_FunctionParameter::~FieldModelPtr_pg_query_FunctionParameter()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_FunctionParameter::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_FunctionParameter::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_FunctionParameter::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_FunctionParameter::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FunctionParameter::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FunctionParameter::get(::pg_query::FunctionParameter** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_FunctionParameter(_buffer, 0);

    ::pg_query::FunctionParameter *tempModel = new ::pg_query::FunctionParameter();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_FunctionParameter::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_FunctionParameter::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_FunctionParameter::set(const ::pg_query::FunctionParameter* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_FunctionParameter(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_FunctionParameter::FieldModel_pg_query_FunctionParameter(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , arg_type(buffer, name.fbe_offset() + name.fbe_size())
    , mode(buffer, arg_type.fbe_offset() + arg_type.fbe_size())
    , defexpr(buffer, mode.fbe_offset() + mode.fbe_size())
{}

size_t FieldModel_pg_query_FunctionParameter::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + arg_type.fbe_size()
        + mode.fbe_size()
        + defexpr.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_FunctionParameter::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + arg_type.fbe_extra()
        + mode.fbe_extra()
        + defexpr.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_FunctionParameter::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_FunctionParameter::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + arg_type.fbe_size()) > fbe_struct_size)
        return true;
    if (!arg_type.verify())
        return false;
    fbe_current_size += arg_type.fbe_size();

    if ((fbe_current_size + mode.fbe_size()) > fbe_struct_size)
        return true;
    if (!mode.verify())
        return false;
    fbe_current_size += mode.fbe_size();

    if ((fbe_current_size + defexpr.fbe_size()) > fbe_struct_size)
        return true;
    if (!defexpr.verify())
        return false;
    fbe_current_size += defexpr.fbe_size();

    return true;
}

size_t FieldModel_pg_query_FunctionParameter::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FunctionParameter::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FunctionParameter::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_FunctionParameter::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::FunctionParameter& fbe_value = static_cast<::pg_query::FunctionParameter&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + arg_type.fbe_size()) <= fbe_struct_size)
        {
            arg_type.get(&fbe_value.arg_type);
        }
    else
        fbe_value.arg_type = nullptr;
    fbe_current_size += arg_type.fbe_size();

    if ((fbe_current_size + mode.fbe_size()) <= fbe_struct_size)
        {
            mode.get(fbe_value.mode);
        }
    else
        fbe_value.mode = ::pg_query::FunctionParameterMode();
    fbe_current_size += mode.fbe_size();

    if ((fbe_current_size + defexpr.fbe_size()) <= fbe_struct_size)
        {
            defexpr.get(fbe_value.defexpr);
        }
    else
        fbe_value.defexpr = ::pg_query::Node();
    fbe_current_size += defexpr.fbe_size();
}

size_t FieldModel_pg_query_FunctionParameter::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_FunctionParameter::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_FunctionParameter::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_FunctionParameter::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::FunctionParameter& fbe_value = static_cast<const ::pg_query::FunctionParameter&>(base_fbe_value);
    name.set(fbe_value.name);
    arg_type.set(fbe_value.arg_type);
    mode.set(fbe_value.mode);
    defexpr.set(fbe_value.defexpr);
}

namespace pg_query {

bool FunctionParameterModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t FunctionParameterModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t FunctionParameterModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t FunctionParameterModel::serialize(const ::pg_query::FunctionParameter& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t FunctionParameterModel::deserialize(::pg_query::FunctionParameter& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_LockingClause::FieldModelPtr_pg_query_LockingClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_LockingClause::~FieldModelPtr_pg_query_LockingClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_LockingClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_LockingClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_LockingClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_LockingClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_LockingClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_LockingClause::get(::pg_query::LockingClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_LockingClause(_buffer, 0);

    ::pg_query::LockingClause *tempModel = new ::pg_query::LockingClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_LockingClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_LockingClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_LockingClause::set(const ::pg_query::LockingClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_LockingClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_LockingClause::FieldModel_pg_query_LockingClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , locked_rels(buffer, 4 + 4)
    , strength(buffer, locked_rels.fbe_offset() + locked_rels.fbe_size())
    , wait_policy(buffer, strength.fbe_offset() + strength.fbe_size())
{}

size_t FieldModel_pg_query_LockingClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + locked_rels.fbe_size()
        + strength.fbe_size()
        + wait_policy.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_LockingClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + locked_rels.fbe_extra()
        + strength.fbe_extra()
        + wait_policy.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_LockingClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_LockingClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + locked_rels.fbe_size()) > fbe_struct_size)
        return true;
    if (!locked_rels.verify())
        return false;
    fbe_current_size += locked_rels.fbe_size();

    if ((fbe_current_size + strength.fbe_size()) > fbe_struct_size)
        return true;
    if (!strength.verify())
        return false;
    fbe_current_size += strength.fbe_size();

    if ((fbe_current_size + wait_policy.fbe_size()) > fbe_struct_size)
        return true;
    if (!wait_policy.verify())
        return false;
    fbe_current_size += wait_policy.fbe_size();

    return true;
}

size_t FieldModel_pg_query_LockingClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_LockingClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_LockingClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_LockingClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::LockingClause& fbe_value = static_cast<::pg_query::LockingClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + locked_rels.fbe_size()) <= fbe_struct_size)
        {
            locked_rels.get(fbe_value.locked_rels);
        }
    else
        fbe_value.locked_rels.clear();
    fbe_current_size += locked_rels.fbe_size();

    if ((fbe_current_size + strength.fbe_size()) <= fbe_struct_size)
        {
            strength.get(fbe_value.strength);
        }
    else
        fbe_value.strength = ::pg_query::LockClauseStrength();
    fbe_current_size += strength.fbe_size();

    if ((fbe_current_size + wait_policy.fbe_size()) <= fbe_struct_size)
        {
            wait_policy.get(fbe_value.wait_policy);
        }
    else
        fbe_value.wait_policy = ::pg_query::LockWaitPolicy();
    fbe_current_size += wait_policy.fbe_size();
}

size_t FieldModel_pg_query_LockingClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_LockingClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_LockingClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_LockingClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::LockingClause& fbe_value = static_cast<const ::pg_query::LockingClause&>(base_fbe_value);
    locked_rels.set(fbe_value.locked_rels);
    strength.set(fbe_value.strength);
    wait_policy.set(fbe_value.wait_policy);
}

namespace pg_query {

bool LockingClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t LockingClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t LockingClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t LockingClauseModel::serialize(const ::pg_query::LockingClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t LockingClauseModel::deserialize(::pg_query::LockingClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RowMarkClause::FieldModelPtr_pg_query_RowMarkClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RowMarkClause::~FieldModelPtr_pg_query_RowMarkClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RowMarkClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RowMarkClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RowMarkClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RowMarkClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RowMarkClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RowMarkClause::get(::pg_query::RowMarkClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RowMarkClause(_buffer, 0);

    ::pg_query::RowMarkClause *tempModel = new ::pg_query::RowMarkClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RowMarkClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RowMarkClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RowMarkClause::set(const ::pg_query::RowMarkClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RowMarkClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RowMarkClause::FieldModel_pg_query_RowMarkClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , rti(buffer, 4 + 4)
    , strength(buffer, rti.fbe_offset() + rti.fbe_size())
    , wait_policy(buffer, strength.fbe_offset() + strength.fbe_size())
    , pushed_down(buffer, wait_policy.fbe_offset() + wait_policy.fbe_size())
{}

size_t FieldModel_pg_query_RowMarkClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + rti.fbe_size()
        + strength.fbe_size()
        + wait_policy.fbe_size()
        + pushed_down.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RowMarkClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + rti.fbe_extra()
        + strength.fbe_extra()
        + wait_policy.fbe_extra()
        + pushed_down.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RowMarkClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RowMarkClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rti.fbe_size()) > fbe_struct_size)
        return true;
    if (!rti.verify())
        return false;
    fbe_current_size += rti.fbe_size();

    if ((fbe_current_size + strength.fbe_size()) > fbe_struct_size)
        return true;
    if (!strength.verify())
        return false;
    fbe_current_size += strength.fbe_size();

    if ((fbe_current_size + wait_policy.fbe_size()) > fbe_struct_size)
        return true;
    if (!wait_policy.verify())
        return false;
    fbe_current_size += wait_policy.fbe_size();

    if ((fbe_current_size + pushed_down.fbe_size()) > fbe_struct_size)
        return true;
    if (!pushed_down.verify())
        return false;
    fbe_current_size += pushed_down.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RowMarkClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RowMarkClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RowMarkClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RowMarkClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RowMarkClause& fbe_value = static_cast<::pg_query::RowMarkClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + rti.fbe_size()) <= fbe_struct_size)
        {
            rti.get(fbe_value.rti);
        }
    else
        fbe_value.rti = (uint32_t)0ull;
    fbe_current_size += rti.fbe_size();

    if ((fbe_current_size + strength.fbe_size()) <= fbe_struct_size)
        {
            strength.get(fbe_value.strength);
        }
    else
        fbe_value.strength = ::pg_query::LockClauseStrength();
    fbe_current_size += strength.fbe_size();

    if ((fbe_current_size + wait_policy.fbe_size()) <= fbe_struct_size)
        {
            wait_policy.get(fbe_value.wait_policy);
        }
    else
        fbe_value.wait_policy = ::pg_query::LockWaitPolicy();
    fbe_current_size += wait_policy.fbe_size();

    if ((fbe_current_size + pushed_down.fbe_size()) <= fbe_struct_size)
        {
            pushed_down.get(fbe_value.pushed_down);
        }
    else
        fbe_value.pushed_down = false;
    fbe_current_size += pushed_down.fbe_size();
}

size_t FieldModel_pg_query_RowMarkClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RowMarkClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RowMarkClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RowMarkClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RowMarkClause& fbe_value = static_cast<const ::pg_query::RowMarkClause&>(base_fbe_value);
    rti.set(fbe_value.rti);
    strength.set(fbe_value.strength);
    wait_policy.set(fbe_value.wait_policy);
    pushed_down.set(fbe_value.pushed_down);
}

namespace pg_query {

bool RowMarkClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RowMarkClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RowMarkClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RowMarkClauseModel::serialize(const ::pg_query::RowMarkClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RowMarkClauseModel::deserialize(::pg_query::RowMarkClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_XmlSerialize::FieldModelPtr_pg_query_XmlSerialize(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_XmlSerialize::~FieldModelPtr_pg_query_XmlSerialize()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_XmlSerialize::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_XmlSerialize::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_XmlSerialize::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_XmlSerialize::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_XmlSerialize::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_XmlSerialize::get(::pg_query::XmlSerialize** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_XmlSerialize(_buffer, 0);

    ::pg_query::XmlSerialize *tempModel = new ::pg_query::XmlSerialize();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_XmlSerialize::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_XmlSerialize::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_XmlSerialize::set(const ::pg_query::XmlSerialize* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_XmlSerialize(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_XmlSerialize::FieldModel_pg_query_XmlSerialize(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , xmloption(buffer, 4 + 4)
    , expr(buffer, xmloption.fbe_offset() + xmloption.fbe_size())
    , type_name(buffer, expr.fbe_offset() + expr.fbe_size())
    , location(buffer, type_name.fbe_offset() + type_name.fbe_size())
{}

size_t FieldModel_pg_query_XmlSerialize::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + xmloption.fbe_size()
        + expr.fbe_size()
        + type_name.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_XmlSerialize::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + xmloption.fbe_extra()
        + expr.fbe_extra()
        + type_name.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_XmlSerialize::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_XmlSerialize::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xmloption.fbe_size()) > fbe_struct_size)
        return true;
    if (!xmloption.verify())
        return false;
    fbe_current_size += xmloption.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) > fbe_struct_size)
        return true;
    if (!expr.verify())
        return false;
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) > fbe_struct_size)
        return true;
    if (!type_name.verify())
        return false;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_XmlSerialize::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_XmlSerialize::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_XmlSerialize::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_XmlSerialize::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::XmlSerialize& fbe_value = static_cast<::pg_query::XmlSerialize&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + xmloption.fbe_size()) <= fbe_struct_size)
        {
            xmloption.get(fbe_value.xmloption);
        }
    else
        fbe_value.xmloption = ::pg_query::XmlOptionType();
    fbe_current_size += xmloption.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) <= fbe_struct_size)
        {
            expr.get(fbe_value.expr);
        }
    else
        fbe_value.expr = ::pg_query::Node();
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + type_name.fbe_size()) <= fbe_struct_size)
        {
            type_name.get(&fbe_value.type_name);
        }
    else
        fbe_value.type_name = nullptr;
    fbe_current_size += type_name.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_XmlSerialize::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_XmlSerialize::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_XmlSerialize::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_XmlSerialize::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::XmlSerialize& fbe_value = static_cast<const ::pg_query::XmlSerialize&>(base_fbe_value);
    xmloption.set(fbe_value.xmloption);
    expr.set(fbe_value.expr);
    type_name.set(fbe_value.type_name);
    location.set(fbe_value.location);
}

namespace pg_query {

bool XmlSerializeModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t XmlSerializeModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t XmlSerializeModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t XmlSerializeModel::serialize(const ::pg_query::XmlSerialize& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t XmlSerializeModel::deserialize(::pg_query::XmlSerialize& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_WithClause::FieldModelPtr_pg_query_WithClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_WithClause::~FieldModelPtr_pg_query_WithClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_WithClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_WithClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_WithClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_WithClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WithClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WithClause::get(::pg_query::WithClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_WithClause(_buffer, 0);

    ::pg_query::WithClause *tempModel = new ::pg_query::WithClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_WithClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_WithClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_WithClause::set(const ::pg_query::WithClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_WithClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_WithClause::FieldModel_pg_query_WithClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , ctes(buffer, 4 + 4)
    , recursive(buffer, ctes.fbe_offset() + ctes.fbe_size())
    , location(buffer, recursive.fbe_offset() + recursive.fbe_size())
{}

size_t FieldModel_pg_query_WithClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + ctes.fbe_size()
        + recursive.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_WithClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + ctes.fbe_extra()
        + recursive.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_WithClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_WithClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + ctes.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctes.verify())
        return false;
    fbe_current_size += ctes.fbe_size();

    if ((fbe_current_size + recursive.fbe_size()) > fbe_struct_size)
        return true;
    if (!recursive.verify())
        return false;
    fbe_current_size += recursive.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_WithClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WithClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WithClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_WithClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::WithClause& fbe_value = static_cast<::pg_query::WithClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + ctes.fbe_size()) <= fbe_struct_size)
        {
            ctes.get(fbe_value.ctes);
        }
    else
        fbe_value.ctes.clear();
    fbe_current_size += ctes.fbe_size();

    if ((fbe_current_size + recursive.fbe_size()) <= fbe_struct_size)
        {
            recursive.get(fbe_value.recursive);
        }
    else
        fbe_value.recursive = false;
    fbe_current_size += recursive.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_WithClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_WithClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_WithClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_WithClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::WithClause& fbe_value = static_cast<const ::pg_query::WithClause&>(base_fbe_value);
    ctes.set(fbe_value.ctes);
    recursive.set(fbe_value.recursive);
    location.set(fbe_value.location);
}

namespace pg_query {

bool WithClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t WithClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t WithClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t WithClauseModel::serialize(const ::pg_query::WithClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t WithClauseModel::deserialize(::pg_query::WithClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_InferClause::FieldModelPtr_pg_query_InferClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_InferClause::~FieldModelPtr_pg_query_InferClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_InferClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_InferClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_InferClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_InferClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_InferClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_InferClause::get(::pg_query::InferClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_InferClause(_buffer, 0);

    ::pg_query::InferClause *tempModel = new ::pg_query::InferClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_InferClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_InferClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_InferClause::set(const ::pg_query::InferClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_InferClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_InferClause::FieldModel_pg_query_InferClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , index_elems(buffer, 4 + 4)
    , where_clause(buffer, index_elems.fbe_offset() + index_elems.fbe_size())
    , conname(buffer, where_clause.fbe_offset() + where_clause.fbe_size())
    , location(buffer, conname.fbe_offset() + conname.fbe_size())
{}

size_t FieldModel_pg_query_InferClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + index_elems.fbe_size()
        + where_clause.fbe_size()
        + conname.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_InferClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + index_elems.fbe_extra()
        + where_clause.fbe_extra()
        + conname.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_InferClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_InferClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + index_elems.fbe_size()) > fbe_struct_size)
        return true;
    if (!index_elems.verify())
        return false;
    fbe_current_size += index_elems.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!where_clause.verify())
        return false;
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + conname.fbe_size()) > fbe_struct_size)
        return true;
    if (!conname.verify())
        return false;
    fbe_current_size += conname.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_InferClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_InferClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_InferClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_InferClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::InferClause& fbe_value = static_cast<::pg_query::InferClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + index_elems.fbe_size()) <= fbe_struct_size)
        {
            index_elems.get(fbe_value.index_elems);
        }
    else
        fbe_value.index_elems.clear();
    fbe_current_size += index_elems.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) <= fbe_struct_size)
        {
            where_clause.get(fbe_value.where_clause);
        }
    else
        fbe_value.where_clause = ::pg_query::Node();
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + conname.fbe_size()) <= fbe_struct_size)
        {
            conname.get(fbe_value.conname);
        }
    else
        fbe_value.conname = "";
    fbe_current_size += conname.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_InferClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_InferClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_InferClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_InferClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::InferClause& fbe_value = static_cast<const ::pg_query::InferClause&>(base_fbe_value);
    index_elems.set(fbe_value.index_elems);
    where_clause.set(fbe_value.where_clause);
    conname.set(fbe_value.conname);
    location.set(fbe_value.location);
}

namespace pg_query {

bool InferClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t InferClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t InferClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t InferClauseModel::serialize(const ::pg_query::InferClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t InferClauseModel::deserialize(::pg_query::InferClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_OnConflictClause::FieldModelPtr_pg_query_OnConflictClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_OnConflictClause::~FieldModelPtr_pg_query_OnConflictClause()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_OnConflictClause::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_OnConflictClause::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_OnConflictClause::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_OnConflictClause::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_OnConflictClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_OnConflictClause::get(::pg_query::OnConflictClause** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_OnConflictClause(_buffer, 0);

    ::pg_query::OnConflictClause *tempModel = new ::pg_query::OnConflictClause();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_OnConflictClause::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_OnConflictClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_OnConflictClause::set(const ::pg_query::OnConflictClause* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_OnConflictClause(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_OnConflictClause::FieldModel_pg_query_OnConflictClause(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , action(buffer, 4 + 4)
    , infer(buffer, action.fbe_offset() + action.fbe_size())
    , target_list(buffer, infer.fbe_offset() + infer.fbe_size())
    , where_clause(buffer, target_list.fbe_offset() + target_list.fbe_size())
    , location(buffer, where_clause.fbe_offset() + where_clause.fbe_size())
{}

size_t FieldModel_pg_query_OnConflictClause::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + action.fbe_size()
        + infer.fbe_size()
        + target_list.fbe_size()
        + where_clause.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_OnConflictClause::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + action.fbe_extra()
        + infer.fbe_extra()
        + target_list.fbe_extra()
        + where_clause.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_OnConflictClause::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_OnConflictClause::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + action.fbe_size()) > fbe_struct_size)
        return true;
    if (!action.verify())
        return false;
    fbe_current_size += action.fbe_size();

    if ((fbe_current_size + infer.fbe_size()) > fbe_struct_size)
        return true;
    if (!infer.verify())
        return false;
    fbe_current_size += infer.fbe_size();

    if ((fbe_current_size + target_list.fbe_size()) > fbe_struct_size)
        return true;
    if (!target_list.verify())
        return false;
    fbe_current_size += target_list.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) > fbe_struct_size)
        return true;
    if (!where_clause.verify())
        return false;
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_OnConflictClause::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_OnConflictClause::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_OnConflictClause::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_OnConflictClause::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::OnConflictClause& fbe_value = static_cast<::pg_query::OnConflictClause&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + action.fbe_size()) <= fbe_struct_size)
        {
            action.get(fbe_value.action);
        }
    else
        fbe_value.action = ::pg_query::OnConflictAction();
    fbe_current_size += action.fbe_size();

    if ((fbe_current_size + infer.fbe_size()) <= fbe_struct_size)
        {
            infer.get(&fbe_value.infer);
        }
    else
        fbe_value.infer = nullptr;
    fbe_current_size += infer.fbe_size();

    if ((fbe_current_size + target_list.fbe_size()) <= fbe_struct_size)
        {
            target_list.get(fbe_value.target_list);
        }
    else
        fbe_value.target_list.clear();
    fbe_current_size += target_list.fbe_size();

    if ((fbe_current_size + where_clause.fbe_size()) <= fbe_struct_size)
        {
            where_clause.get(fbe_value.where_clause);
        }
    else
        fbe_value.where_clause = ::pg_query::Node();
    fbe_current_size += where_clause.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_OnConflictClause::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_OnConflictClause::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_OnConflictClause::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_OnConflictClause::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::OnConflictClause& fbe_value = static_cast<const ::pg_query::OnConflictClause&>(base_fbe_value);
    action.set(fbe_value.action);
    infer.set(fbe_value.infer);
    target_list.set(fbe_value.target_list);
    where_clause.set(fbe_value.where_clause);
    location.set(fbe_value.location);
}

namespace pg_query {

bool OnConflictClauseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t OnConflictClauseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t OnConflictClauseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t OnConflictClauseModel::serialize(const ::pg_query::OnConflictClause& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t OnConflictClauseModel::deserialize(::pg_query::OnConflictClause& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CommonTableExpr::FieldModelPtr_pg_query_CommonTableExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CommonTableExpr::~FieldModelPtr_pg_query_CommonTableExpr()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CommonTableExpr::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CommonTableExpr::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CommonTableExpr::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CommonTableExpr::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CommonTableExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CommonTableExpr::get(::pg_query::CommonTableExpr** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CommonTableExpr(_buffer, 0);

    ::pg_query::CommonTableExpr *tempModel = new ::pg_query::CommonTableExpr();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CommonTableExpr::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CommonTableExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CommonTableExpr::set(const ::pg_query::CommonTableExpr* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CommonTableExpr(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CommonTableExpr::FieldModel_pg_query_CommonTableExpr(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , ctename(buffer, 4 + 4)
    , aliascolnames(buffer, ctename.fbe_offset() + ctename.fbe_size())
    , ctematerialized(buffer, aliascolnames.fbe_offset() + aliascolnames.fbe_size())
    , ctequery(buffer, ctematerialized.fbe_offset() + ctematerialized.fbe_size())
    , location(buffer, ctequery.fbe_offset() + ctequery.fbe_size())
    , cterecursive(buffer, location.fbe_offset() + location.fbe_size())
    , cterefcount(buffer, cterecursive.fbe_offset() + cterecursive.fbe_size())
    , ctecolnames(buffer, cterefcount.fbe_offset() + cterefcount.fbe_size())
    , ctecoltypes(buffer, ctecolnames.fbe_offset() + ctecolnames.fbe_size())
    , ctecoltypmods(buffer, ctecoltypes.fbe_offset() + ctecoltypes.fbe_size())
    , ctecolcollations(buffer, ctecoltypmods.fbe_offset() + ctecoltypmods.fbe_size())
{}

size_t FieldModel_pg_query_CommonTableExpr::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + ctename.fbe_size()
        + aliascolnames.fbe_size()
        + ctematerialized.fbe_size()
        + ctequery.fbe_size()
        + location.fbe_size()
        + cterecursive.fbe_size()
        + cterefcount.fbe_size()
        + ctecolnames.fbe_size()
        + ctecoltypes.fbe_size()
        + ctecoltypmods.fbe_size()
        + ctecolcollations.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CommonTableExpr::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + ctename.fbe_extra()
        + aliascolnames.fbe_extra()
        + ctematerialized.fbe_extra()
        + ctequery.fbe_extra()
        + location.fbe_extra()
        + cterecursive.fbe_extra()
        + cterefcount.fbe_extra()
        + ctecolnames.fbe_extra()
        + ctecoltypes.fbe_extra()
        + ctecoltypmods.fbe_extra()
        + ctecolcollations.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CommonTableExpr::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CommonTableExpr::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + ctename.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctename.verify())
        return false;
    fbe_current_size += ctename.fbe_size();

    if ((fbe_current_size + aliascolnames.fbe_size()) > fbe_struct_size)
        return true;
    if (!aliascolnames.verify())
        return false;
    fbe_current_size += aliascolnames.fbe_size();

    if ((fbe_current_size + ctematerialized.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctematerialized.verify())
        return false;
    fbe_current_size += ctematerialized.fbe_size();

    if ((fbe_current_size + ctequery.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctequery.verify())
        return false;
    fbe_current_size += ctequery.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    if ((fbe_current_size + cterecursive.fbe_size()) > fbe_struct_size)
        return true;
    if (!cterecursive.verify())
        return false;
    fbe_current_size += cterecursive.fbe_size();

    if ((fbe_current_size + cterefcount.fbe_size()) > fbe_struct_size)
        return true;
    if (!cterefcount.verify())
        return false;
    fbe_current_size += cterefcount.fbe_size();

    if ((fbe_current_size + ctecolnames.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctecolnames.verify())
        return false;
    fbe_current_size += ctecolnames.fbe_size();

    if ((fbe_current_size + ctecoltypes.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctecoltypes.verify())
        return false;
    fbe_current_size += ctecoltypes.fbe_size();

    if ((fbe_current_size + ctecoltypmods.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctecoltypmods.verify())
        return false;
    fbe_current_size += ctecoltypmods.fbe_size();

    if ((fbe_current_size + ctecolcollations.fbe_size()) > fbe_struct_size)
        return true;
    if (!ctecolcollations.verify())
        return false;
    fbe_current_size += ctecolcollations.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CommonTableExpr::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CommonTableExpr::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CommonTableExpr::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CommonTableExpr::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CommonTableExpr& fbe_value = static_cast<::pg_query::CommonTableExpr&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + ctename.fbe_size()) <= fbe_struct_size)
        {
            ctename.get(fbe_value.ctename);
        }
    else
        fbe_value.ctename = "";
    fbe_current_size += ctename.fbe_size();

    if ((fbe_current_size + aliascolnames.fbe_size()) <= fbe_struct_size)
        {
            aliascolnames.get(fbe_value.aliascolnames);
        }
    else
        fbe_value.aliascolnames.clear();
    fbe_current_size += aliascolnames.fbe_size();

    if ((fbe_current_size + ctematerialized.fbe_size()) <= fbe_struct_size)
        {
            ctematerialized.get(fbe_value.ctematerialized);
        }
    else
        fbe_value.ctematerialized = ::pg_query::CTEMaterialize();
    fbe_current_size += ctematerialized.fbe_size();

    if ((fbe_current_size + ctequery.fbe_size()) <= fbe_struct_size)
        {
            ctequery.get(fbe_value.ctequery);
        }
    else
        fbe_value.ctequery = ::pg_query::Node();
    fbe_current_size += ctequery.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();

    if ((fbe_current_size + cterecursive.fbe_size()) <= fbe_struct_size)
        {
            cterecursive.get(fbe_value.cterecursive);
        }
    else
        fbe_value.cterecursive = false;
    fbe_current_size += cterecursive.fbe_size();

    if ((fbe_current_size + cterefcount.fbe_size()) <= fbe_struct_size)
        {
            cterefcount.get(fbe_value.cterefcount);
        }
    else
        fbe_value.cterefcount = (int32_t)0ll;
    fbe_current_size += cterefcount.fbe_size();

    if ((fbe_current_size + ctecolnames.fbe_size()) <= fbe_struct_size)
        {
            ctecolnames.get(fbe_value.ctecolnames);
        }
    else
        fbe_value.ctecolnames.clear();
    fbe_current_size += ctecolnames.fbe_size();

    if ((fbe_current_size + ctecoltypes.fbe_size()) <= fbe_struct_size)
        {
            ctecoltypes.get(fbe_value.ctecoltypes);
        }
    else
        fbe_value.ctecoltypes.clear();
    fbe_current_size += ctecoltypes.fbe_size();

    if ((fbe_current_size + ctecoltypmods.fbe_size()) <= fbe_struct_size)
        {
            ctecoltypmods.get(fbe_value.ctecoltypmods);
        }
    else
        fbe_value.ctecoltypmods.clear();
    fbe_current_size += ctecoltypmods.fbe_size();

    if ((fbe_current_size + ctecolcollations.fbe_size()) <= fbe_struct_size)
        {
            ctecolcollations.get(fbe_value.ctecolcollations);
        }
    else
        fbe_value.ctecolcollations.clear();
    fbe_current_size += ctecolcollations.fbe_size();
}

size_t FieldModel_pg_query_CommonTableExpr::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CommonTableExpr::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CommonTableExpr::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CommonTableExpr::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CommonTableExpr& fbe_value = static_cast<const ::pg_query::CommonTableExpr&>(base_fbe_value);
    ctename.set(fbe_value.ctename);
    aliascolnames.set(fbe_value.aliascolnames);
    ctematerialized.set(fbe_value.ctematerialized);
    ctequery.set(fbe_value.ctequery);
    location.set(fbe_value.location);
    cterecursive.set(fbe_value.cterecursive);
    cterefcount.set(fbe_value.cterefcount);
    ctecolnames.set(fbe_value.ctecolnames);
    ctecoltypes.set(fbe_value.ctecoltypes);
    ctecoltypmods.set(fbe_value.ctecoltypmods);
    ctecolcollations.set(fbe_value.ctecolcollations);
}

namespace pg_query {

bool CommonTableExprModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CommonTableExprModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CommonTableExprModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CommonTableExprModel::serialize(const ::pg_query::CommonTableExpr& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CommonTableExprModel::deserialize(::pg_query::CommonTableExpr& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_RoleSpec::FieldModelPtr_pg_query_RoleSpec(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_RoleSpec::~FieldModelPtr_pg_query_RoleSpec()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_RoleSpec::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_RoleSpec::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_RoleSpec::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_RoleSpec::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RoleSpec::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RoleSpec::get(::pg_query::RoleSpec** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_RoleSpec(_buffer, 0);

    ::pg_query::RoleSpec *tempModel = new ::pg_query::RoleSpec();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_RoleSpec::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_RoleSpec::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_RoleSpec::set(const ::pg_query::RoleSpec* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_RoleSpec(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_RoleSpec::FieldModel_pg_query_RoleSpec(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , roletype(buffer, 4 + 4)
    , rolename(buffer, roletype.fbe_offset() + roletype.fbe_size())
    , location(buffer, rolename.fbe_offset() + rolename.fbe_size())
{}

size_t FieldModel_pg_query_RoleSpec::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + roletype.fbe_size()
        + rolename.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_RoleSpec::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + roletype.fbe_extra()
        + rolename.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_RoleSpec::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_RoleSpec::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + roletype.fbe_size()) > fbe_struct_size)
        return true;
    if (!roletype.verify())
        return false;
    fbe_current_size += roletype.fbe_size();

    if ((fbe_current_size + rolename.fbe_size()) > fbe_struct_size)
        return true;
    if (!rolename.verify())
        return false;
    fbe_current_size += rolename.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_RoleSpec::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RoleSpec::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RoleSpec::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_RoleSpec::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::RoleSpec& fbe_value = static_cast<::pg_query::RoleSpec&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + roletype.fbe_size()) <= fbe_struct_size)
        {
            roletype.get(fbe_value.roletype);
        }
    else
        fbe_value.roletype = ::pg_query::RoleSpecType();
    fbe_current_size += roletype.fbe_size();

    if ((fbe_current_size + rolename.fbe_size()) <= fbe_struct_size)
        {
            rolename.get(fbe_value.rolename);
        }
    else
        fbe_value.rolename = "";
    fbe_current_size += rolename.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_RoleSpec::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_RoleSpec::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_RoleSpec::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_RoleSpec::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::RoleSpec& fbe_value = static_cast<const ::pg_query::RoleSpec&>(base_fbe_value);
    roletype.set(fbe_value.roletype);
    rolename.set(fbe_value.rolename);
    location.set(fbe_value.location);
}

namespace pg_query {

bool RoleSpecModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t RoleSpecModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t RoleSpecModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t RoleSpecModel::serialize(const ::pg_query::RoleSpec& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t RoleSpecModel::deserialize(::pg_query::RoleSpec& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_TriggerTransition::FieldModelPtr_pg_query_TriggerTransition(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_TriggerTransition::~FieldModelPtr_pg_query_TriggerTransition()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_TriggerTransition::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_TriggerTransition::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_TriggerTransition::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_TriggerTransition::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TriggerTransition::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TriggerTransition::get(::pg_query::TriggerTransition** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_TriggerTransition(_buffer, 0);

    ::pg_query::TriggerTransition *tempModel = new ::pg_query::TriggerTransition();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_TriggerTransition::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_TriggerTransition::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_TriggerTransition::set(const ::pg_query::TriggerTransition* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_TriggerTransition(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_TriggerTransition::FieldModel_pg_query_TriggerTransition(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , is_new(buffer, name.fbe_offset() + name.fbe_size())
    , is_table(buffer, is_new.fbe_offset() + is_new.fbe_size())
{}

size_t FieldModel_pg_query_TriggerTransition::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + is_new.fbe_size()
        + is_table.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_TriggerTransition::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + is_new.fbe_extra()
        + is_table.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_TriggerTransition::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_TriggerTransition::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + is_new.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_new.verify())
        return false;
    fbe_current_size += is_new.fbe_size();

    if ((fbe_current_size + is_table.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_table.verify())
        return false;
    fbe_current_size += is_table.fbe_size();

    return true;
}

size_t FieldModel_pg_query_TriggerTransition::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TriggerTransition::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TriggerTransition::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_TriggerTransition::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::TriggerTransition& fbe_value = static_cast<::pg_query::TriggerTransition&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + is_new.fbe_size()) <= fbe_struct_size)
        {
            is_new.get(fbe_value.is_new);
        }
    else
        fbe_value.is_new = false;
    fbe_current_size += is_new.fbe_size();

    if ((fbe_current_size + is_table.fbe_size()) <= fbe_struct_size)
        {
            is_table.get(fbe_value.is_table);
        }
    else
        fbe_value.is_table = false;
    fbe_current_size += is_table.fbe_size();
}

size_t FieldModel_pg_query_TriggerTransition::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_TriggerTransition::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_TriggerTransition::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_TriggerTransition::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::TriggerTransition& fbe_value = static_cast<const ::pg_query::TriggerTransition&>(base_fbe_value);
    name.set(fbe_value.name);
    is_new.set(fbe_value.is_new);
    is_table.set(fbe_value.is_table);
}

namespace pg_query {

bool TriggerTransitionModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TriggerTransitionModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TriggerTransitionModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TriggerTransitionModel::serialize(const ::pg_query::TriggerTransition& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TriggerTransitionModel::deserialize(::pg_query::TriggerTransition& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_PartitionElem::FieldModelPtr_pg_query_PartitionElem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_PartitionElem::~FieldModelPtr_pg_query_PartitionElem()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_PartitionElem::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionElem::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionElem::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_PartitionElem::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionElem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionElem::get(::pg_query::PartitionElem** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_PartitionElem(_buffer, 0);

    ::pg_query::PartitionElem *tempModel = new ::pg_query::PartitionElem();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_PartitionElem::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionElem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionElem::set(const ::pg_query::PartitionElem* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_PartitionElem(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_PartitionElem::FieldModel_pg_query_PartitionElem(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , expr(buffer, name.fbe_offset() + name.fbe_size())
    , collation(buffer, expr.fbe_offset() + expr.fbe_size())
    , opclass(buffer, collation.fbe_offset() + collation.fbe_size())
    , location(buffer, opclass.fbe_offset() + opclass.fbe_size())
{}

size_t FieldModel_pg_query_PartitionElem::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + expr.fbe_size()
        + collation.fbe_size()
        + opclass.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_PartitionElem::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + expr.fbe_extra()
        + collation.fbe_extra()
        + opclass.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_PartitionElem::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_PartitionElem::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) > fbe_struct_size)
        return true;
    if (!expr.verify())
        return false;
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) > fbe_struct_size)
        return true;
    if (!collation.verify())
        return false;
    fbe_current_size += collation.fbe_size();

    if ((fbe_current_size + opclass.fbe_size()) > fbe_struct_size)
        return true;
    if (!opclass.verify())
        return false;
    fbe_current_size += opclass.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_PartitionElem::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionElem::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionElem::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_PartitionElem::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::PartitionElem& fbe_value = static_cast<::pg_query::PartitionElem&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + expr.fbe_size()) <= fbe_struct_size)
        {
            expr.get(fbe_value.expr);
        }
    else
        fbe_value.expr = ::pg_query::Node();
    fbe_current_size += expr.fbe_size();

    if ((fbe_current_size + collation.fbe_size()) <= fbe_struct_size)
        {
            collation.get(fbe_value.collation);
        }
    else
        fbe_value.collation.clear();
    fbe_current_size += collation.fbe_size();

    if ((fbe_current_size + opclass.fbe_size()) <= fbe_struct_size)
        {
            opclass.get(fbe_value.opclass);
        }
    else
        fbe_value.opclass.clear();
    fbe_current_size += opclass.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_PartitionElem::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionElem::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionElem::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_PartitionElem::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::PartitionElem& fbe_value = static_cast<const ::pg_query::PartitionElem&>(base_fbe_value);
    name.set(fbe_value.name);
    expr.set(fbe_value.expr);
    collation.set(fbe_value.collation);
    opclass.set(fbe_value.opclass);
    location.set(fbe_value.location);
}

namespace pg_query {

bool PartitionElemModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t PartitionElemModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t PartitionElemModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t PartitionElemModel::serialize(const ::pg_query::PartitionElem& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t PartitionElemModel::deserialize(::pg_query::PartitionElem& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_PartitionSpec::FieldModelPtr_pg_query_PartitionSpec(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_PartitionSpec::~FieldModelPtr_pg_query_PartitionSpec()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_PartitionSpec::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionSpec::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionSpec::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_PartitionSpec::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionSpec::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionSpec::get(::pg_query::PartitionSpec** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_PartitionSpec(_buffer, 0);

    ::pg_query::PartitionSpec *tempModel = new ::pg_query::PartitionSpec();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_PartitionSpec::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionSpec::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionSpec::set(const ::pg_query::PartitionSpec* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_PartitionSpec(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_PartitionSpec::FieldModel_pg_query_PartitionSpec(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , strategy(buffer, 4 + 4)
    , part_params(buffer, strategy.fbe_offset() + strategy.fbe_size())
    , location(buffer, part_params.fbe_offset() + part_params.fbe_size())
{}

size_t FieldModel_pg_query_PartitionSpec::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + strategy.fbe_size()
        + part_params.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_PartitionSpec::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + strategy.fbe_extra()
        + part_params.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_PartitionSpec::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_PartitionSpec::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + strategy.fbe_size()) > fbe_struct_size)
        return true;
    if (!strategy.verify())
        return false;
    fbe_current_size += strategy.fbe_size();

    if ((fbe_current_size + part_params.fbe_size()) > fbe_struct_size)
        return true;
    if (!part_params.verify())
        return false;
    fbe_current_size += part_params.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_PartitionSpec::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionSpec::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionSpec::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_PartitionSpec::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::PartitionSpec& fbe_value = static_cast<::pg_query::PartitionSpec&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + strategy.fbe_size()) <= fbe_struct_size)
        {
            strategy.get(fbe_value.strategy);
        }
    else
        fbe_value.strategy = "";
    fbe_current_size += strategy.fbe_size();

    if ((fbe_current_size + part_params.fbe_size()) <= fbe_struct_size)
        {
            part_params.get(fbe_value.part_params);
        }
    else
        fbe_value.part_params.clear();
    fbe_current_size += part_params.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_PartitionSpec::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionSpec::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionSpec::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_PartitionSpec::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::PartitionSpec& fbe_value = static_cast<const ::pg_query::PartitionSpec&>(base_fbe_value);
    strategy.set(fbe_value.strategy);
    part_params.set(fbe_value.part_params);
    location.set(fbe_value.location);
}

namespace pg_query {

bool PartitionSpecModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t PartitionSpecModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t PartitionSpecModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t PartitionSpecModel::serialize(const ::pg_query::PartitionSpec& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t PartitionSpecModel::deserialize(::pg_query::PartitionSpec& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_PartitionBoundSpec::FieldModelPtr_pg_query_PartitionBoundSpec(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_PartitionBoundSpec::~FieldModelPtr_pg_query_PartitionBoundSpec()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_PartitionBoundSpec::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionBoundSpec::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionBoundSpec::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_PartitionBoundSpec::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionBoundSpec::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionBoundSpec::get(::pg_query::PartitionBoundSpec** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_PartitionBoundSpec(_buffer, 0);

    ::pg_query::PartitionBoundSpec *tempModel = new ::pg_query::PartitionBoundSpec();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_PartitionBoundSpec::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionBoundSpec::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionBoundSpec::set(const ::pg_query::PartitionBoundSpec* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_PartitionBoundSpec(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_PartitionBoundSpec::FieldModel_pg_query_PartitionBoundSpec(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , strategy(buffer, 4 + 4)
    , is_default(buffer, strategy.fbe_offset() + strategy.fbe_size())
    , modulus(buffer, is_default.fbe_offset() + is_default.fbe_size())
    , remainder(buffer, modulus.fbe_offset() + modulus.fbe_size())
    , listdatums(buffer, remainder.fbe_offset() + remainder.fbe_size())
    , lowerdatums(buffer, listdatums.fbe_offset() + listdatums.fbe_size())
    , upperdatums(buffer, lowerdatums.fbe_offset() + lowerdatums.fbe_size())
    , location(buffer, upperdatums.fbe_offset() + upperdatums.fbe_size())
{}

size_t FieldModel_pg_query_PartitionBoundSpec::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + strategy.fbe_size()
        + is_default.fbe_size()
        + modulus.fbe_size()
        + remainder.fbe_size()
        + listdatums.fbe_size()
        + lowerdatums.fbe_size()
        + upperdatums.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_PartitionBoundSpec::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + strategy.fbe_extra()
        + is_default.fbe_extra()
        + modulus.fbe_extra()
        + remainder.fbe_extra()
        + listdatums.fbe_extra()
        + lowerdatums.fbe_extra()
        + upperdatums.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_PartitionBoundSpec::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_PartitionBoundSpec::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + strategy.fbe_size()) > fbe_struct_size)
        return true;
    if (!strategy.verify())
        return false;
    fbe_current_size += strategy.fbe_size();

    if ((fbe_current_size + is_default.fbe_size()) > fbe_struct_size)
        return true;
    if (!is_default.verify())
        return false;
    fbe_current_size += is_default.fbe_size();

    if ((fbe_current_size + modulus.fbe_size()) > fbe_struct_size)
        return true;
    if (!modulus.verify())
        return false;
    fbe_current_size += modulus.fbe_size();

    if ((fbe_current_size + remainder.fbe_size()) > fbe_struct_size)
        return true;
    if (!remainder.verify())
        return false;
    fbe_current_size += remainder.fbe_size();

    if ((fbe_current_size + listdatums.fbe_size()) > fbe_struct_size)
        return true;
    if (!listdatums.verify())
        return false;
    fbe_current_size += listdatums.fbe_size();

    if ((fbe_current_size + lowerdatums.fbe_size()) > fbe_struct_size)
        return true;
    if (!lowerdatums.verify())
        return false;
    fbe_current_size += lowerdatums.fbe_size();

    if ((fbe_current_size + upperdatums.fbe_size()) > fbe_struct_size)
        return true;
    if (!upperdatums.verify())
        return false;
    fbe_current_size += upperdatums.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_PartitionBoundSpec::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionBoundSpec::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionBoundSpec::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_PartitionBoundSpec::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::PartitionBoundSpec& fbe_value = static_cast<::pg_query::PartitionBoundSpec&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + strategy.fbe_size()) <= fbe_struct_size)
        {
            strategy.get(fbe_value.strategy);
        }
    else
        fbe_value.strategy = "";
    fbe_current_size += strategy.fbe_size();

    if ((fbe_current_size + is_default.fbe_size()) <= fbe_struct_size)
        {
            is_default.get(fbe_value.is_default);
        }
    else
        fbe_value.is_default = false;
    fbe_current_size += is_default.fbe_size();

    if ((fbe_current_size + modulus.fbe_size()) <= fbe_struct_size)
        {
            modulus.get(fbe_value.modulus);
        }
    else
        fbe_value.modulus = (int32_t)0ll;
    fbe_current_size += modulus.fbe_size();

    if ((fbe_current_size + remainder.fbe_size()) <= fbe_struct_size)
        {
            remainder.get(fbe_value.remainder);
        }
    else
        fbe_value.remainder = (int32_t)0ll;
    fbe_current_size += remainder.fbe_size();

    if ((fbe_current_size + listdatums.fbe_size()) <= fbe_struct_size)
        {
            listdatums.get(fbe_value.listdatums);
        }
    else
        fbe_value.listdatums.clear();
    fbe_current_size += listdatums.fbe_size();

    if ((fbe_current_size + lowerdatums.fbe_size()) <= fbe_struct_size)
        {
            lowerdatums.get(fbe_value.lowerdatums);
        }
    else
        fbe_value.lowerdatums.clear();
    fbe_current_size += lowerdatums.fbe_size();

    if ((fbe_current_size + upperdatums.fbe_size()) <= fbe_struct_size)
        {
            upperdatums.get(fbe_value.upperdatums);
        }
    else
        fbe_value.upperdatums.clear();
    fbe_current_size += upperdatums.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_PartitionBoundSpec::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionBoundSpec::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionBoundSpec::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_PartitionBoundSpec::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::PartitionBoundSpec& fbe_value = static_cast<const ::pg_query::PartitionBoundSpec&>(base_fbe_value);
    strategy.set(fbe_value.strategy);
    is_default.set(fbe_value.is_default);
    modulus.set(fbe_value.modulus);
    remainder.set(fbe_value.remainder);
    listdatums.set(fbe_value.listdatums);
    lowerdatums.set(fbe_value.lowerdatums);
    upperdatums.set(fbe_value.upperdatums);
    location.set(fbe_value.location);
}

namespace pg_query {

bool PartitionBoundSpecModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t PartitionBoundSpecModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t PartitionBoundSpecModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t PartitionBoundSpecModel::serialize(const ::pg_query::PartitionBoundSpec& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t PartitionBoundSpecModel::deserialize(::pg_query::PartitionBoundSpec& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_PartitionRangeDatum::FieldModelPtr_pg_query_PartitionRangeDatum(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_PartitionRangeDatum::~FieldModelPtr_pg_query_PartitionRangeDatum()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_PartitionRangeDatum::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionRangeDatum::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionRangeDatum::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_PartitionRangeDatum::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionRangeDatum::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionRangeDatum::get(::pg_query::PartitionRangeDatum** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_PartitionRangeDatum(_buffer, 0);

    ::pg_query::PartitionRangeDatum *tempModel = new ::pg_query::PartitionRangeDatum();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_PartitionRangeDatum::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionRangeDatum::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionRangeDatum::set(const ::pg_query::PartitionRangeDatum* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_PartitionRangeDatum(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_PartitionRangeDatum::FieldModel_pg_query_PartitionRangeDatum(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , kind(buffer, 4 + 4)
    , value(buffer, kind.fbe_offset() + kind.fbe_size())
    , location(buffer, value.fbe_offset() + value.fbe_size())
{}

size_t FieldModel_pg_query_PartitionRangeDatum::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + kind.fbe_size()
        + value.fbe_size()
        + location.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_PartitionRangeDatum::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + kind.fbe_extra()
        + value.fbe_extra()
        + location.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_PartitionRangeDatum::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_PartitionRangeDatum::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!kind.verify())
        return false;
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + value.fbe_size()) > fbe_struct_size)
        return true;
    if (!value.verify())
        return false;
    fbe_current_size += value.fbe_size();

    if ((fbe_current_size + location.fbe_size()) > fbe_struct_size)
        return true;
    if (!location.verify())
        return false;
    fbe_current_size += location.fbe_size();

    return true;
}

size_t FieldModel_pg_query_PartitionRangeDatum::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionRangeDatum::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionRangeDatum::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_PartitionRangeDatum::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::PartitionRangeDatum& fbe_value = static_cast<::pg_query::PartitionRangeDatum&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + kind.fbe_size()) <= fbe_struct_size)
        {
            kind.get(fbe_value.kind);
        }
    else
        fbe_value.kind = ::pg_query::PartitionRangeDatumKind();
    fbe_current_size += kind.fbe_size();

    if ((fbe_current_size + value.fbe_size()) <= fbe_struct_size)
        {
            value.get(fbe_value.value);
        }
    else
        fbe_value.value = ::pg_query::Node();
    fbe_current_size += value.fbe_size();

    if ((fbe_current_size + location.fbe_size()) <= fbe_struct_size)
        {
            location.get(fbe_value.location);
        }
    else
        fbe_value.location = (int32_t)0ll;
    fbe_current_size += location.fbe_size();
}

size_t FieldModel_pg_query_PartitionRangeDatum::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionRangeDatum::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionRangeDatum::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_PartitionRangeDatum::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::PartitionRangeDatum& fbe_value = static_cast<const ::pg_query::PartitionRangeDatum&>(base_fbe_value);
    kind.set(fbe_value.kind);
    value.set(fbe_value.value);
    location.set(fbe_value.location);
}

namespace pg_query {

bool PartitionRangeDatumModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t PartitionRangeDatumModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t PartitionRangeDatumModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t PartitionRangeDatumModel::serialize(const ::pg_query::PartitionRangeDatum& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t PartitionRangeDatumModel::deserialize(::pg_query::PartitionRangeDatum& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_PartitionCmd::FieldModelPtr_pg_query_PartitionCmd(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_PartitionCmd::~FieldModelPtr_pg_query_PartitionCmd()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_PartitionCmd::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionCmd::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_PartitionCmd::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_PartitionCmd::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionCmd::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionCmd::get(::pg_query::PartitionCmd** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_PartitionCmd(_buffer, 0);

    ::pg_query::PartitionCmd *tempModel = new ::pg_query::PartitionCmd();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_PartitionCmd::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_PartitionCmd::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_PartitionCmd::set(const ::pg_query::PartitionCmd* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_PartitionCmd(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_PartitionCmd::FieldModel_pg_query_PartitionCmd(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
    , bound(buffer, name.fbe_offset() + name.fbe_size())
{}

size_t FieldModel_pg_query_PartitionCmd::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        + bound.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_PartitionCmd::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        + bound.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_PartitionCmd::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_PartitionCmd::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + bound.fbe_size()) > fbe_struct_size)
        return true;
    if (!bound.verify())
        return false;
    fbe_current_size += bound.fbe_size();

    return true;
}

size_t FieldModel_pg_query_PartitionCmd::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionCmd::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionCmd::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_PartitionCmd::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::PartitionCmd& fbe_value = static_cast<::pg_query::PartitionCmd&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(&fbe_value.name);
        }
    else
        fbe_value.name = nullptr;
    fbe_current_size += name.fbe_size();

    if ((fbe_current_size + bound.fbe_size()) <= fbe_struct_size)
        {
            bound.get(&fbe_value.bound);
        }
    else
        fbe_value.bound = nullptr;
    fbe_current_size += bound.fbe_size();
}

size_t FieldModel_pg_query_PartitionCmd::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_PartitionCmd::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_PartitionCmd::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_PartitionCmd::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::PartitionCmd& fbe_value = static_cast<const ::pg_query::PartitionCmd&>(base_fbe_value);
    name.set(fbe_value.name);
    bound.set(fbe_value.bound);
}

namespace pg_query {

bool PartitionCmdModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t PartitionCmdModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t PartitionCmdModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t PartitionCmdModel::serialize(const ::pg_query::PartitionCmd& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t PartitionCmdModel::deserialize(::pg_query::PartitionCmd& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_VacuumRelation::FieldModelPtr_pg_query_VacuumRelation(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_VacuumRelation::~FieldModelPtr_pg_query_VacuumRelation()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_VacuumRelation::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_VacuumRelation::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_VacuumRelation::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_VacuumRelation::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_VacuumRelation::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_VacuumRelation::get(::pg_query::VacuumRelation** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_VacuumRelation(_buffer, 0);

    ::pg_query::VacuumRelation *tempModel = new ::pg_query::VacuumRelation();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_VacuumRelation::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_VacuumRelation::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_VacuumRelation::set(const ::pg_query::VacuumRelation* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_VacuumRelation(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_VacuumRelation::FieldModel_pg_query_VacuumRelation(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , relation(buffer, 4 + 4)
    , oid(buffer, relation.fbe_offset() + relation.fbe_size())
    , va_cols(buffer, oid.fbe_offset() + oid.fbe_size())
{}

size_t FieldModel_pg_query_VacuumRelation::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + relation.fbe_size()
        + oid.fbe_size()
        + va_cols.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_VacuumRelation::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + relation.fbe_extra()
        + oid.fbe_extra()
        + va_cols.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_VacuumRelation::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_VacuumRelation::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) > fbe_struct_size)
        return true;
    if (!relation.verify())
        return false;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + oid.fbe_size()) > fbe_struct_size)
        return true;
    if (!oid.verify())
        return false;
    fbe_current_size += oid.fbe_size();

    if ((fbe_current_size + va_cols.fbe_size()) > fbe_struct_size)
        return true;
    if (!va_cols.verify())
        return false;
    fbe_current_size += va_cols.fbe_size();

    return true;
}

size_t FieldModel_pg_query_VacuumRelation::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_VacuumRelation::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_VacuumRelation::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_VacuumRelation::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::VacuumRelation& fbe_value = static_cast<::pg_query::VacuumRelation&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + relation.fbe_size()) <= fbe_struct_size)
        {
            relation.get(&fbe_value.relation);
        }
    else
        fbe_value.relation = nullptr;
    fbe_current_size += relation.fbe_size();

    if ((fbe_current_size + oid.fbe_size()) <= fbe_struct_size)
        {
            oid.get(fbe_value.oid);
        }
    else
        fbe_value.oid = (uint32_t)0ull;
    fbe_current_size += oid.fbe_size();

    if ((fbe_current_size + va_cols.fbe_size()) <= fbe_struct_size)
        {
            va_cols.get(fbe_value.va_cols);
        }
    else
        fbe_value.va_cols.clear();
    fbe_current_size += va_cols.fbe_size();
}

size_t FieldModel_pg_query_VacuumRelation::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_VacuumRelation::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_VacuumRelation::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_VacuumRelation::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::VacuumRelation& fbe_value = static_cast<const ::pg_query::VacuumRelation&>(base_fbe_value);
    relation.set(fbe_value.relation);
    oid.set(fbe_value.oid);
    va_cols.set(fbe_value.va_cols);
}

namespace pg_query {

bool VacuumRelationModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t VacuumRelationModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t VacuumRelationModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t VacuumRelationModel::serialize(const ::pg_query::VacuumRelation& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t VacuumRelationModel::deserialize(::pg_query::VacuumRelation& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_InlineCodeBlock::FieldModelPtr_pg_query_InlineCodeBlock(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_InlineCodeBlock::~FieldModelPtr_pg_query_InlineCodeBlock()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_InlineCodeBlock::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_InlineCodeBlock::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_InlineCodeBlock::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_InlineCodeBlock::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_InlineCodeBlock::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_InlineCodeBlock::get(::pg_query::InlineCodeBlock** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_InlineCodeBlock(_buffer, 0);

    ::pg_query::InlineCodeBlock *tempModel = new ::pg_query::InlineCodeBlock();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_InlineCodeBlock::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_InlineCodeBlock::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_InlineCodeBlock::set(const ::pg_query::InlineCodeBlock* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_InlineCodeBlock(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_InlineCodeBlock::FieldModel_pg_query_InlineCodeBlock(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , source_text(buffer, 4 + 4)
    , lang_oid(buffer, source_text.fbe_offset() + source_text.fbe_size())
    , lang_is_trusted(buffer, lang_oid.fbe_offset() + lang_oid.fbe_size())
    , atomic(buffer, lang_is_trusted.fbe_offset() + lang_is_trusted.fbe_size())
{}

size_t FieldModel_pg_query_InlineCodeBlock::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + source_text.fbe_size()
        + lang_oid.fbe_size()
        + lang_is_trusted.fbe_size()
        + atomic.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_InlineCodeBlock::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + source_text.fbe_extra()
        + lang_oid.fbe_extra()
        + lang_is_trusted.fbe_extra()
        + atomic.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_InlineCodeBlock::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_InlineCodeBlock::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + source_text.fbe_size()) > fbe_struct_size)
        return true;
    if (!source_text.verify())
        return false;
    fbe_current_size += source_text.fbe_size();

    if ((fbe_current_size + lang_oid.fbe_size()) > fbe_struct_size)
        return true;
    if (!lang_oid.verify())
        return false;
    fbe_current_size += lang_oid.fbe_size();

    if ((fbe_current_size + lang_is_trusted.fbe_size()) > fbe_struct_size)
        return true;
    if (!lang_is_trusted.verify())
        return false;
    fbe_current_size += lang_is_trusted.fbe_size();

    if ((fbe_current_size + atomic.fbe_size()) > fbe_struct_size)
        return true;
    if (!atomic.verify())
        return false;
    fbe_current_size += atomic.fbe_size();

    return true;
}

size_t FieldModel_pg_query_InlineCodeBlock::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_InlineCodeBlock::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_InlineCodeBlock::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_InlineCodeBlock::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::InlineCodeBlock& fbe_value = static_cast<::pg_query::InlineCodeBlock&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + source_text.fbe_size()) <= fbe_struct_size)
        {
            source_text.get(fbe_value.source_text);
        }
    else
        fbe_value.source_text = "";
    fbe_current_size += source_text.fbe_size();

    if ((fbe_current_size + lang_oid.fbe_size()) <= fbe_struct_size)
        {
            lang_oid.get(fbe_value.lang_oid);
        }
    else
        fbe_value.lang_oid = (uint32_t)0ull;
    fbe_current_size += lang_oid.fbe_size();

    if ((fbe_current_size + lang_is_trusted.fbe_size()) <= fbe_struct_size)
        {
            lang_is_trusted.get(fbe_value.lang_is_trusted);
        }
    else
        fbe_value.lang_is_trusted = false;
    fbe_current_size += lang_is_trusted.fbe_size();

    if ((fbe_current_size + atomic.fbe_size()) <= fbe_struct_size)
        {
            atomic.get(fbe_value.atomic);
        }
    else
        fbe_value.atomic = false;
    fbe_current_size += atomic.fbe_size();
}

size_t FieldModel_pg_query_InlineCodeBlock::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_InlineCodeBlock::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_InlineCodeBlock::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_InlineCodeBlock::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::InlineCodeBlock& fbe_value = static_cast<const ::pg_query::InlineCodeBlock&>(base_fbe_value);
    source_text.set(fbe_value.source_text);
    lang_oid.set(fbe_value.lang_oid);
    lang_is_trusted.set(fbe_value.lang_is_trusted);
    atomic.set(fbe_value.atomic);
}

namespace pg_query {

bool InlineCodeBlockModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t InlineCodeBlockModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t InlineCodeBlockModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t InlineCodeBlockModel::serialize(const ::pg_query::InlineCodeBlock& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t InlineCodeBlockModel::deserialize(::pg_query::InlineCodeBlock& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_CallContext::FieldModelPtr_pg_query_CallContext(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_CallContext::~FieldModelPtr_pg_query_CallContext()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_CallContext::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_CallContext::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_CallContext::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_CallContext::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CallContext::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CallContext::get(::pg_query::CallContext** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_CallContext(_buffer, 0);

    ::pg_query::CallContext *tempModel = new ::pg_query::CallContext();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_CallContext::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_CallContext::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_CallContext::set(const ::pg_query::CallContext* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_CallContext(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_CallContext::FieldModel_pg_query_CallContext(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , atomic(buffer, 4 + 4)
{}

size_t FieldModel_pg_query_CallContext::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + atomic.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_CallContext::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + atomic.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_CallContext::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_CallContext::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + atomic.fbe_size()) > fbe_struct_size)
        return true;
    if (!atomic.verify())
        return false;
    fbe_current_size += atomic.fbe_size();

    return true;
}

size_t FieldModel_pg_query_CallContext::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CallContext::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CallContext::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_CallContext::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::CallContext& fbe_value = static_cast<::pg_query::CallContext&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + atomic.fbe_size()) <= fbe_struct_size)
        {
            atomic.get(fbe_value.atomic);
        }
    else
        fbe_value.atomic = false;
    fbe_current_size += atomic.fbe_size();
}

size_t FieldModel_pg_query_CallContext::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_CallContext::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_CallContext::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_CallContext::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::CallContext& fbe_value = static_cast<const ::pg_query::CallContext&>(base_fbe_value);
    atomic.set(fbe_value.atomic);
}

namespace pg_query {

bool CallContextModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t CallContextModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t CallContextModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t CallContextModel::serialize(const ::pg_query::CallContext& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t CallContextModel::deserialize(::pg_query::CallContext& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ScanToken::FieldModelPtr_pg_query_ScanToken(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ScanToken::~FieldModelPtr_pg_query_ScanToken()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ScanToken::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ScanToken::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ScanToken::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ScanToken::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ScanToken::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ScanToken::get(::pg_query::ScanToken** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ScanToken(_buffer, 0);

    ::pg_query::ScanToken *tempModel = new ::pg_query::ScanToken();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ScanToken::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ScanToken::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ScanToken::set(const ::pg_query::ScanToken* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ScanToken(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ScanToken::FieldModel_pg_query_ScanToken(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , start(buffer, 4 + 4)
    , end(buffer, start.fbe_offset() + start.fbe_size())
    , token(buffer, end.fbe_offset() + end.fbe_size())
    , keyword_kind(buffer, token.fbe_offset() + token.fbe_size())
{}

size_t FieldModel_pg_query_ScanToken::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + start.fbe_size()
        + end.fbe_size()
        + token.fbe_size()
        + keyword_kind.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ScanToken::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + start.fbe_extra()
        + end.fbe_extra()
        + token.fbe_extra()
        + keyword_kind.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ScanToken::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ScanToken::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + start.fbe_size()) > fbe_struct_size)
        return true;
    if (!start.verify())
        return false;
    fbe_current_size += start.fbe_size();

    if ((fbe_current_size + end.fbe_size()) > fbe_struct_size)
        return true;
    if (!end.verify())
        return false;
    fbe_current_size += end.fbe_size();

    if ((fbe_current_size + token.fbe_size()) > fbe_struct_size)
        return true;
    if (!token.verify())
        return false;
    fbe_current_size += token.fbe_size();

    if ((fbe_current_size + keyword_kind.fbe_size()) > fbe_struct_size)
        return true;
    if (!keyword_kind.verify())
        return false;
    fbe_current_size += keyword_kind.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ScanToken::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ScanToken::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ScanToken::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ScanToken::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ScanToken& fbe_value = static_cast<::pg_query::ScanToken&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + start.fbe_size()) <= fbe_struct_size)
        {
            start.get(fbe_value.start);
        }
    else
        fbe_value.start = (int32_t)0ll;
    fbe_current_size += start.fbe_size();

    if ((fbe_current_size + end.fbe_size()) <= fbe_struct_size)
        {
            end.get(fbe_value.end);
        }
    else
        fbe_value.end = (int32_t)0ll;
    fbe_current_size += end.fbe_size();

    if ((fbe_current_size + token.fbe_size()) <= fbe_struct_size)
        {
            token.get(fbe_value.token);
        }
    else
        fbe_value.token = ::pg_query::Token();
    fbe_current_size += token.fbe_size();

    if ((fbe_current_size + keyword_kind.fbe_size()) <= fbe_struct_size)
        {
            keyword_kind.get(fbe_value.keyword_kind);
        }
    else
        fbe_value.keyword_kind = ::pg_query::KeywordKind();
    fbe_current_size += keyword_kind.fbe_size();
}

size_t FieldModel_pg_query_ScanToken::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ScanToken::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ScanToken::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ScanToken::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ScanToken& fbe_value = static_cast<const ::pg_query::ScanToken&>(base_fbe_value);
    start.set(fbe_value.start);
    end.set(fbe_value.end);
    token.set(fbe_value.token);
    keyword_kind.set(fbe_value.keyword_kind);
}

namespace pg_query {

bool ScanTokenModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ScanTokenModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ScanTokenModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ScanTokenModel::serialize(const ::pg_query::ScanToken& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ScanTokenModel::deserialize(::pg_query::ScanToken& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ParseResult::FieldModelPtr_pg_query_ParseResult(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ParseResult::~FieldModelPtr_pg_query_ParseResult()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ParseResult::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ParseResult::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ParseResult::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ParseResult::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ParseResult::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ParseResult::get(::pg_query::ParseResult** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ParseResult(_buffer, 0);

    ::pg_query::ParseResult *tempModel = new ::pg_query::ParseResult();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ParseResult::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ParseResult::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ParseResult::set(const ::pg_query::ParseResult* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ParseResult(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ParseResult::FieldModel_pg_query_ParseResult(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , version(buffer, 4 + 4)
    , stmts(buffer, version.fbe_offset() + version.fbe_size())
{}

size_t FieldModel_pg_query_ParseResult::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + version.fbe_size()
        + stmts.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ParseResult::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + version.fbe_extra()
        + stmts.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ParseResult::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ParseResult::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + version.fbe_size()) > fbe_struct_size)
        return true;
    if (!version.verify())
        return false;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + stmts.fbe_size()) > fbe_struct_size)
        return true;
    if (!stmts.verify())
        return false;
    fbe_current_size += stmts.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ParseResult::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ParseResult::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ParseResult::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ParseResult::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ParseResult& fbe_value = static_cast<::pg_query::ParseResult&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + version.fbe_size()) <= fbe_struct_size)
        {
            version.get(fbe_value.version);
        }
    else
        fbe_value.version = (int32_t)0ll;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + stmts.fbe_size()) <= fbe_struct_size)
        {
            stmts.get(fbe_value.stmts);
        }
    else
        fbe_value.stmts.clear();
    fbe_current_size += stmts.fbe_size();
}

size_t FieldModel_pg_query_ParseResult::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ParseResult::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ParseResult::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ParseResult::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ParseResult& fbe_value = static_cast<const ::pg_query::ParseResult&>(base_fbe_value);
    version.set(fbe_value.version);
    stmts.set(fbe_value.stmts);
}

namespace pg_query {

bool ParseResultModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ParseResultModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ParseResultModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ParseResultModel::serialize(const ::pg_query::ParseResult& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ParseResultModel::deserialize(::pg_query::ParseResult& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

FieldModelPtr_pg_query_ScanResult::FieldModelPtr_pg_query_ScanResult(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_pg_query_ScanResult::~FieldModelPtr_pg_query_ScanResult()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_pg_query_ScanResult::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_pg_query_ScanResult::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_pg_query_ScanResult::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_pg_query_ScanResult::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ScanResult::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ScanResult::get(::pg_query::ScanResult** fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    ptr = new FieldModel_pg_query_ScanResult(_buffer, 0);

    ::pg_query::ScanResult *tempModel = new ::pg_query::ScanResult();
    ptr->get(*tempModel);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_pg_query_ScanResult::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_pg_query_ScanResult::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_pg_query_ScanResult::set(const ::pg_query::ScanResult* fbe_value) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_pg_query_ScanResult(_buffer, 0);
        ptr = temp;
        ptr->set(*fbe_value);
    }

    set_end(fbe_begin);
}

FieldModel_pg_query_ScanResult::FieldModel_pg_query_ScanResult(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , version(buffer, 4 + 4)
    , tokens(buffer, version.fbe_offset() + version.fbe_size())
{}

size_t FieldModel_pg_query_ScanResult::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + version.fbe_size()
        + tokens.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_pg_query_ScanResult::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + version.fbe_extra()
        + tokens.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_pg_query_ScanResult::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_pg_query_ScanResult::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + version.fbe_size()) > fbe_struct_size)
        return true;
    if (!version.verify())
        return false;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + tokens.fbe_size()) > fbe_struct_size)
        return true;
    if (!tokens.verify())
        return false;
    fbe_current_size += tokens.fbe_size();

    return true;
}

size_t FieldModel_pg_query_ScanResult::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ScanResult::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ScanResult::get(::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel_pg_query_ScanResult::get_fields(::FBE::Base& base_fbe_value, size_t fbe_struct_size) noexcept
{
    ::pg_query::ScanResult& fbe_value = static_cast<::pg_query::ScanResult&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + version.fbe_size()) <= fbe_struct_size)
        {
            version.get(fbe_value.version);
        }
    else
        fbe_value.version = (int32_t)0ll;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + tokens.fbe_size()) <= fbe_struct_size)
        {
            tokens.get(fbe_value.tokens);
        }
    else
        fbe_value.tokens.clear();
    fbe_current_size += tokens.fbe_size();
}

size_t FieldModel_pg_query_ScanResult::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_pg_query_ScanResult::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_pg_query_ScanResult::set(const ::FBE::Base& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel_pg_query_ScanResult::set_fields(const ::FBE::Base& base_fbe_value) noexcept
{
    const ::pg_query::ScanResult& fbe_value = static_cast<const ::pg_query::ScanResult&>(base_fbe_value);
    version.set(fbe_value.version);
    tokens.set(fbe_value.tokens);
}

namespace pg_query {

bool ScanResultModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ScanResultModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ScanResultModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ScanResultModel::serialize(const ::pg_query::ScanResult& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ScanResultModel::deserialize(::pg_query::ScanResult& value) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace pg_query

} // namespace FBE
