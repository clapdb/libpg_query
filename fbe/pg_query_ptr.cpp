// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: pg_query.fbe
// Version: 1.7.0.0

#include "pg_query_ptr.h"

namespace pg_query {

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] OverridingKind value)
{
    if (value == OverridingKind::OVERRIDING_KIND_UNDEFINED) return stream << "OVERRIDING_KIND_UNDEFINED";
    if (value == OverridingKind::OVERRIDING_NOT_SET) return stream << "OVERRIDING_NOT_SET";
    if (value == OverridingKind::OVERRIDING_USER_VALUE) return stream << "OVERRIDING_USER_VALUE";
    if (value == OverridingKind::OVERRIDING_SYSTEM_VALUE) return stream << "OVERRIDING_SYSTEM_VALUE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] QuerySource value)
{
    if (value == QuerySource::QUERY_SOURCE_UNDEFINED) return stream << "QUERY_SOURCE_UNDEFINED";
    if (value == QuerySource::QSRC_ORIGINAL) return stream << "QSRC_ORIGINAL";
    if (value == QuerySource::QSRC_PARSER) return stream << "QSRC_PARSER";
    if (value == QuerySource::QSRC_INSTEAD_RULE) return stream << "QSRC_INSTEAD_RULE";
    if (value == QuerySource::QSRC_QUAL_INSTEAD_RULE) return stream << "QSRC_QUAL_INSTEAD_RULE";
    if (value == QuerySource::QSRC_NON_INSTEAD_RULE) return stream << "QSRC_NON_INSTEAD_RULE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SortByDir value)
{
    if (value == SortByDir::SORT_BY_DIR_UNDEFINED) return stream << "SORT_BY_DIR_UNDEFINED";
    if (value == SortByDir::SORTBY_DEFAULT) return stream << "SORTBY_DEFAULT";
    if (value == SortByDir::SORTBY_ASC) return stream << "SORTBY_ASC";
    if (value == SortByDir::SORTBY_DESC) return stream << "SORTBY_DESC";
    if (value == SortByDir::SORTBY_USING) return stream << "SORTBY_USING";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SortByNulls value)
{
    if (value == SortByNulls::SORT_BY_NULLS_UNDEFINED) return stream << "SORT_BY_NULLS_UNDEFINED";
    if (value == SortByNulls::SORTBY_NULLS_DEFAULT) return stream << "SORTBY_NULLS_DEFAULT";
    if (value == SortByNulls::SORTBY_NULLS_FIRST) return stream << "SORTBY_NULLS_FIRST";
    if (value == SortByNulls::SORTBY_NULLS_LAST) return stream << "SORTBY_NULLS_LAST";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] A_Expr_Kind value)
{
    if (value == A_Expr_Kind::A_EXPR_KIND_UNDEFINED) return stream << "A_EXPR_KIND_UNDEFINED";
    if (value == A_Expr_Kind::AEXPR_OP) return stream << "AEXPR_OP";
    if (value == A_Expr_Kind::AEXPR_OP_ANY) return stream << "AEXPR_OP_ANY";
    if (value == A_Expr_Kind::AEXPR_OP_ALL) return stream << "AEXPR_OP_ALL";
    if (value == A_Expr_Kind::AEXPR_DISTINCT) return stream << "AEXPR_DISTINCT";
    if (value == A_Expr_Kind::AEXPR_NOT_DISTINCT) return stream << "AEXPR_NOT_DISTINCT";
    if (value == A_Expr_Kind::AEXPR_NULLIF) return stream << "AEXPR_NULLIF";
    if (value == A_Expr_Kind::AEXPR_OF) return stream << "AEXPR_OF";
    if (value == A_Expr_Kind::AEXPR_IN) return stream << "AEXPR_IN";
    if (value == A_Expr_Kind::AEXPR_LIKE) return stream << "AEXPR_LIKE";
    if (value == A_Expr_Kind::AEXPR_ILIKE) return stream << "AEXPR_ILIKE";
    if (value == A_Expr_Kind::AEXPR_SIMILAR) return stream << "AEXPR_SIMILAR";
    if (value == A_Expr_Kind::AEXPR_BETWEEN) return stream << "AEXPR_BETWEEN";
    if (value == A_Expr_Kind::AEXPR_NOT_BETWEEN) return stream << "AEXPR_NOT_BETWEEN";
    if (value == A_Expr_Kind::AEXPR_BETWEEN_SYM) return stream << "AEXPR_BETWEEN_SYM";
    if (value == A_Expr_Kind::AEXPR_NOT_BETWEEN_SYM) return stream << "AEXPR_NOT_BETWEEN_SYM";
    if (value == A_Expr_Kind::AEXPR_PAREN) return stream << "AEXPR_PAREN";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] RoleSpecType value)
{
    if (value == RoleSpecType::ROLE_SPEC_TYPE_UNDEFINED) return stream << "ROLE_SPEC_TYPE_UNDEFINED";
    if (value == RoleSpecType::ROLESPEC_CSTRING) return stream << "ROLESPEC_CSTRING";
    if (value == RoleSpecType::ROLESPEC_CURRENT_USER) return stream << "ROLESPEC_CURRENT_USER";
    if (value == RoleSpecType::ROLESPEC_SESSION_USER) return stream << "ROLESPEC_SESSION_USER";
    if (value == RoleSpecType::ROLESPEC_PUBLIC) return stream << "ROLESPEC_PUBLIC";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] TableLikeOption value)
{
    if (value == TableLikeOption::TABLE_LIKE_OPTION_UNDEFINED) return stream << "TABLE_LIKE_OPTION_UNDEFINED";
    if (value == TableLikeOption::CREATE_TABLE_LIKE_COMMENTS) return stream << "CREATE_TABLE_LIKE_COMMENTS";
    if (value == TableLikeOption::CREATE_TABLE_LIKE_CONSTRAINTS) return stream << "CREATE_TABLE_LIKE_CONSTRAINTS";
    if (value == TableLikeOption::CREATE_TABLE_LIKE_DEFAULTS) return stream << "CREATE_TABLE_LIKE_DEFAULTS";
    if (value == TableLikeOption::CREATE_TABLE_LIKE_GENERATED) return stream << "CREATE_TABLE_LIKE_GENERATED";
    if (value == TableLikeOption::CREATE_TABLE_LIKE_IDENTITY) return stream << "CREATE_TABLE_LIKE_IDENTITY";
    if (value == TableLikeOption::CREATE_TABLE_LIKE_INDEXES) return stream << "CREATE_TABLE_LIKE_INDEXES";
    if (value == TableLikeOption::CREATE_TABLE_LIKE_STATISTICS) return stream << "CREATE_TABLE_LIKE_STATISTICS";
    if (value == TableLikeOption::CREATE_TABLE_LIKE_STORAGE) return stream << "CREATE_TABLE_LIKE_STORAGE";
    if (value == TableLikeOption::CREATE_TABLE_LIKE_ALL) return stream << "CREATE_TABLE_LIKE_ALL";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] DefElemAction value)
{
    if (value == DefElemAction::DEF_ELEM_ACTION_UNDEFINED) return stream << "DEF_ELEM_ACTION_UNDEFINED";
    if (value == DefElemAction::DEFELEM_UNSPEC) return stream << "DEFELEM_UNSPEC";
    if (value == DefElemAction::DEFELEM_SET) return stream << "DEFELEM_SET";
    if (value == DefElemAction::DEFELEM_ADD) return stream << "DEFELEM_ADD";
    if (value == DefElemAction::DEFELEM_DROP) return stream << "DEFELEM_DROP";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] PartitionRangeDatumKind value)
{
    if (value == PartitionRangeDatumKind::PARTITION_RANGE_DATUM_KIND_UNDEFINED) return stream << "PARTITION_RANGE_DATUM_KIND_UNDEFINED";
    if (value == PartitionRangeDatumKind::PARTITION_RANGE_DATUM_MINVALUE) return stream << "PARTITION_RANGE_DATUM_MINVALUE";
    if (value == PartitionRangeDatumKind::PARTITION_RANGE_DATUM_VALUE) return stream << "PARTITION_RANGE_DATUM_VALUE";
    if (value == PartitionRangeDatumKind::PARTITION_RANGE_DATUM_MAXVALUE) return stream << "PARTITION_RANGE_DATUM_MAXVALUE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] RTEKind value)
{
    if (value == RTEKind::RTEKIND_UNDEFINED) return stream << "RTEKIND_UNDEFINED";
    if (value == RTEKind::RTE_RELATION) return stream << "RTE_RELATION";
    if (value == RTEKind::RTE_SUBQUERY) return stream << "RTE_SUBQUERY";
    if (value == RTEKind::RTE_JOIN) return stream << "RTE_JOIN";
    if (value == RTEKind::RTE_FUNCTION) return stream << "RTE_FUNCTION";
    if (value == RTEKind::RTE_TABLEFUNC) return stream << "RTE_TABLEFUNC";
    if (value == RTEKind::RTE_VALUES) return stream << "RTE_VALUES";
    if (value == RTEKind::RTE_CTE) return stream << "RTE_CTE";
    if (value == RTEKind::RTE_NAMEDTUPLESTORE) return stream << "RTE_NAMEDTUPLESTORE";
    if (value == RTEKind::RTE_RESULT) return stream << "RTE_RESULT";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] WCOKind value)
{
    if (value == WCOKind::WCOKIND_UNDEFINED) return stream << "WCOKIND_UNDEFINED";
    if (value == WCOKind::WCO_VIEW_CHECK) return stream << "WCO_VIEW_CHECK";
    if (value == WCOKind::WCO_RLS_INSERT_CHECK) return stream << "WCO_RLS_INSERT_CHECK";
    if (value == WCOKind::WCO_RLS_UPDATE_CHECK) return stream << "WCO_RLS_UPDATE_CHECK";
    if (value == WCOKind::WCO_RLS_CONFLICT_CHECK) return stream << "WCO_RLS_CONFLICT_CHECK";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] GroupingSetKind value)
{
    if (value == GroupingSetKind::GROUPING_SET_KIND_UNDEFINED) return stream << "GROUPING_SET_KIND_UNDEFINED";
    if (value == GroupingSetKind::GROUPING_SET_EMPTY) return stream << "GROUPING_SET_EMPTY";
    if (value == GroupingSetKind::GROUPING_SET_SIMPLE) return stream << "GROUPING_SET_SIMPLE";
    if (value == GroupingSetKind::GROUPING_SET_ROLLUP) return stream << "GROUPING_SET_ROLLUP";
    if (value == GroupingSetKind::GROUPING_SET_CUBE) return stream << "GROUPING_SET_CUBE";
    if (value == GroupingSetKind::GROUPING_SET_SETS) return stream << "GROUPING_SET_SETS";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] CTEMaterialize value)
{
    if (value == CTEMaterialize::CTEMATERIALIZE_UNDEFINED) return stream << "CTEMATERIALIZE_UNDEFINED";
    if (value == CTEMaterialize::CTEMaterializeDefault) return stream << "CTEMaterializeDefault";
    if (value == CTEMaterialize::CTEMaterializeAlways) return stream << "CTEMaterializeAlways";
    if (value == CTEMaterialize::CTEMaterializeNever) return stream << "CTEMaterializeNever";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SetOperation value)
{
    if (value == SetOperation::SET_OPERATION_UNDEFINED) return stream << "SET_OPERATION_UNDEFINED";
    if (value == SetOperation::SETOP_NONE) return stream << "SETOP_NONE";
    if (value == SetOperation::SETOP_UNION) return stream << "SETOP_UNION";
    if (value == SetOperation::SETOP_INTERSECT) return stream << "SETOP_INTERSECT";
    if (value == SetOperation::SETOP_EXCEPT) return stream << "SETOP_EXCEPT";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ObjectType value)
{
    if (value == ObjectType::OBJECT_TYPE_UNDEFINED) return stream << "OBJECT_TYPE_UNDEFINED";
    if (value == ObjectType::OBJECT_ACCESS_METHOD) return stream << "OBJECT_ACCESS_METHOD";
    if (value == ObjectType::OBJECT_AGGREGATE) return stream << "OBJECT_AGGREGATE";
    if (value == ObjectType::OBJECT_AMOP) return stream << "OBJECT_AMOP";
    if (value == ObjectType::OBJECT_AMPROC) return stream << "OBJECT_AMPROC";
    if (value == ObjectType::OBJECT_ATTRIBUTE) return stream << "OBJECT_ATTRIBUTE";
    if (value == ObjectType::OBJECT_CAST) return stream << "OBJECT_CAST";
    if (value == ObjectType::OBJECT_COLUMN) return stream << "OBJECT_COLUMN";
    if (value == ObjectType::OBJECT_COLLATION) return stream << "OBJECT_COLLATION";
    if (value == ObjectType::OBJECT_CONVERSION) return stream << "OBJECT_CONVERSION";
    if (value == ObjectType::OBJECT_DATABASE) return stream << "OBJECT_DATABASE";
    if (value == ObjectType::OBJECT_DEFAULT) return stream << "OBJECT_DEFAULT";
    if (value == ObjectType::OBJECT_DEFACL) return stream << "OBJECT_DEFACL";
    if (value == ObjectType::OBJECT_DOMAIN) return stream << "OBJECT_DOMAIN";
    if (value == ObjectType::OBJECT_DOMCONSTRAINT) return stream << "OBJECT_DOMCONSTRAINT";
    if (value == ObjectType::OBJECT_EVENT_TRIGGER) return stream << "OBJECT_EVENT_TRIGGER";
    if (value == ObjectType::OBJECT_EXTENSION) return stream << "OBJECT_EXTENSION";
    if (value == ObjectType::OBJECT_FDW) return stream << "OBJECT_FDW";
    if (value == ObjectType::OBJECT_FOREIGN_SERVER) return stream << "OBJECT_FOREIGN_SERVER";
    if (value == ObjectType::OBJECT_FOREIGN_TABLE) return stream << "OBJECT_FOREIGN_TABLE";
    if (value == ObjectType::OBJECT_FUNCTION) return stream << "OBJECT_FUNCTION";
    if (value == ObjectType::OBJECT_INDEX) return stream << "OBJECT_INDEX";
    if (value == ObjectType::OBJECT_LANGUAGE) return stream << "OBJECT_LANGUAGE";
    if (value == ObjectType::OBJECT_LARGEOBJECT) return stream << "OBJECT_LARGEOBJECT";
    if (value == ObjectType::OBJECT_MATVIEW) return stream << "OBJECT_MATVIEW";
    if (value == ObjectType::OBJECT_OPCLASS) return stream << "OBJECT_OPCLASS";
    if (value == ObjectType::OBJECT_OPERATOR) return stream << "OBJECT_OPERATOR";
    if (value == ObjectType::OBJECT_OPFAMILY) return stream << "OBJECT_OPFAMILY";
    if (value == ObjectType::OBJECT_POLICY) return stream << "OBJECT_POLICY";
    if (value == ObjectType::OBJECT_PROCEDURE) return stream << "OBJECT_PROCEDURE";
    if (value == ObjectType::OBJECT_PUBLICATION) return stream << "OBJECT_PUBLICATION";
    if (value == ObjectType::OBJECT_PUBLICATION_REL) return stream << "OBJECT_PUBLICATION_REL";
    if (value == ObjectType::OBJECT_ROLE) return stream << "OBJECT_ROLE";
    if (value == ObjectType::OBJECT_ROUTINE) return stream << "OBJECT_ROUTINE";
    if (value == ObjectType::OBJECT_RULE) return stream << "OBJECT_RULE";
    if (value == ObjectType::OBJECT_SCHEMA) return stream << "OBJECT_SCHEMA";
    if (value == ObjectType::OBJECT_SEQUENCE) return stream << "OBJECT_SEQUENCE";
    if (value == ObjectType::OBJECT_SUBSCRIPTION) return stream << "OBJECT_SUBSCRIPTION";
    if (value == ObjectType::OBJECT_STATISTIC_EXT) return stream << "OBJECT_STATISTIC_EXT";
    if (value == ObjectType::OBJECT_TABCONSTRAINT) return stream << "OBJECT_TABCONSTRAINT";
    if (value == ObjectType::OBJECT_TABLE) return stream << "OBJECT_TABLE";
    if (value == ObjectType::OBJECT_TABLESPACE) return stream << "OBJECT_TABLESPACE";
    if (value == ObjectType::OBJECT_TRANSFORM) return stream << "OBJECT_TRANSFORM";
    if (value == ObjectType::OBJECT_TRIGGER) return stream << "OBJECT_TRIGGER";
    if (value == ObjectType::OBJECT_TSCONFIGURATION) return stream << "OBJECT_TSCONFIGURATION";
    if (value == ObjectType::OBJECT_TSDICTIONARY) return stream << "OBJECT_TSDICTIONARY";
    if (value == ObjectType::OBJECT_TSPARSER) return stream << "OBJECT_TSPARSER";
    if (value == ObjectType::OBJECT_TSTEMPLATE) return stream << "OBJECT_TSTEMPLATE";
    if (value == ObjectType::OBJECT_TYPE) return stream << "OBJECT_TYPE";
    if (value == ObjectType::OBJECT_USER_MAPPING) return stream << "OBJECT_USER_MAPPING";
    if (value == ObjectType::OBJECT_VIEW) return stream << "OBJECT_VIEW";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] DropBehavior value)
{
    if (value == DropBehavior::DROP_BEHAVIOR_UNDEFINED) return stream << "DROP_BEHAVIOR_UNDEFINED";
    if (value == DropBehavior::DROP_RESTRICT) return stream << "DROP_RESTRICT";
    if (value == DropBehavior::DROP_CASCADE) return stream << "DROP_CASCADE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AlterTableType value)
{
    if (value == AlterTableType::ALTER_TABLE_TYPE_UNDEFINED) return stream << "ALTER_TABLE_TYPE_UNDEFINED";
    if (value == AlterTableType::AT_AddColumn) return stream << "AT_AddColumn";
    if (value == AlterTableType::AT_AddColumnRecurse) return stream << "AT_AddColumnRecurse";
    if (value == AlterTableType::AT_AddColumnToView) return stream << "AT_AddColumnToView";
    if (value == AlterTableType::AT_ColumnDefault) return stream << "AT_ColumnDefault";
    if (value == AlterTableType::AT_CookedColumnDefault) return stream << "AT_CookedColumnDefault";
    if (value == AlterTableType::AT_DropNotNull) return stream << "AT_DropNotNull";
    if (value == AlterTableType::AT_SetNotNull) return stream << "AT_SetNotNull";
    if (value == AlterTableType::AT_DropExpression) return stream << "AT_DropExpression";
    if (value == AlterTableType::AT_CheckNotNull) return stream << "AT_CheckNotNull";
    if (value == AlterTableType::AT_SetStatistics) return stream << "AT_SetStatistics";
    if (value == AlterTableType::AT_SetOptions) return stream << "AT_SetOptions";
    if (value == AlterTableType::AT_ResetOptions) return stream << "AT_ResetOptions";
    if (value == AlterTableType::AT_SetStorage) return stream << "AT_SetStorage";
    if (value == AlterTableType::AT_DropColumn) return stream << "AT_DropColumn";
    if (value == AlterTableType::AT_DropColumnRecurse) return stream << "AT_DropColumnRecurse";
    if (value == AlterTableType::AT_AddIndex) return stream << "AT_AddIndex";
    if (value == AlterTableType::AT_ReAddIndex) return stream << "AT_ReAddIndex";
    if (value == AlterTableType::AT_AddConstraint) return stream << "AT_AddConstraint";
    if (value == AlterTableType::AT_AddConstraintRecurse) return stream << "AT_AddConstraintRecurse";
    if (value == AlterTableType::AT_ReAddConstraint) return stream << "AT_ReAddConstraint";
    if (value == AlterTableType::AT_ReAddDomainConstraint) return stream << "AT_ReAddDomainConstraint";
    if (value == AlterTableType::AT_AlterConstraint) return stream << "AT_AlterConstraint";
    if (value == AlterTableType::AT_ValidateConstraint) return stream << "AT_ValidateConstraint";
    if (value == AlterTableType::AT_ValidateConstraintRecurse) return stream << "AT_ValidateConstraintRecurse";
    if (value == AlterTableType::AT_AddIndexConstraint) return stream << "AT_AddIndexConstraint";
    if (value == AlterTableType::AT_DropConstraint) return stream << "AT_DropConstraint";
    if (value == AlterTableType::AT_DropConstraintRecurse) return stream << "AT_DropConstraintRecurse";
    if (value == AlterTableType::AT_ReAddComment) return stream << "AT_ReAddComment";
    if (value == AlterTableType::AT_AlterColumnType) return stream << "AT_AlterColumnType";
    if (value == AlterTableType::AT_AlterColumnGenericOptions) return stream << "AT_AlterColumnGenericOptions";
    if (value == AlterTableType::AT_ChangeOwner) return stream << "AT_ChangeOwner";
    if (value == AlterTableType::AT_ClusterOn) return stream << "AT_ClusterOn";
    if (value == AlterTableType::AT_DropCluster) return stream << "AT_DropCluster";
    if (value == AlterTableType::AT_SetLogged) return stream << "AT_SetLogged";
    if (value == AlterTableType::AT_SetUnLogged) return stream << "AT_SetUnLogged";
    if (value == AlterTableType::AT_DropOids) return stream << "AT_DropOids";
    if (value == AlterTableType::AT_SetTableSpace) return stream << "AT_SetTableSpace";
    if (value == AlterTableType::AT_SetRelOptions) return stream << "AT_SetRelOptions";
    if (value == AlterTableType::AT_ResetRelOptions) return stream << "AT_ResetRelOptions";
    if (value == AlterTableType::AT_ReplaceRelOptions) return stream << "AT_ReplaceRelOptions";
    if (value == AlterTableType::AT_EnableTrig) return stream << "AT_EnableTrig";
    if (value == AlterTableType::AT_EnableAlwaysTrig) return stream << "AT_EnableAlwaysTrig";
    if (value == AlterTableType::AT_EnableReplicaTrig) return stream << "AT_EnableReplicaTrig";
    if (value == AlterTableType::AT_DisableTrig) return stream << "AT_DisableTrig";
    if (value == AlterTableType::AT_EnableTrigAll) return stream << "AT_EnableTrigAll";
    if (value == AlterTableType::AT_DisableTrigAll) return stream << "AT_DisableTrigAll";
    if (value == AlterTableType::AT_EnableTrigUser) return stream << "AT_EnableTrigUser";
    if (value == AlterTableType::AT_DisableTrigUser) return stream << "AT_DisableTrigUser";
    if (value == AlterTableType::AT_EnableRule) return stream << "AT_EnableRule";
    if (value == AlterTableType::AT_EnableAlwaysRule) return stream << "AT_EnableAlwaysRule";
    if (value == AlterTableType::AT_EnableReplicaRule) return stream << "AT_EnableReplicaRule";
    if (value == AlterTableType::AT_DisableRule) return stream << "AT_DisableRule";
    if (value == AlterTableType::AT_AddInherit) return stream << "AT_AddInherit";
    if (value == AlterTableType::AT_DropInherit) return stream << "AT_DropInherit";
    if (value == AlterTableType::AT_AddOf) return stream << "AT_AddOf";
    if (value == AlterTableType::AT_DropOf) return stream << "AT_DropOf";
    if (value == AlterTableType::AT_ReplicaIdentity) return stream << "AT_ReplicaIdentity";
    if (value == AlterTableType::AT_EnableRowSecurity) return stream << "AT_EnableRowSecurity";
    if (value == AlterTableType::AT_DisableRowSecurity) return stream << "AT_DisableRowSecurity";
    if (value == AlterTableType::AT_ForceRowSecurity) return stream << "AT_ForceRowSecurity";
    if (value == AlterTableType::AT_NoForceRowSecurity) return stream << "AT_NoForceRowSecurity";
    if (value == AlterTableType::AT_GenericOptions) return stream << "AT_GenericOptions";
    if (value == AlterTableType::AT_AttachPartition) return stream << "AT_AttachPartition";
    if (value == AlterTableType::AT_DetachPartition) return stream << "AT_DetachPartition";
    if (value == AlterTableType::AT_AddIdentity) return stream << "AT_AddIdentity";
    if (value == AlterTableType::AT_SetIdentity) return stream << "AT_SetIdentity";
    if (value == AlterTableType::AT_DropIdentity) return stream << "AT_DropIdentity";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] GrantTargetType value)
{
    if (value == GrantTargetType::GRANT_TARGET_TYPE_UNDEFINED) return stream << "GRANT_TARGET_TYPE_UNDEFINED";
    if (value == GrantTargetType::ACL_TARGET_OBJECT) return stream << "ACL_TARGET_OBJECT";
    if (value == GrantTargetType::ACL_TARGET_ALL_IN_SCHEMA) return stream << "ACL_TARGET_ALL_IN_SCHEMA";
    if (value == GrantTargetType::ACL_TARGET_DEFAULTS) return stream << "ACL_TARGET_DEFAULTS";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] VariableSetKind value)
{
    if (value == VariableSetKind::VARIABLE_SET_KIND_UNDEFINED) return stream << "VARIABLE_SET_KIND_UNDEFINED";
    if (value == VariableSetKind::VAR_SET_VALUE) return stream << "VAR_SET_VALUE";
    if (value == VariableSetKind::VAR_SET_DEFAULT) return stream << "VAR_SET_DEFAULT";
    if (value == VariableSetKind::VAR_SET_CURRENT) return stream << "VAR_SET_CURRENT";
    if (value == VariableSetKind::VAR_SET_MULTI) return stream << "VAR_SET_MULTI";
    if (value == VariableSetKind::VAR_RESET) return stream << "VAR_RESET";
    if (value == VariableSetKind::VAR_RESET_ALL) return stream << "VAR_RESET_ALL";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ConstrType value)
{
    if (value == ConstrType::CONSTR_TYPE_UNDEFINED) return stream << "CONSTR_TYPE_UNDEFINED";
    if (value == ConstrType::CONSTR_NULL) return stream << "CONSTR_NULL";
    if (value == ConstrType::CONSTR_NOTNULL) return stream << "CONSTR_NOTNULL";
    if (value == ConstrType::CONSTR_DEFAULT) return stream << "CONSTR_DEFAULT";
    if (value == ConstrType::CONSTR_IDENTITY) return stream << "CONSTR_IDENTITY";
    if (value == ConstrType::CONSTR_GENERATED) return stream << "CONSTR_GENERATED";
    if (value == ConstrType::CONSTR_CHECK) return stream << "CONSTR_CHECK";
    if (value == ConstrType::CONSTR_PRIMARY) return stream << "CONSTR_PRIMARY";
    if (value == ConstrType::CONSTR_UNIQUE) return stream << "CONSTR_UNIQUE";
    if (value == ConstrType::CONSTR_EXCLUSION) return stream << "CONSTR_EXCLUSION";
    if (value == ConstrType::CONSTR_FOREIGN) return stream << "CONSTR_FOREIGN";
    if (value == ConstrType::CONSTR_ATTR_DEFERRABLE) return stream << "CONSTR_ATTR_DEFERRABLE";
    if (value == ConstrType::CONSTR_ATTR_NOT_DEFERRABLE) return stream << "CONSTR_ATTR_NOT_DEFERRABLE";
    if (value == ConstrType::CONSTR_ATTR_DEFERRED) return stream << "CONSTR_ATTR_DEFERRED";
    if (value == ConstrType::CONSTR_ATTR_IMMEDIATE) return stream << "CONSTR_ATTR_IMMEDIATE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ImportForeignSchemaType value)
{
    if (value == ImportForeignSchemaType::IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED) return stream << "IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED";
    if (value == ImportForeignSchemaType::FDW_IMPORT_SCHEMA_ALL) return stream << "FDW_IMPORT_SCHEMA_ALL";
    if (value == ImportForeignSchemaType::FDW_IMPORT_SCHEMA_LIMIT_TO) return stream << "FDW_IMPORT_SCHEMA_LIMIT_TO";
    if (value == ImportForeignSchemaType::FDW_IMPORT_SCHEMA_EXCEPT) return stream << "FDW_IMPORT_SCHEMA_EXCEPT";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] RoleStmtType value)
{
    if (value == RoleStmtType::ROLE_STMT_TYPE_UNDEFINED) return stream << "ROLE_STMT_TYPE_UNDEFINED";
    if (value == RoleStmtType::ROLESTMT_ROLE) return stream << "ROLESTMT_ROLE";
    if (value == RoleStmtType::ROLESTMT_USER) return stream << "ROLESTMT_USER";
    if (value == RoleStmtType::ROLESTMT_GROUP) return stream << "ROLESTMT_GROUP";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] FetchDirection value)
{
    if (value == FetchDirection::FETCH_DIRECTION_UNDEFINED) return stream << "FETCH_DIRECTION_UNDEFINED";
    if (value == FetchDirection::FETCH_FORWARD) return stream << "FETCH_FORWARD";
    if (value == FetchDirection::FETCH_BACKWARD) return stream << "FETCH_BACKWARD";
    if (value == FetchDirection::FETCH_ABSOLUTE) return stream << "FETCH_ABSOLUTE";
    if (value == FetchDirection::FETCH_RELATIVE) return stream << "FETCH_RELATIVE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] FunctionParameterMode value)
{
    if (value == FunctionParameterMode::FUNCTION_PARAMETER_MODE_UNDEFINED) return stream << "FUNCTION_PARAMETER_MODE_UNDEFINED";
    if (value == FunctionParameterMode::FUNC_PARAM_IN) return stream << "FUNC_PARAM_IN";
    if (value == FunctionParameterMode::FUNC_PARAM_OUT) return stream << "FUNC_PARAM_OUT";
    if (value == FunctionParameterMode::FUNC_PARAM_INOUT) return stream << "FUNC_PARAM_INOUT";
    if (value == FunctionParameterMode::FUNC_PARAM_VARIADIC) return stream << "FUNC_PARAM_VARIADIC";
    if (value == FunctionParameterMode::FUNC_PARAM_TABLE) return stream << "FUNC_PARAM_TABLE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] TransactionStmtKind value)
{
    if (value == TransactionStmtKind::TRANSACTION_STMT_KIND_UNDEFINED) return stream << "TRANSACTION_STMT_KIND_UNDEFINED";
    if (value == TransactionStmtKind::TRANS_STMT_BEGIN) return stream << "TRANS_STMT_BEGIN";
    if (value == TransactionStmtKind::TRANS_STMT_START) return stream << "TRANS_STMT_START";
    if (value == TransactionStmtKind::TRANS_STMT_COMMIT) return stream << "TRANS_STMT_COMMIT";
    if (value == TransactionStmtKind::TRANS_STMT_ROLLBACK) return stream << "TRANS_STMT_ROLLBACK";
    if (value == TransactionStmtKind::TRANS_STMT_SAVEPOINT) return stream << "TRANS_STMT_SAVEPOINT";
    if (value == TransactionStmtKind::TRANS_STMT_RELEASE) return stream << "TRANS_STMT_RELEASE";
    if (value == TransactionStmtKind::TRANS_STMT_ROLLBACK_TO) return stream << "TRANS_STMT_ROLLBACK_TO";
    if (value == TransactionStmtKind::TRANS_STMT_PREPARE) return stream << "TRANS_STMT_PREPARE";
    if (value == TransactionStmtKind::TRANS_STMT_COMMIT_PREPARED) return stream << "TRANS_STMT_COMMIT_PREPARED";
    if (value == TransactionStmtKind::TRANS_STMT_ROLLBACK_PREPARED) return stream << "TRANS_STMT_ROLLBACK_PREPARED";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ViewCheckOption value)
{
    if (value == ViewCheckOption::VIEW_CHECK_OPTION_UNDEFINED) return stream << "VIEW_CHECK_OPTION_UNDEFINED";
    if (value == ViewCheckOption::NO_CHECK_OPTION) return stream << "NO_CHECK_OPTION";
    if (value == ViewCheckOption::LOCAL_CHECK_OPTION) return stream << "LOCAL_CHECK_OPTION";
    if (value == ViewCheckOption::CASCADED_CHECK_OPTION) return stream << "CASCADED_CHECK_OPTION";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ClusterOption value)
{
    if (value == ClusterOption::CLUSTER_OPTION_UNDEFINED) return stream << "CLUSTER_OPTION_UNDEFINED";
    if (value == ClusterOption::CLUOPT_RECHECK) return stream << "CLUOPT_RECHECK";
    if (value == ClusterOption::CLUOPT_VERBOSE) return stream << "CLUOPT_VERBOSE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] DiscardMode value)
{
    if (value == DiscardMode::DISCARD_MODE_UNDEFINED) return stream << "DISCARD_MODE_UNDEFINED";
    if (value == DiscardMode::DISCARD_ALL) return stream << "DISCARD_ALL";
    if (value == DiscardMode::DISCARD_PLANS) return stream << "DISCARD_PLANS";
    if (value == DiscardMode::DISCARD_SEQUENCES) return stream << "DISCARD_SEQUENCES";
    if (value == DiscardMode::DISCARD_TEMP) return stream << "DISCARD_TEMP";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ReindexObjectType value)
{
    if (value == ReindexObjectType::REINDEX_OBJECT_TYPE_UNDEFINED) return stream << "REINDEX_OBJECT_TYPE_UNDEFINED";
    if (value == ReindexObjectType::REINDEX_OBJECT_INDEX) return stream << "REINDEX_OBJECT_INDEX";
    if (value == ReindexObjectType::REINDEX_OBJECT_TABLE) return stream << "REINDEX_OBJECT_TABLE";
    if (value == ReindexObjectType::REINDEX_OBJECT_SCHEMA) return stream << "REINDEX_OBJECT_SCHEMA";
    if (value == ReindexObjectType::REINDEX_OBJECT_SYSTEM) return stream << "REINDEX_OBJECT_SYSTEM";
    if (value == ReindexObjectType::REINDEX_OBJECT_DATABASE) return stream << "REINDEX_OBJECT_DATABASE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AlterTSConfigType value)
{
    if (value == AlterTSConfigType::ALTER_TSCONFIG_TYPE_UNDEFINED) return stream << "ALTER_TSCONFIG_TYPE_UNDEFINED";
    if (value == AlterTSConfigType::ALTER_TSCONFIG_ADD_MAPPING) return stream << "ALTER_TSCONFIG_ADD_MAPPING";
    if (value == AlterTSConfigType::ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN) return stream << "ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN";
    if (value == AlterTSConfigType::ALTER_TSCONFIG_REPLACE_DICT) return stream << "ALTER_TSCONFIG_REPLACE_DICT";
    if (value == AlterTSConfigType::ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN) return stream << "ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN";
    if (value == AlterTSConfigType::ALTER_TSCONFIG_DROP_MAPPING) return stream << "ALTER_TSCONFIG_DROP_MAPPING";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AlterSubscriptionType value)
{
    if (value == AlterSubscriptionType::ALTER_SUBSCRIPTION_TYPE_UNDEFINED) return stream << "ALTER_SUBSCRIPTION_TYPE_UNDEFINED";
    if (value == AlterSubscriptionType::ALTER_SUBSCRIPTION_OPTIONS) return stream << "ALTER_SUBSCRIPTION_OPTIONS";
    if (value == AlterSubscriptionType::ALTER_SUBSCRIPTION_CONNECTION) return stream << "ALTER_SUBSCRIPTION_CONNECTION";
    if (value == AlterSubscriptionType::ALTER_SUBSCRIPTION_PUBLICATION) return stream << "ALTER_SUBSCRIPTION_PUBLICATION";
    if (value == AlterSubscriptionType::ALTER_SUBSCRIPTION_REFRESH) return stream << "ALTER_SUBSCRIPTION_REFRESH";
    if (value == AlterSubscriptionType::ALTER_SUBSCRIPTION_ENABLED) return stream << "ALTER_SUBSCRIPTION_ENABLED";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] OnCommitAction value)
{
    if (value == OnCommitAction::ON_COMMIT_ACTION_UNDEFINED) return stream << "ON_COMMIT_ACTION_UNDEFINED";
    if (value == OnCommitAction::ONCOMMIT_NOOP) return stream << "ONCOMMIT_NOOP";
    if (value == OnCommitAction::ONCOMMIT_PRESERVE_ROWS) return stream << "ONCOMMIT_PRESERVE_ROWS";
    if (value == OnCommitAction::ONCOMMIT_DELETE_ROWS) return stream << "ONCOMMIT_DELETE_ROWS";
    if (value == OnCommitAction::ONCOMMIT_DROP) return stream << "ONCOMMIT_DROP";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ParamKind value)
{
    if (value == ParamKind::PARAM_KIND_UNDEFINED) return stream << "PARAM_KIND_UNDEFINED";
    if (value == ParamKind::PARAM_EXTERN) return stream << "PARAM_EXTERN";
    if (value == ParamKind::PARAM_EXEC) return stream << "PARAM_EXEC";
    if (value == ParamKind::PARAM_SUBLINK) return stream << "PARAM_SUBLINK";
    if (value == ParamKind::PARAM_MULTIEXPR) return stream << "PARAM_MULTIEXPR";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] CoercionContext value)
{
    if (value == CoercionContext::COERCION_CONTEXT_UNDEFINED) return stream << "COERCION_CONTEXT_UNDEFINED";
    if (value == CoercionContext::COERCION_IMPLICIT) return stream << "COERCION_IMPLICIT";
    if (value == CoercionContext::COERCION_ASSIGNMENT) return stream << "COERCION_ASSIGNMENT";
    if (value == CoercionContext::COERCION_EXPLICIT) return stream << "COERCION_EXPLICIT";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] CoercionForm value)
{
    if (value == CoercionForm::COERCION_FORM_UNDEFINED) return stream << "COERCION_FORM_UNDEFINED";
    if (value == CoercionForm::COERCE_EXPLICIT_CALL) return stream << "COERCE_EXPLICIT_CALL";
    if (value == CoercionForm::COERCE_EXPLICIT_CAST) return stream << "COERCE_EXPLICIT_CAST";
    if (value == CoercionForm::COERCE_IMPLICIT_CAST) return stream << "COERCE_IMPLICIT_CAST";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] BoolExprType value)
{
    if (value == BoolExprType::BOOL_EXPR_TYPE_UNDEFINED) return stream << "BOOL_EXPR_TYPE_UNDEFINED";
    if (value == BoolExprType::AND_EXPR) return stream << "AND_EXPR";
    if (value == BoolExprType::OR_EXPR) return stream << "OR_EXPR";
    if (value == BoolExprType::NOT_EXPR) return stream << "NOT_EXPR";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SubLinkType value)
{
    if (value == SubLinkType::SUB_LINK_TYPE_UNDEFINED) return stream << "SUB_LINK_TYPE_UNDEFINED";
    if (value == SubLinkType::EXISTS_SUBLINK) return stream << "EXISTS_SUBLINK";
    if (value == SubLinkType::ALL_SUBLINK) return stream << "ALL_SUBLINK";
    if (value == SubLinkType::ANY_SUBLINK) return stream << "ANY_SUBLINK";
    if (value == SubLinkType::ROWCOMPARE_SUBLINK) return stream << "ROWCOMPARE_SUBLINK";
    if (value == SubLinkType::EXPR_SUBLINK) return stream << "EXPR_SUBLINK";
    if (value == SubLinkType::MULTIEXPR_SUBLINK) return stream << "MULTIEXPR_SUBLINK";
    if (value == SubLinkType::ARRAY_SUBLINK) return stream << "ARRAY_SUBLINK";
    if (value == SubLinkType::CTE_SUBLINK) return stream << "CTE_SUBLINK";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] RowCompareType value)
{
    if (value == RowCompareType::ROW_COMPARE_TYPE_UNDEFINED) return stream << "ROW_COMPARE_TYPE_UNDEFINED";
    if (value == RowCompareType::ROWCOMPARE_LT) return stream << "ROWCOMPARE_LT";
    if (value == RowCompareType::ROWCOMPARE_LE) return stream << "ROWCOMPARE_LE";
    if (value == RowCompareType::ROWCOMPARE_EQ) return stream << "ROWCOMPARE_EQ";
    if (value == RowCompareType::ROWCOMPARE_GE) return stream << "ROWCOMPARE_GE";
    if (value == RowCompareType::ROWCOMPARE_GT) return stream << "ROWCOMPARE_GT";
    if (value == RowCompareType::ROWCOMPARE_NE) return stream << "ROWCOMPARE_NE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] MinMaxOp value)
{
    if (value == MinMaxOp::MIN_MAX_OP_UNDEFINED) return stream << "MIN_MAX_OP_UNDEFINED";
    if (value == MinMaxOp::IS_GREATEST) return stream << "IS_GREATEST";
    if (value == MinMaxOp::IS_LEAST) return stream << "IS_LEAST";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SQLValueFunctionOp value)
{
    if (value == SQLValueFunctionOp::SQLVALUE_FUNCTION_OP_UNDEFINED) return stream << "SQLVALUE_FUNCTION_OP_UNDEFINED";
    if (value == SQLValueFunctionOp::SVFOP_CURRENT_DATE) return stream << "SVFOP_CURRENT_DATE";
    if (value == SQLValueFunctionOp::SVFOP_CURRENT_TIME) return stream << "SVFOP_CURRENT_TIME";
    if (value == SQLValueFunctionOp::SVFOP_CURRENT_TIME_N) return stream << "SVFOP_CURRENT_TIME_N";
    if (value == SQLValueFunctionOp::SVFOP_CURRENT_TIMESTAMP) return stream << "SVFOP_CURRENT_TIMESTAMP";
    if (value == SQLValueFunctionOp::SVFOP_CURRENT_TIMESTAMP_N) return stream << "SVFOP_CURRENT_TIMESTAMP_N";
    if (value == SQLValueFunctionOp::SVFOP_LOCALTIME) return stream << "SVFOP_LOCALTIME";
    if (value == SQLValueFunctionOp::SVFOP_LOCALTIME_N) return stream << "SVFOP_LOCALTIME_N";
    if (value == SQLValueFunctionOp::SVFOP_LOCALTIMESTAMP) return stream << "SVFOP_LOCALTIMESTAMP";
    if (value == SQLValueFunctionOp::SVFOP_LOCALTIMESTAMP_N) return stream << "SVFOP_LOCALTIMESTAMP_N";
    if (value == SQLValueFunctionOp::SVFOP_CURRENT_ROLE) return stream << "SVFOP_CURRENT_ROLE";
    if (value == SQLValueFunctionOp::SVFOP_CURRENT_USER) return stream << "SVFOP_CURRENT_USER";
    if (value == SQLValueFunctionOp::SVFOP_USER) return stream << "SVFOP_USER";
    if (value == SQLValueFunctionOp::SVFOP_SESSION_USER) return stream << "SVFOP_SESSION_USER";
    if (value == SQLValueFunctionOp::SVFOP_CURRENT_CATALOG) return stream << "SVFOP_CURRENT_CATALOG";
    if (value == SQLValueFunctionOp::SVFOP_CURRENT_SCHEMA) return stream << "SVFOP_CURRENT_SCHEMA";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] XmlExprOp value)
{
    if (value == XmlExprOp::XML_EXPR_OP_UNDEFINED) return stream << "XML_EXPR_OP_UNDEFINED";
    if (value == XmlExprOp::IS_XMLCONCAT) return stream << "IS_XMLCONCAT";
    if (value == XmlExprOp::IS_XMLELEMENT) return stream << "IS_XMLELEMENT";
    if (value == XmlExprOp::IS_XMLFOREST) return stream << "IS_XMLFOREST";
    if (value == XmlExprOp::IS_XMLPARSE) return stream << "IS_XMLPARSE";
    if (value == XmlExprOp::IS_XMLPI) return stream << "IS_XMLPI";
    if (value == XmlExprOp::IS_XMLROOT) return stream << "IS_XMLROOT";
    if (value == XmlExprOp::IS_XMLSERIALIZE) return stream << "IS_XMLSERIALIZE";
    if (value == XmlExprOp::IS_DOCUMENT) return stream << "IS_DOCUMENT";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] XmlOptionType value)
{
    if (value == XmlOptionType::XML_OPTION_TYPE_UNDEFINED) return stream << "XML_OPTION_TYPE_UNDEFINED";
    if (value == XmlOptionType::XMLOPTION_DOCUMENT) return stream << "XMLOPTION_DOCUMENT";
    if (value == XmlOptionType::XMLOPTION_CONTENT) return stream << "XMLOPTION_CONTENT";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] NullTestType value)
{
    if (value == NullTestType::NULL_TEST_TYPE_UNDEFINED) return stream << "NULL_TEST_TYPE_UNDEFINED";
    if (value == NullTestType::IS_NULL) return stream << "IS_NULL";
    if (value == NullTestType::IS_NOT_NULL) return stream << "IS_NOT_NULL";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] BoolTestType value)
{
    if (value == BoolTestType::BOOL_TEST_TYPE_UNDEFINED) return stream << "BOOL_TEST_TYPE_UNDEFINED";
    if (value == BoolTestType::IS_TRUE) return stream << "IS_TRUE";
    if (value == BoolTestType::IS_NOT_TRUE) return stream << "IS_NOT_TRUE";
    if (value == BoolTestType::IS_FALSE) return stream << "IS_FALSE";
    if (value == BoolTestType::IS_NOT_FALSE) return stream << "IS_NOT_FALSE";
    if (value == BoolTestType::IS_UNKNOWN) return stream << "IS_UNKNOWN";
    if (value == BoolTestType::IS_NOT_UNKNOWN) return stream << "IS_NOT_UNKNOWN";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] CmdType value)
{
    if (value == CmdType::CMD_TYPE_UNDEFINED) return stream << "CMD_TYPE_UNDEFINED";
    if (value == CmdType::CMD_UNKNOWN) return stream << "CMD_UNKNOWN";
    if (value == CmdType::CMD_SELECT) return stream << "CMD_SELECT";
    if (value == CmdType::CMD_UPDATE) return stream << "CMD_UPDATE";
    if (value == CmdType::CMD_INSERT) return stream << "CMD_INSERT";
    if (value == CmdType::CMD_DELETE) return stream << "CMD_DELETE";
    if (value == CmdType::CMD_UTILITY) return stream << "CMD_UTILITY";
    if (value == CmdType::CMD_NOTHING) return stream << "CMD_NOTHING";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] JoinType value)
{
    if (value == JoinType::JOIN_TYPE_UNDEFINED) return stream << "JOIN_TYPE_UNDEFINED";
    if (value == JoinType::JOIN_INNER) return stream << "JOIN_INNER";
    if (value == JoinType::JOIN_LEFT) return stream << "JOIN_LEFT";
    if (value == JoinType::JOIN_FULL) return stream << "JOIN_FULL";
    if (value == JoinType::JOIN_RIGHT) return stream << "JOIN_RIGHT";
    if (value == JoinType::JOIN_SEMI) return stream << "JOIN_SEMI";
    if (value == JoinType::JOIN_ANTI) return stream << "JOIN_ANTI";
    if (value == JoinType::JOIN_UNIQUE_OUTER) return stream << "JOIN_UNIQUE_OUTER";
    if (value == JoinType::JOIN_UNIQUE_INNER) return stream << "JOIN_UNIQUE_INNER";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AggStrategy value)
{
    if (value == AggStrategy::AGG_STRATEGY_UNDEFINED) return stream << "AGG_STRATEGY_UNDEFINED";
    if (value == AggStrategy::AGG_PLAIN) return stream << "AGG_PLAIN";
    if (value == AggStrategy::AGG_SORTED) return stream << "AGG_SORTED";
    if (value == AggStrategy::AGG_HASHED) return stream << "AGG_HASHED";
    if (value == AggStrategy::AGG_MIXED) return stream << "AGG_MIXED";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AggSplit value)
{
    if (value == AggSplit::AGG_SPLIT_UNDEFINED) return stream << "AGG_SPLIT_UNDEFINED";
    if (value == AggSplit::AGGSPLIT_SIMPLE) return stream << "AGGSPLIT_SIMPLE";
    if (value == AggSplit::AGGSPLIT_INITIAL_SERIAL) return stream << "AGGSPLIT_INITIAL_SERIAL";
    if (value == AggSplit::AGGSPLIT_FINAL_DESERIAL) return stream << "AGGSPLIT_FINAL_DESERIAL";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SetOpCmd value)
{
    if (value == SetOpCmd::SET_OP_CMD_UNDEFINED) return stream << "SET_OP_CMD_UNDEFINED";
    if (value == SetOpCmd::SETOPCMD_INTERSECT) return stream << "SETOPCMD_INTERSECT";
    if (value == SetOpCmd::SETOPCMD_INTERSECT_ALL) return stream << "SETOPCMD_INTERSECT_ALL";
    if (value == SetOpCmd::SETOPCMD_EXCEPT) return stream << "SETOPCMD_EXCEPT";
    if (value == SetOpCmd::SETOPCMD_EXCEPT_ALL) return stream << "SETOPCMD_EXCEPT_ALL";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SetOpStrategy value)
{
    if (value == SetOpStrategy::SET_OP_STRATEGY_UNDEFINED) return stream << "SET_OP_STRATEGY_UNDEFINED";
    if (value == SetOpStrategy::SETOP_SORTED) return stream << "SETOP_SORTED";
    if (value == SetOpStrategy::SETOP_HASHED) return stream << "SETOP_HASHED";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] OnConflictAction value)
{
    if (value == OnConflictAction::ON_CONFLICT_ACTION_UNDEFINED) return stream << "ON_CONFLICT_ACTION_UNDEFINED";
    if (value == OnConflictAction::ONCONFLICT_NONE) return stream << "ONCONFLICT_NONE";
    if (value == OnConflictAction::ONCONFLICT_NOTHING) return stream << "ONCONFLICT_NOTHING";
    if (value == OnConflictAction::ONCONFLICT_UPDATE) return stream << "ONCONFLICT_UPDATE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] LimitOption value)
{
    if (value == LimitOption::LIMIT_OPTION_UNDEFINED) return stream << "LIMIT_OPTION_UNDEFINED";
    if (value == LimitOption::LIMIT_OPTION_DEFAULT) return stream << "LIMIT_OPTION_DEFAULT";
    if (value == LimitOption::LIMIT_OPTION_COUNT) return stream << "LIMIT_OPTION_COUNT";
    if (value == LimitOption::LIMIT_OPTION_WITH_TIES) return stream << "LIMIT_OPTION_WITH_TIES";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] LockClauseStrength value)
{
    if (value == LockClauseStrength::LOCK_CLAUSE_STRENGTH_UNDEFINED) return stream << "LOCK_CLAUSE_STRENGTH_UNDEFINED";
    if (value == LockClauseStrength::LCS_NONE) return stream << "LCS_NONE";
    if (value == LockClauseStrength::LCS_FORKEYSHARE) return stream << "LCS_FORKEYSHARE";
    if (value == LockClauseStrength::LCS_FORSHARE) return stream << "LCS_FORSHARE";
    if (value == LockClauseStrength::LCS_FORNOKEYUPDATE) return stream << "LCS_FORNOKEYUPDATE";
    if (value == LockClauseStrength::LCS_FORUPDATE) return stream << "LCS_FORUPDATE";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] LockWaitPolicy value)
{
    if (value == LockWaitPolicy::LOCK_WAIT_POLICY_UNDEFINED) return stream << "LOCK_WAIT_POLICY_UNDEFINED";
    if (value == LockWaitPolicy::LockWaitBlock) return stream << "LockWaitBlock";
    if (value == LockWaitPolicy::LockWaitSkip) return stream << "LockWaitSkip";
    if (value == LockWaitPolicy::LockWaitError) return stream << "LockWaitError";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] LockTupleMode value)
{
    if (value == LockTupleMode::LOCK_TUPLE_MODE_UNDEFINED) return stream << "LOCK_TUPLE_MODE_UNDEFINED";
    if (value == LockTupleMode::LockTupleKeyShare) return stream << "LockTupleKeyShare";
    if (value == LockTupleMode::LockTupleShare) return stream << "LockTupleShare";
    if (value == LockTupleMode::LockTupleNoKeyExclusive) return stream << "LockTupleNoKeyExclusive";
    if (value == LockTupleMode::LockTupleExclusive) return stream << "LockTupleExclusive";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] KeywordKind value)
{
    if (value == KeywordKind::NO_KEYWORD) return stream << "NO_KEYWORD";
    if (value == KeywordKind::UNRESERVED_KEYWORD) return stream << "UNRESERVED_KEYWORD";
    if (value == KeywordKind::COL_NAME_KEYWORD) return stream << "COL_NAME_KEYWORD";
    if (value == KeywordKind::TYPE_FUNC_NAME_KEYWORD) return stream << "TYPE_FUNC_NAME_KEYWORD";
    if (value == KeywordKind::RESERVED_KEYWORD) return stream << "RESERVED_KEYWORD";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] Token value)
{
    if (value == Token::NUL) return stream << "NUL";
    if (value == Token::ASCII_37) return stream << "ASCII_37";
    if (value == Token::ASCII_40) return stream << "ASCII_40";
    if (value == Token::ASCII_41) return stream << "ASCII_41";
    if (value == Token::ASCII_42) return stream << "ASCII_42";
    if (value == Token::ASCII_43) return stream << "ASCII_43";
    if (value == Token::ASCII_44) return stream << "ASCII_44";
    if (value == Token::ASCII_45) return stream << "ASCII_45";
    if (value == Token::ASCII_46) return stream << "ASCII_46";
    if (value == Token::ASCII_47) return stream << "ASCII_47";
    if (value == Token::ASCII_58) return stream << "ASCII_58";
    if (value == Token::ASCII_59) return stream << "ASCII_59";
    if (value == Token::ASCII_60) return stream << "ASCII_60";
    if (value == Token::ASCII_61) return stream << "ASCII_61";
    if (value == Token::ASCII_62) return stream << "ASCII_62";
    if (value == Token::ASCII_63) return stream << "ASCII_63";
    if (value == Token::ASCII_91) return stream << "ASCII_91";
    if (value == Token::ASCII_92) return stream << "ASCII_92";
    if (value == Token::ASCII_93) return stream << "ASCII_93";
    if (value == Token::ASCII_94) return stream << "ASCII_94";
    if (value == Token::IDENT) return stream << "IDENT";
    if (value == Token::UIDENT) return stream << "UIDENT";
    if (value == Token::FCONST) return stream << "FCONST";
    if (value == Token::SCONST) return stream << "SCONST";
    if (value == Token::USCONST) return stream << "USCONST";
    if (value == Token::BCONST) return stream << "BCONST";
    if (value == Token::XCONST) return stream << "XCONST";
    if (value == Token::Op) return stream << "Op";
    if (value == Token::ICONST) return stream << "ICONST";
    if (value == Token::PARAM) return stream << "PARAM";
    if (value == Token::TYPECAST) return stream << "TYPECAST";
    if (value == Token::DOT_DOT) return stream << "DOT_DOT";
    if (value == Token::COLON_EQUALS) return stream << "COLON_EQUALS";
    if (value == Token::EQUALS_GREATER) return stream << "EQUALS_GREATER";
    if (value == Token::LESS_EQUALS) return stream << "LESS_EQUALS";
    if (value == Token::GREATER_EQUALS) return stream << "GREATER_EQUALS";
    if (value == Token::NOT_EQUALS) return stream << "NOT_EQUALS";
    if (value == Token::SQL_COMMENT) return stream << "SQL_COMMENT";
    if (value == Token::C_COMMENT) return stream << "C_COMMENT";
    if (value == Token::ABORT_P) return stream << "ABORT_P";
    if (value == Token::ABSOLUTE_P) return stream << "ABSOLUTE_P";
    if (value == Token::ACCESS) return stream << "ACCESS";
    if (value == Token::ACTION) return stream << "ACTION";
    if (value == Token::ADD_P) return stream << "ADD_P";
    if (value == Token::ADMIN) return stream << "ADMIN";
    if (value == Token::AFTER) return stream << "AFTER";
    if (value == Token::AGGREGATE) return stream << "AGGREGATE";
    if (value == Token::ALL) return stream << "ALL";
    if (value == Token::ALSO) return stream << "ALSO";
    if (value == Token::ALTER) return stream << "ALTER";
    if (value == Token::ALWAYS) return stream << "ALWAYS";
    if (value == Token::ANALYSE) return stream << "ANALYSE";
    if (value == Token::ANALYZE) return stream << "ANALYZE";
    if (value == Token::AND) return stream << "AND";
    if (value == Token::ANY) return stream << "ANY";
    if (value == Token::ARRAY) return stream << "ARRAY";
    if (value == Token::AS) return stream << "AS";
    if (value == Token::ASC) return stream << "ASC";
    if (value == Token::ASSERTION) return stream << "ASSERTION";
    if (value == Token::ASSIGNMENT) return stream << "ASSIGNMENT";
    if (value == Token::ASYMMETRIC) return stream << "ASYMMETRIC";
    if (value == Token::AT) return stream << "AT";
    if (value == Token::ATTACH) return stream << "ATTACH";
    if (value == Token::ATTRIBUTE) return stream << "ATTRIBUTE";
    if (value == Token::AUTHORIZATION) return stream << "AUTHORIZATION";
    if (value == Token::BACKWARD) return stream << "BACKWARD";
    if (value == Token::BEFORE) return stream << "BEFORE";
    if (value == Token::BEGIN_P) return stream << "BEGIN_P";
    if (value == Token::BETWEEN) return stream << "BETWEEN";
    if (value == Token::BIGINT) return stream << "BIGINT";
    if (value == Token::BINARY) return stream << "BINARY";
    if (value == Token::BIT) return stream << "BIT";
    if (value == Token::BOOLEAN_P) return stream << "BOOLEAN_P";
    if (value == Token::BOTH) return stream << "BOTH";
    if (value == Token::BY) return stream << "BY";
    if (value == Token::CACHE) return stream << "CACHE";
    if (value == Token::CALL) return stream << "CALL";
    if (value == Token::CALLED) return stream << "CALLED";
    if (value == Token::CASCADE) return stream << "CASCADE";
    if (value == Token::CASCADED) return stream << "CASCADED";
    if (value == Token::CASE) return stream << "CASE";
    if (value == Token::CAST) return stream << "CAST";
    if (value == Token::CATALOG_P) return stream << "CATALOG_P";
    if (value == Token::CHAIN) return stream << "CHAIN";
    if (value == Token::CHAR_P) return stream << "CHAR_P";
    if (value == Token::CHARACTER) return stream << "CHARACTER";
    if (value == Token::CHARACTERISTICS) return stream << "CHARACTERISTICS";
    if (value == Token::CHECK) return stream << "CHECK";
    if (value == Token::CHECKPOINT) return stream << "CHECKPOINT";
    if (value == Token::CLASS) return stream << "CLASS";
    if (value == Token::CLOSE) return stream << "CLOSE";
    if (value == Token::CLUSTER) return stream << "CLUSTER";
    if (value == Token::COALESCE) return stream << "COALESCE";
    if (value == Token::COLLATE) return stream << "COLLATE";
    if (value == Token::COLLATION) return stream << "COLLATION";
    if (value == Token::COLUMN) return stream << "COLUMN";
    if (value == Token::COLUMNS) return stream << "COLUMNS";
    if (value == Token::COMMENT) return stream << "COMMENT";
    if (value == Token::COMMENTS) return stream << "COMMENTS";
    if (value == Token::COMMIT) return stream << "COMMIT";
    if (value == Token::COMMITTED) return stream << "COMMITTED";
    if (value == Token::CONCURRENTLY) return stream << "CONCURRENTLY";
    if (value == Token::CONFIGURATION) return stream << "CONFIGURATION";
    if (value == Token::CONFLICT) return stream << "CONFLICT";
    if (value == Token::CONNECTION) return stream << "CONNECTION";
    if (value == Token::CONSTRAINT) return stream << "CONSTRAINT";
    if (value == Token::CONSTRAINTS) return stream << "CONSTRAINTS";
    if (value == Token::CONTENT_P) return stream << "CONTENT_P";
    if (value == Token::CONTINUE_P) return stream << "CONTINUE_P";
    if (value == Token::CONVERSION_P) return stream << "CONVERSION_P";
    if (value == Token::COPY) return stream << "COPY";
    if (value == Token::COST) return stream << "COST";
    if (value == Token::CREATE) return stream << "CREATE";
    if (value == Token::CROSS) return stream << "CROSS";
    if (value == Token::CSV) return stream << "CSV";
    if (value == Token::CUBE) return stream << "CUBE";
    if (value == Token::CURRENT_P) return stream << "CURRENT_P";
    if (value == Token::CURRENT_CATALOG) return stream << "CURRENT_CATALOG";
    if (value == Token::CURRENT_DATE) return stream << "CURRENT_DATE";
    if (value == Token::CURRENT_ROLE) return stream << "CURRENT_ROLE";
    if (value == Token::CURRENT_SCHEMA) return stream << "CURRENT_SCHEMA";
    if (value == Token::CURRENT_TIME) return stream << "CURRENT_TIME";
    if (value == Token::CURRENT_TIMESTAMP) return stream << "CURRENT_TIMESTAMP";
    if (value == Token::CURRENT_USER) return stream << "CURRENT_USER";
    if (value == Token::CURSOR) return stream << "CURSOR";
    if (value == Token::CYCLE) return stream << "CYCLE";
    if (value == Token::DATA_P) return stream << "DATA_P";
    if (value == Token::DATABASE) return stream << "DATABASE";
    if (value == Token::DAY_P) return stream << "DAY_P";
    if (value == Token::DEALLOCATE) return stream << "DEALLOCATE";
    if (value == Token::DEC) return stream << "DEC";
    if (value == Token::DECIMAL_P) return stream << "DECIMAL_P";
    if (value == Token::DECLARE) return stream << "DECLARE";
    if (value == Token::DEFAULT) return stream << "DEFAULT";
    if (value == Token::DEFAULTS) return stream << "DEFAULTS";
    if (value == Token::DEFERRABLE) return stream << "DEFERRABLE";
    if (value == Token::DEFERRED) return stream << "DEFERRED";
    if (value == Token::DEFINER) return stream << "DEFINER";
    if (value == Token::DELETE_P) return stream << "DELETE_P";
    if (value == Token::DELIMITER) return stream << "DELIMITER";
    if (value == Token::DELIMITERS) return stream << "DELIMITERS";
    if (value == Token::DEPENDS) return stream << "DEPENDS";
    if (value == Token::DESC) return stream << "DESC";
    if (value == Token::DETACH) return stream << "DETACH";
    if (value == Token::DICTIONARY) return stream << "DICTIONARY";
    if (value == Token::DISABLE_P) return stream << "DISABLE_P";
    if (value == Token::DISCARD) return stream << "DISCARD";
    if (value == Token::DISTINCT) return stream << "DISTINCT";
    if (value == Token::DO) return stream << "DO";
    if (value == Token::DOCUMENT_P) return stream << "DOCUMENT_P";
    if (value == Token::DOMAIN_P) return stream << "DOMAIN_P";
    if (value == Token::DOUBLE_P) return stream << "DOUBLE_P";
    if (value == Token::DROP) return stream << "DROP";
    if (value == Token::EACH) return stream << "EACH";
    if (value == Token::ELSE) return stream << "ELSE";
    if (value == Token::ENABLE_P) return stream << "ENABLE_P";
    if (value == Token::ENCODING) return stream << "ENCODING";
    if (value == Token::ENCRYPTED) return stream << "ENCRYPTED";
    if (value == Token::END_P) return stream << "END_P";
    if (value == Token::ENUM_P) return stream << "ENUM_P";
    if (value == Token::ESCAPE) return stream << "ESCAPE";
    if (value == Token::EVENT) return stream << "EVENT";
    if (value == Token::EXCEPT) return stream << "EXCEPT";
    if (value == Token::EXCLUDE) return stream << "EXCLUDE";
    if (value == Token::EXCLUDING) return stream << "EXCLUDING";
    if (value == Token::EXCLUSIVE) return stream << "EXCLUSIVE";
    if (value == Token::EXECUTE) return stream << "EXECUTE";
    if (value == Token::EXISTS) return stream << "EXISTS";
    if (value == Token::EXPLAIN) return stream << "EXPLAIN";
    if (value == Token::EXPRESSION) return stream << "EXPRESSION";
    if (value == Token::EXTENSION) return stream << "EXTENSION";
    if (value == Token::EXTERNAL) return stream << "EXTERNAL";
    if (value == Token::EXTRACT) return stream << "EXTRACT";
    if (value == Token::FALSE_P) return stream << "FALSE_P";
    if (value == Token::FAMILY) return stream << "FAMILY";
    if (value == Token::FETCH) return stream << "FETCH";
    if (value == Token::FILTER) return stream << "FILTER";
    if (value == Token::FIRST_P) return stream << "FIRST_P";
    if (value == Token::FLOAT_P) return stream << "FLOAT_P";
    if (value == Token::FOLLOWING) return stream << "FOLLOWING";
    if (value == Token::FOR) return stream << "FOR";
    if (value == Token::FORCE) return stream << "FORCE";
    if (value == Token::FOREIGN) return stream << "FOREIGN";
    if (value == Token::FORWARD) return stream << "FORWARD";
    if (value == Token::FREEZE) return stream << "FREEZE";
    if (value == Token::FROM) return stream << "FROM";
    if (value == Token::FULL) return stream << "FULL";
    if (value == Token::FUNCTION) return stream << "FUNCTION";
    if (value == Token::FUNCTIONS) return stream << "FUNCTIONS";
    if (value == Token::GENERATED) return stream << "GENERATED";
    if (value == Token::GLOBAL) return stream << "GLOBAL";
    if (value == Token::GRANT) return stream << "GRANT";
    if (value == Token::GRANTED) return stream << "GRANTED";
    if (value == Token::GREATEST) return stream << "GREATEST";
    if (value == Token::GROUP_P) return stream << "GROUP_P";
    if (value == Token::GROUPING) return stream << "GROUPING";
    if (value == Token::GROUPS) return stream << "GROUPS";
    if (value == Token::HANDLER) return stream << "HANDLER";
    if (value == Token::HAVING) return stream << "HAVING";
    if (value == Token::HEADER_P) return stream << "HEADER_P";
    if (value == Token::HOLD) return stream << "HOLD";
    if (value == Token::HOUR_P) return stream << "HOUR_P";
    if (value == Token::IDENTITY_P) return stream << "IDENTITY_P";
    if (value == Token::IF_P) return stream << "IF_P";
    if (value == Token::ILIKE) return stream << "ILIKE";
    if (value == Token::IMMEDIATE) return stream << "IMMEDIATE";
    if (value == Token::IMMUTABLE) return stream << "IMMUTABLE";
    if (value == Token::IMPLICIT_P) return stream << "IMPLICIT_P";
    if (value == Token::IMPORT_P) return stream << "IMPORT_P";
    if (value == Token::IN_P) return stream << "IN_P";
    if (value == Token::INCLUDE) return stream << "INCLUDE";
    if (value == Token::INCLUDING) return stream << "INCLUDING";
    if (value == Token::INCREMENT) return stream << "INCREMENT";
    if (value == Token::INDEX) return stream << "INDEX";
    if (value == Token::INDEXES) return stream << "INDEXES";
    if (value == Token::INHERIT) return stream << "INHERIT";
    if (value == Token::INHERITS) return stream << "INHERITS";
    if (value == Token::INITIALLY) return stream << "INITIALLY";
    if (value == Token::INLINE_P) return stream << "INLINE_P";
    if (value == Token::INNER_P) return stream << "INNER_P";
    if (value == Token::INOUT) return stream << "INOUT";
    if (value == Token::INPUT_P) return stream << "INPUT_P";
    if (value == Token::INSENSITIVE) return stream << "INSENSITIVE";
    if (value == Token::INSERT) return stream << "INSERT";
    if (value == Token::INSTEAD) return stream << "INSTEAD";
    if (value == Token::INT_P) return stream << "INT_P";
    if (value == Token::INTEGER) return stream << "INTEGER";
    if (value == Token::INTERSECT) return stream << "INTERSECT";
    if (value == Token::INTERVAL) return stream << "INTERVAL";
    if (value == Token::INTO) return stream << "INTO";
    if (value == Token::INVOKER) return stream << "INVOKER";
    if (value == Token::IS) return stream << "IS";
    if (value == Token::ISNULL) return stream << "ISNULL";
    if (value == Token::ISOLATION) return stream << "ISOLATION";
    if (value == Token::JOIN) return stream << "JOIN";
    if (value == Token::KEY) return stream << "KEY";
    if (value == Token::LABEL) return stream << "LABEL";
    if (value == Token::LANGUAGE) return stream << "LANGUAGE";
    if (value == Token::LARGE_P) return stream << "LARGE_P";
    if (value == Token::LAST_P) return stream << "LAST_P";
    if (value == Token::LATERAL_P) return stream << "LATERAL_P";
    if (value == Token::LEADING) return stream << "LEADING";
    if (value == Token::LEAKPROOF) return stream << "LEAKPROOF";
    if (value == Token::LEAST) return stream << "LEAST";
    if (value == Token::LEFT) return stream << "LEFT";
    if (value == Token::LEVEL) return stream << "LEVEL";
    if (value == Token::LIKE) return stream << "LIKE";
    if (value == Token::LIMIT) return stream << "LIMIT";
    if (value == Token::LISTEN) return stream << "LISTEN";
    if (value == Token::LOAD) return stream << "LOAD";
    if (value == Token::LOCAL) return stream << "LOCAL";
    if (value == Token::LOCALTIME) return stream << "LOCALTIME";
    if (value == Token::LOCALTIMESTAMP) return stream << "LOCALTIMESTAMP";
    if (value == Token::LOCATION) return stream << "LOCATION";
    if (value == Token::LOCK_P) return stream << "LOCK_P";
    if (value == Token::LOCKED) return stream << "LOCKED";
    if (value == Token::LOGGED) return stream << "LOGGED";
    if (value == Token::MAPPING) return stream << "MAPPING";
    if (value == Token::MATCH) return stream << "MATCH";
    if (value == Token::MATERIALIZED) return stream << "MATERIALIZED";
    if (value == Token::MAXVALUE) return stream << "MAXVALUE";
    if (value == Token::METHOD) return stream << "METHOD";
    if (value == Token::MINUTE_P) return stream << "MINUTE_P";
    if (value == Token::MINVALUE) return stream << "MINVALUE";
    if (value == Token::MODE) return stream << "MODE";
    if (value == Token::MONTH_P) return stream << "MONTH_P";
    if (value == Token::MOVE) return stream << "MOVE";
    if (value == Token::NAME_P) return stream << "NAME_P";
    if (value == Token::NAMES) return stream << "NAMES";
    if (value == Token::NATIONAL) return stream << "NATIONAL";
    if (value == Token::NATURAL) return stream << "NATURAL";
    if (value == Token::NCHAR) return stream << "NCHAR";
    if (value == Token::NEW) return stream << "NEW";
    if (value == Token::NEXT) return stream << "NEXT";
    if (value == Token::NFC) return stream << "NFC";
    if (value == Token::NFD) return stream << "NFD";
    if (value == Token::NFKC) return stream << "NFKC";
    if (value == Token::NFKD) return stream << "NFKD";
    if (value == Token::NO) return stream << "NO";
    if (value == Token::NONE) return stream << "NONE";
    if (value == Token::NORMALIZE) return stream << "NORMALIZE";
    if (value == Token::NORMALIZED) return stream << "NORMALIZED";
    if (value == Token::NOT) return stream << "NOT";
    if (value == Token::NOTHING) return stream << "NOTHING";
    if (value == Token::NOTIFY) return stream << "NOTIFY";
    if (value == Token::NOTNULL) return stream << "NOTNULL";
    if (value == Token::NOWAIT) return stream << "NOWAIT";
    if (value == Token::NULL_P) return stream << "NULL_P";
    if (value == Token::NULLIF) return stream << "NULLIF";
    if (value == Token::NULLS_P) return stream << "NULLS_P";
    if (value == Token::NUMERIC) return stream << "NUMERIC";
    if (value == Token::OBJECT_P) return stream << "OBJECT_P";
    if (value == Token::OF) return stream << "OF";
    if (value == Token::OFF) return stream << "OFF";
    if (value == Token::OFFSET) return stream << "OFFSET";
    if (value == Token::OIDS) return stream << "OIDS";
    if (value == Token::OLD) return stream << "OLD";
    if (value == Token::ON) return stream << "ON";
    if (value == Token::ONLY) return stream << "ONLY";
    if (value == Token::OPERATOR) return stream << "OPERATOR";
    if (value == Token::OPTION) return stream << "OPTION";
    if (value == Token::OPTIONS) return stream << "OPTIONS";
    if (value == Token::OR) return stream << "OR";
    if (value == Token::ORDER) return stream << "ORDER";
    if (value == Token::ORDINALITY) return stream << "ORDINALITY";
    if (value == Token::OTHERS) return stream << "OTHERS";
    if (value == Token::OUT_P) return stream << "OUT_P";
    if (value == Token::OUTER_P) return stream << "OUTER_P";
    if (value == Token::OVER) return stream << "OVER";
    if (value == Token::OVERLAPS) return stream << "OVERLAPS";
    if (value == Token::OVERLAY) return stream << "OVERLAY";
    if (value == Token::OVERRIDING) return stream << "OVERRIDING";
    if (value == Token::OWNED) return stream << "OWNED";
    if (value == Token::OWNER) return stream << "OWNER";
    if (value == Token::PARALLEL) return stream << "PARALLEL";
    if (value == Token::PARSER) return stream << "PARSER";
    if (value == Token::PARTIAL) return stream << "PARTIAL";
    if (value == Token::PARTITION) return stream << "PARTITION";
    if (value == Token::PASSING) return stream << "PASSING";
    if (value == Token::PASSWORD) return stream << "PASSWORD";
    if (value == Token::PLACING) return stream << "PLACING";
    if (value == Token::PLANS) return stream << "PLANS";
    if (value == Token::POLICY) return stream << "POLICY";
    if (value == Token::POSITION) return stream << "POSITION";
    if (value == Token::PRECEDING) return stream << "PRECEDING";
    if (value == Token::PRECISION) return stream << "PRECISION";
    if (value == Token::PRESERVE) return stream << "PRESERVE";
    if (value == Token::PREPARE) return stream << "PREPARE";
    if (value == Token::PREPARED) return stream << "PREPARED";
    if (value == Token::PRIMARY) return stream << "PRIMARY";
    if (value == Token::PRIOR) return stream << "PRIOR";
    if (value == Token::PRIVILEGES) return stream << "PRIVILEGES";
    if (value == Token::PROCEDURAL) return stream << "PROCEDURAL";
    if (value == Token::PROCEDURE) return stream << "PROCEDURE";
    if (value == Token::PROCEDURES) return stream << "PROCEDURES";
    if (value == Token::PROGRAM) return stream << "PROGRAM";
    if (value == Token::PUBLICATION) return stream << "PUBLICATION";
    if (value == Token::QUOTE) return stream << "QUOTE";
    if (value == Token::RANGE) return stream << "RANGE";
    if (value == Token::READ) return stream << "READ";
    if (value == Token::REAL) return stream << "REAL";
    if (value == Token::REASSIGN) return stream << "REASSIGN";
    if (value == Token::RECHECK) return stream << "RECHECK";
    if (value == Token::RECURSIVE) return stream << "RECURSIVE";
    if (value == Token::REF) return stream << "REF";
    if (value == Token::REFERENCES) return stream << "REFERENCES";
    if (value == Token::REFERENCING) return stream << "REFERENCING";
    if (value == Token::REFRESH) return stream << "REFRESH";
    if (value == Token::REINDEX) return stream << "REINDEX";
    if (value == Token::RELATIVE_P) return stream << "RELATIVE_P";
    if (value == Token::RELEASE) return stream << "RELEASE";
    if (value == Token::RENAME) return stream << "RENAME";
    if (value == Token::REPEATABLE) return stream << "REPEATABLE";
    if (value == Token::REPLACE) return stream << "REPLACE";
    if (value == Token::REPLICA) return stream << "REPLICA";
    if (value == Token::RESET) return stream << "RESET";
    if (value == Token::RESTART) return stream << "RESTART";
    if (value == Token::RESTRICT) return stream << "RESTRICT";
    if (value == Token::RETURNING) return stream << "RETURNING";
    if (value == Token::RETURNS) return stream << "RETURNS";
    if (value == Token::REVOKE) return stream << "REVOKE";
    if (value == Token::RIGHT) return stream << "RIGHT";
    if (value == Token::ROLE) return stream << "ROLE";
    if (value == Token::ROLLBACK) return stream << "ROLLBACK";
    if (value == Token::ROLLUP) return stream << "ROLLUP";
    if (value == Token::ROUTINE) return stream << "ROUTINE";
    if (value == Token::ROUTINES) return stream << "ROUTINES";
    if (value == Token::ROW) return stream << "ROW";
    if (value == Token::ROWS) return stream << "ROWS";
    if (value == Token::RULE) return stream << "RULE";
    if (value == Token::SAVEPOINT) return stream << "SAVEPOINT";
    if (value == Token::SCHEMA) return stream << "SCHEMA";
    if (value == Token::SCHEMAS) return stream << "SCHEMAS";
    if (value == Token::SCROLL) return stream << "SCROLL";
    if (value == Token::SEARCH) return stream << "SEARCH";
    if (value == Token::SECOND_P) return stream << "SECOND_P";
    if (value == Token::SECURITY) return stream << "SECURITY";
    if (value == Token::SELECT) return stream << "SELECT";
    if (value == Token::SEQUENCE) return stream << "SEQUENCE";
    if (value == Token::SEQUENCES) return stream << "SEQUENCES";
    if (value == Token::SERIALIZABLE) return stream << "SERIALIZABLE";
    if (value == Token::SERVER) return stream << "SERVER";
    if (value == Token::SESSION) return stream << "SESSION";
    if (value == Token::SESSION_USER) return stream << "SESSION_USER";
    if (value == Token::SET) return stream << "SET";
    if (value == Token::SETS) return stream << "SETS";
    if (value == Token::SETOF) return stream << "SETOF";
    if (value == Token::SHARE) return stream << "SHARE";
    if (value == Token::SHOW) return stream << "SHOW";
    if (value == Token::SIMILAR) return stream << "SIMILAR";
    if (value == Token::SIMPLE) return stream << "SIMPLE";
    if (value == Token::SKIP) return stream << "SKIP";
    if (value == Token::SMALLINT) return stream << "SMALLINT";
    if (value == Token::SNAPSHOT) return stream << "SNAPSHOT";
    if (value == Token::SOME) return stream << "SOME";
    if (value == Token::SQL_P) return stream << "SQL_P";
    if (value == Token::STABLE) return stream << "STABLE";
    if (value == Token::STANDALONE_P) return stream << "STANDALONE_P";
    if (value == Token::START) return stream << "START";
    if (value == Token::STATEMENT) return stream << "STATEMENT";
    if (value == Token::STATISTICS) return stream << "STATISTICS";
    if (value == Token::STDIN) return stream << "STDIN";
    if (value == Token::STDOUT) return stream << "STDOUT";
    if (value == Token::STORAGE) return stream << "STORAGE";
    if (value == Token::STORED) return stream << "STORED";
    if (value == Token::STRICT_P) return stream << "STRICT_P";
    if (value == Token::STRIP_P) return stream << "STRIP_P";
    if (value == Token::SUBSCRIPTION) return stream << "SUBSCRIPTION";
    if (value == Token::SUBSTRING) return stream << "SUBSTRING";
    if (value == Token::SUPPORT) return stream << "SUPPORT";
    if (value == Token::SYMMETRIC) return stream << "SYMMETRIC";
    if (value == Token::SYSID) return stream << "SYSID";
    if (value == Token::SYSTEM_P) return stream << "SYSTEM_P";
    if (value == Token::TABLE) return stream << "TABLE";
    if (value == Token::TABLES) return stream << "TABLES";
    if (value == Token::TABLESAMPLE) return stream << "TABLESAMPLE";
    if (value == Token::TABLESPACE) return stream << "TABLESPACE";
    if (value == Token::TEMP) return stream << "TEMP";
    if (value == Token::TEMPLATE) return stream << "TEMPLATE";
    if (value == Token::TEMPORARY) return stream << "TEMPORARY";
    if (value == Token::TEXT_P) return stream << "TEXT_P";
    if (value == Token::THEN) return stream << "THEN";
    if (value == Token::TIES) return stream << "TIES";
    if (value == Token::TIME) return stream << "TIME";
    if (value == Token::TIMESTAMP) return stream << "TIMESTAMP";
    if (value == Token::TO) return stream << "TO";
    if (value == Token::TRAILING) return stream << "TRAILING";
    if (value == Token::TRANSACTION) return stream << "TRANSACTION";
    if (value == Token::TRANSFORM) return stream << "TRANSFORM";
    if (value == Token::TREAT) return stream << "TREAT";
    if (value == Token::TRIGGER) return stream << "TRIGGER";
    if (value == Token::TRIM) return stream << "TRIM";
    if (value == Token::TRUE_P) return stream << "TRUE_P";
    if (value == Token::TRUNCATE) return stream << "TRUNCATE";
    if (value == Token::TRUSTED) return stream << "TRUSTED";
    if (value == Token::TYPE_P) return stream << "TYPE_P";
    if (value == Token::TYPES_P) return stream << "TYPES_P";
    if (value == Token::UESCAPE) return stream << "UESCAPE";
    if (value == Token::UNBOUNDED) return stream << "UNBOUNDED";
    if (value == Token::UNCOMMITTED) return stream << "UNCOMMITTED";
    if (value == Token::UNENCRYPTED) return stream << "UNENCRYPTED";
    if (value == Token::UNION) return stream << "UNION";
    if (value == Token::UNIQUE) return stream << "UNIQUE";
    if (value == Token::UNKNOWN) return stream << "UNKNOWN";
    if (value == Token::UNLISTEN) return stream << "UNLISTEN";
    if (value == Token::UNLOGGED) return stream << "UNLOGGED";
    if (value == Token::UNTIL) return stream << "UNTIL";
    if (value == Token::UPDATE) return stream << "UPDATE";
    if (value == Token::USER) return stream << "USER";
    if (value == Token::USING) return stream << "USING";
    if (value == Token::VACUUM) return stream << "VACUUM";
    if (value == Token::VALID) return stream << "VALID";
    if (value == Token::VALIDATE) return stream << "VALIDATE";
    if (value == Token::VALIDATOR) return stream << "VALIDATOR";
    if (value == Token::VALUE_P) return stream << "VALUE_P";
    if (value == Token::VALUES) return stream << "VALUES";
    if (value == Token::VARCHAR) return stream << "VARCHAR";
    if (value == Token::VARIADIC) return stream << "VARIADIC";
    if (value == Token::VARYING) return stream << "VARYING";
    if (value == Token::VERBOSE) return stream << "VERBOSE";
    if (value == Token::VERSION_P) return stream << "VERSION_P";
    if (value == Token::VIEW) return stream << "VIEW";
    if (value == Token::VIEWS) return stream << "VIEWS";
    if (value == Token::VOLATILE) return stream << "VOLATILE";
    if (value == Token::WHEN) return stream << "WHEN";
    if (value == Token::WHERE) return stream << "WHERE";
    if (value == Token::WHITESPACE_P) return stream << "WHITESPACE_P";
    if (value == Token::WINDOW) return stream << "WINDOW";
    if (value == Token::WITH) return stream << "WITH";
    if (value == Token::WITHIN) return stream << "WITHIN";
    if (value == Token::WITHOUT) return stream << "WITHOUT";
    if (value == Token::WORK) return stream << "WORK";
    if (value == Token::WRAPPER) return stream << "WRAPPER";
    if (value == Token::WRITE) return stream << "WRITE";
    if (value == Token::XML_P) return stream << "XML_P";
    if (value == Token::XMLATTRIBUTES) return stream << "XMLATTRIBUTES";
    if (value == Token::XMLCONCAT) return stream << "XMLCONCAT";
    if (value == Token::XMLELEMENT) return stream << "XMLELEMENT";
    if (value == Token::XMLEXISTS) return stream << "XMLEXISTS";
    if (value == Token::XMLFOREST) return stream << "XMLFOREST";
    if (value == Token::XMLNAMESPACES) return stream << "XMLNAMESPACES";
    if (value == Token::XMLPARSE) return stream << "XMLPARSE";
    if (value == Token::XMLPI) return stream << "XMLPI";
    if (value == Token::XMLROOT) return stream << "XMLROOT";
    if (value == Token::XMLSERIALIZE) return stream << "XMLSERIALIZE";
    if (value == Token::XMLTABLE) return stream << "XMLTABLE";
    if (value == Token::YEAR_P) return stream << "YEAR_P";
    if (value == Token::YES_P) return stream << "YES_P";
    if (value == Token::ZONE) return stream << "ZONE";
    if (value == Token::NOT_LA) return stream << "NOT_LA";
    if (value == Token::NULLS_LA) return stream << "NULLS_LA";
    if (value == Token::WITH_LA) return stream << "WITH_LA";
    if (value == Token::POSTFIXOP) return stream << "POSTFIXOP";
    if (value == Token::UMINUS) return stream << "UMINUS";
    return stream << "<unknown>";
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Node& value)
{
    std::visit(
        overloaded
        {
            [&stream](auto& ptr) { if(ptr != nullptr) stream << *ptr; },
        },
        value);
    return stream;
}

Integer::Integer()
    : ival((int32_t)0ll)
{}

Integer::Integer(int32_t arg_ival)
    : ival(arg_ival)
{}

Integer::Integer(Integer&& other) noexcept
    : ival(std::exchange(other.ival, (int32_t)0ll))
{}

Integer::~Integer()
{
}

bool Integer::operator==([[maybe_unused]] const Integer& other) const noexcept
{
    return (
        true
        );
}

bool Integer::operator<([[maybe_unused]] const Integer& other) const noexcept
{
    return false;
}

Integer& Integer::operator=(Integer&& other) noexcept
{
    if (this != &other)
    {
        ival = std::exchange(other.ival, (int32_t)0ll);
    }
    return *this;
}

std::string Integer::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Integer::swap(Integer& other) noexcept
{
    using std::swap;
    swap(ival, other.ival);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Integer& value)
{
    stream << "Integer(";
    stream << "ival="; stream << value.ival;
    stream << ")";
    return stream;
}

Float::Float()
    : str()
{}

Float::Float(const std::string& arg_str)
    : str(arg_str)
{}

Float::Float(Float&& other) noexcept
    : str(std::move(other.str))
{}

Float::~Float()
{
}

bool Float::operator==([[maybe_unused]] const Float& other) const noexcept
{
    return (
        true
        );
}

bool Float::operator<([[maybe_unused]] const Float& other) const noexcept
{
    return false;
}

Float& Float::operator=(Float&& other) noexcept
{
    if (this != &other)
    {
        str = std::move(other.str);
    }
    return *this;
}

std::string Float::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Float::swap(Float& other) noexcept
{
    using std::swap;
    swap(str, other.str);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Float& value)
{
    stream << "Float(";
    stream << "str="; stream << "\"" << value.str << "\"";
    stream << ")";
    return stream;
}

String::String()
    : str()
{}

String::String(const std::string& arg_str)
    : str(arg_str)
{}

String::String(String&& other) noexcept
    : str(std::move(other.str))
{}

String::~String()
{
}

bool String::operator==([[maybe_unused]] const String& other) const noexcept
{
    return (
        true
        );
}

bool String::operator<([[maybe_unused]] const String& other) const noexcept
{
    return false;
}

String& String::operator=(String&& other) noexcept
{
    if (this != &other)
    {
        str = std::move(other.str);
    }
    return *this;
}

std::string String::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void String::swap(String& other) noexcept
{
    using std::swap;
    swap(str, other.str);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const String& value)
{
    stream << "String(";
    stream << "str="; stream << "\"" << value.str << "\"";
    stream << ")";
    return stream;
}

BitString::BitString()
    : str()
{}

BitString::BitString(const std::string& arg_str)
    : str(arg_str)
{}

BitString::BitString(BitString&& other) noexcept
    : str(std::move(other.str))
{}

BitString::~BitString()
{
}

bool BitString::operator==([[maybe_unused]] const BitString& other) const noexcept
{
    return (
        true
        );
}

bool BitString::operator<([[maybe_unused]] const BitString& other) const noexcept
{
    return false;
}

BitString& BitString::operator=(BitString&& other) noexcept
{
    if (this != &other)
    {
        str = std::move(other.str);
    }
    return *this;
}

std::string BitString::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void BitString::swap(BitString& other) noexcept
{
    using std::swap;
    swap(str, other.str);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const BitString& value)
{
    stream << "BitString(";
    stream << "str="; stream << "\"" << value.str << "\"";
    stream << ")";
    return stream;
}

Null::Null()
{}

Null::Null(Null&& other) noexcept
{}

Null::~Null()
{
}

bool Null::operator==([[maybe_unused]] const Null& other) const noexcept
{
    return (
        true
        );
}

bool Null::operator<([[maybe_unused]] const Null& other) const noexcept
{
    return false;
}

Null& Null::operator=(Null&& other) noexcept
{
    if (this != &other)
    {
    }
    return *this;
}

std::string Null::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Null::swap(Null& other) noexcept
{
    using std::swap;
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Null& value)
{
    stream << "Null(";
    stream << ")";
    return stream;
}

List::List()
    : items()
{}

List::List(std::vector<::pg_query::Node> arg_items)
    : items(std::move(arg_items))
{}

List::List(List&& other) noexcept
    : items(std::move(other.items))
{}

List::~List()
{
}

bool List::operator==([[maybe_unused]] const List& other) const noexcept
{
    return (
        true
        );
}

bool List::operator<([[maybe_unused]] const List& other) const noexcept
{
    return false;
}

List& List::operator=(List&& other) noexcept
{
    if (this != &other)
    {
        items = std::move(other.items);
    }
    return *this;
}

std::string List::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void List::swap(List& other) noexcept
{
    using std::swap;
    swap(items, other.items);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const List& value)
{
    stream << "List(";
    {
        bool first = true;
        stream << "items=[" << value.items.size() << "][";
        for (const auto& it : value.items)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

OidList::OidList()
    : items()
{}

OidList::OidList(std::vector<::pg_query::Node> arg_items)
    : items(std::move(arg_items))
{}

OidList::OidList(OidList&& other) noexcept
    : items(std::move(other.items))
{}

OidList::~OidList()
{
}

bool OidList::operator==([[maybe_unused]] const OidList& other) const noexcept
{
    return (
        true
        );
}

bool OidList::operator<([[maybe_unused]] const OidList& other) const noexcept
{
    return false;
}

OidList& OidList::operator=(OidList&& other) noexcept
{
    if (this != &other)
    {
        items = std::move(other.items);
    }
    return *this;
}

std::string OidList::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void OidList::swap(OidList& other) noexcept
{
    using std::swap;
    swap(items, other.items);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const OidList& value)
{
    stream << "OidList(";
    {
        bool first = true;
        stream << "items=[" << value.items.size() << "][";
        for (const auto& it : value.items)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

IntList::IntList()
    : items()
{}

IntList::IntList(std::vector<::pg_query::Node> arg_items)
    : items(std::move(arg_items))
{}

IntList::IntList(IntList&& other) noexcept
    : items(std::move(other.items))
{}

IntList::~IntList()
{
}

bool IntList::operator==([[maybe_unused]] const IntList& other) const noexcept
{
    return (
        true
        );
}

bool IntList::operator<([[maybe_unused]] const IntList& other) const noexcept
{
    return false;
}

IntList& IntList::operator=(IntList&& other) noexcept
{
    if (this != &other)
    {
        items = std::move(other.items);
    }
    return *this;
}

std::string IntList::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void IntList::swap(IntList& other) noexcept
{
    using std::swap;
    swap(items, other.items);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const IntList& value)
{
    stream << "IntList(";
    {
        bool first = true;
        stream << "items=[" << value.items.size() << "][";
        for (const auto& it : value.items)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

Alias::Alias()
    : aliasname()
    , colnames()
{}

Alias::Alias(const std::string& arg_aliasname, std::vector<::pg_query::Node> arg_colnames)
    : aliasname(arg_aliasname)
    , colnames(std::move(arg_colnames))
{}

Alias::Alias(Alias&& other) noexcept
    : aliasname(std::move(other.aliasname))
    , colnames(std::move(other.colnames))
{}

Alias::~Alias()
{
}

bool Alias::operator==([[maybe_unused]] const Alias& other) const noexcept
{
    return (
        true
        );
}

bool Alias::operator<([[maybe_unused]] const Alias& other) const noexcept
{
    return false;
}

Alias& Alias::operator=(Alias&& other) noexcept
{
    if (this != &other)
    {
        aliasname = std::move(other.aliasname);
        colnames = std::move(other.colnames);
    }
    return *this;
}

std::string Alias::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Alias::swap(Alias& other) noexcept
{
    using std::swap;
    swap(aliasname, other.aliasname);
    swap(colnames, other.colnames);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Alias& value)
{
    stream << "Alias(";
    stream << "aliasname="; stream << "\"" << value.aliasname << "\"";
    {
        bool first = true;
        stream << ",colnames=[" << value.colnames.size() << "][";
        for (const auto& it : value.colnames)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

RangeVar::RangeVar()
    : catalogname()
    , schemaname()
    , relname()
    , inh(false)
    , relpersistence()
    , alias(nullptr)
    , location((int32_t)0ll)
{}

RangeVar::RangeVar(const std::string& arg_catalogname, const std::string& arg_schemaname, const std::string& arg_relname, bool arg_inh, const std::string& arg_relpersistence, std::unique_ptr<::pg_query::Alias> arg_alias, int32_t arg_location)
    : catalogname(arg_catalogname)
    , schemaname(arg_schemaname)
    , relname(arg_relname)
    , inh(arg_inh)
    , relpersistence(arg_relpersistence)
    , alias(arg_alias.release())
    , location(arg_location)
{}

RangeVar::RangeVar(RangeVar&& other) noexcept
    : catalogname(std::move(other.catalogname))
    , schemaname(std::move(other.schemaname))
    , relname(std::move(other.relname))
    , inh(std::exchange(other.inh, false))
    , relpersistence(std::move(other.relpersistence))
    , alias(std::exchange(other.alias, nullptr))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

RangeVar::~RangeVar()
{
    if (alias) delete alias;
}

bool RangeVar::operator==([[maybe_unused]] const RangeVar& other) const noexcept
{
    return (
        true
        );
}

bool RangeVar::operator<([[maybe_unused]] const RangeVar& other) const noexcept
{
    return false;
}

RangeVar& RangeVar::operator=(RangeVar&& other) noexcept
{
    if (this != &other)
    {
        catalogname = std::move(other.catalogname);
        schemaname = std::move(other.schemaname);
        relname = std::move(other.relname);
        inh = std::exchange(other.inh, false);
        relpersistence = std::move(other.relpersistence);
        alias = std::exchange(other.alias, nullptr);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string RangeVar::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RangeVar::swap(RangeVar& other) noexcept
{
    using std::swap;
    swap(catalogname, other.catalogname);
    swap(schemaname, other.schemaname);
    swap(relname, other.relname);
    swap(inh, other.inh);
    swap(relpersistence, other.relpersistence);
    swap(alias, other.alias);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RangeVar& value)
{
    stream << "RangeVar(";
    stream << "catalogname="; stream << "\"" << value.catalogname << "\"";
    stream << ",schemaname="; stream << "\"" << value.schemaname << "\"";
    stream << ",relname="; stream << "\"" << value.relname << "\"";
    stream << ",inh="; stream << (value.inh ? "true" : "false");
    stream << ",relpersistence="; stream << "\"" << value.relpersistence << "\"";
    stream << ",alias="; stream << " ptr of other struct" << (value.alias == nullptr ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

TableFunc::TableFunc()
    : ns_uris()
    , ns_names()
    , docexpr()
    , rowexpr()
    , colnames()
    , coltypes()
    , coltypmods()
    , colcollations()
    , colexprs()
    , coldefexprs()
    , notnulls()
    , ordinalitycol((int32_t)0ll)
    , location((int32_t)0ll)
{}

TableFunc::TableFunc(std::vector<::pg_query::Node> arg_ns_uris, std::vector<::pg_query::Node> arg_ns_names, ::pg_query::Node&& arg_docexpr, ::pg_query::Node&& arg_rowexpr, std::vector<::pg_query::Node> arg_colnames, std::vector<::pg_query::Node> arg_coltypes, std::vector<::pg_query::Node> arg_coltypmods, std::vector<::pg_query::Node> arg_colcollations, std::vector<::pg_query::Node> arg_colexprs, std::vector<::pg_query::Node> arg_coldefexprs, std::vector<uint64_t> arg_notnulls, int32_t arg_ordinalitycol, int32_t arg_location)
    : ns_uris(std::move(arg_ns_uris))
    , ns_names(std::move(arg_ns_names))
    , docexpr(std::move(arg_docexpr))
    , rowexpr(std::move(arg_rowexpr))
    , colnames(std::move(arg_colnames))
    , coltypes(std::move(arg_coltypes))
    , coltypmods(std::move(arg_coltypmods))
    , colcollations(std::move(arg_colcollations))
    , colexprs(std::move(arg_colexprs))
    , coldefexprs(std::move(arg_coldefexprs))
    , notnulls(arg_notnulls)
    , ordinalitycol(arg_ordinalitycol)
    , location(arg_location)
{}

TableFunc::TableFunc(TableFunc&& other) noexcept
    : ns_uris(std::move(other.ns_uris))
    , ns_names(std::move(other.ns_names))
    , docexpr(std::move(other.docexpr))
    , rowexpr(std::move(other.rowexpr))
    , colnames(std::move(other.colnames))
    , coltypes(std::move(other.coltypes))
    , coltypmods(std::move(other.coltypmods))
    , colcollations(std::move(other.colcollations))
    , colexprs(std::move(other.colexprs))
    , coldefexprs(std::move(other.coldefexprs))
    , notnulls(std::move(other.notnulls))
    , ordinalitycol(std::exchange(other.ordinalitycol, (int32_t)0ll))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

TableFunc::~TableFunc()
{
}

bool TableFunc::operator==([[maybe_unused]] const TableFunc& other) const noexcept
{
    return (
        true
        );
}

bool TableFunc::operator<([[maybe_unused]] const TableFunc& other) const noexcept
{
    return false;
}

TableFunc& TableFunc::operator=(TableFunc&& other) noexcept
{
    if (this != &other)
    {
        ns_uris = std::move(other.ns_uris);
        ns_names = std::move(other.ns_names);
        docexpr = std::move(other.docexpr);
        rowexpr = std::move(other.rowexpr);
        colnames = std::move(other.colnames);
        coltypes = std::move(other.coltypes);
        coltypmods = std::move(other.coltypmods);
        colcollations = std::move(other.colcollations);
        colexprs = std::move(other.colexprs);
        coldefexprs = std::move(other.coldefexprs);
        notnulls = std::move(other.notnulls);
        ordinalitycol = std::exchange(other.ordinalitycol, (int32_t)0ll);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string TableFunc::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void TableFunc::swap(TableFunc& other) noexcept
{
    using std::swap;
    swap(ns_uris, other.ns_uris);
    swap(ns_names, other.ns_names);
    swap(docexpr, other.docexpr);
    swap(rowexpr, other.rowexpr);
    swap(colnames, other.colnames);
    swap(coltypes, other.coltypes);
    swap(coltypmods, other.coltypmods);
    swap(colcollations, other.colcollations);
    swap(colexprs, other.colexprs);
    swap(coldefexprs, other.coldefexprs);
    swap(notnulls, other.notnulls);
    swap(ordinalitycol, other.ordinalitycol);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const TableFunc& value)
{
    stream << "TableFunc(";
    {
        bool first = true;
        stream << "ns_uris=[" << value.ns_uris.size() << "][";
        for (const auto& it : value.ns_uris)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",ns_names=[" << value.ns_names.size() << "][";
        for (const auto& it : value.ns_names)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",docexpr="; stream << value.docexpr;
    stream << ",rowexpr="; stream << value.rowexpr;
    {
        bool first = true;
        stream << ",colnames=[" << value.colnames.size() << "][";
        for (const auto& it : value.colnames)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",coltypes=[" << value.coltypes.size() << "][";
        for (const auto& it : value.coltypes)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",coltypmods=[" << value.coltypmods.size() << "][";
        for (const auto& it : value.coltypmods)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",colcollations=[" << value.colcollations.size() << "][";
        for (const auto& it : value.colcollations)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",colexprs=[" << value.colexprs.size() << "][";
        for (const auto& it : value.colexprs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",coldefexprs=[" << value.coldefexprs.size() << "][";
        for (const auto& it : value.coldefexprs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",notnulls=[" << value.notnulls.size() << "][";
        for (const auto& it : value.notnulls)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",ordinalitycol="; stream << value.ordinalitycol;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

Expr::Expr()
{}

Expr::Expr(Expr&& other) noexcept
{}

Expr::~Expr()
{
}

bool Expr::operator==([[maybe_unused]] const Expr& other) const noexcept
{
    return (
        true
        );
}

bool Expr::operator<([[maybe_unused]] const Expr& other) const noexcept
{
    return false;
}

Expr& Expr::operator=(Expr&& other) noexcept
{
    if (this != &other)
    {
    }
    return *this;
}

std::string Expr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Expr::swap(Expr& other) noexcept
{
    using std::swap;
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Expr& value)
{
    stream << "Expr(";
    stream << ")";
    return stream;
}

Var::Var()
    : xpr()
    , varno((uint32_t)0ull)
    , varattno((int32_t)0ll)
    , vartype((uint32_t)0ull)
    , vartypmod((int32_t)0ll)
    , varcollid((uint32_t)0ull)
    , varlevelsup((uint32_t)0ull)
    , varnosyn((uint32_t)0ull)
    , varattnosyn((int32_t)0ll)
    , location((int32_t)0ll)
{}

Var::Var(::pg_query::Node&& arg_xpr, uint32_t arg_varno, int32_t arg_varattno, uint32_t arg_vartype, int32_t arg_vartypmod, uint32_t arg_varcollid, uint32_t arg_varlevelsup, uint32_t arg_varnosyn, int32_t arg_varattnosyn, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , varno(arg_varno)
    , varattno(arg_varattno)
    , vartype(arg_vartype)
    , vartypmod(arg_vartypmod)
    , varcollid(arg_varcollid)
    , varlevelsup(arg_varlevelsup)
    , varnosyn(arg_varnosyn)
    , varattnosyn(arg_varattnosyn)
    , location(arg_location)
{}

Var::Var(Var&& other) noexcept
    : xpr(std::move(other.xpr))
    , varno(std::exchange(other.varno, (uint32_t)0ull))
    , varattno(std::exchange(other.varattno, (int32_t)0ll))
    , vartype(std::exchange(other.vartype, (uint32_t)0ull))
    , vartypmod(std::exchange(other.vartypmod, (int32_t)0ll))
    , varcollid(std::exchange(other.varcollid, (uint32_t)0ull))
    , varlevelsup(std::exchange(other.varlevelsup, (uint32_t)0ull))
    , varnosyn(std::exchange(other.varnosyn, (uint32_t)0ull))
    , varattnosyn(std::exchange(other.varattnosyn, (int32_t)0ll))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

Var::~Var()
{
}

bool Var::operator==([[maybe_unused]] const Var& other) const noexcept
{
    return (
        true
        );
}

bool Var::operator<([[maybe_unused]] const Var& other) const noexcept
{
    return false;
}

Var& Var::operator=(Var&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        varno = std::exchange(other.varno, (uint32_t)0ull);
        varattno = std::exchange(other.varattno, (int32_t)0ll);
        vartype = std::exchange(other.vartype, (uint32_t)0ull);
        vartypmod = std::exchange(other.vartypmod, (int32_t)0ll);
        varcollid = std::exchange(other.varcollid, (uint32_t)0ull);
        varlevelsup = std::exchange(other.varlevelsup, (uint32_t)0ull);
        varnosyn = std::exchange(other.varnosyn, (uint32_t)0ull);
        varattnosyn = std::exchange(other.varattnosyn, (int32_t)0ll);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string Var::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Var::swap(Var& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(varno, other.varno);
    swap(varattno, other.varattno);
    swap(vartype, other.vartype);
    swap(vartypmod, other.vartypmod);
    swap(varcollid, other.varcollid);
    swap(varlevelsup, other.varlevelsup);
    swap(varnosyn, other.varnosyn);
    swap(varattnosyn, other.varattnosyn);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Var& value)
{
    stream << "Var(";
    stream << "xpr="; stream << value.xpr;
    stream << ",varno="; stream << value.varno;
    stream << ",varattno="; stream << value.varattno;
    stream << ",vartype="; stream << value.vartype;
    stream << ",vartypmod="; stream << value.vartypmod;
    stream << ",varcollid="; stream << value.varcollid;
    stream << ",varlevelsup="; stream << value.varlevelsup;
    stream << ",varnosyn="; stream << value.varnosyn;
    stream << ",varattnosyn="; stream << value.varattnosyn;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

Param::Param()
    : xpr()
    , paramkind()
    , paramid((int32_t)0ll)
    , paramtype((uint32_t)0ull)
    , paramtypmod((int32_t)0ll)
    , paramcollid((uint32_t)0ull)
    , location((int32_t)0ll)
{}

Param::Param(::pg_query::Node&& arg_xpr, ::pg_query::ParamKind&& arg_paramkind, int32_t arg_paramid, uint32_t arg_paramtype, int32_t arg_paramtypmod, uint32_t arg_paramcollid, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , paramkind(std::move(arg_paramkind))
    , paramid(arg_paramid)
    , paramtype(arg_paramtype)
    , paramtypmod(arg_paramtypmod)
    , paramcollid(arg_paramcollid)
    , location(arg_location)
{}

Param::Param(Param&& other) noexcept
    : xpr(std::move(other.xpr))
    , paramkind(std::move(other.paramkind))
    , paramid(std::exchange(other.paramid, (int32_t)0ll))
    , paramtype(std::exchange(other.paramtype, (uint32_t)0ull))
    , paramtypmod(std::exchange(other.paramtypmod, (int32_t)0ll))
    , paramcollid(std::exchange(other.paramcollid, (uint32_t)0ull))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

Param::~Param()
{
}

bool Param::operator==([[maybe_unused]] const Param& other) const noexcept
{
    return (
        true
        );
}

bool Param::operator<([[maybe_unused]] const Param& other) const noexcept
{
    return false;
}

Param& Param::operator=(Param&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        paramkind = std::move(other.paramkind);
        paramid = std::exchange(other.paramid, (int32_t)0ll);
        paramtype = std::exchange(other.paramtype, (uint32_t)0ull);
        paramtypmod = std::exchange(other.paramtypmod, (int32_t)0ll);
        paramcollid = std::exchange(other.paramcollid, (uint32_t)0ull);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string Param::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Param::swap(Param& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(paramkind, other.paramkind);
    swap(paramid, other.paramid);
    swap(paramtype, other.paramtype);
    swap(paramtypmod, other.paramtypmod);
    swap(paramcollid, other.paramcollid);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Param& value)
{
    stream << "Param(";
    stream << "xpr="; stream << value.xpr;
    stream << ",paramkind="; stream << value.paramkind;
    stream << ",paramid="; stream << value.paramid;
    stream << ",paramtype="; stream << value.paramtype;
    stream << ",paramtypmod="; stream << value.paramtypmod;
    stream << ",paramcollid="; stream << value.paramcollid;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

Aggref::Aggref()
    : xpr()
    , aggfnoid((uint32_t)0ull)
    , aggtype((uint32_t)0ull)
    , aggcollid((uint32_t)0ull)
    , inputcollid((uint32_t)0ull)
    , aggtranstype((uint32_t)0ull)
    , aggargtypes()
    , aggdirectargs()
    , args()
    , aggorder()
    , aggdistinct()
    , aggfilter()
    , aggstar(false)
    , aggvariadic(false)
    , aggkind()
    , agglevelsup((uint32_t)0ull)
    , aggsplit()
    , location((int32_t)0ll)
{}

Aggref::Aggref(::pg_query::Node&& arg_xpr, uint32_t arg_aggfnoid, uint32_t arg_aggtype, uint32_t arg_aggcollid, uint32_t arg_inputcollid, uint32_t arg_aggtranstype, std::vector<::pg_query::Node> arg_aggargtypes, std::vector<::pg_query::Node> arg_aggdirectargs, std::vector<::pg_query::Node> arg_args, std::vector<::pg_query::Node> arg_aggorder, std::vector<::pg_query::Node> arg_aggdistinct, ::pg_query::Node&& arg_aggfilter, bool arg_aggstar, bool arg_aggvariadic, const std::string& arg_aggkind, uint32_t arg_agglevelsup, ::pg_query::AggSplit&& arg_aggsplit, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , aggfnoid(arg_aggfnoid)
    , aggtype(arg_aggtype)
    , aggcollid(arg_aggcollid)
    , inputcollid(arg_inputcollid)
    , aggtranstype(arg_aggtranstype)
    , aggargtypes(std::move(arg_aggargtypes))
    , aggdirectargs(std::move(arg_aggdirectargs))
    , args(std::move(arg_args))
    , aggorder(std::move(arg_aggorder))
    , aggdistinct(std::move(arg_aggdistinct))
    , aggfilter(std::move(arg_aggfilter))
    , aggstar(arg_aggstar)
    , aggvariadic(arg_aggvariadic)
    , aggkind(arg_aggkind)
    , agglevelsup(arg_agglevelsup)
    , aggsplit(std::move(arg_aggsplit))
    , location(arg_location)
{}

Aggref::Aggref(Aggref&& other) noexcept
    : xpr(std::move(other.xpr))
    , aggfnoid(std::exchange(other.aggfnoid, (uint32_t)0ull))
    , aggtype(std::exchange(other.aggtype, (uint32_t)0ull))
    , aggcollid(std::exchange(other.aggcollid, (uint32_t)0ull))
    , inputcollid(std::exchange(other.inputcollid, (uint32_t)0ull))
    , aggtranstype(std::exchange(other.aggtranstype, (uint32_t)0ull))
    , aggargtypes(std::move(other.aggargtypes))
    , aggdirectargs(std::move(other.aggdirectargs))
    , args(std::move(other.args))
    , aggorder(std::move(other.aggorder))
    , aggdistinct(std::move(other.aggdistinct))
    , aggfilter(std::move(other.aggfilter))
    , aggstar(std::exchange(other.aggstar, false))
    , aggvariadic(std::exchange(other.aggvariadic, false))
    , aggkind(std::move(other.aggkind))
    , agglevelsup(std::exchange(other.agglevelsup, (uint32_t)0ull))
    , aggsplit(std::move(other.aggsplit))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

Aggref::~Aggref()
{
}

bool Aggref::operator==([[maybe_unused]] const Aggref& other) const noexcept
{
    return (
        true
        );
}

bool Aggref::operator<([[maybe_unused]] const Aggref& other) const noexcept
{
    return false;
}

Aggref& Aggref::operator=(Aggref&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        aggfnoid = std::exchange(other.aggfnoid, (uint32_t)0ull);
        aggtype = std::exchange(other.aggtype, (uint32_t)0ull);
        aggcollid = std::exchange(other.aggcollid, (uint32_t)0ull);
        inputcollid = std::exchange(other.inputcollid, (uint32_t)0ull);
        aggtranstype = std::exchange(other.aggtranstype, (uint32_t)0ull);
        aggargtypes = std::move(other.aggargtypes);
        aggdirectargs = std::move(other.aggdirectargs);
        args = std::move(other.args);
        aggorder = std::move(other.aggorder);
        aggdistinct = std::move(other.aggdistinct);
        aggfilter = std::move(other.aggfilter);
        aggstar = std::exchange(other.aggstar, false);
        aggvariadic = std::exchange(other.aggvariadic, false);
        aggkind = std::move(other.aggkind);
        agglevelsup = std::exchange(other.agglevelsup, (uint32_t)0ull);
        aggsplit = std::move(other.aggsplit);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string Aggref::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Aggref::swap(Aggref& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(aggfnoid, other.aggfnoid);
    swap(aggtype, other.aggtype);
    swap(aggcollid, other.aggcollid);
    swap(inputcollid, other.inputcollid);
    swap(aggtranstype, other.aggtranstype);
    swap(aggargtypes, other.aggargtypes);
    swap(aggdirectargs, other.aggdirectargs);
    swap(args, other.args);
    swap(aggorder, other.aggorder);
    swap(aggdistinct, other.aggdistinct);
    swap(aggfilter, other.aggfilter);
    swap(aggstar, other.aggstar);
    swap(aggvariadic, other.aggvariadic);
    swap(aggkind, other.aggkind);
    swap(agglevelsup, other.agglevelsup);
    swap(aggsplit, other.aggsplit);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Aggref& value)
{
    stream << "Aggref(";
    stream << "xpr="; stream << value.xpr;
    stream << ",aggfnoid="; stream << value.aggfnoid;
    stream << ",aggtype="; stream << value.aggtype;
    stream << ",aggcollid="; stream << value.aggcollid;
    stream << ",inputcollid="; stream << value.inputcollid;
    stream << ",aggtranstype="; stream << value.aggtranstype;
    {
        bool first = true;
        stream << ",aggargtypes=[" << value.aggargtypes.size() << "][";
        for (const auto& it : value.aggargtypes)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",aggdirectargs=[" << value.aggdirectargs.size() << "][";
        for (const auto& it : value.aggdirectargs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",aggorder=[" << value.aggorder.size() << "][";
        for (const auto& it : value.aggorder)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",aggdistinct=[" << value.aggdistinct.size() << "][";
        for (const auto& it : value.aggdistinct)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",aggfilter="; stream << value.aggfilter;
    stream << ",aggstar="; stream << (value.aggstar ? "true" : "false");
    stream << ",aggvariadic="; stream << (value.aggvariadic ? "true" : "false");
    stream << ",aggkind="; stream << "\"" << value.aggkind << "\"";
    stream << ",agglevelsup="; stream << value.agglevelsup;
    stream << ",aggsplit="; stream << value.aggsplit;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

GroupingFunc::GroupingFunc()
    : xpr()
    , args()
    , refs()
    , cols()
    , agglevelsup((uint32_t)0ull)
    , location((int32_t)0ll)
{}

GroupingFunc::GroupingFunc(::pg_query::Node&& arg_xpr, std::vector<::pg_query::Node> arg_args, std::vector<::pg_query::Node> arg_refs, std::vector<::pg_query::Node> arg_cols, uint32_t arg_agglevelsup, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , args(std::move(arg_args))
    , refs(std::move(arg_refs))
    , cols(std::move(arg_cols))
    , agglevelsup(arg_agglevelsup)
    , location(arg_location)
{}

GroupingFunc::GroupingFunc(GroupingFunc&& other) noexcept
    : xpr(std::move(other.xpr))
    , args(std::move(other.args))
    , refs(std::move(other.refs))
    , cols(std::move(other.cols))
    , agglevelsup(std::exchange(other.agglevelsup, (uint32_t)0ull))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

GroupingFunc::~GroupingFunc()
{
}

bool GroupingFunc::operator==([[maybe_unused]] const GroupingFunc& other) const noexcept
{
    return (
        true
        );
}

bool GroupingFunc::operator<([[maybe_unused]] const GroupingFunc& other) const noexcept
{
    return false;
}

GroupingFunc& GroupingFunc::operator=(GroupingFunc&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        args = std::move(other.args);
        refs = std::move(other.refs);
        cols = std::move(other.cols);
        agglevelsup = std::exchange(other.agglevelsup, (uint32_t)0ull);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string GroupingFunc::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void GroupingFunc::swap(GroupingFunc& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(args, other.args);
    swap(refs, other.refs);
    swap(cols, other.cols);
    swap(agglevelsup, other.agglevelsup);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const GroupingFunc& value)
{
    stream << "GroupingFunc(";
    stream << "xpr="; stream << value.xpr;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",refs=[" << value.refs.size() << "][";
        for (const auto& it : value.refs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",cols=[" << value.cols.size() << "][";
        for (const auto& it : value.cols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",agglevelsup="; stream << value.agglevelsup;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

WindowFunc::WindowFunc()
    : xpr()
    , winfnoid((uint32_t)0ull)
    , wintype((uint32_t)0ull)
    , wincollid((uint32_t)0ull)
    , inputcollid((uint32_t)0ull)
    , args()
    , aggfilter()
    , winref((uint32_t)0ull)
    , winstar(false)
    , winagg(false)
    , location((int32_t)0ll)
{}

WindowFunc::WindowFunc(::pg_query::Node&& arg_xpr, uint32_t arg_winfnoid, uint32_t arg_wintype, uint32_t arg_wincollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, ::pg_query::Node&& arg_aggfilter, uint32_t arg_winref, bool arg_winstar, bool arg_winagg, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , winfnoid(arg_winfnoid)
    , wintype(arg_wintype)
    , wincollid(arg_wincollid)
    , inputcollid(arg_inputcollid)
    , args(std::move(arg_args))
    , aggfilter(std::move(arg_aggfilter))
    , winref(arg_winref)
    , winstar(arg_winstar)
    , winagg(arg_winagg)
    , location(arg_location)
{}

WindowFunc::WindowFunc(WindowFunc&& other) noexcept
    : xpr(std::move(other.xpr))
    , winfnoid(std::exchange(other.winfnoid, (uint32_t)0ull))
    , wintype(std::exchange(other.wintype, (uint32_t)0ull))
    , wincollid(std::exchange(other.wincollid, (uint32_t)0ull))
    , inputcollid(std::exchange(other.inputcollid, (uint32_t)0ull))
    , args(std::move(other.args))
    , aggfilter(std::move(other.aggfilter))
    , winref(std::exchange(other.winref, (uint32_t)0ull))
    , winstar(std::exchange(other.winstar, false))
    , winagg(std::exchange(other.winagg, false))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

WindowFunc::~WindowFunc()
{
}

bool WindowFunc::operator==([[maybe_unused]] const WindowFunc& other) const noexcept
{
    return (
        true
        );
}

bool WindowFunc::operator<([[maybe_unused]] const WindowFunc& other) const noexcept
{
    return false;
}

WindowFunc& WindowFunc::operator=(WindowFunc&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        winfnoid = std::exchange(other.winfnoid, (uint32_t)0ull);
        wintype = std::exchange(other.wintype, (uint32_t)0ull);
        wincollid = std::exchange(other.wincollid, (uint32_t)0ull);
        inputcollid = std::exchange(other.inputcollid, (uint32_t)0ull);
        args = std::move(other.args);
        aggfilter = std::move(other.aggfilter);
        winref = std::exchange(other.winref, (uint32_t)0ull);
        winstar = std::exchange(other.winstar, false);
        winagg = std::exchange(other.winagg, false);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string WindowFunc::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void WindowFunc::swap(WindowFunc& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(winfnoid, other.winfnoid);
    swap(wintype, other.wintype);
    swap(wincollid, other.wincollid);
    swap(inputcollid, other.inputcollid);
    swap(args, other.args);
    swap(aggfilter, other.aggfilter);
    swap(winref, other.winref);
    swap(winstar, other.winstar);
    swap(winagg, other.winagg);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const WindowFunc& value)
{
    stream << "WindowFunc(";
    stream << "xpr="; stream << value.xpr;
    stream << ",winfnoid="; stream << value.winfnoid;
    stream << ",wintype="; stream << value.wintype;
    stream << ",wincollid="; stream << value.wincollid;
    stream << ",inputcollid="; stream << value.inputcollid;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",aggfilter="; stream << value.aggfilter;
    stream << ",winref="; stream << value.winref;
    stream << ",winstar="; stream << (value.winstar ? "true" : "false");
    stream << ",winagg="; stream << (value.winagg ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

SubscriptingRef::SubscriptingRef()
    : xpr()
    , refcontainertype((uint32_t)0ull)
    , refelemtype((uint32_t)0ull)
    , reftypmod((int32_t)0ll)
    , refcollid((uint32_t)0ull)
    , refupperindexpr()
    , reflowerindexpr()
    , refexpr()
    , refassgnexpr()
{}

SubscriptingRef::SubscriptingRef(::pg_query::Node&& arg_xpr, uint32_t arg_refcontainertype, uint32_t arg_refelemtype, int32_t arg_reftypmod, uint32_t arg_refcollid, std::vector<::pg_query::Node> arg_refupperindexpr, std::vector<::pg_query::Node> arg_reflowerindexpr, ::pg_query::Node&& arg_refexpr, ::pg_query::Node&& arg_refassgnexpr)
    : xpr(std::move(arg_xpr))
    , refcontainertype(arg_refcontainertype)
    , refelemtype(arg_refelemtype)
    , reftypmod(arg_reftypmod)
    , refcollid(arg_refcollid)
    , refupperindexpr(std::move(arg_refupperindexpr))
    , reflowerindexpr(std::move(arg_reflowerindexpr))
    , refexpr(std::move(arg_refexpr))
    , refassgnexpr(std::move(arg_refassgnexpr))
{}

SubscriptingRef::SubscriptingRef(SubscriptingRef&& other) noexcept
    : xpr(std::move(other.xpr))
    , refcontainertype(std::exchange(other.refcontainertype, (uint32_t)0ull))
    , refelemtype(std::exchange(other.refelemtype, (uint32_t)0ull))
    , reftypmod(std::exchange(other.reftypmod, (int32_t)0ll))
    , refcollid(std::exchange(other.refcollid, (uint32_t)0ull))
    , refupperindexpr(std::move(other.refupperindexpr))
    , reflowerindexpr(std::move(other.reflowerindexpr))
    , refexpr(std::move(other.refexpr))
    , refassgnexpr(std::move(other.refassgnexpr))
{}

SubscriptingRef::~SubscriptingRef()
{
}

bool SubscriptingRef::operator==([[maybe_unused]] const SubscriptingRef& other) const noexcept
{
    return (
        true
        );
}

bool SubscriptingRef::operator<([[maybe_unused]] const SubscriptingRef& other) const noexcept
{
    return false;
}

SubscriptingRef& SubscriptingRef::operator=(SubscriptingRef&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        refcontainertype = std::exchange(other.refcontainertype, (uint32_t)0ull);
        refelemtype = std::exchange(other.refelemtype, (uint32_t)0ull);
        reftypmod = std::exchange(other.reftypmod, (int32_t)0ll);
        refcollid = std::exchange(other.refcollid, (uint32_t)0ull);
        refupperindexpr = std::move(other.refupperindexpr);
        reflowerindexpr = std::move(other.reflowerindexpr);
        refexpr = std::move(other.refexpr);
        refassgnexpr = std::move(other.refassgnexpr);
    }
    return *this;
}

std::string SubscriptingRef::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SubscriptingRef::swap(SubscriptingRef& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(refcontainertype, other.refcontainertype);
    swap(refelemtype, other.refelemtype);
    swap(reftypmod, other.reftypmod);
    swap(refcollid, other.refcollid);
    swap(refupperindexpr, other.refupperindexpr);
    swap(reflowerindexpr, other.reflowerindexpr);
    swap(refexpr, other.refexpr);
    swap(refassgnexpr, other.refassgnexpr);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SubscriptingRef& value)
{
    stream << "SubscriptingRef(";
    stream << "xpr="; stream << value.xpr;
    stream << ",refcontainertype="; stream << value.refcontainertype;
    stream << ",refelemtype="; stream << value.refelemtype;
    stream << ",reftypmod="; stream << value.reftypmod;
    stream << ",refcollid="; stream << value.refcollid;
    {
        bool first = true;
        stream << ",refupperindexpr=[" << value.refupperindexpr.size() << "][";
        for (const auto& it : value.refupperindexpr)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",reflowerindexpr=[" << value.reflowerindexpr.size() << "][";
        for (const auto& it : value.reflowerindexpr)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",refexpr="; stream << value.refexpr;
    stream << ",refassgnexpr="; stream << value.refassgnexpr;
    stream << ")";
    return stream;
}

FuncExpr::FuncExpr()
    : xpr()
    , funcid((uint32_t)0ull)
    , funcresulttype((uint32_t)0ull)
    , funcretset(false)
    , funcvariadic(false)
    , funcformat()
    , funccollid((uint32_t)0ull)
    , inputcollid((uint32_t)0ull)
    , args()
    , location((int32_t)0ll)
{}

FuncExpr::FuncExpr(::pg_query::Node&& arg_xpr, uint32_t arg_funcid, uint32_t arg_funcresulttype, bool arg_funcretset, bool arg_funcvariadic, ::pg_query::CoercionForm&& arg_funcformat, uint32_t arg_funccollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , funcid(arg_funcid)
    , funcresulttype(arg_funcresulttype)
    , funcretset(arg_funcretset)
    , funcvariadic(arg_funcvariadic)
    , funcformat(std::move(arg_funcformat))
    , funccollid(arg_funccollid)
    , inputcollid(arg_inputcollid)
    , args(std::move(arg_args))
    , location(arg_location)
{}

FuncExpr::FuncExpr(FuncExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , funcid(std::exchange(other.funcid, (uint32_t)0ull))
    , funcresulttype(std::exchange(other.funcresulttype, (uint32_t)0ull))
    , funcretset(std::exchange(other.funcretset, false))
    , funcvariadic(std::exchange(other.funcvariadic, false))
    , funcformat(std::move(other.funcformat))
    , funccollid(std::exchange(other.funccollid, (uint32_t)0ull))
    , inputcollid(std::exchange(other.inputcollid, (uint32_t)0ull))
    , args(std::move(other.args))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

FuncExpr::~FuncExpr()
{
}

bool FuncExpr::operator==([[maybe_unused]] const FuncExpr& other) const noexcept
{
    return (
        true
        );
}

bool FuncExpr::operator<([[maybe_unused]] const FuncExpr& other) const noexcept
{
    return false;
}

FuncExpr& FuncExpr::operator=(FuncExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        funcid = std::exchange(other.funcid, (uint32_t)0ull);
        funcresulttype = std::exchange(other.funcresulttype, (uint32_t)0ull);
        funcretset = std::exchange(other.funcretset, false);
        funcvariadic = std::exchange(other.funcvariadic, false);
        funcformat = std::move(other.funcformat);
        funccollid = std::exchange(other.funccollid, (uint32_t)0ull);
        inputcollid = std::exchange(other.inputcollid, (uint32_t)0ull);
        args = std::move(other.args);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string FuncExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void FuncExpr::swap(FuncExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(funcid, other.funcid);
    swap(funcresulttype, other.funcresulttype);
    swap(funcretset, other.funcretset);
    swap(funcvariadic, other.funcvariadic);
    swap(funcformat, other.funcformat);
    swap(funccollid, other.funccollid);
    swap(inputcollid, other.inputcollid);
    swap(args, other.args);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const FuncExpr& value)
{
    stream << "FuncExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",funcid="; stream << value.funcid;
    stream << ",funcresulttype="; stream << value.funcresulttype;
    stream << ",funcretset="; stream << (value.funcretset ? "true" : "false");
    stream << ",funcvariadic="; stream << (value.funcvariadic ? "true" : "false");
    stream << ",funcformat="; stream << value.funcformat;
    stream << ",funccollid="; stream << value.funccollid;
    stream << ",inputcollid="; stream << value.inputcollid;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

NamedArgExpr::NamedArgExpr()
    : xpr()
    , arg()
    , name()
    , argnumber((int32_t)0ll)
    , location((int32_t)0ll)
{}

NamedArgExpr::NamedArgExpr(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, const std::string& arg_name, int32_t arg_argnumber, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , name(arg_name)
    , argnumber(arg_argnumber)
    , location(arg_location)
{}

NamedArgExpr::NamedArgExpr(NamedArgExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , name(std::move(other.name))
    , argnumber(std::exchange(other.argnumber, (int32_t)0ll))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

NamedArgExpr::~NamedArgExpr()
{
}

bool NamedArgExpr::operator==([[maybe_unused]] const NamedArgExpr& other) const noexcept
{
    return (
        true
        );
}

bool NamedArgExpr::operator<([[maybe_unused]] const NamedArgExpr& other) const noexcept
{
    return false;
}

NamedArgExpr& NamedArgExpr::operator=(NamedArgExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        name = std::move(other.name);
        argnumber = std::exchange(other.argnumber, (int32_t)0ll);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string NamedArgExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void NamedArgExpr::swap(NamedArgExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(name, other.name);
    swap(argnumber, other.argnumber);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const NamedArgExpr& value)
{
    stream << "NamedArgExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",name="; stream << "\"" << value.name << "\"";
    stream << ",argnumber="; stream << value.argnumber;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

OpExpr::OpExpr()
    : xpr()
    , opno((uint32_t)0ull)
    , opfuncid((uint32_t)0ull)
    , opresulttype((uint32_t)0ull)
    , opretset(false)
    , opcollid((uint32_t)0ull)
    , inputcollid((uint32_t)0ull)
    , args()
    , location((int32_t)0ll)
{}

OpExpr::OpExpr(::pg_query::Node&& arg_xpr, uint32_t arg_opno, uint32_t arg_opfuncid, uint32_t arg_opresulttype, bool arg_opretset, uint32_t arg_opcollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , opno(arg_opno)
    , opfuncid(arg_opfuncid)
    , opresulttype(arg_opresulttype)
    , opretset(arg_opretset)
    , opcollid(arg_opcollid)
    , inputcollid(arg_inputcollid)
    , args(std::move(arg_args))
    , location(arg_location)
{}

OpExpr::OpExpr(OpExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , opno(std::exchange(other.opno, (uint32_t)0ull))
    , opfuncid(std::exchange(other.opfuncid, (uint32_t)0ull))
    , opresulttype(std::exchange(other.opresulttype, (uint32_t)0ull))
    , opretset(std::exchange(other.opretset, false))
    , opcollid(std::exchange(other.opcollid, (uint32_t)0ull))
    , inputcollid(std::exchange(other.inputcollid, (uint32_t)0ull))
    , args(std::move(other.args))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

OpExpr::~OpExpr()
{
}

bool OpExpr::operator==([[maybe_unused]] const OpExpr& other) const noexcept
{
    return (
        true
        );
}

bool OpExpr::operator<([[maybe_unused]] const OpExpr& other) const noexcept
{
    return false;
}

OpExpr& OpExpr::operator=(OpExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        opno = std::exchange(other.opno, (uint32_t)0ull);
        opfuncid = std::exchange(other.opfuncid, (uint32_t)0ull);
        opresulttype = std::exchange(other.opresulttype, (uint32_t)0ull);
        opretset = std::exchange(other.opretset, false);
        opcollid = std::exchange(other.opcollid, (uint32_t)0ull);
        inputcollid = std::exchange(other.inputcollid, (uint32_t)0ull);
        args = std::move(other.args);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string OpExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void OpExpr::swap(OpExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(opno, other.opno);
    swap(opfuncid, other.opfuncid);
    swap(opresulttype, other.opresulttype);
    swap(opretset, other.opretset);
    swap(opcollid, other.opcollid);
    swap(inputcollid, other.inputcollid);
    swap(args, other.args);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const OpExpr& value)
{
    stream << "OpExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",opno="; stream << value.opno;
    stream << ",opfuncid="; stream << value.opfuncid;
    stream << ",opresulttype="; stream << value.opresulttype;
    stream << ",opretset="; stream << (value.opretset ? "true" : "false");
    stream << ",opcollid="; stream << value.opcollid;
    stream << ",inputcollid="; stream << value.inputcollid;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

DistinctExpr::DistinctExpr()
    : xpr()
    , opno((uint32_t)0ull)
    , opfuncid((uint32_t)0ull)
    , opresulttype((uint32_t)0ull)
    , opretset(false)
    , opcollid((uint32_t)0ull)
    , inputcollid((uint32_t)0ull)
    , args()
    , location((int32_t)0ll)
{}

DistinctExpr::DistinctExpr(::pg_query::Node&& arg_xpr, uint32_t arg_opno, uint32_t arg_opfuncid, uint32_t arg_opresulttype, bool arg_opretset, uint32_t arg_opcollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , opno(arg_opno)
    , opfuncid(arg_opfuncid)
    , opresulttype(arg_opresulttype)
    , opretset(arg_opretset)
    , opcollid(arg_opcollid)
    , inputcollid(arg_inputcollid)
    , args(std::move(arg_args))
    , location(arg_location)
{}

DistinctExpr::DistinctExpr(DistinctExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , opno(std::exchange(other.opno, (uint32_t)0ull))
    , opfuncid(std::exchange(other.opfuncid, (uint32_t)0ull))
    , opresulttype(std::exchange(other.opresulttype, (uint32_t)0ull))
    , opretset(std::exchange(other.opretset, false))
    , opcollid(std::exchange(other.opcollid, (uint32_t)0ull))
    , inputcollid(std::exchange(other.inputcollid, (uint32_t)0ull))
    , args(std::move(other.args))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

DistinctExpr::~DistinctExpr()
{
}

bool DistinctExpr::operator==([[maybe_unused]] const DistinctExpr& other) const noexcept
{
    return (
        true
        );
}

bool DistinctExpr::operator<([[maybe_unused]] const DistinctExpr& other) const noexcept
{
    return false;
}

DistinctExpr& DistinctExpr::operator=(DistinctExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        opno = std::exchange(other.opno, (uint32_t)0ull);
        opfuncid = std::exchange(other.opfuncid, (uint32_t)0ull);
        opresulttype = std::exchange(other.opresulttype, (uint32_t)0ull);
        opretset = std::exchange(other.opretset, false);
        opcollid = std::exchange(other.opcollid, (uint32_t)0ull);
        inputcollid = std::exchange(other.inputcollid, (uint32_t)0ull);
        args = std::move(other.args);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string DistinctExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DistinctExpr::swap(DistinctExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(opno, other.opno);
    swap(opfuncid, other.opfuncid);
    swap(opresulttype, other.opresulttype);
    swap(opretset, other.opretset);
    swap(opcollid, other.opcollid);
    swap(inputcollid, other.inputcollid);
    swap(args, other.args);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DistinctExpr& value)
{
    stream << "DistinctExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",opno="; stream << value.opno;
    stream << ",opfuncid="; stream << value.opfuncid;
    stream << ",opresulttype="; stream << value.opresulttype;
    stream << ",opretset="; stream << (value.opretset ? "true" : "false");
    stream << ",opcollid="; stream << value.opcollid;
    stream << ",inputcollid="; stream << value.inputcollid;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

NullIfExpr::NullIfExpr()
    : xpr()
    , opno((uint32_t)0ull)
    , opfuncid((uint32_t)0ull)
    , opresulttype((uint32_t)0ull)
    , opretset(false)
    , opcollid((uint32_t)0ull)
    , inputcollid((uint32_t)0ull)
    , args()
    , location((int32_t)0ll)
{}

NullIfExpr::NullIfExpr(::pg_query::Node&& arg_xpr, uint32_t arg_opno, uint32_t arg_opfuncid, uint32_t arg_opresulttype, bool arg_opretset, uint32_t arg_opcollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , opno(arg_opno)
    , opfuncid(arg_opfuncid)
    , opresulttype(arg_opresulttype)
    , opretset(arg_opretset)
    , opcollid(arg_opcollid)
    , inputcollid(arg_inputcollid)
    , args(std::move(arg_args))
    , location(arg_location)
{}

NullIfExpr::NullIfExpr(NullIfExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , opno(std::exchange(other.opno, (uint32_t)0ull))
    , opfuncid(std::exchange(other.opfuncid, (uint32_t)0ull))
    , opresulttype(std::exchange(other.opresulttype, (uint32_t)0ull))
    , opretset(std::exchange(other.opretset, false))
    , opcollid(std::exchange(other.opcollid, (uint32_t)0ull))
    , inputcollid(std::exchange(other.inputcollid, (uint32_t)0ull))
    , args(std::move(other.args))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

NullIfExpr::~NullIfExpr()
{
}

bool NullIfExpr::operator==([[maybe_unused]] const NullIfExpr& other) const noexcept
{
    return (
        true
        );
}

bool NullIfExpr::operator<([[maybe_unused]] const NullIfExpr& other) const noexcept
{
    return false;
}

NullIfExpr& NullIfExpr::operator=(NullIfExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        opno = std::exchange(other.opno, (uint32_t)0ull);
        opfuncid = std::exchange(other.opfuncid, (uint32_t)0ull);
        opresulttype = std::exchange(other.opresulttype, (uint32_t)0ull);
        opretset = std::exchange(other.opretset, false);
        opcollid = std::exchange(other.opcollid, (uint32_t)0ull);
        inputcollid = std::exchange(other.inputcollid, (uint32_t)0ull);
        args = std::move(other.args);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string NullIfExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void NullIfExpr::swap(NullIfExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(opno, other.opno);
    swap(opfuncid, other.opfuncid);
    swap(opresulttype, other.opresulttype);
    swap(opretset, other.opretset);
    swap(opcollid, other.opcollid);
    swap(inputcollid, other.inputcollid);
    swap(args, other.args);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const NullIfExpr& value)
{
    stream << "NullIfExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",opno="; stream << value.opno;
    stream << ",opfuncid="; stream << value.opfuncid;
    stream << ",opresulttype="; stream << value.opresulttype;
    stream << ",opretset="; stream << (value.opretset ? "true" : "false");
    stream << ",opcollid="; stream << value.opcollid;
    stream << ",inputcollid="; stream << value.inputcollid;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

ScalarArrayOpExpr::ScalarArrayOpExpr()
    : xpr()
    , opno((uint32_t)0ull)
    , opfuncid((uint32_t)0ull)
    , use_or(false)
    , inputcollid((uint32_t)0ull)
    , args()
    , location((int32_t)0ll)
{}

ScalarArrayOpExpr::ScalarArrayOpExpr(::pg_query::Node&& arg_xpr, uint32_t arg_opno, uint32_t arg_opfuncid, bool arg_use_or, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , opno(arg_opno)
    , opfuncid(arg_opfuncid)
    , use_or(arg_use_or)
    , inputcollid(arg_inputcollid)
    , args(std::move(arg_args))
    , location(arg_location)
{}

ScalarArrayOpExpr::ScalarArrayOpExpr(ScalarArrayOpExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , opno(std::exchange(other.opno, (uint32_t)0ull))
    , opfuncid(std::exchange(other.opfuncid, (uint32_t)0ull))
    , use_or(std::exchange(other.use_or, false))
    , inputcollid(std::exchange(other.inputcollid, (uint32_t)0ull))
    , args(std::move(other.args))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

ScalarArrayOpExpr::~ScalarArrayOpExpr()
{
}

bool ScalarArrayOpExpr::operator==([[maybe_unused]] const ScalarArrayOpExpr& other) const noexcept
{
    return (
        true
        );
}

bool ScalarArrayOpExpr::operator<([[maybe_unused]] const ScalarArrayOpExpr& other) const noexcept
{
    return false;
}

ScalarArrayOpExpr& ScalarArrayOpExpr::operator=(ScalarArrayOpExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        opno = std::exchange(other.opno, (uint32_t)0ull);
        opfuncid = std::exchange(other.opfuncid, (uint32_t)0ull);
        use_or = std::exchange(other.use_or, false);
        inputcollid = std::exchange(other.inputcollid, (uint32_t)0ull);
        args = std::move(other.args);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string ScalarArrayOpExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ScalarArrayOpExpr::swap(ScalarArrayOpExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(opno, other.opno);
    swap(opfuncid, other.opfuncid);
    swap(use_or, other.use_or);
    swap(inputcollid, other.inputcollid);
    swap(args, other.args);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ScalarArrayOpExpr& value)
{
    stream << "ScalarArrayOpExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",opno="; stream << value.opno;
    stream << ",opfuncid="; stream << value.opfuncid;
    stream << ",use_or="; stream << (value.use_or ? "true" : "false");
    stream << ",inputcollid="; stream << value.inputcollid;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

BoolExpr::BoolExpr()
    : xpr()
    , boolop()
    , args()
    , location((int32_t)0ll)
{}

BoolExpr::BoolExpr(::pg_query::Node&& arg_xpr, ::pg_query::BoolExprType&& arg_boolop, std::vector<::pg_query::Node> arg_args, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , boolop(std::move(arg_boolop))
    , args(std::move(arg_args))
    , location(arg_location)
{}

BoolExpr::BoolExpr(BoolExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , boolop(std::move(other.boolop))
    , args(std::move(other.args))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

BoolExpr::~BoolExpr()
{
}

bool BoolExpr::operator==([[maybe_unused]] const BoolExpr& other) const noexcept
{
    return (
        true
        );
}

bool BoolExpr::operator<([[maybe_unused]] const BoolExpr& other) const noexcept
{
    return false;
}

BoolExpr& BoolExpr::operator=(BoolExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        boolop = std::move(other.boolop);
        args = std::move(other.args);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string BoolExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void BoolExpr::swap(BoolExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(boolop, other.boolop);
    swap(args, other.args);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const BoolExpr& value)
{
    stream << "BoolExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",boolop="; stream << value.boolop;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

SubLink::SubLink()
    : xpr()
    , sub_link_type()
    , sub_link_id((int32_t)0ll)
    , testexpr()
    , oper_name()
    , subselect()
    , location((int32_t)0ll)
{}

SubLink::SubLink(::pg_query::Node&& arg_xpr, ::pg_query::SubLinkType&& arg_sub_link_type, int32_t arg_sub_link_id, ::pg_query::Node&& arg_testexpr, std::vector<::pg_query::Node> arg_oper_name, ::pg_query::Node&& arg_subselect, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , sub_link_type(std::move(arg_sub_link_type))
    , sub_link_id(arg_sub_link_id)
    , testexpr(std::move(arg_testexpr))
    , oper_name(std::move(arg_oper_name))
    , subselect(std::move(arg_subselect))
    , location(arg_location)
{}

SubLink::SubLink(SubLink&& other) noexcept
    : xpr(std::move(other.xpr))
    , sub_link_type(std::move(other.sub_link_type))
    , sub_link_id(std::exchange(other.sub_link_id, (int32_t)0ll))
    , testexpr(std::move(other.testexpr))
    , oper_name(std::move(other.oper_name))
    , subselect(std::move(other.subselect))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

SubLink::~SubLink()
{
}

bool SubLink::operator==([[maybe_unused]] const SubLink& other) const noexcept
{
    return (
        true
        );
}

bool SubLink::operator<([[maybe_unused]] const SubLink& other) const noexcept
{
    return false;
}

SubLink& SubLink::operator=(SubLink&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        sub_link_type = std::move(other.sub_link_type);
        sub_link_id = std::exchange(other.sub_link_id, (int32_t)0ll);
        testexpr = std::move(other.testexpr);
        oper_name = std::move(other.oper_name);
        subselect = std::move(other.subselect);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string SubLink::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SubLink::swap(SubLink& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(sub_link_type, other.sub_link_type);
    swap(sub_link_id, other.sub_link_id);
    swap(testexpr, other.testexpr);
    swap(oper_name, other.oper_name);
    swap(subselect, other.subselect);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SubLink& value)
{
    stream << "SubLink(";
    stream << "xpr="; stream << value.xpr;
    stream << ",sub_link_type="; stream << value.sub_link_type;
    stream << ",sub_link_id="; stream << value.sub_link_id;
    stream << ",testexpr="; stream << value.testexpr;
    {
        bool first = true;
        stream << ",oper_name=[" << value.oper_name.size() << "][";
        for (const auto& it : value.oper_name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",subselect="; stream << value.subselect;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

SubPlan::SubPlan()
    : xpr()
    , sub_link_type()
    , testexpr()
    , param_ids()
    , plan_id((int32_t)0ll)
    , plan_name()
    , first_col_type((uint32_t)0ull)
    , first_col_typmod((int32_t)0ll)
    , first_col_collation((uint32_t)0ull)
    , use_hash_table(false)
    , unknown_eq_false(false)
    , parallel_safe(false)
    , set_param()
    , par_param()
    , args()
    , startup_cost(0.0)
    , per_call_cost(0.0)
{}

SubPlan::SubPlan(::pg_query::Node&& arg_xpr, ::pg_query::SubLinkType&& arg_sub_link_type, ::pg_query::Node&& arg_testexpr, std::vector<::pg_query::Node> arg_param_ids, int32_t arg_plan_id, const std::string& arg_plan_name, uint32_t arg_first_col_type, int32_t arg_first_col_typmod, uint32_t arg_first_col_collation, bool arg_use_hash_table, bool arg_unknown_eq_false, bool arg_parallel_safe, std::vector<::pg_query::Node> arg_set_param, std::vector<::pg_query::Node> arg_par_param, std::vector<::pg_query::Node> arg_args, double arg_startup_cost, double arg_per_call_cost)
    : xpr(std::move(arg_xpr))
    , sub_link_type(std::move(arg_sub_link_type))
    , testexpr(std::move(arg_testexpr))
    , param_ids(std::move(arg_param_ids))
    , plan_id(arg_plan_id)
    , plan_name(arg_plan_name)
    , first_col_type(arg_first_col_type)
    , first_col_typmod(arg_first_col_typmod)
    , first_col_collation(arg_first_col_collation)
    , use_hash_table(arg_use_hash_table)
    , unknown_eq_false(arg_unknown_eq_false)
    , parallel_safe(arg_parallel_safe)
    , set_param(std::move(arg_set_param))
    , par_param(std::move(arg_par_param))
    , args(std::move(arg_args))
    , startup_cost(arg_startup_cost)
    , per_call_cost(arg_per_call_cost)
{}

SubPlan::SubPlan(SubPlan&& other) noexcept
    : xpr(std::move(other.xpr))
    , sub_link_type(std::move(other.sub_link_type))
    , testexpr(std::move(other.testexpr))
    , param_ids(std::move(other.param_ids))
    , plan_id(std::exchange(other.plan_id, (int32_t)0ll))
    , plan_name(std::move(other.plan_name))
    , first_col_type(std::exchange(other.first_col_type, (uint32_t)0ull))
    , first_col_typmod(std::exchange(other.first_col_typmod, (int32_t)0ll))
    , first_col_collation(std::exchange(other.first_col_collation, (uint32_t)0ull))
    , use_hash_table(std::exchange(other.use_hash_table, false))
    , unknown_eq_false(std::exchange(other.unknown_eq_false, false))
    , parallel_safe(std::exchange(other.parallel_safe, false))
    , set_param(std::move(other.set_param))
    , par_param(std::move(other.par_param))
    , args(std::move(other.args))
    , startup_cost(std::exchange(other.startup_cost, 0.0))
    , per_call_cost(std::exchange(other.per_call_cost, 0.0))
{}

SubPlan::~SubPlan()
{
}

bool SubPlan::operator==([[maybe_unused]] const SubPlan& other) const noexcept
{
    return (
        true
        );
}

bool SubPlan::operator<([[maybe_unused]] const SubPlan& other) const noexcept
{
    return false;
}

SubPlan& SubPlan::operator=(SubPlan&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        sub_link_type = std::move(other.sub_link_type);
        testexpr = std::move(other.testexpr);
        param_ids = std::move(other.param_ids);
        plan_id = std::exchange(other.plan_id, (int32_t)0ll);
        plan_name = std::move(other.plan_name);
        first_col_type = std::exchange(other.first_col_type, (uint32_t)0ull);
        first_col_typmod = std::exchange(other.first_col_typmod, (int32_t)0ll);
        first_col_collation = std::exchange(other.first_col_collation, (uint32_t)0ull);
        use_hash_table = std::exchange(other.use_hash_table, false);
        unknown_eq_false = std::exchange(other.unknown_eq_false, false);
        parallel_safe = std::exchange(other.parallel_safe, false);
        set_param = std::move(other.set_param);
        par_param = std::move(other.par_param);
        args = std::move(other.args);
        startup_cost = std::exchange(other.startup_cost, 0.0);
        per_call_cost = std::exchange(other.per_call_cost, 0.0);
    }
    return *this;
}

std::string SubPlan::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SubPlan::swap(SubPlan& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(sub_link_type, other.sub_link_type);
    swap(testexpr, other.testexpr);
    swap(param_ids, other.param_ids);
    swap(plan_id, other.plan_id);
    swap(plan_name, other.plan_name);
    swap(first_col_type, other.first_col_type);
    swap(first_col_typmod, other.first_col_typmod);
    swap(first_col_collation, other.first_col_collation);
    swap(use_hash_table, other.use_hash_table);
    swap(unknown_eq_false, other.unknown_eq_false);
    swap(parallel_safe, other.parallel_safe);
    swap(set_param, other.set_param);
    swap(par_param, other.par_param);
    swap(args, other.args);
    swap(startup_cost, other.startup_cost);
    swap(per_call_cost, other.per_call_cost);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SubPlan& value)
{
    stream << "SubPlan(";
    stream << "xpr="; stream << value.xpr;
    stream << ",sub_link_type="; stream << value.sub_link_type;
    stream << ",testexpr="; stream << value.testexpr;
    {
        bool first = true;
        stream << ",param_ids=[" << value.param_ids.size() << "][";
        for (const auto& it : value.param_ids)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",plan_id="; stream << value.plan_id;
    stream << ",plan_name="; stream << "\"" << value.plan_name << "\"";
    stream << ",first_col_type="; stream << value.first_col_type;
    stream << ",first_col_typmod="; stream << value.first_col_typmod;
    stream << ",first_col_collation="; stream << value.first_col_collation;
    stream << ",use_hash_table="; stream << (value.use_hash_table ? "true" : "false");
    stream << ",unknown_eq_false="; stream << (value.unknown_eq_false ? "true" : "false");
    stream << ",parallel_safe="; stream << (value.parallel_safe ? "true" : "false");
    {
        bool first = true;
        stream << ",set_param=[" << value.set_param.size() << "][";
        for (const auto& it : value.set_param)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",par_param=[" << value.par_param.size() << "][";
        for (const auto& it : value.par_param)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",startup_cost="; stream << value.startup_cost;
    stream << ",per_call_cost="; stream << value.per_call_cost;
    stream << ")";
    return stream;
}

AlternativeSubPlan::AlternativeSubPlan()
    : xpr()
    , subplans()
{}

AlternativeSubPlan::AlternativeSubPlan(::pg_query::Node&& arg_xpr, std::vector<::pg_query::Node> arg_subplans)
    : xpr(std::move(arg_xpr))
    , subplans(std::move(arg_subplans))
{}

AlternativeSubPlan::AlternativeSubPlan(AlternativeSubPlan&& other) noexcept
    : xpr(std::move(other.xpr))
    , subplans(std::move(other.subplans))
{}

AlternativeSubPlan::~AlternativeSubPlan()
{
}

bool AlternativeSubPlan::operator==([[maybe_unused]] const AlternativeSubPlan& other) const noexcept
{
    return (
        true
        );
}

bool AlternativeSubPlan::operator<([[maybe_unused]] const AlternativeSubPlan& other) const noexcept
{
    return false;
}

AlternativeSubPlan& AlternativeSubPlan::operator=(AlternativeSubPlan&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        subplans = std::move(other.subplans);
    }
    return *this;
}

std::string AlternativeSubPlan::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlternativeSubPlan::swap(AlternativeSubPlan& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(subplans, other.subplans);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlternativeSubPlan& value)
{
    stream << "AlternativeSubPlan(";
    stream << "xpr="; stream << value.xpr;
    {
        bool first = true;
        stream << ",subplans=[" << value.subplans.size() << "][";
        for (const auto& it : value.subplans)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

FieldSelect::FieldSelect()
    : xpr()
    , arg()
    , fieldnum((int32_t)0ll)
    , resulttype((uint32_t)0ull)
    , resulttypmod((int32_t)0ll)
    , resultcollid((uint32_t)0ull)
{}

FieldSelect::FieldSelect(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, int32_t arg_fieldnum, uint32_t arg_resulttype, int32_t arg_resulttypmod, uint32_t arg_resultcollid)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , fieldnum(arg_fieldnum)
    , resulttype(arg_resulttype)
    , resulttypmod(arg_resulttypmod)
    , resultcollid(arg_resultcollid)
{}

FieldSelect::FieldSelect(FieldSelect&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , fieldnum(std::exchange(other.fieldnum, (int32_t)0ll))
    , resulttype(std::exchange(other.resulttype, (uint32_t)0ull))
    , resulttypmod(std::exchange(other.resulttypmod, (int32_t)0ll))
    , resultcollid(std::exchange(other.resultcollid, (uint32_t)0ull))
{}

FieldSelect::~FieldSelect()
{
}

bool FieldSelect::operator==([[maybe_unused]] const FieldSelect& other) const noexcept
{
    return (
        true
        );
}

bool FieldSelect::operator<([[maybe_unused]] const FieldSelect& other) const noexcept
{
    return false;
}

FieldSelect& FieldSelect::operator=(FieldSelect&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        fieldnum = std::exchange(other.fieldnum, (int32_t)0ll);
        resulttype = std::exchange(other.resulttype, (uint32_t)0ull);
        resulttypmod = std::exchange(other.resulttypmod, (int32_t)0ll);
        resultcollid = std::exchange(other.resultcollid, (uint32_t)0ull);
    }
    return *this;
}

std::string FieldSelect::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void FieldSelect::swap(FieldSelect& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(fieldnum, other.fieldnum);
    swap(resulttype, other.resulttype);
    swap(resulttypmod, other.resulttypmod);
    swap(resultcollid, other.resultcollid);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const FieldSelect& value)
{
    stream << "FieldSelect(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",fieldnum="; stream << value.fieldnum;
    stream << ",resulttype="; stream << value.resulttype;
    stream << ",resulttypmod="; stream << value.resulttypmod;
    stream << ",resultcollid="; stream << value.resultcollid;
    stream << ")";
    return stream;
}

FieldStore::FieldStore()
    : xpr()
    , arg()
    , newvals()
    , fieldnums()
    , resulttype((uint32_t)0ull)
{}

FieldStore::FieldStore(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, std::vector<::pg_query::Node> arg_newvals, std::vector<::pg_query::Node> arg_fieldnums, uint32_t arg_resulttype)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , newvals(std::move(arg_newvals))
    , fieldnums(std::move(arg_fieldnums))
    , resulttype(arg_resulttype)
{}

FieldStore::FieldStore(FieldStore&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , newvals(std::move(other.newvals))
    , fieldnums(std::move(other.fieldnums))
    , resulttype(std::exchange(other.resulttype, (uint32_t)0ull))
{}

FieldStore::~FieldStore()
{
}

bool FieldStore::operator==([[maybe_unused]] const FieldStore& other) const noexcept
{
    return (
        true
        );
}

bool FieldStore::operator<([[maybe_unused]] const FieldStore& other) const noexcept
{
    return false;
}

FieldStore& FieldStore::operator=(FieldStore&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        newvals = std::move(other.newvals);
        fieldnums = std::move(other.fieldnums);
        resulttype = std::exchange(other.resulttype, (uint32_t)0ull);
    }
    return *this;
}

std::string FieldStore::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void FieldStore::swap(FieldStore& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(newvals, other.newvals);
    swap(fieldnums, other.fieldnums);
    swap(resulttype, other.resulttype);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const FieldStore& value)
{
    stream << "FieldStore(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    {
        bool first = true;
        stream << ",newvals=[" << value.newvals.size() << "][";
        for (const auto& it : value.newvals)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",fieldnums=[" << value.fieldnums.size() << "][";
        for (const auto& it : value.fieldnums)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",resulttype="; stream << value.resulttype;
    stream << ")";
    return stream;
}

RelabelType::RelabelType()
    : xpr()
    , arg()
    , resulttype((uint32_t)0ull)
    , resulttypmod((int32_t)0ll)
    , resultcollid((uint32_t)0ull)
    , relabelformat()
    , location((int32_t)0ll)
{}

RelabelType::RelabelType(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_resulttype, int32_t arg_resulttypmod, uint32_t arg_resultcollid, ::pg_query::CoercionForm&& arg_relabelformat, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , resulttype(arg_resulttype)
    , resulttypmod(arg_resulttypmod)
    , resultcollid(arg_resultcollid)
    , relabelformat(std::move(arg_relabelformat))
    , location(arg_location)
{}

RelabelType::RelabelType(RelabelType&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , resulttype(std::exchange(other.resulttype, (uint32_t)0ull))
    , resulttypmod(std::exchange(other.resulttypmod, (int32_t)0ll))
    , resultcollid(std::exchange(other.resultcollid, (uint32_t)0ull))
    , relabelformat(std::move(other.relabelformat))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

RelabelType::~RelabelType()
{
}

bool RelabelType::operator==([[maybe_unused]] const RelabelType& other) const noexcept
{
    return (
        true
        );
}

bool RelabelType::operator<([[maybe_unused]] const RelabelType& other) const noexcept
{
    return false;
}

RelabelType& RelabelType::operator=(RelabelType&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        resulttype = std::exchange(other.resulttype, (uint32_t)0ull);
        resulttypmod = std::exchange(other.resulttypmod, (int32_t)0ll);
        resultcollid = std::exchange(other.resultcollid, (uint32_t)0ull);
        relabelformat = std::move(other.relabelformat);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string RelabelType::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RelabelType::swap(RelabelType& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(resulttype, other.resulttype);
    swap(resulttypmod, other.resulttypmod);
    swap(resultcollid, other.resultcollid);
    swap(relabelformat, other.relabelformat);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RelabelType& value)
{
    stream << "RelabelType(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",resulttype="; stream << value.resulttype;
    stream << ",resulttypmod="; stream << value.resulttypmod;
    stream << ",resultcollid="; stream << value.resultcollid;
    stream << ",relabelformat="; stream << value.relabelformat;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CoerceViaIO::CoerceViaIO()
    : xpr()
    , arg()
    , resulttype((uint32_t)0ull)
    , resultcollid((uint32_t)0ull)
    , coerceformat()
    , location((int32_t)0ll)
{}

CoerceViaIO::CoerceViaIO(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_resulttype, uint32_t arg_resultcollid, ::pg_query::CoercionForm&& arg_coerceformat, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , resulttype(arg_resulttype)
    , resultcollid(arg_resultcollid)
    , coerceformat(std::move(arg_coerceformat))
    , location(arg_location)
{}

CoerceViaIO::CoerceViaIO(CoerceViaIO&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , resulttype(std::exchange(other.resulttype, (uint32_t)0ull))
    , resultcollid(std::exchange(other.resultcollid, (uint32_t)0ull))
    , coerceformat(std::move(other.coerceformat))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

CoerceViaIO::~CoerceViaIO()
{
}

bool CoerceViaIO::operator==([[maybe_unused]] const CoerceViaIO& other) const noexcept
{
    return (
        true
        );
}

bool CoerceViaIO::operator<([[maybe_unused]] const CoerceViaIO& other) const noexcept
{
    return false;
}

CoerceViaIO& CoerceViaIO::operator=(CoerceViaIO&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        resulttype = std::exchange(other.resulttype, (uint32_t)0ull);
        resultcollid = std::exchange(other.resultcollid, (uint32_t)0ull);
        coerceformat = std::move(other.coerceformat);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string CoerceViaIO::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CoerceViaIO::swap(CoerceViaIO& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(resulttype, other.resulttype);
    swap(resultcollid, other.resultcollid);
    swap(coerceformat, other.coerceformat);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CoerceViaIO& value)
{
    stream << "CoerceViaIO(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",resulttype="; stream << value.resulttype;
    stream << ",resultcollid="; stream << value.resultcollid;
    stream << ",coerceformat="; stream << value.coerceformat;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

ArrayCoerceExpr::ArrayCoerceExpr()
    : xpr()
    , arg()
    , elemexpr()
    , resulttype((uint32_t)0ull)
    , resulttypmod((int32_t)0ll)
    , resultcollid((uint32_t)0ull)
    , coerceformat()
    , location((int32_t)0ll)
{}

ArrayCoerceExpr::ArrayCoerceExpr(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, ::pg_query::Node&& arg_elemexpr, uint32_t arg_resulttype, int32_t arg_resulttypmod, uint32_t arg_resultcollid, ::pg_query::CoercionForm&& arg_coerceformat, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , elemexpr(std::move(arg_elemexpr))
    , resulttype(arg_resulttype)
    , resulttypmod(arg_resulttypmod)
    , resultcollid(arg_resultcollid)
    , coerceformat(std::move(arg_coerceformat))
    , location(arg_location)
{}

ArrayCoerceExpr::ArrayCoerceExpr(ArrayCoerceExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , elemexpr(std::move(other.elemexpr))
    , resulttype(std::exchange(other.resulttype, (uint32_t)0ull))
    , resulttypmod(std::exchange(other.resulttypmod, (int32_t)0ll))
    , resultcollid(std::exchange(other.resultcollid, (uint32_t)0ull))
    , coerceformat(std::move(other.coerceformat))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

ArrayCoerceExpr::~ArrayCoerceExpr()
{
}

bool ArrayCoerceExpr::operator==([[maybe_unused]] const ArrayCoerceExpr& other) const noexcept
{
    return (
        true
        );
}

bool ArrayCoerceExpr::operator<([[maybe_unused]] const ArrayCoerceExpr& other) const noexcept
{
    return false;
}

ArrayCoerceExpr& ArrayCoerceExpr::operator=(ArrayCoerceExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        elemexpr = std::move(other.elemexpr);
        resulttype = std::exchange(other.resulttype, (uint32_t)0ull);
        resulttypmod = std::exchange(other.resulttypmod, (int32_t)0ll);
        resultcollid = std::exchange(other.resultcollid, (uint32_t)0ull);
        coerceformat = std::move(other.coerceformat);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string ArrayCoerceExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ArrayCoerceExpr::swap(ArrayCoerceExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(elemexpr, other.elemexpr);
    swap(resulttype, other.resulttype);
    swap(resulttypmod, other.resulttypmod);
    swap(resultcollid, other.resultcollid);
    swap(coerceformat, other.coerceformat);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ArrayCoerceExpr& value)
{
    stream << "ArrayCoerceExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",elemexpr="; stream << value.elemexpr;
    stream << ",resulttype="; stream << value.resulttype;
    stream << ",resulttypmod="; stream << value.resulttypmod;
    stream << ",resultcollid="; stream << value.resultcollid;
    stream << ",coerceformat="; stream << value.coerceformat;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

ConvertRowtypeExpr::ConvertRowtypeExpr()
    : xpr()
    , arg()
    , resulttype((uint32_t)0ull)
    , convertformat()
    , location((int32_t)0ll)
{}

ConvertRowtypeExpr::ConvertRowtypeExpr(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_resulttype, ::pg_query::CoercionForm&& arg_convertformat, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , resulttype(arg_resulttype)
    , convertformat(std::move(arg_convertformat))
    , location(arg_location)
{}

ConvertRowtypeExpr::ConvertRowtypeExpr(ConvertRowtypeExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , resulttype(std::exchange(other.resulttype, (uint32_t)0ull))
    , convertformat(std::move(other.convertformat))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

ConvertRowtypeExpr::~ConvertRowtypeExpr()
{
}

bool ConvertRowtypeExpr::operator==([[maybe_unused]] const ConvertRowtypeExpr& other) const noexcept
{
    return (
        true
        );
}

bool ConvertRowtypeExpr::operator<([[maybe_unused]] const ConvertRowtypeExpr& other) const noexcept
{
    return false;
}

ConvertRowtypeExpr& ConvertRowtypeExpr::operator=(ConvertRowtypeExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        resulttype = std::exchange(other.resulttype, (uint32_t)0ull);
        convertformat = std::move(other.convertformat);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string ConvertRowtypeExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ConvertRowtypeExpr::swap(ConvertRowtypeExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(resulttype, other.resulttype);
    swap(convertformat, other.convertformat);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ConvertRowtypeExpr& value)
{
    stream << "ConvertRowtypeExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",resulttype="; stream << value.resulttype;
    stream << ",convertformat="; stream << value.convertformat;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CollateExpr::CollateExpr()
    : xpr()
    , arg()
    , coll_oid((uint32_t)0ull)
    , location((int32_t)0ll)
{}

CollateExpr::CollateExpr(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_coll_oid, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , coll_oid(arg_coll_oid)
    , location(arg_location)
{}

CollateExpr::CollateExpr(CollateExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , coll_oid(std::exchange(other.coll_oid, (uint32_t)0ull))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

CollateExpr::~CollateExpr()
{
}

bool CollateExpr::operator==([[maybe_unused]] const CollateExpr& other) const noexcept
{
    return (
        true
        );
}

bool CollateExpr::operator<([[maybe_unused]] const CollateExpr& other) const noexcept
{
    return false;
}

CollateExpr& CollateExpr::operator=(CollateExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        coll_oid = std::exchange(other.coll_oid, (uint32_t)0ull);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string CollateExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CollateExpr::swap(CollateExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(coll_oid, other.coll_oid);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CollateExpr& value)
{
    stream << "CollateExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",coll_oid="; stream << value.coll_oid;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CaseExpr::CaseExpr()
    : xpr()
    , casetype((uint32_t)0ull)
    , casecollid((uint32_t)0ull)
    , arg()
    , args()
    , defresult()
    , location((int32_t)0ll)
{}

CaseExpr::CaseExpr(::pg_query::Node&& arg_xpr, uint32_t arg_casetype, uint32_t arg_casecollid, ::pg_query::Node&& arg_arg, std::vector<::pg_query::Node> arg_args, ::pg_query::Node&& arg_defresult, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , casetype(arg_casetype)
    , casecollid(arg_casecollid)
    , arg(std::move(arg_arg))
    , args(std::move(arg_args))
    , defresult(std::move(arg_defresult))
    , location(arg_location)
{}

CaseExpr::CaseExpr(CaseExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , casetype(std::exchange(other.casetype, (uint32_t)0ull))
    , casecollid(std::exchange(other.casecollid, (uint32_t)0ull))
    , arg(std::move(other.arg))
    , args(std::move(other.args))
    , defresult(std::move(other.defresult))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

CaseExpr::~CaseExpr()
{
}

bool CaseExpr::operator==([[maybe_unused]] const CaseExpr& other) const noexcept
{
    return (
        true
        );
}

bool CaseExpr::operator<([[maybe_unused]] const CaseExpr& other) const noexcept
{
    return false;
}

CaseExpr& CaseExpr::operator=(CaseExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        casetype = std::exchange(other.casetype, (uint32_t)0ull);
        casecollid = std::exchange(other.casecollid, (uint32_t)0ull);
        arg = std::move(other.arg);
        args = std::move(other.args);
        defresult = std::move(other.defresult);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string CaseExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CaseExpr::swap(CaseExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(casetype, other.casetype);
    swap(casecollid, other.casecollid);
    swap(arg, other.arg);
    swap(args, other.args);
    swap(defresult, other.defresult);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CaseExpr& value)
{
    stream << "CaseExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",casetype="; stream << value.casetype;
    stream << ",casecollid="; stream << value.casecollid;
    stream << ",arg="; stream << value.arg;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",defresult="; stream << value.defresult;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CaseWhen::CaseWhen()
    : xpr()
    , expr()
    , result()
    , location((int32_t)0ll)
{}

CaseWhen::CaseWhen(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_expr, ::pg_query::Node&& arg_result, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , expr(std::move(arg_expr))
    , result(std::move(arg_result))
    , location(arg_location)
{}

CaseWhen::CaseWhen(CaseWhen&& other) noexcept
    : xpr(std::move(other.xpr))
    , expr(std::move(other.expr))
    , result(std::move(other.result))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

CaseWhen::~CaseWhen()
{
}

bool CaseWhen::operator==([[maybe_unused]] const CaseWhen& other) const noexcept
{
    return (
        true
        );
}

bool CaseWhen::operator<([[maybe_unused]] const CaseWhen& other) const noexcept
{
    return false;
}

CaseWhen& CaseWhen::operator=(CaseWhen&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        expr = std::move(other.expr);
        result = std::move(other.result);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string CaseWhen::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CaseWhen::swap(CaseWhen& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(expr, other.expr);
    swap(result, other.result);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CaseWhen& value)
{
    stream << "CaseWhen(";
    stream << "xpr="; stream << value.xpr;
    stream << ",expr="; stream << value.expr;
    stream << ",result="; stream << value.result;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CaseTestExpr::CaseTestExpr()
    : xpr()
    , type_id((uint32_t)0ull)
    , type_mod((int32_t)0ll)
    , collation((uint32_t)0ull)
{}

CaseTestExpr::CaseTestExpr(::pg_query::Node&& arg_xpr, uint32_t arg_type_id, int32_t arg_type_mod, uint32_t arg_collation)
    : xpr(std::move(arg_xpr))
    , type_id(arg_type_id)
    , type_mod(arg_type_mod)
    , collation(arg_collation)
{}

CaseTestExpr::CaseTestExpr(CaseTestExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , type_id(std::exchange(other.type_id, (uint32_t)0ull))
    , type_mod(std::exchange(other.type_mod, (int32_t)0ll))
    , collation(std::exchange(other.collation, (uint32_t)0ull))
{}

CaseTestExpr::~CaseTestExpr()
{
}

bool CaseTestExpr::operator==([[maybe_unused]] const CaseTestExpr& other) const noexcept
{
    return (
        true
        );
}

bool CaseTestExpr::operator<([[maybe_unused]] const CaseTestExpr& other) const noexcept
{
    return false;
}

CaseTestExpr& CaseTestExpr::operator=(CaseTestExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        type_id = std::exchange(other.type_id, (uint32_t)0ull);
        type_mod = std::exchange(other.type_mod, (int32_t)0ll);
        collation = std::exchange(other.collation, (uint32_t)0ull);
    }
    return *this;
}

std::string CaseTestExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CaseTestExpr::swap(CaseTestExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(type_id, other.type_id);
    swap(type_mod, other.type_mod);
    swap(collation, other.collation);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CaseTestExpr& value)
{
    stream << "CaseTestExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",type_id="; stream << value.type_id;
    stream << ",type_mod="; stream << value.type_mod;
    stream << ",collation="; stream << value.collation;
    stream << ")";
    return stream;
}

ArrayExpr::ArrayExpr()
    : xpr()
    , array_typeid((uint32_t)0ull)
    , array_collid((uint32_t)0ull)
    , element_typeid((uint32_t)0ull)
    , elements()
    , multidims(false)
    , location((int32_t)0ll)
{}

ArrayExpr::ArrayExpr(::pg_query::Node&& arg_xpr, uint32_t arg_array_typeid, uint32_t arg_array_collid, uint32_t arg_element_typeid, std::vector<::pg_query::Node> arg_elements, bool arg_multidims, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , array_typeid(arg_array_typeid)
    , array_collid(arg_array_collid)
    , element_typeid(arg_element_typeid)
    , elements(std::move(arg_elements))
    , multidims(arg_multidims)
    , location(arg_location)
{}

ArrayExpr::ArrayExpr(ArrayExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , array_typeid(std::exchange(other.array_typeid, (uint32_t)0ull))
    , array_collid(std::exchange(other.array_collid, (uint32_t)0ull))
    , element_typeid(std::exchange(other.element_typeid, (uint32_t)0ull))
    , elements(std::move(other.elements))
    , multidims(std::exchange(other.multidims, false))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

ArrayExpr::~ArrayExpr()
{
}

bool ArrayExpr::operator==([[maybe_unused]] const ArrayExpr& other) const noexcept
{
    return (
        true
        );
}

bool ArrayExpr::operator<([[maybe_unused]] const ArrayExpr& other) const noexcept
{
    return false;
}

ArrayExpr& ArrayExpr::operator=(ArrayExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        array_typeid = std::exchange(other.array_typeid, (uint32_t)0ull);
        array_collid = std::exchange(other.array_collid, (uint32_t)0ull);
        element_typeid = std::exchange(other.element_typeid, (uint32_t)0ull);
        elements = std::move(other.elements);
        multidims = std::exchange(other.multidims, false);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string ArrayExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ArrayExpr::swap(ArrayExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(array_typeid, other.array_typeid);
    swap(array_collid, other.array_collid);
    swap(element_typeid, other.element_typeid);
    swap(elements, other.elements);
    swap(multidims, other.multidims);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ArrayExpr& value)
{
    stream << "ArrayExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",array_typeid="; stream << value.array_typeid;
    stream << ",array_collid="; stream << value.array_collid;
    stream << ",element_typeid="; stream << value.element_typeid;
    {
        bool first = true;
        stream << ",elements=[" << value.elements.size() << "][";
        for (const auto& it : value.elements)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",multidims="; stream << (value.multidims ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

RowExpr::RowExpr()
    : xpr()
    , args()
    , row_typeid((uint32_t)0ull)
    , row_format()
    , colnames()
    , location((int32_t)0ll)
{}

RowExpr::RowExpr(::pg_query::Node&& arg_xpr, std::vector<::pg_query::Node> arg_args, uint32_t arg_row_typeid, ::pg_query::CoercionForm&& arg_row_format, std::vector<::pg_query::Node> arg_colnames, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , args(std::move(arg_args))
    , row_typeid(arg_row_typeid)
    , row_format(std::move(arg_row_format))
    , colnames(std::move(arg_colnames))
    , location(arg_location)
{}

RowExpr::RowExpr(RowExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , args(std::move(other.args))
    , row_typeid(std::exchange(other.row_typeid, (uint32_t)0ull))
    , row_format(std::move(other.row_format))
    , colnames(std::move(other.colnames))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

RowExpr::~RowExpr()
{
}

bool RowExpr::operator==([[maybe_unused]] const RowExpr& other) const noexcept
{
    return (
        true
        );
}

bool RowExpr::operator<([[maybe_unused]] const RowExpr& other) const noexcept
{
    return false;
}

RowExpr& RowExpr::operator=(RowExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        args = std::move(other.args);
        row_typeid = std::exchange(other.row_typeid, (uint32_t)0ull);
        row_format = std::move(other.row_format);
        colnames = std::move(other.colnames);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string RowExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RowExpr::swap(RowExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(args, other.args);
    swap(row_typeid, other.row_typeid);
    swap(row_format, other.row_format);
    swap(colnames, other.colnames);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RowExpr& value)
{
    stream << "RowExpr(";
    stream << "xpr="; stream << value.xpr;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",row_typeid="; stream << value.row_typeid;
    stream << ",row_format="; stream << value.row_format;
    {
        bool first = true;
        stream << ",colnames=[" << value.colnames.size() << "][";
        for (const auto& it : value.colnames)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

RowCompareExpr::RowCompareExpr()
    : xpr()
    , rctype()
    , opnos()
    , opfamilies()
    , inputcollids()
    , largs()
    , rargs()
{}

RowCompareExpr::RowCompareExpr(::pg_query::Node&& arg_xpr, ::pg_query::RowCompareType&& arg_rctype, std::vector<::pg_query::Node> arg_opnos, std::vector<::pg_query::Node> arg_opfamilies, std::vector<::pg_query::Node> arg_inputcollids, std::vector<::pg_query::Node> arg_largs, std::vector<::pg_query::Node> arg_rargs)
    : xpr(std::move(arg_xpr))
    , rctype(std::move(arg_rctype))
    , opnos(std::move(arg_opnos))
    , opfamilies(std::move(arg_opfamilies))
    , inputcollids(std::move(arg_inputcollids))
    , largs(std::move(arg_largs))
    , rargs(std::move(arg_rargs))
{}

RowCompareExpr::RowCompareExpr(RowCompareExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , rctype(std::move(other.rctype))
    , opnos(std::move(other.opnos))
    , opfamilies(std::move(other.opfamilies))
    , inputcollids(std::move(other.inputcollids))
    , largs(std::move(other.largs))
    , rargs(std::move(other.rargs))
{}

RowCompareExpr::~RowCompareExpr()
{
}

bool RowCompareExpr::operator==([[maybe_unused]] const RowCompareExpr& other) const noexcept
{
    return (
        true
        );
}

bool RowCompareExpr::operator<([[maybe_unused]] const RowCompareExpr& other) const noexcept
{
    return false;
}

RowCompareExpr& RowCompareExpr::operator=(RowCompareExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        rctype = std::move(other.rctype);
        opnos = std::move(other.opnos);
        opfamilies = std::move(other.opfamilies);
        inputcollids = std::move(other.inputcollids);
        largs = std::move(other.largs);
        rargs = std::move(other.rargs);
    }
    return *this;
}

std::string RowCompareExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RowCompareExpr::swap(RowCompareExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(rctype, other.rctype);
    swap(opnos, other.opnos);
    swap(opfamilies, other.opfamilies);
    swap(inputcollids, other.inputcollids);
    swap(largs, other.largs);
    swap(rargs, other.rargs);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RowCompareExpr& value)
{
    stream << "RowCompareExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",rctype="; stream << value.rctype;
    {
        bool first = true;
        stream << ",opnos=[" << value.opnos.size() << "][";
        for (const auto& it : value.opnos)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",opfamilies=[" << value.opfamilies.size() << "][";
        for (const auto& it : value.opfamilies)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",inputcollids=[" << value.inputcollids.size() << "][";
        for (const auto& it : value.inputcollids)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",largs=[" << value.largs.size() << "][";
        for (const auto& it : value.largs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",rargs=[" << value.rargs.size() << "][";
        for (const auto& it : value.rargs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

CoalesceExpr::CoalesceExpr()
    : xpr()
    , coalescetype((uint32_t)0ull)
    , coalescecollid((uint32_t)0ull)
    , args()
    , location((int32_t)0ll)
{}

CoalesceExpr::CoalesceExpr(::pg_query::Node&& arg_xpr, uint32_t arg_coalescetype, uint32_t arg_coalescecollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , coalescetype(arg_coalescetype)
    , coalescecollid(arg_coalescecollid)
    , args(std::move(arg_args))
    , location(arg_location)
{}

CoalesceExpr::CoalesceExpr(CoalesceExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , coalescetype(std::exchange(other.coalescetype, (uint32_t)0ull))
    , coalescecollid(std::exchange(other.coalescecollid, (uint32_t)0ull))
    , args(std::move(other.args))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

CoalesceExpr::~CoalesceExpr()
{
}

bool CoalesceExpr::operator==([[maybe_unused]] const CoalesceExpr& other) const noexcept
{
    return (
        true
        );
}

bool CoalesceExpr::operator<([[maybe_unused]] const CoalesceExpr& other) const noexcept
{
    return false;
}

CoalesceExpr& CoalesceExpr::operator=(CoalesceExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        coalescetype = std::exchange(other.coalescetype, (uint32_t)0ull);
        coalescecollid = std::exchange(other.coalescecollid, (uint32_t)0ull);
        args = std::move(other.args);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string CoalesceExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CoalesceExpr::swap(CoalesceExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(coalescetype, other.coalescetype);
    swap(coalescecollid, other.coalescecollid);
    swap(args, other.args);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CoalesceExpr& value)
{
    stream << "CoalesceExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",coalescetype="; stream << value.coalescetype;
    stream << ",coalescecollid="; stream << value.coalescecollid;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

MinMaxExpr::MinMaxExpr()
    : xpr()
    , minmaxtype((uint32_t)0ull)
    , minmaxcollid((uint32_t)0ull)
    , inputcollid((uint32_t)0ull)
    , op()
    , args()
    , location((int32_t)0ll)
{}

MinMaxExpr::MinMaxExpr(::pg_query::Node&& arg_xpr, uint32_t arg_minmaxtype, uint32_t arg_minmaxcollid, uint32_t arg_inputcollid, ::pg_query::MinMaxOp&& arg_op, std::vector<::pg_query::Node> arg_args, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , minmaxtype(arg_minmaxtype)
    , minmaxcollid(arg_minmaxcollid)
    , inputcollid(arg_inputcollid)
    , op(std::move(arg_op))
    , args(std::move(arg_args))
    , location(arg_location)
{}

MinMaxExpr::MinMaxExpr(MinMaxExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , minmaxtype(std::exchange(other.minmaxtype, (uint32_t)0ull))
    , minmaxcollid(std::exchange(other.minmaxcollid, (uint32_t)0ull))
    , inputcollid(std::exchange(other.inputcollid, (uint32_t)0ull))
    , op(std::move(other.op))
    , args(std::move(other.args))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

MinMaxExpr::~MinMaxExpr()
{
}

bool MinMaxExpr::operator==([[maybe_unused]] const MinMaxExpr& other) const noexcept
{
    return (
        true
        );
}

bool MinMaxExpr::operator<([[maybe_unused]] const MinMaxExpr& other) const noexcept
{
    return false;
}

MinMaxExpr& MinMaxExpr::operator=(MinMaxExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        minmaxtype = std::exchange(other.minmaxtype, (uint32_t)0ull);
        minmaxcollid = std::exchange(other.minmaxcollid, (uint32_t)0ull);
        inputcollid = std::exchange(other.inputcollid, (uint32_t)0ull);
        op = std::move(other.op);
        args = std::move(other.args);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string MinMaxExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void MinMaxExpr::swap(MinMaxExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(minmaxtype, other.minmaxtype);
    swap(minmaxcollid, other.minmaxcollid);
    swap(inputcollid, other.inputcollid);
    swap(op, other.op);
    swap(args, other.args);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const MinMaxExpr& value)
{
    stream << "MinMaxExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",minmaxtype="; stream << value.minmaxtype;
    stream << ",minmaxcollid="; stream << value.minmaxcollid;
    stream << ",inputcollid="; stream << value.inputcollid;
    stream << ",op="; stream << value.op;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

SQLValueFunction::SQLValueFunction()
    : xpr()
    , op()
    , type((uint32_t)0ull)
    , typmod((int32_t)0ll)
    , location((int32_t)0ll)
{}

SQLValueFunction::SQLValueFunction(::pg_query::Node&& arg_xpr, ::pg_query::SQLValueFunctionOp&& arg_op, uint32_t arg_type, int32_t arg_typmod, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , op(std::move(arg_op))
    , type(arg_type)
    , typmod(arg_typmod)
    , location(arg_location)
{}

SQLValueFunction::SQLValueFunction(SQLValueFunction&& other) noexcept
    : xpr(std::move(other.xpr))
    , op(std::move(other.op))
    , type(std::exchange(other.type, (uint32_t)0ull))
    , typmod(std::exchange(other.typmod, (int32_t)0ll))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

SQLValueFunction::~SQLValueFunction()
{
}

bool SQLValueFunction::operator==([[maybe_unused]] const SQLValueFunction& other) const noexcept
{
    return (
        true
        );
}

bool SQLValueFunction::operator<([[maybe_unused]] const SQLValueFunction& other) const noexcept
{
    return false;
}

SQLValueFunction& SQLValueFunction::operator=(SQLValueFunction&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        op = std::move(other.op);
        type = std::exchange(other.type, (uint32_t)0ull);
        typmod = std::exchange(other.typmod, (int32_t)0ll);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string SQLValueFunction::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SQLValueFunction::swap(SQLValueFunction& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(op, other.op);
    swap(type, other.type);
    swap(typmod, other.typmod);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SQLValueFunction& value)
{
    stream << "SQLValueFunction(";
    stream << "xpr="; stream << value.xpr;
    stream << ",op="; stream << value.op;
    stream << ",type="; stream << value.type;
    stream << ",typmod="; stream << value.typmod;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

XmlExpr::XmlExpr()
    : xpr()
    , op()
    , name()
    , named_args()
    , arg_names()
    , args()
    , xmloption()
    , type((uint32_t)0ull)
    , typmod((int32_t)0ll)
    , location((int32_t)0ll)
{}

XmlExpr::XmlExpr(::pg_query::Node&& arg_xpr, ::pg_query::XmlExprOp&& arg_op, const std::string& arg_name, std::vector<::pg_query::Node> arg_named_args, std::vector<::pg_query::Node> arg_arg_names, std::vector<::pg_query::Node> arg_args, ::pg_query::XmlOptionType&& arg_xmloption, uint32_t arg_type, int32_t arg_typmod, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , op(std::move(arg_op))
    , name(arg_name)
    , named_args(std::move(arg_named_args))
    , arg_names(std::move(arg_arg_names))
    , args(std::move(arg_args))
    , xmloption(std::move(arg_xmloption))
    , type(arg_type)
    , typmod(arg_typmod)
    , location(arg_location)
{}

XmlExpr::XmlExpr(XmlExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , op(std::move(other.op))
    , name(std::move(other.name))
    , named_args(std::move(other.named_args))
    , arg_names(std::move(other.arg_names))
    , args(std::move(other.args))
    , xmloption(std::move(other.xmloption))
    , type(std::exchange(other.type, (uint32_t)0ull))
    , typmod(std::exchange(other.typmod, (int32_t)0ll))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

XmlExpr::~XmlExpr()
{
}

bool XmlExpr::operator==([[maybe_unused]] const XmlExpr& other) const noexcept
{
    return (
        true
        );
}

bool XmlExpr::operator<([[maybe_unused]] const XmlExpr& other) const noexcept
{
    return false;
}

XmlExpr& XmlExpr::operator=(XmlExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        op = std::move(other.op);
        name = std::move(other.name);
        named_args = std::move(other.named_args);
        arg_names = std::move(other.arg_names);
        args = std::move(other.args);
        xmloption = std::move(other.xmloption);
        type = std::exchange(other.type, (uint32_t)0ull);
        typmod = std::exchange(other.typmod, (int32_t)0ll);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string XmlExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void XmlExpr::swap(XmlExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(op, other.op);
    swap(name, other.name);
    swap(named_args, other.named_args);
    swap(arg_names, other.arg_names);
    swap(args, other.args);
    swap(xmloption, other.xmloption);
    swap(type, other.type);
    swap(typmod, other.typmod);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const XmlExpr& value)
{
    stream << "XmlExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",op="; stream << value.op;
    stream << ",name="; stream << "\"" << value.name << "\"";
    {
        bool first = true;
        stream << ",named_args=[" << value.named_args.size() << "][";
        for (const auto& it : value.named_args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",arg_names=[" << value.arg_names.size() << "][";
        for (const auto& it : value.arg_names)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",xmloption="; stream << value.xmloption;
    stream << ",type="; stream << value.type;
    stream << ",typmod="; stream << value.typmod;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

NullTest::NullTest()
    : xpr()
    , arg()
    , nulltesttype()
    , argisrow(false)
    , location((int32_t)0ll)
{}

NullTest::NullTest(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, ::pg_query::NullTestType&& arg_nulltesttype, bool arg_argisrow, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , nulltesttype(std::move(arg_nulltesttype))
    , argisrow(arg_argisrow)
    , location(arg_location)
{}

NullTest::NullTest(NullTest&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , nulltesttype(std::move(other.nulltesttype))
    , argisrow(std::exchange(other.argisrow, false))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

NullTest::~NullTest()
{
}

bool NullTest::operator==([[maybe_unused]] const NullTest& other) const noexcept
{
    return (
        true
        );
}

bool NullTest::operator<([[maybe_unused]] const NullTest& other) const noexcept
{
    return false;
}

NullTest& NullTest::operator=(NullTest&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        nulltesttype = std::move(other.nulltesttype);
        argisrow = std::exchange(other.argisrow, false);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string NullTest::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void NullTest::swap(NullTest& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(nulltesttype, other.nulltesttype);
    swap(argisrow, other.argisrow);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const NullTest& value)
{
    stream << "NullTest(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",nulltesttype="; stream << value.nulltesttype;
    stream << ",argisrow="; stream << (value.argisrow ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

BooleanTest::BooleanTest()
    : xpr()
    , arg()
    , booltesttype()
    , location((int32_t)0ll)
{}

BooleanTest::BooleanTest(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, ::pg_query::BoolTestType&& arg_booltesttype, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , booltesttype(std::move(arg_booltesttype))
    , location(arg_location)
{}

BooleanTest::BooleanTest(BooleanTest&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , booltesttype(std::move(other.booltesttype))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

BooleanTest::~BooleanTest()
{
}

bool BooleanTest::operator==([[maybe_unused]] const BooleanTest& other) const noexcept
{
    return (
        true
        );
}

bool BooleanTest::operator<([[maybe_unused]] const BooleanTest& other) const noexcept
{
    return false;
}

BooleanTest& BooleanTest::operator=(BooleanTest&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        booltesttype = std::move(other.booltesttype);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string BooleanTest::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void BooleanTest::swap(BooleanTest& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(booltesttype, other.booltesttype);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const BooleanTest& value)
{
    stream << "BooleanTest(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",booltesttype="; stream << value.booltesttype;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CoerceToDomain::CoerceToDomain()
    : xpr()
    , arg()
    , resulttype((uint32_t)0ull)
    , resulttypmod((int32_t)0ll)
    , resultcollid((uint32_t)0ull)
    , coercionformat()
    , location((int32_t)0ll)
{}

CoerceToDomain::CoerceToDomain(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_resulttype, int32_t arg_resulttypmod, uint32_t arg_resultcollid, ::pg_query::CoercionForm&& arg_coercionformat, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , arg(std::move(arg_arg))
    , resulttype(arg_resulttype)
    , resulttypmod(arg_resulttypmod)
    , resultcollid(arg_resultcollid)
    , coercionformat(std::move(arg_coercionformat))
    , location(arg_location)
{}

CoerceToDomain::CoerceToDomain(CoerceToDomain&& other) noexcept
    : xpr(std::move(other.xpr))
    , arg(std::move(other.arg))
    , resulttype(std::exchange(other.resulttype, (uint32_t)0ull))
    , resulttypmod(std::exchange(other.resulttypmod, (int32_t)0ll))
    , resultcollid(std::exchange(other.resultcollid, (uint32_t)0ull))
    , coercionformat(std::move(other.coercionformat))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

CoerceToDomain::~CoerceToDomain()
{
}

bool CoerceToDomain::operator==([[maybe_unused]] const CoerceToDomain& other) const noexcept
{
    return (
        true
        );
}

bool CoerceToDomain::operator<([[maybe_unused]] const CoerceToDomain& other) const noexcept
{
    return false;
}

CoerceToDomain& CoerceToDomain::operator=(CoerceToDomain&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        arg = std::move(other.arg);
        resulttype = std::exchange(other.resulttype, (uint32_t)0ull);
        resulttypmod = std::exchange(other.resulttypmod, (int32_t)0ll);
        resultcollid = std::exchange(other.resultcollid, (uint32_t)0ull);
        coercionformat = std::move(other.coercionformat);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string CoerceToDomain::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CoerceToDomain::swap(CoerceToDomain& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(arg, other.arg);
    swap(resulttype, other.resulttype);
    swap(resulttypmod, other.resulttypmod);
    swap(resultcollid, other.resultcollid);
    swap(coercionformat, other.coercionformat);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CoerceToDomain& value)
{
    stream << "CoerceToDomain(";
    stream << "xpr="; stream << value.xpr;
    stream << ",arg="; stream << value.arg;
    stream << ",resulttype="; stream << value.resulttype;
    stream << ",resulttypmod="; stream << value.resulttypmod;
    stream << ",resultcollid="; stream << value.resultcollid;
    stream << ",coercionformat="; stream << value.coercionformat;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CoerceToDomainValue::CoerceToDomainValue()
    : xpr()
    , type_id((uint32_t)0ull)
    , type_mod((int32_t)0ll)
    , collation((uint32_t)0ull)
    , location((int32_t)0ll)
{}

CoerceToDomainValue::CoerceToDomainValue(::pg_query::Node&& arg_xpr, uint32_t arg_type_id, int32_t arg_type_mod, uint32_t arg_collation, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , type_id(arg_type_id)
    , type_mod(arg_type_mod)
    , collation(arg_collation)
    , location(arg_location)
{}

CoerceToDomainValue::CoerceToDomainValue(CoerceToDomainValue&& other) noexcept
    : xpr(std::move(other.xpr))
    , type_id(std::exchange(other.type_id, (uint32_t)0ull))
    , type_mod(std::exchange(other.type_mod, (int32_t)0ll))
    , collation(std::exchange(other.collation, (uint32_t)0ull))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

CoerceToDomainValue::~CoerceToDomainValue()
{
}

bool CoerceToDomainValue::operator==([[maybe_unused]] const CoerceToDomainValue& other) const noexcept
{
    return (
        true
        );
}

bool CoerceToDomainValue::operator<([[maybe_unused]] const CoerceToDomainValue& other) const noexcept
{
    return false;
}

CoerceToDomainValue& CoerceToDomainValue::operator=(CoerceToDomainValue&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        type_id = std::exchange(other.type_id, (uint32_t)0ull);
        type_mod = std::exchange(other.type_mod, (int32_t)0ll);
        collation = std::exchange(other.collation, (uint32_t)0ull);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string CoerceToDomainValue::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CoerceToDomainValue::swap(CoerceToDomainValue& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(type_id, other.type_id);
    swap(type_mod, other.type_mod);
    swap(collation, other.collation);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CoerceToDomainValue& value)
{
    stream << "CoerceToDomainValue(";
    stream << "xpr="; stream << value.xpr;
    stream << ",type_id="; stream << value.type_id;
    stream << ",type_mod="; stream << value.type_mod;
    stream << ",collation="; stream << value.collation;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

SetToDefault::SetToDefault()
    : xpr()
    , type_id((uint32_t)0ull)
    , type_mod((int32_t)0ll)
    , collation((uint32_t)0ull)
    , location((int32_t)0ll)
{}

SetToDefault::SetToDefault(::pg_query::Node&& arg_xpr, uint32_t arg_type_id, int32_t arg_type_mod, uint32_t arg_collation, int32_t arg_location)
    : xpr(std::move(arg_xpr))
    , type_id(arg_type_id)
    , type_mod(arg_type_mod)
    , collation(arg_collation)
    , location(arg_location)
{}

SetToDefault::SetToDefault(SetToDefault&& other) noexcept
    : xpr(std::move(other.xpr))
    , type_id(std::exchange(other.type_id, (uint32_t)0ull))
    , type_mod(std::exchange(other.type_mod, (int32_t)0ll))
    , collation(std::exchange(other.collation, (uint32_t)0ull))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

SetToDefault::~SetToDefault()
{
}

bool SetToDefault::operator==([[maybe_unused]] const SetToDefault& other) const noexcept
{
    return (
        true
        );
}

bool SetToDefault::operator<([[maybe_unused]] const SetToDefault& other) const noexcept
{
    return false;
}

SetToDefault& SetToDefault::operator=(SetToDefault&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        type_id = std::exchange(other.type_id, (uint32_t)0ull);
        type_mod = std::exchange(other.type_mod, (int32_t)0ll);
        collation = std::exchange(other.collation, (uint32_t)0ull);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string SetToDefault::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SetToDefault::swap(SetToDefault& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(type_id, other.type_id);
    swap(type_mod, other.type_mod);
    swap(collation, other.collation);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SetToDefault& value)
{
    stream << "SetToDefault(";
    stream << "xpr="; stream << value.xpr;
    stream << ",type_id="; stream << value.type_id;
    stream << ",type_mod="; stream << value.type_mod;
    stream << ",collation="; stream << value.collation;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CurrentOfExpr::CurrentOfExpr()
    : xpr()
    , cvarno((uint32_t)0ull)
    , cursor_name()
    , cursor_param((int32_t)0ll)
{}

CurrentOfExpr::CurrentOfExpr(::pg_query::Node&& arg_xpr, uint32_t arg_cvarno, const std::string& arg_cursor_name, int32_t arg_cursor_param)
    : xpr(std::move(arg_xpr))
    , cvarno(arg_cvarno)
    , cursor_name(arg_cursor_name)
    , cursor_param(arg_cursor_param)
{}

CurrentOfExpr::CurrentOfExpr(CurrentOfExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , cvarno(std::exchange(other.cvarno, (uint32_t)0ull))
    , cursor_name(std::move(other.cursor_name))
    , cursor_param(std::exchange(other.cursor_param, (int32_t)0ll))
{}

CurrentOfExpr::~CurrentOfExpr()
{
}

bool CurrentOfExpr::operator==([[maybe_unused]] const CurrentOfExpr& other) const noexcept
{
    return (
        true
        );
}

bool CurrentOfExpr::operator<([[maybe_unused]] const CurrentOfExpr& other) const noexcept
{
    return false;
}

CurrentOfExpr& CurrentOfExpr::operator=(CurrentOfExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        cvarno = std::exchange(other.cvarno, (uint32_t)0ull);
        cursor_name = std::move(other.cursor_name);
        cursor_param = std::exchange(other.cursor_param, (int32_t)0ll);
    }
    return *this;
}

std::string CurrentOfExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CurrentOfExpr::swap(CurrentOfExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(cvarno, other.cvarno);
    swap(cursor_name, other.cursor_name);
    swap(cursor_param, other.cursor_param);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CurrentOfExpr& value)
{
    stream << "CurrentOfExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",cvarno="; stream << value.cvarno;
    stream << ",cursor_name="; stream << "\"" << value.cursor_name << "\"";
    stream << ",cursor_param="; stream << value.cursor_param;
    stream << ")";
    return stream;
}

NextValueExpr::NextValueExpr()
    : xpr()
    , seqid((uint32_t)0ull)
    , type_id((uint32_t)0ull)
{}

NextValueExpr::NextValueExpr(::pg_query::Node&& arg_xpr, uint32_t arg_seqid, uint32_t arg_type_id)
    : xpr(std::move(arg_xpr))
    , seqid(arg_seqid)
    , type_id(arg_type_id)
{}

NextValueExpr::NextValueExpr(NextValueExpr&& other) noexcept
    : xpr(std::move(other.xpr))
    , seqid(std::exchange(other.seqid, (uint32_t)0ull))
    , type_id(std::exchange(other.type_id, (uint32_t)0ull))
{}

NextValueExpr::~NextValueExpr()
{
}

bool NextValueExpr::operator==([[maybe_unused]] const NextValueExpr& other) const noexcept
{
    return (
        true
        );
}

bool NextValueExpr::operator<([[maybe_unused]] const NextValueExpr& other) const noexcept
{
    return false;
}

NextValueExpr& NextValueExpr::operator=(NextValueExpr&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        seqid = std::exchange(other.seqid, (uint32_t)0ull);
        type_id = std::exchange(other.type_id, (uint32_t)0ull);
    }
    return *this;
}

std::string NextValueExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void NextValueExpr::swap(NextValueExpr& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(seqid, other.seqid);
    swap(type_id, other.type_id);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const NextValueExpr& value)
{
    stream << "NextValueExpr(";
    stream << "xpr="; stream << value.xpr;
    stream << ",seqid="; stream << value.seqid;
    stream << ",type_id="; stream << value.type_id;
    stream << ")";
    return stream;
}

InferenceElem::InferenceElem()
    : xpr()
    , expr()
    , infercollid((uint32_t)0ull)
    , inferopclass((uint32_t)0ull)
{}

InferenceElem::InferenceElem(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_expr, uint32_t arg_infercollid, uint32_t arg_inferopclass)
    : xpr(std::move(arg_xpr))
    , expr(std::move(arg_expr))
    , infercollid(arg_infercollid)
    , inferopclass(arg_inferopclass)
{}

InferenceElem::InferenceElem(InferenceElem&& other) noexcept
    : xpr(std::move(other.xpr))
    , expr(std::move(other.expr))
    , infercollid(std::exchange(other.infercollid, (uint32_t)0ull))
    , inferopclass(std::exchange(other.inferopclass, (uint32_t)0ull))
{}

InferenceElem::~InferenceElem()
{
}

bool InferenceElem::operator==([[maybe_unused]] const InferenceElem& other) const noexcept
{
    return (
        true
        );
}

bool InferenceElem::operator<([[maybe_unused]] const InferenceElem& other) const noexcept
{
    return false;
}

InferenceElem& InferenceElem::operator=(InferenceElem&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        expr = std::move(other.expr);
        infercollid = std::exchange(other.infercollid, (uint32_t)0ull);
        inferopclass = std::exchange(other.inferopclass, (uint32_t)0ull);
    }
    return *this;
}

std::string InferenceElem::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void InferenceElem::swap(InferenceElem& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(expr, other.expr);
    swap(infercollid, other.infercollid);
    swap(inferopclass, other.inferopclass);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const InferenceElem& value)
{
    stream << "InferenceElem(";
    stream << "xpr="; stream << value.xpr;
    stream << ",expr="; stream << value.expr;
    stream << ",infercollid="; stream << value.infercollid;
    stream << ",inferopclass="; stream << value.inferopclass;
    stream << ")";
    return stream;
}

TargetEntry::TargetEntry()
    : xpr()
    , expr()
    , resno((int32_t)0ll)
    , resname()
    , ressortgroupref((uint32_t)0ull)
    , resorigtbl((uint32_t)0ull)
    , resorigcol((int32_t)0ll)
    , resjunk(false)
{}

TargetEntry::TargetEntry(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_expr, int32_t arg_resno, const std::string& arg_resname, uint32_t arg_ressortgroupref, uint32_t arg_resorigtbl, int32_t arg_resorigcol, bool arg_resjunk)
    : xpr(std::move(arg_xpr))
    , expr(std::move(arg_expr))
    , resno(arg_resno)
    , resname(arg_resname)
    , ressortgroupref(arg_ressortgroupref)
    , resorigtbl(arg_resorigtbl)
    , resorigcol(arg_resorigcol)
    , resjunk(arg_resjunk)
{}

TargetEntry::TargetEntry(TargetEntry&& other) noexcept
    : xpr(std::move(other.xpr))
    , expr(std::move(other.expr))
    , resno(std::exchange(other.resno, (int32_t)0ll))
    , resname(std::move(other.resname))
    , ressortgroupref(std::exchange(other.ressortgroupref, (uint32_t)0ull))
    , resorigtbl(std::exchange(other.resorigtbl, (uint32_t)0ull))
    , resorigcol(std::exchange(other.resorigcol, (int32_t)0ll))
    , resjunk(std::exchange(other.resjunk, false))
{}

TargetEntry::~TargetEntry()
{
}

bool TargetEntry::operator==([[maybe_unused]] const TargetEntry& other) const noexcept
{
    return (
        true
        );
}

bool TargetEntry::operator<([[maybe_unused]] const TargetEntry& other) const noexcept
{
    return false;
}

TargetEntry& TargetEntry::operator=(TargetEntry&& other) noexcept
{
    if (this != &other)
    {
        xpr = std::move(other.xpr);
        expr = std::move(other.expr);
        resno = std::exchange(other.resno, (int32_t)0ll);
        resname = std::move(other.resname);
        ressortgroupref = std::exchange(other.ressortgroupref, (uint32_t)0ull);
        resorigtbl = std::exchange(other.resorigtbl, (uint32_t)0ull);
        resorigcol = std::exchange(other.resorigcol, (int32_t)0ll);
        resjunk = std::exchange(other.resjunk, false);
    }
    return *this;
}

std::string TargetEntry::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void TargetEntry::swap(TargetEntry& other) noexcept
{
    using std::swap;
    swap(xpr, other.xpr);
    swap(expr, other.expr);
    swap(resno, other.resno);
    swap(resname, other.resname);
    swap(ressortgroupref, other.ressortgroupref);
    swap(resorigtbl, other.resorigtbl);
    swap(resorigcol, other.resorigcol);
    swap(resjunk, other.resjunk);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const TargetEntry& value)
{
    stream << "TargetEntry(";
    stream << "xpr="; stream << value.xpr;
    stream << ",expr="; stream << value.expr;
    stream << ",resno="; stream << value.resno;
    stream << ",resname="; stream << "\"" << value.resname << "\"";
    stream << ",ressortgroupref="; stream << value.ressortgroupref;
    stream << ",resorigtbl="; stream << value.resorigtbl;
    stream << ",resorigcol="; stream << value.resorigcol;
    stream << ",resjunk="; stream << (value.resjunk ? "true" : "false");
    stream << ")";
    return stream;
}

RangeTblRef::RangeTblRef()
    : rtindex((int32_t)0ll)
{}

RangeTblRef::RangeTblRef(int32_t arg_rtindex)
    : rtindex(arg_rtindex)
{}

RangeTblRef::RangeTblRef(RangeTblRef&& other) noexcept
    : rtindex(std::exchange(other.rtindex, (int32_t)0ll))
{}

RangeTblRef::~RangeTblRef()
{
}

bool RangeTblRef::operator==([[maybe_unused]] const RangeTblRef& other) const noexcept
{
    return (
        true
        );
}

bool RangeTblRef::operator<([[maybe_unused]] const RangeTblRef& other) const noexcept
{
    return false;
}

RangeTblRef& RangeTblRef::operator=(RangeTblRef&& other) noexcept
{
    if (this != &other)
    {
        rtindex = std::exchange(other.rtindex, (int32_t)0ll);
    }
    return *this;
}

std::string RangeTblRef::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RangeTblRef::swap(RangeTblRef& other) noexcept
{
    using std::swap;
    swap(rtindex, other.rtindex);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RangeTblRef& value)
{
    stream << "RangeTblRef(";
    stream << "rtindex="; stream << value.rtindex;
    stream << ")";
    return stream;
}

JoinExpr::JoinExpr()
    : jointype()
    , is_natural(false)
    , larg()
    , rarg()
    , using_clause()
    , quals()
    , alias(nullptr)
    , rtindex((int32_t)0ll)
{}

JoinExpr::JoinExpr(::pg_query::JoinType&& arg_jointype, bool arg_is_natural, ::pg_query::Node&& arg_larg, ::pg_query::Node&& arg_rarg, std::vector<::pg_query::Node> arg_using_clause, ::pg_query::Node&& arg_quals, std::unique_ptr<::pg_query::Alias> arg_alias, int32_t arg_rtindex)
    : jointype(std::move(arg_jointype))
    , is_natural(arg_is_natural)
    , larg(std::move(arg_larg))
    , rarg(std::move(arg_rarg))
    , using_clause(std::move(arg_using_clause))
    , quals(std::move(arg_quals))
    , alias(arg_alias.release())
    , rtindex(arg_rtindex)
{}

JoinExpr::JoinExpr(JoinExpr&& other) noexcept
    : jointype(std::move(other.jointype))
    , is_natural(std::exchange(other.is_natural, false))
    , larg(std::move(other.larg))
    , rarg(std::move(other.rarg))
    , using_clause(std::move(other.using_clause))
    , quals(std::move(other.quals))
    , alias(std::exchange(other.alias, nullptr))
    , rtindex(std::exchange(other.rtindex, (int32_t)0ll))
{}

JoinExpr::~JoinExpr()
{
    if (alias) delete alias;
}

bool JoinExpr::operator==([[maybe_unused]] const JoinExpr& other) const noexcept
{
    return (
        true
        );
}

bool JoinExpr::operator<([[maybe_unused]] const JoinExpr& other) const noexcept
{
    return false;
}

JoinExpr& JoinExpr::operator=(JoinExpr&& other) noexcept
{
    if (this != &other)
    {
        jointype = std::move(other.jointype);
        is_natural = std::exchange(other.is_natural, false);
        larg = std::move(other.larg);
        rarg = std::move(other.rarg);
        using_clause = std::move(other.using_clause);
        quals = std::move(other.quals);
        alias = std::exchange(other.alias, nullptr);
        rtindex = std::exchange(other.rtindex, (int32_t)0ll);
    }
    return *this;
}

std::string JoinExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void JoinExpr::swap(JoinExpr& other) noexcept
{
    using std::swap;
    swap(jointype, other.jointype);
    swap(is_natural, other.is_natural);
    swap(larg, other.larg);
    swap(rarg, other.rarg);
    swap(using_clause, other.using_clause);
    swap(quals, other.quals);
    swap(alias, other.alias);
    swap(rtindex, other.rtindex);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const JoinExpr& value)
{
    stream << "JoinExpr(";
    stream << "jointype="; stream << value.jointype;
    stream << ",is_natural="; stream << (value.is_natural ? "true" : "false");
    stream << ",larg="; stream << value.larg;
    stream << ",rarg="; stream << value.rarg;
    {
        bool first = true;
        stream << ",using_clause=[" << value.using_clause.size() << "][";
        for (const auto& it : value.using_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",quals="; stream << value.quals;
    stream << ",alias="; stream << " ptr of other struct" << (value.alias == nullptr ? "true" : "false");
    stream << ",rtindex="; stream << value.rtindex;
    stream << ")";
    return stream;
}

FromExpr::FromExpr()
    : fromlist()
    , quals()
{}

FromExpr::FromExpr(std::vector<::pg_query::Node> arg_fromlist, ::pg_query::Node&& arg_quals)
    : fromlist(std::move(arg_fromlist))
    , quals(std::move(arg_quals))
{}

FromExpr::FromExpr(FromExpr&& other) noexcept
    : fromlist(std::move(other.fromlist))
    , quals(std::move(other.quals))
{}

FromExpr::~FromExpr()
{
}

bool FromExpr::operator==([[maybe_unused]] const FromExpr& other) const noexcept
{
    return (
        true
        );
}

bool FromExpr::operator<([[maybe_unused]] const FromExpr& other) const noexcept
{
    return false;
}

FromExpr& FromExpr::operator=(FromExpr&& other) noexcept
{
    if (this != &other)
    {
        fromlist = std::move(other.fromlist);
        quals = std::move(other.quals);
    }
    return *this;
}

std::string FromExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void FromExpr::swap(FromExpr& other) noexcept
{
    using std::swap;
    swap(fromlist, other.fromlist);
    swap(quals, other.quals);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const FromExpr& value)
{
    stream << "FromExpr(";
    {
        bool first = true;
        stream << "fromlist=[" << value.fromlist.size() << "][";
        for (const auto& it : value.fromlist)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",quals="; stream << value.quals;
    stream << ")";
    return stream;
}

OnConflictExpr::OnConflictExpr()
    : action()
    , arbiter_elems()
    , arbiter_where()
    , constraint((uint32_t)0ull)
    , on_conflict_set()
    , on_conflict_where()
    , excl_rel_index((int32_t)0ll)
    , excl_rel_tlist()
{}

OnConflictExpr::OnConflictExpr(::pg_query::OnConflictAction&& arg_action, std::vector<::pg_query::Node> arg_arbiter_elems, ::pg_query::Node&& arg_arbiter_where, uint32_t arg_constraint, std::vector<::pg_query::Node> arg_on_conflict_set, ::pg_query::Node&& arg_on_conflict_where, int32_t arg_excl_rel_index, std::vector<::pg_query::Node> arg_excl_rel_tlist)
    : action(std::move(arg_action))
    , arbiter_elems(std::move(arg_arbiter_elems))
    , arbiter_where(std::move(arg_arbiter_where))
    , constraint(arg_constraint)
    , on_conflict_set(std::move(arg_on_conflict_set))
    , on_conflict_where(std::move(arg_on_conflict_where))
    , excl_rel_index(arg_excl_rel_index)
    , excl_rel_tlist(std::move(arg_excl_rel_tlist))
{}

OnConflictExpr::OnConflictExpr(OnConflictExpr&& other) noexcept
    : action(std::move(other.action))
    , arbiter_elems(std::move(other.arbiter_elems))
    , arbiter_where(std::move(other.arbiter_where))
    , constraint(std::exchange(other.constraint, (uint32_t)0ull))
    , on_conflict_set(std::move(other.on_conflict_set))
    , on_conflict_where(std::move(other.on_conflict_where))
    , excl_rel_index(std::exchange(other.excl_rel_index, (int32_t)0ll))
    , excl_rel_tlist(std::move(other.excl_rel_tlist))
{}

OnConflictExpr::~OnConflictExpr()
{
}

bool OnConflictExpr::operator==([[maybe_unused]] const OnConflictExpr& other) const noexcept
{
    return (
        true
        );
}

bool OnConflictExpr::operator<([[maybe_unused]] const OnConflictExpr& other) const noexcept
{
    return false;
}

OnConflictExpr& OnConflictExpr::operator=(OnConflictExpr&& other) noexcept
{
    if (this != &other)
    {
        action = std::move(other.action);
        arbiter_elems = std::move(other.arbiter_elems);
        arbiter_where = std::move(other.arbiter_where);
        constraint = std::exchange(other.constraint, (uint32_t)0ull);
        on_conflict_set = std::move(other.on_conflict_set);
        on_conflict_where = std::move(other.on_conflict_where);
        excl_rel_index = std::exchange(other.excl_rel_index, (int32_t)0ll);
        excl_rel_tlist = std::move(other.excl_rel_tlist);
    }
    return *this;
}

std::string OnConflictExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void OnConflictExpr::swap(OnConflictExpr& other) noexcept
{
    using std::swap;
    swap(action, other.action);
    swap(arbiter_elems, other.arbiter_elems);
    swap(arbiter_where, other.arbiter_where);
    swap(constraint, other.constraint);
    swap(on_conflict_set, other.on_conflict_set);
    swap(on_conflict_where, other.on_conflict_where);
    swap(excl_rel_index, other.excl_rel_index);
    swap(excl_rel_tlist, other.excl_rel_tlist);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const OnConflictExpr& value)
{
    stream << "OnConflictExpr(";
    stream << "action="; stream << value.action;
    {
        bool first = true;
        stream << ",arbiter_elems=[" << value.arbiter_elems.size() << "][";
        for (const auto& it : value.arbiter_elems)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",arbiter_where="; stream << value.arbiter_where;
    stream << ",constraint="; stream << value.constraint;
    {
        bool first = true;
        stream << ",on_conflict_set=[" << value.on_conflict_set.size() << "][";
        for (const auto& it : value.on_conflict_set)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",on_conflict_where="; stream << value.on_conflict_where;
    stream << ",excl_rel_index="; stream << value.excl_rel_index;
    {
        bool first = true;
        stream << ",excl_rel_tlist=[" << value.excl_rel_tlist.size() << "][";
        for (const auto& it : value.excl_rel_tlist)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

IntoClause::IntoClause()
    : rel(nullptr)
    , col_names()
    , access_method()
    , options()
    , on_commit()
    , table_space_name()
    , view_query()
    , skip_data(false)
{}

IntoClause::IntoClause(std::unique_ptr<::pg_query::RangeVar> arg_rel, std::vector<::pg_query::Node> arg_col_names, const std::string& arg_access_method, std::vector<::pg_query::Node> arg_options, ::pg_query::OnCommitAction&& arg_on_commit, const std::string& arg_table_space_name, ::pg_query::Node&& arg_view_query, bool arg_skip_data)
    : rel(arg_rel.release())
    , col_names(std::move(arg_col_names))
    , access_method(arg_access_method)
    , options(std::move(arg_options))
    , on_commit(std::move(arg_on_commit))
    , table_space_name(arg_table_space_name)
    , view_query(std::move(arg_view_query))
    , skip_data(arg_skip_data)
{}

IntoClause::IntoClause(IntoClause&& other) noexcept
    : rel(std::exchange(other.rel, nullptr))
    , col_names(std::move(other.col_names))
    , access_method(std::move(other.access_method))
    , options(std::move(other.options))
    , on_commit(std::move(other.on_commit))
    , table_space_name(std::move(other.table_space_name))
    , view_query(std::move(other.view_query))
    , skip_data(std::exchange(other.skip_data, false))
{}

IntoClause::~IntoClause()
{
    if (rel) delete rel;
}

bool IntoClause::operator==([[maybe_unused]] const IntoClause& other) const noexcept
{
    return (
        true
        );
}

bool IntoClause::operator<([[maybe_unused]] const IntoClause& other) const noexcept
{
    return false;
}

IntoClause& IntoClause::operator=(IntoClause&& other) noexcept
{
    if (this != &other)
    {
        rel = std::exchange(other.rel, nullptr);
        col_names = std::move(other.col_names);
        access_method = std::move(other.access_method);
        options = std::move(other.options);
        on_commit = std::move(other.on_commit);
        table_space_name = std::move(other.table_space_name);
        view_query = std::move(other.view_query);
        skip_data = std::exchange(other.skip_data, false);
    }
    return *this;
}

std::string IntoClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void IntoClause::swap(IntoClause& other) noexcept
{
    using std::swap;
    swap(rel, other.rel);
    swap(col_names, other.col_names);
    swap(access_method, other.access_method);
    swap(options, other.options);
    swap(on_commit, other.on_commit);
    swap(table_space_name, other.table_space_name);
    swap(view_query, other.view_query);
    swap(skip_data, other.skip_data);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const IntoClause& value)
{
    stream << "IntoClause(";
    stream << "rel="; stream << " ptr of other struct" << (value.rel == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",col_names=[" << value.col_names.size() << "][";
        for (const auto& it : value.col_names)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",access_method="; stream << "\"" << value.access_method << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",on_commit="; stream << value.on_commit;
    stream << ",table_space_name="; stream << "\"" << value.table_space_name << "\"";
    stream << ",view_query="; stream << value.view_query;
    stream << ",skip_data="; stream << (value.skip_data ? "true" : "false");
    stream << ")";
    return stream;
}

RawStmt::RawStmt()
    : stmt()
    , stmt_location((int32_t)0ll)
    , stmt_len((int32_t)0ll)
{}

RawStmt::RawStmt(::pg_query::Node&& arg_stmt, int32_t arg_stmt_location, int32_t arg_stmt_len)
    : stmt(std::move(arg_stmt))
    , stmt_location(arg_stmt_location)
    , stmt_len(arg_stmt_len)
{}

RawStmt::RawStmt(RawStmt&& other) noexcept
    : stmt(std::move(other.stmt))
    , stmt_location(std::exchange(other.stmt_location, (int32_t)0ll))
    , stmt_len(std::exchange(other.stmt_len, (int32_t)0ll))
{}

RawStmt::~RawStmt()
{
}

bool RawStmt::operator==([[maybe_unused]] const RawStmt& other) const noexcept
{
    return (
        true
        );
}

bool RawStmt::operator<([[maybe_unused]] const RawStmt& other) const noexcept
{
    return false;
}

RawStmt& RawStmt::operator=(RawStmt&& other) noexcept
{
    if (this != &other)
    {
        stmt = std::move(other.stmt);
        stmt_location = std::exchange(other.stmt_location, (int32_t)0ll);
        stmt_len = std::exchange(other.stmt_len, (int32_t)0ll);
    }
    return *this;
}

std::string RawStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RawStmt::swap(RawStmt& other) noexcept
{
    using std::swap;
    swap(stmt, other.stmt);
    swap(stmt_location, other.stmt_location);
    swap(stmt_len, other.stmt_len);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RawStmt& value)
{
    stream << "RawStmt(";
    stream << "stmt="; stream << value.stmt;
    stream << ",stmt_location="; stream << value.stmt_location;
    stream << ",stmt_len="; stream << value.stmt_len;
    stream << ")";
    return stream;
}

Query::Query()
    : command_type()
    , query_source()
    , can_set_tag(false)
    , utility_stmt()
    , result_relation((int32_t)0ll)
    , has_aggs(false)
    , has_window_funcs(false)
    , has_target_srfs(false)
    , has_sub_links(false)
    , has_distinct_on(false)
    , has_recursive(false)
    , has_modifying_cte(false)
    , has_for_update(false)
    , has_row_security(false)
    , cte_list()
    , rtable()
    , jointree(nullptr)
    , target_list()
    , override()
    , on_conflict(nullptr)
    , returning_list()
    , group_clause()
    , grouping_sets()
    , having_qual()
    , window_clause()
    , distinct_clause()
    , sort_clause()
    , limit_offset()
    , limit_count()
    , limit_option()
    , row_marks()
    , set_operations()
    , constraint_deps()
    , with_check_options()
    , stmt_location((int32_t)0ll)
    , stmt_len((int32_t)0ll)
{}

Query::Query(::pg_query::CmdType&& arg_command_type, ::pg_query::QuerySource&& arg_query_source, bool arg_can_set_tag, ::pg_query::Node&& arg_utility_stmt, int32_t arg_result_relation, bool arg_has_aggs, bool arg_has_window_funcs, bool arg_has_target_srfs, bool arg_has_sub_links, bool arg_has_distinct_on, bool arg_has_recursive, bool arg_has_modifying_cte, bool arg_has_for_update, bool arg_has_row_security, std::vector<::pg_query::Node> arg_cte_list, std::vector<::pg_query::Node> arg_rtable, std::unique_ptr<::pg_query::FromExpr> arg_jointree, std::vector<::pg_query::Node> arg_target_list, ::pg_query::OverridingKind&& arg_override, std::unique_ptr<::pg_query::OnConflictExpr> arg_on_conflict, std::vector<::pg_query::Node> arg_returning_list, std::vector<::pg_query::Node> arg_group_clause, std::vector<::pg_query::Node> arg_grouping_sets, ::pg_query::Node&& arg_having_qual, std::vector<::pg_query::Node> arg_window_clause, std::vector<::pg_query::Node> arg_distinct_clause, std::vector<::pg_query::Node> arg_sort_clause, ::pg_query::Node&& arg_limit_offset, ::pg_query::Node&& arg_limit_count, ::pg_query::LimitOption&& arg_limit_option, std::vector<::pg_query::Node> arg_row_marks, ::pg_query::Node&& arg_set_operations, std::vector<::pg_query::Node> arg_constraint_deps, std::vector<::pg_query::Node> arg_with_check_options, int32_t arg_stmt_location, int32_t arg_stmt_len)
    : command_type(std::move(arg_command_type))
    , query_source(std::move(arg_query_source))
    , can_set_tag(arg_can_set_tag)
    , utility_stmt(std::move(arg_utility_stmt))
    , result_relation(arg_result_relation)
    , has_aggs(arg_has_aggs)
    , has_window_funcs(arg_has_window_funcs)
    , has_target_srfs(arg_has_target_srfs)
    , has_sub_links(arg_has_sub_links)
    , has_distinct_on(arg_has_distinct_on)
    , has_recursive(arg_has_recursive)
    , has_modifying_cte(arg_has_modifying_cte)
    , has_for_update(arg_has_for_update)
    , has_row_security(arg_has_row_security)
    , cte_list(std::move(arg_cte_list))
    , rtable(std::move(arg_rtable))
    , jointree(arg_jointree.release())
    , target_list(std::move(arg_target_list))
    , override(std::move(arg_override))
    , on_conflict(arg_on_conflict.release())
    , returning_list(std::move(arg_returning_list))
    , group_clause(std::move(arg_group_clause))
    , grouping_sets(std::move(arg_grouping_sets))
    , having_qual(std::move(arg_having_qual))
    , window_clause(std::move(arg_window_clause))
    , distinct_clause(std::move(arg_distinct_clause))
    , sort_clause(std::move(arg_sort_clause))
    , limit_offset(std::move(arg_limit_offset))
    , limit_count(std::move(arg_limit_count))
    , limit_option(std::move(arg_limit_option))
    , row_marks(std::move(arg_row_marks))
    , set_operations(std::move(arg_set_operations))
    , constraint_deps(std::move(arg_constraint_deps))
    , with_check_options(std::move(arg_with_check_options))
    , stmt_location(arg_stmt_location)
    , stmt_len(arg_stmt_len)
{}

Query::Query(Query&& other) noexcept
    : command_type(std::move(other.command_type))
    , query_source(std::move(other.query_source))
    , can_set_tag(std::exchange(other.can_set_tag, false))
    , utility_stmt(std::move(other.utility_stmt))
    , result_relation(std::exchange(other.result_relation, (int32_t)0ll))
    , has_aggs(std::exchange(other.has_aggs, false))
    , has_window_funcs(std::exchange(other.has_window_funcs, false))
    , has_target_srfs(std::exchange(other.has_target_srfs, false))
    , has_sub_links(std::exchange(other.has_sub_links, false))
    , has_distinct_on(std::exchange(other.has_distinct_on, false))
    , has_recursive(std::exchange(other.has_recursive, false))
    , has_modifying_cte(std::exchange(other.has_modifying_cte, false))
    , has_for_update(std::exchange(other.has_for_update, false))
    , has_row_security(std::exchange(other.has_row_security, false))
    , cte_list(std::move(other.cte_list))
    , rtable(std::move(other.rtable))
    , jointree(std::exchange(other.jointree, nullptr))
    , target_list(std::move(other.target_list))
    , override(std::move(other.override))
    , on_conflict(std::exchange(other.on_conflict, nullptr))
    , returning_list(std::move(other.returning_list))
    , group_clause(std::move(other.group_clause))
    , grouping_sets(std::move(other.grouping_sets))
    , having_qual(std::move(other.having_qual))
    , window_clause(std::move(other.window_clause))
    , distinct_clause(std::move(other.distinct_clause))
    , sort_clause(std::move(other.sort_clause))
    , limit_offset(std::move(other.limit_offset))
    , limit_count(std::move(other.limit_count))
    , limit_option(std::move(other.limit_option))
    , row_marks(std::move(other.row_marks))
    , set_operations(std::move(other.set_operations))
    , constraint_deps(std::move(other.constraint_deps))
    , with_check_options(std::move(other.with_check_options))
    , stmt_location(std::exchange(other.stmt_location, (int32_t)0ll))
    , stmt_len(std::exchange(other.stmt_len, (int32_t)0ll))
{}

Query::~Query()
{
    if (jointree) delete jointree;
    if (on_conflict) delete on_conflict;
}

bool Query::operator==([[maybe_unused]] const Query& other) const noexcept
{
    return (
        true
        );
}

bool Query::operator<([[maybe_unused]] const Query& other) const noexcept
{
    return false;
}

Query& Query::operator=(Query&& other) noexcept
{
    if (this != &other)
    {
        command_type = std::move(other.command_type);
        query_source = std::move(other.query_source);
        can_set_tag = std::exchange(other.can_set_tag, false);
        utility_stmt = std::move(other.utility_stmt);
        result_relation = std::exchange(other.result_relation, (int32_t)0ll);
        has_aggs = std::exchange(other.has_aggs, false);
        has_window_funcs = std::exchange(other.has_window_funcs, false);
        has_target_srfs = std::exchange(other.has_target_srfs, false);
        has_sub_links = std::exchange(other.has_sub_links, false);
        has_distinct_on = std::exchange(other.has_distinct_on, false);
        has_recursive = std::exchange(other.has_recursive, false);
        has_modifying_cte = std::exchange(other.has_modifying_cte, false);
        has_for_update = std::exchange(other.has_for_update, false);
        has_row_security = std::exchange(other.has_row_security, false);
        cte_list = std::move(other.cte_list);
        rtable = std::move(other.rtable);
        jointree = std::exchange(other.jointree, nullptr);
        target_list = std::move(other.target_list);
        override = std::move(other.override);
        on_conflict = std::exchange(other.on_conflict, nullptr);
        returning_list = std::move(other.returning_list);
        group_clause = std::move(other.group_clause);
        grouping_sets = std::move(other.grouping_sets);
        having_qual = std::move(other.having_qual);
        window_clause = std::move(other.window_clause);
        distinct_clause = std::move(other.distinct_clause);
        sort_clause = std::move(other.sort_clause);
        limit_offset = std::move(other.limit_offset);
        limit_count = std::move(other.limit_count);
        limit_option = std::move(other.limit_option);
        row_marks = std::move(other.row_marks);
        set_operations = std::move(other.set_operations);
        constraint_deps = std::move(other.constraint_deps);
        with_check_options = std::move(other.with_check_options);
        stmt_location = std::exchange(other.stmt_location, (int32_t)0ll);
        stmt_len = std::exchange(other.stmt_len, (int32_t)0ll);
    }
    return *this;
}

std::string Query::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Query::swap(Query& other) noexcept
{
    using std::swap;
    swap(command_type, other.command_type);
    swap(query_source, other.query_source);
    swap(can_set_tag, other.can_set_tag);
    swap(utility_stmt, other.utility_stmt);
    swap(result_relation, other.result_relation);
    swap(has_aggs, other.has_aggs);
    swap(has_window_funcs, other.has_window_funcs);
    swap(has_target_srfs, other.has_target_srfs);
    swap(has_sub_links, other.has_sub_links);
    swap(has_distinct_on, other.has_distinct_on);
    swap(has_recursive, other.has_recursive);
    swap(has_modifying_cte, other.has_modifying_cte);
    swap(has_for_update, other.has_for_update);
    swap(has_row_security, other.has_row_security);
    swap(cte_list, other.cte_list);
    swap(rtable, other.rtable);
    swap(jointree, other.jointree);
    swap(target_list, other.target_list);
    swap(override, other.override);
    swap(on_conflict, other.on_conflict);
    swap(returning_list, other.returning_list);
    swap(group_clause, other.group_clause);
    swap(grouping_sets, other.grouping_sets);
    swap(having_qual, other.having_qual);
    swap(window_clause, other.window_clause);
    swap(distinct_clause, other.distinct_clause);
    swap(sort_clause, other.sort_clause);
    swap(limit_offset, other.limit_offset);
    swap(limit_count, other.limit_count);
    swap(limit_option, other.limit_option);
    swap(row_marks, other.row_marks);
    swap(set_operations, other.set_operations);
    swap(constraint_deps, other.constraint_deps);
    swap(with_check_options, other.with_check_options);
    swap(stmt_location, other.stmt_location);
    swap(stmt_len, other.stmt_len);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Query& value)
{
    stream << "Query(";
    stream << "command_type="; stream << value.command_type;
    stream << ",query_source="; stream << value.query_source;
    stream << ",can_set_tag="; stream << (value.can_set_tag ? "true" : "false");
    stream << ",utility_stmt="; stream << value.utility_stmt;
    stream << ",result_relation="; stream << value.result_relation;
    stream << ",has_aggs="; stream << (value.has_aggs ? "true" : "false");
    stream << ",has_window_funcs="; stream << (value.has_window_funcs ? "true" : "false");
    stream << ",has_target_srfs="; stream << (value.has_target_srfs ? "true" : "false");
    stream << ",has_sub_links="; stream << (value.has_sub_links ? "true" : "false");
    stream << ",has_distinct_on="; stream << (value.has_distinct_on ? "true" : "false");
    stream << ",has_recursive="; stream << (value.has_recursive ? "true" : "false");
    stream << ",has_modifying_cte="; stream << (value.has_modifying_cte ? "true" : "false");
    stream << ",has_for_update="; stream << (value.has_for_update ? "true" : "false");
    stream << ",has_row_security="; stream << (value.has_row_security ? "true" : "false");
    {
        bool first = true;
        stream << ",cte_list=[" << value.cte_list.size() << "][";
        for (const auto& it : value.cte_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",rtable=[" << value.rtable.size() << "][";
        for (const auto& it : value.rtable)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",jointree="; stream << " ptr of other struct" << (value.jointree == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",target_list=[" << value.target_list.size() << "][";
        for (const auto& it : value.target_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",override="; stream << value.override;
    stream << ",on_conflict="; stream << " ptr of other struct" << (value.on_conflict == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",returning_list=[" << value.returning_list.size() << "][";
        for (const auto& it : value.returning_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",group_clause=[" << value.group_clause.size() << "][";
        for (const auto& it : value.group_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",grouping_sets=[" << value.grouping_sets.size() << "][";
        for (const auto& it : value.grouping_sets)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",having_qual="; stream << value.having_qual;
    {
        bool first = true;
        stream << ",window_clause=[" << value.window_clause.size() << "][";
        for (const auto& it : value.window_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",distinct_clause=[" << value.distinct_clause.size() << "][";
        for (const auto& it : value.distinct_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",sort_clause=[" << value.sort_clause.size() << "][";
        for (const auto& it : value.sort_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",limit_offset="; stream << value.limit_offset;
    stream << ",limit_count="; stream << value.limit_count;
    stream << ",limit_option="; stream << value.limit_option;
    {
        bool first = true;
        stream << ",row_marks=[" << value.row_marks.size() << "][";
        for (const auto& it : value.row_marks)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",set_operations="; stream << value.set_operations;
    {
        bool first = true;
        stream << ",constraint_deps=[" << value.constraint_deps.size() << "][";
        for (const auto& it : value.constraint_deps)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",with_check_options=[" << value.with_check_options.size() << "][";
        for (const auto& it : value.with_check_options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",stmt_location="; stream << value.stmt_location;
    stream << ",stmt_len="; stream << value.stmt_len;
    stream << ")";
    return stream;
}

InsertStmt::InsertStmt()
    : relation(nullptr)
    , cols()
    , select_stmt()
    , on_conflict_clause(nullptr)
    , returning_list()
    , with_clause(nullptr)
    , override()
{}

InsertStmt::InsertStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_cols, ::pg_query::Node&& arg_select_stmt, std::unique_ptr<::pg_query::OnConflictClause> arg_on_conflict_clause, std::vector<::pg_query::Node> arg_returning_list, std::unique_ptr<::pg_query::WithClause> arg_with_clause, ::pg_query::OverridingKind&& arg_override)
    : relation(arg_relation.release())
    , cols(std::move(arg_cols))
    , select_stmt(std::move(arg_select_stmt))
    , on_conflict_clause(arg_on_conflict_clause.release())
    , returning_list(std::move(arg_returning_list))
    , with_clause(arg_with_clause.release())
    , override(std::move(arg_override))
{}

InsertStmt::InsertStmt(InsertStmt&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , cols(std::move(other.cols))
    , select_stmt(std::move(other.select_stmt))
    , on_conflict_clause(std::exchange(other.on_conflict_clause, nullptr))
    , returning_list(std::move(other.returning_list))
    , with_clause(std::exchange(other.with_clause, nullptr))
    , override(std::move(other.override))
{}

InsertStmt::~InsertStmt()
{
    if (relation) delete relation;
    if (on_conflict_clause) delete on_conflict_clause;
    if (with_clause) delete with_clause;
}

bool InsertStmt::operator==([[maybe_unused]] const InsertStmt& other) const noexcept
{
    return (
        true
        );
}

bool InsertStmt::operator<([[maybe_unused]] const InsertStmt& other) const noexcept
{
    return false;
}

InsertStmt& InsertStmt::operator=(InsertStmt&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        cols = std::move(other.cols);
        select_stmt = std::move(other.select_stmt);
        on_conflict_clause = std::exchange(other.on_conflict_clause, nullptr);
        returning_list = std::move(other.returning_list);
        with_clause = std::exchange(other.with_clause, nullptr);
        override = std::move(other.override);
    }
    return *this;
}

std::string InsertStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void InsertStmt::swap(InsertStmt& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(cols, other.cols);
    swap(select_stmt, other.select_stmt);
    swap(on_conflict_clause, other.on_conflict_clause);
    swap(returning_list, other.returning_list);
    swap(with_clause, other.with_clause);
    swap(override, other.override);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const InsertStmt& value)
{
    stream << "InsertStmt(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",cols=[" << value.cols.size() << "][";
        for (const auto& it : value.cols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",select_stmt="; stream << value.select_stmt;
    stream << ",on_conflict_clause="; stream << " ptr of other struct" << (value.on_conflict_clause == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",returning_list=[" << value.returning_list.size() << "][";
        for (const auto& it : value.returning_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",with_clause="; stream << " ptr of other struct" << (value.with_clause == nullptr ? "true" : "false");
    stream << ",override="; stream << value.override;
    stream << ")";
    return stream;
}

DeleteStmt::DeleteStmt()
    : relation(nullptr)
    , using_clause()
    , where_clause()
    , returning_list()
    , with_clause(nullptr)
{}

DeleteStmt::DeleteStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_using_clause, ::pg_query::Node&& arg_where_clause, std::vector<::pg_query::Node> arg_returning_list, std::unique_ptr<::pg_query::WithClause> arg_with_clause)
    : relation(arg_relation.release())
    , using_clause(std::move(arg_using_clause))
    , where_clause(std::move(arg_where_clause))
    , returning_list(std::move(arg_returning_list))
    , with_clause(arg_with_clause.release())
{}

DeleteStmt::DeleteStmt(DeleteStmt&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , using_clause(std::move(other.using_clause))
    , where_clause(std::move(other.where_clause))
    , returning_list(std::move(other.returning_list))
    , with_clause(std::exchange(other.with_clause, nullptr))
{}

DeleteStmt::~DeleteStmt()
{
    if (relation) delete relation;
    if (with_clause) delete with_clause;
}

bool DeleteStmt::operator==([[maybe_unused]] const DeleteStmt& other) const noexcept
{
    return (
        true
        );
}

bool DeleteStmt::operator<([[maybe_unused]] const DeleteStmt& other) const noexcept
{
    return false;
}

DeleteStmt& DeleteStmt::operator=(DeleteStmt&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        using_clause = std::move(other.using_clause);
        where_clause = std::move(other.where_clause);
        returning_list = std::move(other.returning_list);
        with_clause = std::exchange(other.with_clause, nullptr);
    }
    return *this;
}

std::string DeleteStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DeleteStmt::swap(DeleteStmt& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(using_clause, other.using_clause);
    swap(where_clause, other.where_clause);
    swap(returning_list, other.returning_list);
    swap(with_clause, other.with_clause);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DeleteStmt& value)
{
    stream << "DeleteStmt(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",using_clause=[" << value.using_clause.size() << "][";
        for (const auto& it : value.using_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",where_clause="; stream << value.where_clause;
    {
        bool first = true;
        stream << ",returning_list=[" << value.returning_list.size() << "][";
        for (const auto& it : value.returning_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",with_clause="; stream << " ptr of other struct" << (value.with_clause == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

UpdateStmt::UpdateStmt()
    : relation(nullptr)
    , target_list()
    , where_clause()
    , from_clause()
    , returning_list()
    , with_clause(nullptr)
{}

UpdateStmt::UpdateStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_target_list, ::pg_query::Node&& arg_where_clause, std::vector<::pg_query::Node> arg_from_clause, std::vector<::pg_query::Node> arg_returning_list, std::unique_ptr<::pg_query::WithClause> arg_with_clause)
    : relation(arg_relation.release())
    , target_list(std::move(arg_target_list))
    , where_clause(std::move(arg_where_clause))
    , from_clause(std::move(arg_from_clause))
    , returning_list(std::move(arg_returning_list))
    , with_clause(arg_with_clause.release())
{}

UpdateStmt::UpdateStmt(UpdateStmt&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , target_list(std::move(other.target_list))
    , where_clause(std::move(other.where_clause))
    , from_clause(std::move(other.from_clause))
    , returning_list(std::move(other.returning_list))
    , with_clause(std::exchange(other.with_clause, nullptr))
{}

UpdateStmt::~UpdateStmt()
{
    if (relation) delete relation;
    if (with_clause) delete with_clause;
}

bool UpdateStmt::operator==([[maybe_unused]] const UpdateStmt& other) const noexcept
{
    return (
        true
        );
}

bool UpdateStmt::operator<([[maybe_unused]] const UpdateStmt& other) const noexcept
{
    return false;
}

UpdateStmt& UpdateStmt::operator=(UpdateStmt&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        target_list = std::move(other.target_list);
        where_clause = std::move(other.where_clause);
        from_clause = std::move(other.from_clause);
        returning_list = std::move(other.returning_list);
        with_clause = std::exchange(other.with_clause, nullptr);
    }
    return *this;
}

std::string UpdateStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void UpdateStmt::swap(UpdateStmt& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(target_list, other.target_list);
    swap(where_clause, other.where_clause);
    swap(from_clause, other.from_clause);
    swap(returning_list, other.returning_list);
    swap(with_clause, other.with_clause);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const UpdateStmt& value)
{
    stream << "UpdateStmt(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",target_list=[" << value.target_list.size() << "][";
        for (const auto& it : value.target_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",where_clause="; stream << value.where_clause;
    {
        bool first = true;
        stream << ",from_clause=[" << value.from_clause.size() << "][";
        for (const auto& it : value.from_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",returning_list=[" << value.returning_list.size() << "][";
        for (const auto& it : value.returning_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",with_clause="; stream << " ptr of other struct" << (value.with_clause == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

SelectStmt::SelectStmt()
    : distinct_clause()
    , into_clause(nullptr)
    , target_list()
    , from_clause()
    , where_clause()
    , group_clause()
    , having_clause()
    , window_clause()
    , values_lists()
    , sort_clause()
    , limit_offset()
    , limit_count()
    , limit_option()
    , locking_clause()
    , with_clause(nullptr)
    , op()
    , all(false)
    , larg(nullptr)
    , rarg(nullptr)
{}

SelectStmt::SelectStmt(std::vector<::pg_query::Node> arg_distinct_clause, std::unique_ptr<::pg_query::IntoClause> arg_into_clause, std::vector<::pg_query::Node> arg_target_list, std::vector<::pg_query::Node> arg_from_clause, ::pg_query::Node&& arg_where_clause, std::vector<::pg_query::Node> arg_group_clause, ::pg_query::Node&& arg_having_clause, std::vector<::pg_query::Node> arg_window_clause, std::vector<::pg_query::Node> arg_values_lists, std::vector<::pg_query::Node> arg_sort_clause, ::pg_query::Node&& arg_limit_offset, ::pg_query::Node&& arg_limit_count, ::pg_query::LimitOption&& arg_limit_option, std::vector<::pg_query::Node> arg_locking_clause, std::unique_ptr<::pg_query::WithClause> arg_with_clause, ::pg_query::SetOperation&& arg_op, bool arg_all, std::unique_ptr<::pg_query::SelectStmt> arg_larg, std::unique_ptr<::pg_query::SelectStmt> arg_rarg)
    : distinct_clause(std::move(arg_distinct_clause))
    , into_clause(arg_into_clause.release())
    , target_list(std::move(arg_target_list))
    , from_clause(std::move(arg_from_clause))
    , where_clause(std::move(arg_where_clause))
    , group_clause(std::move(arg_group_clause))
    , having_clause(std::move(arg_having_clause))
    , window_clause(std::move(arg_window_clause))
    , values_lists(std::move(arg_values_lists))
    , sort_clause(std::move(arg_sort_clause))
    , limit_offset(std::move(arg_limit_offset))
    , limit_count(std::move(arg_limit_count))
    , limit_option(std::move(arg_limit_option))
    , locking_clause(std::move(arg_locking_clause))
    , with_clause(arg_with_clause.release())
    , op(std::move(arg_op))
    , all(arg_all)
    , larg(arg_larg.release())
    , rarg(arg_rarg.release())
{}

SelectStmt::SelectStmt(SelectStmt&& other) noexcept
    : distinct_clause(std::move(other.distinct_clause))
    , into_clause(std::exchange(other.into_clause, nullptr))
    , target_list(std::move(other.target_list))
    , from_clause(std::move(other.from_clause))
    , where_clause(std::move(other.where_clause))
    , group_clause(std::move(other.group_clause))
    , having_clause(std::move(other.having_clause))
    , window_clause(std::move(other.window_clause))
    , values_lists(std::move(other.values_lists))
    , sort_clause(std::move(other.sort_clause))
    , limit_offset(std::move(other.limit_offset))
    , limit_count(std::move(other.limit_count))
    , limit_option(std::move(other.limit_option))
    , locking_clause(std::move(other.locking_clause))
    , with_clause(std::exchange(other.with_clause, nullptr))
    , op(std::move(other.op))
    , all(std::exchange(other.all, false))
    , larg(std::exchange(other.larg, nullptr))
    , rarg(std::exchange(other.rarg, nullptr))
{}

SelectStmt::~SelectStmt()
{
    if (into_clause) delete into_clause;
    if (with_clause) delete with_clause;
    if (larg) delete larg;
    if (rarg) delete rarg;
}

bool SelectStmt::operator==([[maybe_unused]] const SelectStmt& other) const noexcept
{
    return (
        true
        );
}

bool SelectStmt::operator<([[maybe_unused]] const SelectStmt& other) const noexcept
{
    return false;
}

SelectStmt& SelectStmt::operator=(SelectStmt&& other) noexcept
{
    if (this != &other)
    {
        distinct_clause = std::move(other.distinct_clause);
        into_clause = std::exchange(other.into_clause, nullptr);
        target_list = std::move(other.target_list);
        from_clause = std::move(other.from_clause);
        where_clause = std::move(other.where_clause);
        group_clause = std::move(other.group_clause);
        having_clause = std::move(other.having_clause);
        window_clause = std::move(other.window_clause);
        values_lists = std::move(other.values_lists);
        sort_clause = std::move(other.sort_clause);
        limit_offset = std::move(other.limit_offset);
        limit_count = std::move(other.limit_count);
        limit_option = std::move(other.limit_option);
        locking_clause = std::move(other.locking_clause);
        with_clause = std::exchange(other.with_clause, nullptr);
        op = std::move(other.op);
        all = std::exchange(other.all, false);
        larg = std::exchange(other.larg, nullptr);
        rarg = std::exchange(other.rarg, nullptr);
    }
    return *this;
}

std::string SelectStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SelectStmt::swap(SelectStmt& other) noexcept
{
    using std::swap;
    swap(distinct_clause, other.distinct_clause);
    swap(into_clause, other.into_clause);
    swap(target_list, other.target_list);
    swap(from_clause, other.from_clause);
    swap(where_clause, other.where_clause);
    swap(group_clause, other.group_clause);
    swap(having_clause, other.having_clause);
    swap(window_clause, other.window_clause);
    swap(values_lists, other.values_lists);
    swap(sort_clause, other.sort_clause);
    swap(limit_offset, other.limit_offset);
    swap(limit_count, other.limit_count);
    swap(limit_option, other.limit_option);
    swap(locking_clause, other.locking_clause);
    swap(with_clause, other.with_clause);
    swap(op, other.op);
    swap(all, other.all);
    swap(larg, other.larg);
    swap(rarg, other.rarg);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SelectStmt& value)
{
    stream << "SelectStmt(";
    {
        bool first = true;
        stream << "distinct_clause=[" << value.distinct_clause.size() << "][";
        for (const auto& it : value.distinct_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",into_clause="; stream << " ptr of other struct" << (value.into_clause == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",target_list=[" << value.target_list.size() << "][";
        for (const auto& it : value.target_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",from_clause=[" << value.from_clause.size() << "][";
        for (const auto& it : value.from_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",where_clause="; stream << value.where_clause;
    {
        bool first = true;
        stream << ",group_clause=[" << value.group_clause.size() << "][";
        for (const auto& it : value.group_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",having_clause="; stream << value.having_clause;
    {
        bool first = true;
        stream << ",window_clause=[" << value.window_clause.size() << "][";
        for (const auto& it : value.window_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",values_lists=[" << value.values_lists.size() << "][";
        for (const auto& it : value.values_lists)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",sort_clause=[" << value.sort_clause.size() << "][";
        for (const auto& it : value.sort_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",limit_offset="; stream << value.limit_offset;
    stream << ",limit_count="; stream << value.limit_count;
    stream << ",limit_option="; stream << value.limit_option;
    {
        bool first = true;
        stream << ",locking_clause=[" << value.locking_clause.size() << "][";
        for (const auto& it : value.locking_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",with_clause="; stream << " ptr of other struct" << (value.with_clause == nullptr ? "true" : "false");
    stream << ",op="; stream << value.op;
    stream << ",all="; stream << (value.all ? "true" : "false");
    stream << ",larg="; stream << " ptr of other struct" << (value.larg == nullptr ? "true" : "false");
    stream << ",rarg="; stream << " ptr of other struct" << (value.rarg == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

AlterTableStmt::AlterTableStmt()
    : relation(nullptr)
    , cmds()
    , relkind()
    , missing_ok(false)
{}

AlterTableStmt::AlterTableStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_cmds, ::pg_query::ObjectType&& arg_relkind, bool arg_missing_ok)
    : relation(arg_relation.release())
    , cmds(std::move(arg_cmds))
    , relkind(std::move(arg_relkind))
    , missing_ok(arg_missing_ok)
{}

AlterTableStmt::AlterTableStmt(AlterTableStmt&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , cmds(std::move(other.cmds))
    , relkind(std::move(other.relkind))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

AlterTableStmt::~AlterTableStmt()
{
    if (relation) delete relation;
}

bool AlterTableStmt::operator==([[maybe_unused]] const AlterTableStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterTableStmt::operator<([[maybe_unused]] const AlterTableStmt& other) const noexcept
{
    return false;
}

AlterTableStmt& AlterTableStmt::operator=(AlterTableStmt&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        cmds = std::move(other.cmds);
        relkind = std::move(other.relkind);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string AlterTableStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterTableStmt::swap(AlterTableStmt& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(cmds, other.cmds);
    swap(relkind, other.relkind);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterTableStmt& value)
{
    stream << "AlterTableStmt(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",cmds=[" << value.cmds.size() << "][";
        for (const auto& it : value.cmds)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",relkind="; stream << value.relkind;
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

AlterTableCmd::AlterTableCmd()
    : subtype()
    , name()
    , num((int32_t)0ll)
    , newowner(nullptr)
    , def()
    , behavior()
    , missing_ok(false)
{}

AlterTableCmd::AlterTableCmd(::pg_query::AlterTableType&& arg_subtype, const std::string& arg_name, int32_t arg_num, std::unique_ptr<::pg_query::RoleSpec> arg_newowner, ::pg_query::Node&& arg_def, ::pg_query::DropBehavior&& arg_behavior, bool arg_missing_ok)
    : subtype(std::move(arg_subtype))
    , name(arg_name)
    , num(arg_num)
    , newowner(arg_newowner.release())
    , def(std::move(arg_def))
    , behavior(std::move(arg_behavior))
    , missing_ok(arg_missing_ok)
{}

AlterTableCmd::AlterTableCmd(AlterTableCmd&& other) noexcept
    : subtype(std::move(other.subtype))
    , name(std::move(other.name))
    , num(std::exchange(other.num, (int32_t)0ll))
    , newowner(std::exchange(other.newowner, nullptr))
    , def(std::move(other.def))
    , behavior(std::move(other.behavior))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

AlterTableCmd::~AlterTableCmd()
{
    if (newowner) delete newowner;
}

bool AlterTableCmd::operator==([[maybe_unused]] const AlterTableCmd& other) const noexcept
{
    return (
        true
        );
}

bool AlterTableCmd::operator<([[maybe_unused]] const AlterTableCmd& other) const noexcept
{
    return false;
}

AlterTableCmd& AlterTableCmd::operator=(AlterTableCmd&& other) noexcept
{
    if (this != &other)
    {
        subtype = std::move(other.subtype);
        name = std::move(other.name);
        num = std::exchange(other.num, (int32_t)0ll);
        newowner = std::exchange(other.newowner, nullptr);
        def = std::move(other.def);
        behavior = std::move(other.behavior);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string AlterTableCmd::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterTableCmd::swap(AlterTableCmd& other) noexcept
{
    using std::swap;
    swap(subtype, other.subtype);
    swap(name, other.name);
    swap(num, other.num);
    swap(newowner, other.newowner);
    swap(def, other.def);
    swap(behavior, other.behavior);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterTableCmd& value)
{
    stream << "AlterTableCmd(";
    stream << "subtype="; stream << value.subtype;
    stream << ",name="; stream << "\"" << value.name << "\"";
    stream << ",num="; stream << value.num;
    stream << ",newowner="; stream << " ptr of other struct" << (value.newowner == nullptr ? "true" : "false");
    stream << ",def="; stream << value.def;
    stream << ",behavior="; stream << value.behavior;
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

AlterDomainStmt::AlterDomainStmt()
    : subtype()
    , type_name()
    , name()
    , def()
    , behavior()
    , missing_ok(false)
{}

AlterDomainStmt::AlterDomainStmt(const std::string& arg_subtype, std::vector<::pg_query::Node> arg_type_name, const std::string& arg_name, ::pg_query::Node&& arg_def, ::pg_query::DropBehavior&& arg_behavior, bool arg_missing_ok)
    : subtype(arg_subtype)
    , type_name(std::move(arg_type_name))
    , name(arg_name)
    , def(std::move(arg_def))
    , behavior(std::move(arg_behavior))
    , missing_ok(arg_missing_ok)
{}

AlterDomainStmt::AlterDomainStmt(AlterDomainStmt&& other) noexcept
    : subtype(std::move(other.subtype))
    , type_name(std::move(other.type_name))
    , name(std::move(other.name))
    , def(std::move(other.def))
    , behavior(std::move(other.behavior))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

AlterDomainStmt::~AlterDomainStmt()
{
}

bool AlterDomainStmt::operator==([[maybe_unused]] const AlterDomainStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterDomainStmt::operator<([[maybe_unused]] const AlterDomainStmt& other) const noexcept
{
    return false;
}

AlterDomainStmt& AlterDomainStmt::operator=(AlterDomainStmt&& other) noexcept
{
    if (this != &other)
    {
        subtype = std::move(other.subtype);
        type_name = std::move(other.type_name);
        name = std::move(other.name);
        def = std::move(other.def);
        behavior = std::move(other.behavior);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string AlterDomainStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterDomainStmt::swap(AlterDomainStmt& other) noexcept
{
    using std::swap;
    swap(subtype, other.subtype);
    swap(type_name, other.type_name);
    swap(name, other.name);
    swap(def, other.def);
    swap(behavior, other.behavior);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterDomainStmt& value)
{
    stream << "AlterDomainStmt(";
    stream << "subtype="; stream << "\"" << value.subtype << "\"";
    {
        bool first = true;
        stream << ",type_name=[" << value.type_name.size() << "][";
        for (const auto& it : value.type_name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",name="; stream << "\"" << value.name << "\"";
    stream << ",def="; stream << value.def;
    stream << ",behavior="; stream << value.behavior;
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

SetOperationStmt::SetOperationStmt()
    : op()
    , all(false)
    , larg()
    , rarg()
    , col_types()
    , col_typmods()
    , col_collations()
    , group_clauses()
{}

SetOperationStmt::SetOperationStmt(::pg_query::SetOperation&& arg_op, bool arg_all, ::pg_query::Node&& arg_larg, ::pg_query::Node&& arg_rarg, std::vector<::pg_query::Node> arg_col_types, std::vector<::pg_query::Node> arg_col_typmods, std::vector<::pg_query::Node> arg_col_collations, std::vector<::pg_query::Node> arg_group_clauses)
    : op(std::move(arg_op))
    , all(arg_all)
    , larg(std::move(arg_larg))
    , rarg(std::move(arg_rarg))
    , col_types(std::move(arg_col_types))
    , col_typmods(std::move(arg_col_typmods))
    , col_collations(std::move(arg_col_collations))
    , group_clauses(std::move(arg_group_clauses))
{}

SetOperationStmt::SetOperationStmt(SetOperationStmt&& other) noexcept
    : op(std::move(other.op))
    , all(std::exchange(other.all, false))
    , larg(std::move(other.larg))
    , rarg(std::move(other.rarg))
    , col_types(std::move(other.col_types))
    , col_typmods(std::move(other.col_typmods))
    , col_collations(std::move(other.col_collations))
    , group_clauses(std::move(other.group_clauses))
{}

SetOperationStmt::~SetOperationStmt()
{
}

bool SetOperationStmt::operator==([[maybe_unused]] const SetOperationStmt& other) const noexcept
{
    return (
        true
        );
}

bool SetOperationStmt::operator<([[maybe_unused]] const SetOperationStmt& other) const noexcept
{
    return false;
}

SetOperationStmt& SetOperationStmt::operator=(SetOperationStmt&& other) noexcept
{
    if (this != &other)
    {
        op = std::move(other.op);
        all = std::exchange(other.all, false);
        larg = std::move(other.larg);
        rarg = std::move(other.rarg);
        col_types = std::move(other.col_types);
        col_typmods = std::move(other.col_typmods);
        col_collations = std::move(other.col_collations);
        group_clauses = std::move(other.group_clauses);
    }
    return *this;
}

std::string SetOperationStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SetOperationStmt::swap(SetOperationStmt& other) noexcept
{
    using std::swap;
    swap(op, other.op);
    swap(all, other.all);
    swap(larg, other.larg);
    swap(rarg, other.rarg);
    swap(col_types, other.col_types);
    swap(col_typmods, other.col_typmods);
    swap(col_collations, other.col_collations);
    swap(group_clauses, other.group_clauses);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SetOperationStmt& value)
{
    stream << "SetOperationStmt(";
    stream << "op="; stream << value.op;
    stream << ",all="; stream << (value.all ? "true" : "false");
    stream << ",larg="; stream << value.larg;
    stream << ",rarg="; stream << value.rarg;
    {
        bool first = true;
        stream << ",col_types=[" << value.col_types.size() << "][";
        for (const auto& it : value.col_types)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",col_typmods=[" << value.col_typmods.size() << "][";
        for (const auto& it : value.col_typmods)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",col_collations=[" << value.col_collations.size() << "][";
        for (const auto& it : value.col_collations)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",group_clauses=[" << value.group_clauses.size() << "][";
        for (const auto& it : value.group_clauses)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

GrantStmt::GrantStmt()
    : is_grant(false)
    , targtype()
    , objtype()
    , objects()
    , privileges()
    , grantees()
    , grant_option(false)
    , behavior()
{}

GrantStmt::GrantStmt(bool arg_is_grant, ::pg_query::GrantTargetType&& arg_targtype, ::pg_query::ObjectType&& arg_objtype, std::vector<::pg_query::Node> arg_objects, std::vector<::pg_query::Node> arg_privileges, std::vector<::pg_query::Node> arg_grantees, bool arg_grant_option, ::pg_query::DropBehavior&& arg_behavior)
    : is_grant(arg_is_grant)
    , targtype(std::move(arg_targtype))
    , objtype(std::move(arg_objtype))
    , objects(std::move(arg_objects))
    , privileges(std::move(arg_privileges))
    , grantees(std::move(arg_grantees))
    , grant_option(arg_grant_option)
    , behavior(std::move(arg_behavior))
{}

GrantStmt::GrantStmt(GrantStmt&& other) noexcept
    : is_grant(std::exchange(other.is_grant, false))
    , targtype(std::move(other.targtype))
    , objtype(std::move(other.objtype))
    , objects(std::move(other.objects))
    , privileges(std::move(other.privileges))
    , grantees(std::move(other.grantees))
    , grant_option(std::exchange(other.grant_option, false))
    , behavior(std::move(other.behavior))
{}

GrantStmt::~GrantStmt()
{
}

bool GrantStmt::operator==([[maybe_unused]] const GrantStmt& other) const noexcept
{
    return (
        true
        );
}

bool GrantStmt::operator<([[maybe_unused]] const GrantStmt& other) const noexcept
{
    return false;
}

GrantStmt& GrantStmt::operator=(GrantStmt&& other) noexcept
{
    if (this != &other)
    {
        is_grant = std::exchange(other.is_grant, false);
        targtype = std::move(other.targtype);
        objtype = std::move(other.objtype);
        objects = std::move(other.objects);
        privileges = std::move(other.privileges);
        grantees = std::move(other.grantees);
        grant_option = std::exchange(other.grant_option, false);
        behavior = std::move(other.behavior);
    }
    return *this;
}

std::string GrantStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void GrantStmt::swap(GrantStmt& other) noexcept
{
    using std::swap;
    swap(is_grant, other.is_grant);
    swap(targtype, other.targtype);
    swap(objtype, other.objtype);
    swap(objects, other.objects);
    swap(privileges, other.privileges);
    swap(grantees, other.grantees);
    swap(grant_option, other.grant_option);
    swap(behavior, other.behavior);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const GrantStmt& value)
{
    stream << "GrantStmt(";
    stream << "is_grant="; stream << (value.is_grant ? "true" : "false");
    stream << ",targtype="; stream << value.targtype;
    stream << ",objtype="; stream << value.objtype;
    {
        bool first = true;
        stream << ",objects=[" << value.objects.size() << "][";
        for (const auto& it : value.objects)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",privileges=[" << value.privileges.size() << "][";
        for (const auto& it : value.privileges)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",grantees=[" << value.grantees.size() << "][";
        for (const auto& it : value.grantees)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",grant_option="; stream << (value.grant_option ? "true" : "false");
    stream << ",behavior="; stream << value.behavior;
    stream << ")";
    return stream;
}

GrantRoleStmt::GrantRoleStmt()
    : granted_roles()
    , grantee_roles()
    , is_grant(false)
    , admin_opt(false)
    , grantor(nullptr)
    , behavior()
{}

GrantRoleStmt::GrantRoleStmt(std::vector<::pg_query::Node> arg_granted_roles, std::vector<::pg_query::Node> arg_grantee_roles, bool arg_is_grant, bool arg_admin_opt, std::unique_ptr<::pg_query::RoleSpec> arg_grantor, ::pg_query::DropBehavior&& arg_behavior)
    : granted_roles(std::move(arg_granted_roles))
    , grantee_roles(std::move(arg_grantee_roles))
    , is_grant(arg_is_grant)
    , admin_opt(arg_admin_opt)
    , grantor(arg_grantor.release())
    , behavior(std::move(arg_behavior))
{}

GrantRoleStmt::GrantRoleStmt(GrantRoleStmt&& other) noexcept
    : granted_roles(std::move(other.granted_roles))
    , grantee_roles(std::move(other.grantee_roles))
    , is_grant(std::exchange(other.is_grant, false))
    , admin_opt(std::exchange(other.admin_opt, false))
    , grantor(std::exchange(other.grantor, nullptr))
    , behavior(std::move(other.behavior))
{}

GrantRoleStmt::~GrantRoleStmt()
{
    if (grantor) delete grantor;
}

bool GrantRoleStmt::operator==([[maybe_unused]] const GrantRoleStmt& other) const noexcept
{
    return (
        true
        );
}

bool GrantRoleStmt::operator<([[maybe_unused]] const GrantRoleStmt& other) const noexcept
{
    return false;
}

GrantRoleStmt& GrantRoleStmt::operator=(GrantRoleStmt&& other) noexcept
{
    if (this != &other)
    {
        granted_roles = std::move(other.granted_roles);
        grantee_roles = std::move(other.grantee_roles);
        is_grant = std::exchange(other.is_grant, false);
        admin_opt = std::exchange(other.admin_opt, false);
        grantor = std::exchange(other.grantor, nullptr);
        behavior = std::move(other.behavior);
    }
    return *this;
}

std::string GrantRoleStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void GrantRoleStmt::swap(GrantRoleStmt& other) noexcept
{
    using std::swap;
    swap(granted_roles, other.granted_roles);
    swap(grantee_roles, other.grantee_roles);
    swap(is_grant, other.is_grant);
    swap(admin_opt, other.admin_opt);
    swap(grantor, other.grantor);
    swap(behavior, other.behavior);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const GrantRoleStmt& value)
{
    stream << "GrantRoleStmt(";
    {
        bool first = true;
        stream << "granted_roles=[" << value.granted_roles.size() << "][";
        for (const auto& it : value.granted_roles)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",grantee_roles=[" << value.grantee_roles.size() << "][";
        for (const auto& it : value.grantee_roles)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",is_grant="; stream << (value.is_grant ? "true" : "false");
    stream << ",admin_opt="; stream << (value.admin_opt ? "true" : "false");
    stream << ",grantor="; stream << " ptr of other struct" << (value.grantor == nullptr ? "true" : "false");
    stream << ",behavior="; stream << value.behavior;
    stream << ")";
    return stream;
}

AlterDefaultPrivilegesStmt::AlterDefaultPrivilegesStmt()
    : options()
    , action(nullptr)
{}

AlterDefaultPrivilegesStmt::AlterDefaultPrivilegesStmt(std::vector<::pg_query::Node> arg_options, std::unique_ptr<::pg_query::GrantStmt> arg_action)
    : options(std::move(arg_options))
    , action(arg_action.release())
{}

AlterDefaultPrivilegesStmt::AlterDefaultPrivilegesStmt(AlterDefaultPrivilegesStmt&& other) noexcept
    : options(std::move(other.options))
    , action(std::exchange(other.action, nullptr))
{}

AlterDefaultPrivilegesStmt::~AlterDefaultPrivilegesStmt()
{
    if (action) delete action;
}

bool AlterDefaultPrivilegesStmt::operator==([[maybe_unused]] const AlterDefaultPrivilegesStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterDefaultPrivilegesStmt::operator<([[maybe_unused]] const AlterDefaultPrivilegesStmt& other) const noexcept
{
    return false;
}

AlterDefaultPrivilegesStmt& AlterDefaultPrivilegesStmt::operator=(AlterDefaultPrivilegesStmt&& other) noexcept
{
    if (this != &other)
    {
        options = std::move(other.options);
        action = std::exchange(other.action, nullptr);
    }
    return *this;
}

std::string AlterDefaultPrivilegesStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterDefaultPrivilegesStmt::swap(AlterDefaultPrivilegesStmt& other) noexcept
{
    using std::swap;
    swap(options, other.options);
    swap(action, other.action);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterDefaultPrivilegesStmt& value)
{
    stream << "AlterDefaultPrivilegesStmt(";
    {
        bool first = true;
        stream << "options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",action="; stream << " ptr of other struct" << (value.action == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

ClosePortalStmt::ClosePortalStmt()
    : portalname()
{}

ClosePortalStmt::ClosePortalStmt(const std::string& arg_portalname)
    : portalname(arg_portalname)
{}

ClosePortalStmt::ClosePortalStmt(ClosePortalStmt&& other) noexcept
    : portalname(std::move(other.portalname))
{}

ClosePortalStmt::~ClosePortalStmt()
{
}

bool ClosePortalStmt::operator==([[maybe_unused]] const ClosePortalStmt& other) const noexcept
{
    return (
        true
        );
}

bool ClosePortalStmt::operator<([[maybe_unused]] const ClosePortalStmt& other) const noexcept
{
    return false;
}

ClosePortalStmt& ClosePortalStmt::operator=(ClosePortalStmt&& other) noexcept
{
    if (this != &other)
    {
        portalname = std::move(other.portalname);
    }
    return *this;
}

std::string ClosePortalStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ClosePortalStmt::swap(ClosePortalStmt& other) noexcept
{
    using std::swap;
    swap(portalname, other.portalname);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ClosePortalStmt& value)
{
    stream << "ClosePortalStmt(";
    stream << "portalname="; stream << "\"" << value.portalname << "\"";
    stream << ")";
    return stream;
}

ClusterStmt::ClusterStmt()
    : relation(nullptr)
    , indexname()
    , options((int32_t)0ll)
{}

ClusterStmt::ClusterStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, const std::string& arg_indexname, int32_t arg_options)
    : relation(arg_relation.release())
    , indexname(arg_indexname)
    , options(arg_options)
{}

ClusterStmt::ClusterStmt(ClusterStmt&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , indexname(std::move(other.indexname))
    , options(std::exchange(other.options, (int32_t)0ll))
{}

ClusterStmt::~ClusterStmt()
{
    if (relation) delete relation;
}

bool ClusterStmt::operator==([[maybe_unused]] const ClusterStmt& other) const noexcept
{
    return (
        true
        );
}

bool ClusterStmt::operator<([[maybe_unused]] const ClusterStmt& other) const noexcept
{
    return false;
}

ClusterStmt& ClusterStmt::operator=(ClusterStmt&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        indexname = std::move(other.indexname);
        options = std::exchange(other.options, (int32_t)0ll);
    }
    return *this;
}

std::string ClusterStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ClusterStmt::swap(ClusterStmt& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(indexname, other.indexname);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ClusterStmt& value)
{
    stream << "ClusterStmt(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",indexname="; stream << "\"" << value.indexname << "\"";
    stream << ",options="; stream << value.options;
    stream << ")";
    return stream;
}

CopyStmt::CopyStmt()
    : relation(nullptr)
    , query()
    , attlist()
    , is_from(false)
    , is_program(false)
    , filename()
    , options()
    , where_clause()
{}

CopyStmt::CopyStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_query, std::vector<::pg_query::Node> arg_attlist, bool arg_is_from, bool arg_is_program, const std::string& arg_filename, std::vector<::pg_query::Node> arg_options, ::pg_query::Node&& arg_where_clause)
    : relation(arg_relation.release())
    , query(std::move(arg_query))
    , attlist(std::move(arg_attlist))
    , is_from(arg_is_from)
    , is_program(arg_is_program)
    , filename(arg_filename)
    , options(std::move(arg_options))
    , where_clause(std::move(arg_where_clause))
{}

CopyStmt::CopyStmt(CopyStmt&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , query(std::move(other.query))
    , attlist(std::move(other.attlist))
    , is_from(std::exchange(other.is_from, false))
    , is_program(std::exchange(other.is_program, false))
    , filename(std::move(other.filename))
    , options(std::move(other.options))
    , where_clause(std::move(other.where_clause))
{}

CopyStmt::~CopyStmt()
{
    if (relation) delete relation;
}

bool CopyStmt::operator==([[maybe_unused]] const CopyStmt& other) const noexcept
{
    return (
        true
        );
}

bool CopyStmt::operator<([[maybe_unused]] const CopyStmt& other) const noexcept
{
    return false;
}

CopyStmt& CopyStmt::operator=(CopyStmt&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        query = std::move(other.query);
        attlist = std::move(other.attlist);
        is_from = std::exchange(other.is_from, false);
        is_program = std::exchange(other.is_program, false);
        filename = std::move(other.filename);
        options = std::move(other.options);
        where_clause = std::move(other.where_clause);
    }
    return *this;
}

std::string CopyStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CopyStmt::swap(CopyStmt& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(query, other.query);
    swap(attlist, other.attlist);
    swap(is_from, other.is_from);
    swap(is_program, other.is_program);
    swap(filename, other.filename);
    swap(options, other.options);
    swap(where_clause, other.where_clause);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CopyStmt& value)
{
    stream << "CopyStmt(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",query="; stream << value.query;
    {
        bool first = true;
        stream << ",attlist=[" << value.attlist.size() << "][";
        for (const auto& it : value.attlist)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",is_from="; stream << (value.is_from ? "true" : "false");
    stream << ",is_program="; stream << (value.is_program ? "true" : "false");
    stream << ",filename="; stream << "\"" << value.filename << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",where_clause="; stream << value.where_clause;
    stream << ")";
    return stream;
}

CreateStmt::CreateStmt()
    : relation(nullptr)
    , table_elts()
    , inh_relations()
    , partbound(nullptr)
    , partspec(nullptr)
    , of_typename(nullptr)
    , constraints()
    , options()
    , oncommit()
    , tablespacename()
    , access_method()
    , if_not_exists(false)
{}

CreateStmt::CreateStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_table_elts, std::vector<::pg_query::Node> arg_inh_relations, std::unique_ptr<::pg_query::PartitionBoundSpec> arg_partbound, std::unique_ptr<::pg_query::PartitionSpec> arg_partspec, std::unique_ptr<::pg_query::TypeName> arg_of_typename, std::vector<::pg_query::Node> arg_constraints, std::vector<::pg_query::Node> arg_options, ::pg_query::OnCommitAction&& arg_oncommit, const std::string& arg_tablespacename, const std::string& arg_access_method, bool arg_if_not_exists)
    : relation(arg_relation.release())
    , table_elts(std::move(arg_table_elts))
    , inh_relations(std::move(arg_inh_relations))
    , partbound(arg_partbound.release())
    , partspec(arg_partspec.release())
    , of_typename(arg_of_typename.release())
    , constraints(std::move(arg_constraints))
    , options(std::move(arg_options))
    , oncommit(std::move(arg_oncommit))
    , tablespacename(arg_tablespacename)
    , access_method(arg_access_method)
    , if_not_exists(arg_if_not_exists)
{}

CreateStmt::CreateStmt(CreateStmt&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , table_elts(std::move(other.table_elts))
    , inh_relations(std::move(other.inh_relations))
    , partbound(std::exchange(other.partbound, nullptr))
    , partspec(std::exchange(other.partspec, nullptr))
    , of_typename(std::exchange(other.of_typename, nullptr))
    , constraints(std::move(other.constraints))
    , options(std::move(other.options))
    , oncommit(std::move(other.oncommit))
    , tablespacename(std::move(other.tablespacename))
    , access_method(std::move(other.access_method))
    , if_not_exists(std::exchange(other.if_not_exists, false))
{}

CreateStmt::~CreateStmt()
{
    if (relation) delete relation;
    if (partbound) delete partbound;
    if (partspec) delete partspec;
    if (of_typename) delete of_typename;
}

bool CreateStmt::operator==([[maybe_unused]] const CreateStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateStmt::operator<([[maybe_unused]] const CreateStmt& other) const noexcept
{
    return false;
}

CreateStmt& CreateStmt::operator=(CreateStmt&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        table_elts = std::move(other.table_elts);
        inh_relations = std::move(other.inh_relations);
        partbound = std::exchange(other.partbound, nullptr);
        partspec = std::exchange(other.partspec, nullptr);
        of_typename = std::exchange(other.of_typename, nullptr);
        constraints = std::move(other.constraints);
        options = std::move(other.options);
        oncommit = std::move(other.oncommit);
        tablespacename = std::move(other.tablespacename);
        access_method = std::move(other.access_method);
        if_not_exists = std::exchange(other.if_not_exists, false);
    }
    return *this;
}

std::string CreateStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateStmt::swap(CreateStmt& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(table_elts, other.table_elts);
    swap(inh_relations, other.inh_relations);
    swap(partbound, other.partbound);
    swap(partspec, other.partspec);
    swap(of_typename, other.of_typename);
    swap(constraints, other.constraints);
    swap(options, other.options);
    swap(oncommit, other.oncommit);
    swap(tablespacename, other.tablespacename);
    swap(access_method, other.access_method);
    swap(if_not_exists, other.if_not_exists);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateStmt& value)
{
    stream << "CreateStmt(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",table_elts=[" << value.table_elts.size() << "][";
        for (const auto& it : value.table_elts)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",inh_relations=[" << value.inh_relations.size() << "][";
        for (const auto& it : value.inh_relations)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",partbound="; stream << " ptr of other struct" << (value.partbound == nullptr ? "true" : "false");
    stream << ",partspec="; stream << " ptr of other struct" << (value.partspec == nullptr ? "true" : "false");
    stream << ",of_typename="; stream << " ptr of other struct" << (value.of_typename == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",constraints=[" << value.constraints.size() << "][";
        for (const auto& it : value.constraints)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",oncommit="; stream << value.oncommit;
    stream << ",tablespacename="; stream << "\"" << value.tablespacename << "\"";
    stream << ",access_method="; stream << "\"" << value.access_method << "\"";
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    stream << ")";
    return stream;
}

DefineStmt::DefineStmt()
    : kind()
    , oldstyle(false)
    , defnames()
    , args()
    , definition()
    , if_not_exists(false)
    , replace(false)
{}

DefineStmt::DefineStmt(::pg_query::ObjectType&& arg_kind, bool arg_oldstyle, std::vector<::pg_query::Node> arg_defnames, std::vector<::pg_query::Node> arg_args, std::vector<::pg_query::Node> arg_definition, bool arg_if_not_exists, bool arg_replace)
    : kind(std::move(arg_kind))
    , oldstyle(arg_oldstyle)
    , defnames(std::move(arg_defnames))
    , args(std::move(arg_args))
    , definition(std::move(arg_definition))
    , if_not_exists(arg_if_not_exists)
    , replace(arg_replace)
{}

DefineStmt::DefineStmt(DefineStmt&& other) noexcept
    : kind(std::move(other.kind))
    , oldstyle(std::exchange(other.oldstyle, false))
    , defnames(std::move(other.defnames))
    , args(std::move(other.args))
    , definition(std::move(other.definition))
    , if_not_exists(std::exchange(other.if_not_exists, false))
    , replace(std::exchange(other.replace, false))
{}

DefineStmt::~DefineStmt()
{
}

bool DefineStmt::operator==([[maybe_unused]] const DefineStmt& other) const noexcept
{
    return (
        true
        );
}

bool DefineStmt::operator<([[maybe_unused]] const DefineStmt& other) const noexcept
{
    return false;
}

DefineStmt& DefineStmt::operator=(DefineStmt&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        oldstyle = std::exchange(other.oldstyle, false);
        defnames = std::move(other.defnames);
        args = std::move(other.args);
        definition = std::move(other.definition);
        if_not_exists = std::exchange(other.if_not_exists, false);
        replace = std::exchange(other.replace, false);
    }
    return *this;
}

std::string DefineStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DefineStmt::swap(DefineStmt& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(oldstyle, other.oldstyle);
    swap(defnames, other.defnames);
    swap(args, other.args);
    swap(definition, other.definition);
    swap(if_not_exists, other.if_not_exists);
    swap(replace, other.replace);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DefineStmt& value)
{
    stream << "DefineStmt(";
    stream << "kind="; stream << value.kind;
    stream << ",oldstyle="; stream << (value.oldstyle ? "true" : "false");
    {
        bool first = true;
        stream << ",defnames=[" << value.defnames.size() << "][";
        for (const auto& it : value.defnames)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",definition=[" << value.definition.size() << "][";
        for (const auto& it : value.definition)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    stream << ",replace="; stream << (value.replace ? "true" : "false");
    stream << ")";
    return stream;
}

DropStmt::DropStmt()
    : objects()
    , remove_type()
    , behavior()
    , missing_ok(false)
    , concurrent(false)
{}

DropStmt::DropStmt(std::vector<::pg_query::Node> arg_objects, ::pg_query::ObjectType&& arg_remove_type, ::pg_query::DropBehavior&& arg_behavior, bool arg_missing_ok, bool arg_concurrent)
    : objects(std::move(arg_objects))
    , remove_type(std::move(arg_remove_type))
    , behavior(std::move(arg_behavior))
    , missing_ok(arg_missing_ok)
    , concurrent(arg_concurrent)
{}

DropStmt::DropStmt(DropStmt&& other) noexcept
    : objects(std::move(other.objects))
    , remove_type(std::move(other.remove_type))
    , behavior(std::move(other.behavior))
    , missing_ok(std::exchange(other.missing_ok, false))
    , concurrent(std::exchange(other.concurrent, false))
{}

DropStmt::~DropStmt()
{
}

bool DropStmt::operator==([[maybe_unused]] const DropStmt& other) const noexcept
{
    return (
        true
        );
}

bool DropStmt::operator<([[maybe_unused]] const DropStmt& other) const noexcept
{
    return false;
}

DropStmt& DropStmt::operator=(DropStmt&& other) noexcept
{
    if (this != &other)
    {
        objects = std::move(other.objects);
        remove_type = std::move(other.remove_type);
        behavior = std::move(other.behavior);
        missing_ok = std::exchange(other.missing_ok, false);
        concurrent = std::exchange(other.concurrent, false);
    }
    return *this;
}

std::string DropStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DropStmt::swap(DropStmt& other) noexcept
{
    using std::swap;
    swap(objects, other.objects);
    swap(remove_type, other.remove_type);
    swap(behavior, other.behavior);
    swap(missing_ok, other.missing_ok);
    swap(concurrent, other.concurrent);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DropStmt& value)
{
    stream << "DropStmt(";
    {
        bool first = true;
        stream << "objects=[" << value.objects.size() << "][";
        for (const auto& it : value.objects)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",remove_type="; stream << value.remove_type;
    stream << ",behavior="; stream << value.behavior;
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ",concurrent="; stream << (value.concurrent ? "true" : "false");
    stream << ")";
    return stream;
}

TruncateStmt::TruncateStmt()
    : relations()
    , restart_seqs(false)
    , behavior()
{}

TruncateStmt::TruncateStmt(std::vector<::pg_query::Node> arg_relations, bool arg_restart_seqs, ::pg_query::DropBehavior&& arg_behavior)
    : relations(std::move(arg_relations))
    , restart_seqs(arg_restart_seqs)
    , behavior(std::move(arg_behavior))
{}

TruncateStmt::TruncateStmt(TruncateStmt&& other) noexcept
    : relations(std::move(other.relations))
    , restart_seqs(std::exchange(other.restart_seqs, false))
    , behavior(std::move(other.behavior))
{}

TruncateStmt::~TruncateStmt()
{
}

bool TruncateStmt::operator==([[maybe_unused]] const TruncateStmt& other) const noexcept
{
    return (
        true
        );
}

bool TruncateStmt::operator<([[maybe_unused]] const TruncateStmt& other) const noexcept
{
    return false;
}

TruncateStmt& TruncateStmt::operator=(TruncateStmt&& other) noexcept
{
    if (this != &other)
    {
        relations = std::move(other.relations);
        restart_seqs = std::exchange(other.restart_seqs, false);
        behavior = std::move(other.behavior);
    }
    return *this;
}

std::string TruncateStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void TruncateStmt::swap(TruncateStmt& other) noexcept
{
    using std::swap;
    swap(relations, other.relations);
    swap(restart_seqs, other.restart_seqs);
    swap(behavior, other.behavior);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const TruncateStmt& value)
{
    stream << "TruncateStmt(";
    {
        bool first = true;
        stream << "relations=[" << value.relations.size() << "][";
        for (const auto& it : value.relations)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",restart_seqs="; stream << (value.restart_seqs ? "true" : "false");
    stream << ",behavior="; stream << value.behavior;
    stream << ")";
    return stream;
}

CommentStmt::CommentStmt()
    : objtype()
    , object()
    , comment()
{}

CommentStmt::CommentStmt(::pg_query::ObjectType&& arg_objtype, ::pg_query::Node&& arg_object, const std::string& arg_comment)
    : objtype(std::move(arg_objtype))
    , object(std::move(arg_object))
    , comment(arg_comment)
{}

CommentStmt::CommentStmt(CommentStmt&& other) noexcept
    : objtype(std::move(other.objtype))
    , object(std::move(other.object))
    , comment(std::move(other.comment))
{}

CommentStmt::~CommentStmt()
{
}

bool CommentStmt::operator==([[maybe_unused]] const CommentStmt& other) const noexcept
{
    return (
        true
        );
}

bool CommentStmt::operator<([[maybe_unused]] const CommentStmt& other) const noexcept
{
    return false;
}

CommentStmt& CommentStmt::operator=(CommentStmt&& other) noexcept
{
    if (this != &other)
    {
        objtype = std::move(other.objtype);
        object = std::move(other.object);
        comment = std::move(other.comment);
    }
    return *this;
}

std::string CommentStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CommentStmt::swap(CommentStmt& other) noexcept
{
    using std::swap;
    swap(objtype, other.objtype);
    swap(object, other.object);
    swap(comment, other.comment);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CommentStmt& value)
{
    stream << "CommentStmt(";
    stream << "objtype="; stream << value.objtype;
    stream << ",object="; stream << value.object;
    stream << ",comment="; stream << "\"" << value.comment << "\"";
    stream << ")";
    return stream;
}

FetchStmt::FetchStmt()
    : direction()
    , how_many((int64_t)0ll)
    , portalname()
    , ismove(false)
{}

FetchStmt::FetchStmt(::pg_query::FetchDirection&& arg_direction, int64_t arg_how_many, const std::string& arg_portalname, bool arg_ismove)
    : direction(std::move(arg_direction))
    , how_many(arg_how_many)
    , portalname(arg_portalname)
    , ismove(arg_ismove)
{}

FetchStmt::FetchStmt(FetchStmt&& other) noexcept
    : direction(std::move(other.direction))
    , how_many(std::exchange(other.how_many, (int64_t)0ll))
    , portalname(std::move(other.portalname))
    , ismove(std::exchange(other.ismove, false))
{}

FetchStmt::~FetchStmt()
{
}

bool FetchStmt::operator==([[maybe_unused]] const FetchStmt& other) const noexcept
{
    return (
        true
        );
}

bool FetchStmt::operator<([[maybe_unused]] const FetchStmt& other) const noexcept
{
    return false;
}

FetchStmt& FetchStmt::operator=(FetchStmt&& other) noexcept
{
    if (this != &other)
    {
        direction = std::move(other.direction);
        how_many = std::exchange(other.how_many, (int64_t)0ll);
        portalname = std::move(other.portalname);
        ismove = std::exchange(other.ismove, false);
    }
    return *this;
}

std::string FetchStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void FetchStmt::swap(FetchStmt& other) noexcept
{
    using std::swap;
    swap(direction, other.direction);
    swap(how_many, other.how_many);
    swap(portalname, other.portalname);
    swap(ismove, other.ismove);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const FetchStmt& value)
{
    stream << "FetchStmt(";
    stream << "direction="; stream << value.direction;
    stream << ",how_many="; stream << value.how_many;
    stream << ",portalname="; stream << "\"" << value.portalname << "\"";
    stream << ",ismove="; stream << (value.ismove ? "true" : "false");
    stream << ")";
    return stream;
}

IndexStmt::IndexStmt()
    : idxname()
    , relation(nullptr)
    , access_method()
    , table_space()
    , index_params()
    , index_including_params()
    , options()
    , where_clause()
    , exclude_op_names()
    , idxcomment()
    , index_oid((uint32_t)0ull)
    , old_node((uint32_t)0ull)
    , old_create_subid((uint32_t)0ull)
    , old_first_relfilenode_subid((uint32_t)0ull)
    , unique(false)
    , primary(false)
    , isconstraint(false)
    , deferrable(false)
    , initdeferred(false)
    , transformed(false)
    , concurrent(false)
    , if_not_exists(false)
    , reset_default_tblspc(false)
{}

IndexStmt::IndexStmt(const std::string& arg_idxname, std::unique_ptr<::pg_query::RangeVar> arg_relation, const std::string& arg_access_method, const std::string& arg_table_space, std::vector<::pg_query::Node> arg_index_params, std::vector<::pg_query::Node> arg_index_including_params, std::vector<::pg_query::Node> arg_options, ::pg_query::Node&& arg_where_clause, std::vector<::pg_query::Node> arg_exclude_op_names, const std::string& arg_idxcomment, uint32_t arg_index_oid, uint32_t arg_old_node, uint32_t arg_old_create_subid, uint32_t arg_old_first_relfilenode_subid, bool arg_unique, bool arg_primary, bool arg_isconstraint, bool arg_deferrable, bool arg_initdeferred, bool arg_transformed, bool arg_concurrent, bool arg_if_not_exists, bool arg_reset_default_tblspc)
    : idxname(arg_idxname)
    , relation(arg_relation.release())
    , access_method(arg_access_method)
    , table_space(arg_table_space)
    , index_params(std::move(arg_index_params))
    , index_including_params(std::move(arg_index_including_params))
    , options(std::move(arg_options))
    , where_clause(std::move(arg_where_clause))
    , exclude_op_names(std::move(arg_exclude_op_names))
    , idxcomment(arg_idxcomment)
    , index_oid(arg_index_oid)
    , old_node(arg_old_node)
    , old_create_subid(arg_old_create_subid)
    , old_first_relfilenode_subid(arg_old_first_relfilenode_subid)
    , unique(arg_unique)
    , primary(arg_primary)
    , isconstraint(arg_isconstraint)
    , deferrable(arg_deferrable)
    , initdeferred(arg_initdeferred)
    , transformed(arg_transformed)
    , concurrent(arg_concurrent)
    , if_not_exists(arg_if_not_exists)
    , reset_default_tblspc(arg_reset_default_tblspc)
{}

IndexStmt::IndexStmt(IndexStmt&& other) noexcept
    : idxname(std::move(other.idxname))
    , relation(std::exchange(other.relation, nullptr))
    , access_method(std::move(other.access_method))
    , table_space(std::move(other.table_space))
    , index_params(std::move(other.index_params))
    , index_including_params(std::move(other.index_including_params))
    , options(std::move(other.options))
    , where_clause(std::move(other.where_clause))
    , exclude_op_names(std::move(other.exclude_op_names))
    , idxcomment(std::move(other.idxcomment))
    , index_oid(std::exchange(other.index_oid, (uint32_t)0ull))
    , old_node(std::exchange(other.old_node, (uint32_t)0ull))
    , old_create_subid(std::exchange(other.old_create_subid, (uint32_t)0ull))
    , old_first_relfilenode_subid(std::exchange(other.old_first_relfilenode_subid, (uint32_t)0ull))
    , unique(std::exchange(other.unique, false))
    , primary(std::exchange(other.primary, false))
    , isconstraint(std::exchange(other.isconstraint, false))
    , deferrable(std::exchange(other.deferrable, false))
    , initdeferred(std::exchange(other.initdeferred, false))
    , transformed(std::exchange(other.transformed, false))
    , concurrent(std::exchange(other.concurrent, false))
    , if_not_exists(std::exchange(other.if_not_exists, false))
    , reset_default_tblspc(std::exchange(other.reset_default_tblspc, false))
{}

IndexStmt::~IndexStmt()
{
    if (relation) delete relation;
}

bool IndexStmt::operator==([[maybe_unused]] const IndexStmt& other) const noexcept
{
    return (
        true
        );
}

bool IndexStmt::operator<([[maybe_unused]] const IndexStmt& other) const noexcept
{
    return false;
}

IndexStmt& IndexStmt::operator=(IndexStmt&& other) noexcept
{
    if (this != &other)
    {
        idxname = std::move(other.idxname);
        relation = std::exchange(other.relation, nullptr);
        access_method = std::move(other.access_method);
        table_space = std::move(other.table_space);
        index_params = std::move(other.index_params);
        index_including_params = std::move(other.index_including_params);
        options = std::move(other.options);
        where_clause = std::move(other.where_clause);
        exclude_op_names = std::move(other.exclude_op_names);
        idxcomment = std::move(other.idxcomment);
        index_oid = std::exchange(other.index_oid, (uint32_t)0ull);
        old_node = std::exchange(other.old_node, (uint32_t)0ull);
        old_create_subid = std::exchange(other.old_create_subid, (uint32_t)0ull);
        old_first_relfilenode_subid = std::exchange(other.old_first_relfilenode_subid, (uint32_t)0ull);
        unique = std::exchange(other.unique, false);
        primary = std::exchange(other.primary, false);
        isconstraint = std::exchange(other.isconstraint, false);
        deferrable = std::exchange(other.deferrable, false);
        initdeferred = std::exchange(other.initdeferred, false);
        transformed = std::exchange(other.transformed, false);
        concurrent = std::exchange(other.concurrent, false);
        if_not_exists = std::exchange(other.if_not_exists, false);
        reset_default_tblspc = std::exchange(other.reset_default_tblspc, false);
    }
    return *this;
}

std::string IndexStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void IndexStmt::swap(IndexStmt& other) noexcept
{
    using std::swap;
    swap(idxname, other.idxname);
    swap(relation, other.relation);
    swap(access_method, other.access_method);
    swap(table_space, other.table_space);
    swap(index_params, other.index_params);
    swap(index_including_params, other.index_including_params);
    swap(options, other.options);
    swap(where_clause, other.where_clause);
    swap(exclude_op_names, other.exclude_op_names);
    swap(idxcomment, other.idxcomment);
    swap(index_oid, other.index_oid);
    swap(old_node, other.old_node);
    swap(old_create_subid, other.old_create_subid);
    swap(old_first_relfilenode_subid, other.old_first_relfilenode_subid);
    swap(unique, other.unique);
    swap(primary, other.primary);
    swap(isconstraint, other.isconstraint);
    swap(deferrable, other.deferrable);
    swap(initdeferred, other.initdeferred);
    swap(transformed, other.transformed);
    swap(concurrent, other.concurrent);
    swap(if_not_exists, other.if_not_exists);
    swap(reset_default_tblspc, other.reset_default_tblspc);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const IndexStmt& value)
{
    stream << "IndexStmt(";
    stream << "idxname="; stream << "\"" << value.idxname << "\"";
    stream << ",relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",access_method="; stream << "\"" << value.access_method << "\"";
    stream << ",table_space="; stream << "\"" << value.table_space << "\"";
    {
        bool first = true;
        stream << ",index_params=[" << value.index_params.size() << "][";
        for (const auto& it : value.index_params)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",index_including_params=[" << value.index_including_params.size() << "][";
        for (const auto& it : value.index_including_params)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",where_clause="; stream << value.where_clause;
    {
        bool first = true;
        stream << ",exclude_op_names=[" << value.exclude_op_names.size() << "][";
        for (const auto& it : value.exclude_op_names)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",idxcomment="; stream << "\"" << value.idxcomment << "\"";
    stream << ",index_oid="; stream << value.index_oid;
    stream << ",old_node="; stream << value.old_node;
    stream << ",old_create_subid="; stream << value.old_create_subid;
    stream << ",old_first_relfilenode_subid="; stream << value.old_first_relfilenode_subid;
    stream << ",unique="; stream << (value.unique ? "true" : "false");
    stream << ",primary="; stream << (value.primary ? "true" : "false");
    stream << ",isconstraint="; stream << (value.isconstraint ? "true" : "false");
    stream << ",deferrable="; stream << (value.deferrable ? "true" : "false");
    stream << ",initdeferred="; stream << (value.initdeferred ? "true" : "false");
    stream << ",transformed="; stream << (value.transformed ? "true" : "false");
    stream << ",concurrent="; stream << (value.concurrent ? "true" : "false");
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    stream << ",reset_default_tblspc="; stream << (value.reset_default_tblspc ? "true" : "false");
    stream << ")";
    return stream;
}

CreateFunctionStmt::CreateFunctionStmt()
    : is_procedure(false)
    , replace(false)
    , funcname()
    , parameters()
    , return_type(nullptr)
    , options()
{}

CreateFunctionStmt::CreateFunctionStmt(bool arg_is_procedure, bool arg_replace, std::vector<::pg_query::Node> arg_funcname, std::vector<::pg_query::Node> arg_parameters, std::unique_ptr<::pg_query::TypeName> arg_return_type, std::vector<::pg_query::Node> arg_options)
    : is_procedure(arg_is_procedure)
    , replace(arg_replace)
    , funcname(std::move(arg_funcname))
    , parameters(std::move(arg_parameters))
    , return_type(arg_return_type.release())
    , options(std::move(arg_options))
{}

CreateFunctionStmt::CreateFunctionStmt(CreateFunctionStmt&& other) noexcept
    : is_procedure(std::exchange(other.is_procedure, false))
    , replace(std::exchange(other.replace, false))
    , funcname(std::move(other.funcname))
    , parameters(std::move(other.parameters))
    , return_type(std::exchange(other.return_type, nullptr))
    , options(std::move(other.options))
{}

CreateFunctionStmt::~CreateFunctionStmt()
{
    if (return_type) delete return_type;
}

bool CreateFunctionStmt::operator==([[maybe_unused]] const CreateFunctionStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateFunctionStmt::operator<([[maybe_unused]] const CreateFunctionStmt& other) const noexcept
{
    return false;
}

CreateFunctionStmt& CreateFunctionStmt::operator=(CreateFunctionStmt&& other) noexcept
{
    if (this != &other)
    {
        is_procedure = std::exchange(other.is_procedure, false);
        replace = std::exchange(other.replace, false);
        funcname = std::move(other.funcname);
        parameters = std::move(other.parameters);
        return_type = std::exchange(other.return_type, nullptr);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreateFunctionStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateFunctionStmt::swap(CreateFunctionStmt& other) noexcept
{
    using std::swap;
    swap(is_procedure, other.is_procedure);
    swap(replace, other.replace);
    swap(funcname, other.funcname);
    swap(parameters, other.parameters);
    swap(return_type, other.return_type);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateFunctionStmt& value)
{
    stream << "CreateFunctionStmt(";
    stream << "is_procedure="; stream << (value.is_procedure ? "true" : "false");
    stream << ",replace="; stream << (value.replace ? "true" : "false");
    {
        bool first = true;
        stream << ",funcname=[" << value.funcname.size() << "][";
        for (const auto& it : value.funcname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",parameters=[" << value.parameters.size() << "][";
        for (const auto& it : value.parameters)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",return_type="; stream << " ptr of other struct" << (value.return_type == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterFunctionStmt::AlterFunctionStmt()
    : objtype()
    , func(nullptr)
    , actions()
{}

AlterFunctionStmt::AlterFunctionStmt(::pg_query::ObjectType&& arg_objtype, std::unique_ptr<::pg_query::ObjectWithArgs> arg_func, std::vector<::pg_query::Node> arg_actions)
    : objtype(std::move(arg_objtype))
    , func(arg_func.release())
    , actions(std::move(arg_actions))
{}

AlterFunctionStmt::AlterFunctionStmt(AlterFunctionStmt&& other) noexcept
    : objtype(std::move(other.objtype))
    , func(std::exchange(other.func, nullptr))
    , actions(std::move(other.actions))
{}

AlterFunctionStmt::~AlterFunctionStmt()
{
    if (func) delete func;
}

bool AlterFunctionStmt::operator==([[maybe_unused]] const AlterFunctionStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterFunctionStmt::operator<([[maybe_unused]] const AlterFunctionStmt& other) const noexcept
{
    return false;
}

AlterFunctionStmt& AlterFunctionStmt::operator=(AlterFunctionStmt&& other) noexcept
{
    if (this != &other)
    {
        objtype = std::move(other.objtype);
        func = std::exchange(other.func, nullptr);
        actions = std::move(other.actions);
    }
    return *this;
}

std::string AlterFunctionStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterFunctionStmt::swap(AlterFunctionStmt& other) noexcept
{
    using std::swap;
    swap(objtype, other.objtype);
    swap(func, other.func);
    swap(actions, other.actions);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterFunctionStmt& value)
{
    stream << "AlterFunctionStmt(";
    stream << "objtype="; stream << value.objtype;
    stream << ",func="; stream << " ptr of other struct" << (value.func == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",actions=[" << value.actions.size() << "][";
        for (const auto& it : value.actions)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

DoStmt::DoStmt()
    : args()
{}

DoStmt::DoStmt(std::vector<::pg_query::Node> arg_args)
    : args(std::move(arg_args))
{}

DoStmt::DoStmt(DoStmt&& other) noexcept
    : args(std::move(other.args))
{}

DoStmt::~DoStmt()
{
}

bool DoStmt::operator==([[maybe_unused]] const DoStmt& other) const noexcept
{
    return (
        true
        );
}

bool DoStmt::operator<([[maybe_unused]] const DoStmt& other) const noexcept
{
    return false;
}

DoStmt& DoStmt::operator=(DoStmt&& other) noexcept
{
    if (this != &other)
    {
        args = std::move(other.args);
    }
    return *this;
}

std::string DoStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DoStmt::swap(DoStmt& other) noexcept
{
    using std::swap;
    swap(args, other.args);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DoStmt& value)
{
    stream << "DoStmt(";
    {
        bool first = true;
        stream << "args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

RenameStmt::RenameStmt()
    : rename_type()
    , relation_type()
    , relation(nullptr)
    , object()
    , subname()
    , newname()
    , behavior()
    , missing_ok(false)
{}

RenameStmt::RenameStmt(::pg_query::ObjectType&& arg_rename_type, ::pg_query::ObjectType&& arg_relation_type, std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_object, const std::string& arg_subname, const std::string& arg_newname, ::pg_query::DropBehavior&& arg_behavior, bool arg_missing_ok)
    : rename_type(std::move(arg_rename_type))
    , relation_type(std::move(arg_relation_type))
    , relation(arg_relation.release())
    , object(std::move(arg_object))
    , subname(arg_subname)
    , newname(arg_newname)
    , behavior(std::move(arg_behavior))
    , missing_ok(arg_missing_ok)
{}

RenameStmt::RenameStmt(RenameStmt&& other) noexcept
    : rename_type(std::move(other.rename_type))
    , relation_type(std::move(other.relation_type))
    , relation(std::exchange(other.relation, nullptr))
    , object(std::move(other.object))
    , subname(std::move(other.subname))
    , newname(std::move(other.newname))
    , behavior(std::move(other.behavior))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

RenameStmt::~RenameStmt()
{
    if (relation) delete relation;
}

bool RenameStmt::operator==([[maybe_unused]] const RenameStmt& other) const noexcept
{
    return (
        true
        );
}

bool RenameStmt::operator<([[maybe_unused]] const RenameStmt& other) const noexcept
{
    return false;
}

RenameStmt& RenameStmt::operator=(RenameStmt&& other) noexcept
{
    if (this != &other)
    {
        rename_type = std::move(other.rename_type);
        relation_type = std::move(other.relation_type);
        relation = std::exchange(other.relation, nullptr);
        object = std::move(other.object);
        subname = std::move(other.subname);
        newname = std::move(other.newname);
        behavior = std::move(other.behavior);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string RenameStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RenameStmt::swap(RenameStmt& other) noexcept
{
    using std::swap;
    swap(rename_type, other.rename_type);
    swap(relation_type, other.relation_type);
    swap(relation, other.relation);
    swap(object, other.object);
    swap(subname, other.subname);
    swap(newname, other.newname);
    swap(behavior, other.behavior);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RenameStmt& value)
{
    stream << "RenameStmt(";
    stream << "rename_type="; stream << value.rename_type;
    stream << ",relation_type="; stream << value.relation_type;
    stream << ",relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",object="; stream << value.object;
    stream << ",subname="; stream << "\"" << value.subname << "\"";
    stream << ",newname="; stream << "\"" << value.newname << "\"";
    stream << ",behavior="; stream << value.behavior;
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

RuleStmt::RuleStmt()
    : relation(nullptr)
    , rulename()
    , where_clause()
    , event()
    , instead(false)
    , actions()
    , replace(false)
{}

RuleStmt::RuleStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, const std::string& arg_rulename, ::pg_query::Node&& arg_where_clause, ::pg_query::CmdType&& arg_event, bool arg_instead, std::vector<::pg_query::Node> arg_actions, bool arg_replace)
    : relation(arg_relation.release())
    , rulename(arg_rulename)
    , where_clause(std::move(arg_where_clause))
    , event(std::move(arg_event))
    , instead(arg_instead)
    , actions(std::move(arg_actions))
    , replace(arg_replace)
{}

RuleStmt::RuleStmt(RuleStmt&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , rulename(std::move(other.rulename))
    , where_clause(std::move(other.where_clause))
    , event(std::move(other.event))
    , instead(std::exchange(other.instead, false))
    , actions(std::move(other.actions))
    , replace(std::exchange(other.replace, false))
{}

RuleStmt::~RuleStmt()
{
    if (relation) delete relation;
}

bool RuleStmt::operator==([[maybe_unused]] const RuleStmt& other) const noexcept
{
    return (
        true
        );
}

bool RuleStmt::operator<([[maybe_unused]] const RuleStmt& other) const noexcept
{
    return false;
}

RuleStmt& RuleStmt::operator=(RuleStmt&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        rulename = std::move(other.rulename);
        where_clause = std::move(other.where_clause);
        event = std::move(other.event);
        instead = std::exchange(other.instead, false);
        actions = std::move(other.actions);
        replace = std::exchange(other.replace, false);
    }
    return *this;
}

std::string RuleStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RuleStmt::swap(RuleStmt& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(rulename, other.rulename);
    swap(where_clause, other.where_clause);
    swap(event, other.event);
    swap(instead, other.instead);
    swap(actions, other.actions);
    swap(replace, other.replace);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RuleStmt& value)
{
    stream << "RuleStmt(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",rulename="; stream << "\"" << value.rulename << "\"";
    stream << ",where_clause="; stream << value.where_clause;
    stream << ",event="; stream << value.event;
    stream << ",instead="; stream << (value.instead ? "true" : "false");
    {
        bool first = true;
        stream << ",actions=[" << value.actions.size() << "][";
        for (const auto& it : value.actions)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",replace="; stream << (value.replace ? "true" : "false");
    stream << ")";
    return stream;
}

NotifyStmt::NotifyStmt()
    : conditionname()
    , payload()
{}

NotifyStmt::NotifyStmt(const std::string& arg_conditionname, const std::string& arg_payload)
    : conditionname(arg_conditionname)
    , payload(arg_payload)
{}

NotifyStmt::NotifyStmt(NotifyStmt&& other) noexcept
    : conditionname(std::move(other.conditionname))
    , payload(std::move(other.payload))
{}

NotifyStmt::~NotifyStmt()
{
}

bool NotifyStmt::operator==([[maybe_unused]] const NotifyStmt& other) const noexcept
{
    return (
        true
        );
}

bool NotifyStmt::operator<([[maybe_unused]] const NotifyStmt& other) const noexcept
{
    return false;
}

NotifyStmt& NotifyStmt::operator=(NotifyStmt&& other) noexcept
{
    if (this != &other)
    {
        conditionname = std::move(other.conditionname);
        payload = std::move(other.payload);
    }
    return *this;
}

std::string NotifyStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void NotifyStmt::swap(NotifyStmt& other) noexcept
{
    using std::swap;
    swap(conditionname, other.conditionname);
    swap(payload, other.payload);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const NotifyStmt& value)
{
    stream << "NotifyStmt(";
    stream << "conditionname="; stream << "\"" << value.conditionname << "\"";
    stream << ",payload="; stream << "\"" << value.payload << "\"";
    stream << ")";
    return stream;
}

ListenStmt::ListenStmt()
    : conditionname()
{}

ListenStmt::ListenStmt(const std::string& arg_conditionname)
    : conditionname(arg_conditionname)
{}

ListenStmt::ListenStmt(ListenStmt&& other) noexcept
    : conditionname(std::move(other.conditionname))
{}

ListenStmt::~ListenStmt()
{
}

bool ListenStmt::operator==([[maybe_unused]] const ListenStmt& other) const noexcept
{
    return (
        true
        );
}

bool ListenStmt::operator<([[maybe_unused]] const ListenStmt& other) const noexcept
{
    return false;
}

ListenStmt& ListenStmt::operator=(ListenStmt&& other) noexcept
{
    if (this != &other)
    {
        conditionname = std::move(other.conditionname);
    }
    return *this;
}

std::string ListenStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ListenStmt::swap(ListenStmt& other) noexcept
{
    using std::swap;
    swap(conditionname, other.conditionname);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ListenStmt& value)
{
    stream << "ListenStmt(";
    stream << "conditionname="; stream << "\"" << value.conditionname << "\"";
    stream << ")";
    return stream;
}

UnlistenStmt::UnlistenStmt()
    : conditionname()
{}

UnlistenStmt::UnlistenStmt(const std::string& arg_conditionname)
    : conditionname(arg_conditionname)
{}

UnlistenStmt::UnlistenStmt(UnlistenStmt&& other) noexcept
    : conditionname(std::move(other.conditionname))
{}

UnlistenStmt::~UnlistenStmt()
{
}

bool UnlistenStmt::operator==([[maybe_unused]] const UnlistenStmt& other) const noexcept
{
    return (
        true
        );
}

bool UnlistenStmt::operator<([[maybe_unused]] const UnlistenStmt& other) const noexcept
{
    return false;
}

UnlistenStmt& UnlistenStmt::operator=(UnlistenStmt&& other) noexcept
{
    if (this != &other)
    {
        conditionname = std::move(other.conditionname);
    }
    return *this;
}

std::string UnlistenStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void UnlistenStmt::swap(UnlistenStmt& other) noexcept
{
    using std::swap;
    swap(conditionname, other.conditionname);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const UnlistenStmt& value)
{
    stream << "UnlistenStmt(";
    stream << "conditionname="; stream << "\"" << value.conditionname << "\"";
    stream << ")";
    return stream;
}

TransactionStmt::TransactionStmt()
    : kind()
    , options()
    , savepoint_name()
    , gid()
    , chain(false)
{}

TransactionStmt::TransactionStmt(::pg_query::TransactionStmtKind&& arg_kind, std::vector<::pg_query::Node> arg_options, const std::string& arg_savepoint_name, const std::string& arg_gid, bool arg_chain)
    : kind(std::move(arg_kind))
    , options(std::move(arg_options))
    , savepoint_name(arg_savepoint_name)
    , gid(arg_gid)
    , chain(arg_chain)
{}

TransactionStmt::TransactionStmt(TransactionStmt&& other) noexcept
    : kind(std::move(other.kind))
    , options(std::move(other.options))
    , savepoint_name(std::move(other.savepoint_name))
    , gid(std::move(other.gid))
    , chain(std::exchange(other.chain, false))
{}

TransactionStmt::~TransactionStmt()
{
}

bool TransactionStmt::operator==([[maybe_unused]] const TransactionStmt& other) const noexcept
{
    return (
        true
        );
}

bool TransactionStmt::operator<([[maybe_unused]] const TransactionStmt& other) const noexcept
{
    return false;
}

TransactionStmt& TransactionStmt::operator=(TransactionStmt&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        options = std::move(other.options);
        savepoint_name = std::move(other.savepoint_name);
        gid = std::move(other.gid);
        chain = std::exchange(other.chain, false);
    }
    return *this;
}

std::string TransactionStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void TransactionStmt::swap(TransactionStmt& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(options, other.options);
    swap(savepoint_name, other.savepoint_name);
    swap(gid, other.gid);
    swap(chain, other.chain);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const TransactionStmt& value)
{
    stream << "TransactionStmt(";
    stream << "kind="; stream << value.kind;
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",savepoint_name="; stream << "\"" << value.savepoint_name << "\"";
    stream << ",gid="; stream << "\"" << value.gid << "\"";
    stream << ",chain="; stream << (value.chain ? "true" : "false");
    stream << ")";
    return stream;
}

ViewStmt::ViewStmt()
    : view(nullptr)
    , aliases()
    , query()
    , replace(false)
    , options()
    , with_check_option()
{}

ViewStmt::ViewStmt(std::unique_ptr<::pg_query::RangeVar> arg_view, std::vector<::pg_query::Node> arg_aliases, ::pg_query::Node&& arg_query, bool arg_replace, std::vector<::pg_query::Node> arg_options, ::pg_query::ViewCheckOption&& arg_with_check_option)
    : view(arg_view.release())
    , aliases(std::move(arg_aliases))
    , query(std::move(arg_query))
    , replace(arg_replace)
    , options(std::move(arg_options))
    , with_check_option(std::move(arg_with_check_option))
{}

ViewStmt::ViewStmt(ViewStmt&& other) noexcept
    : view(std::exchange(other.view, nullptr))
    , aliases(std::move(other.aliases))
    , query(std::move(other.query))
    , replace(std::exchange(other.replace, false))
    , options(std::move(other.options))
    , with_check_option(std::move(other.with_check_option))
{}

ViewStmt::~ViewStmt()
{
    if (view) delete view;
}

bool ViewStmt::operator==([[maybe_unused]] const ViewStmt& other) const noexcept
{
    return (
        true
        );
}

bool ViewStmt::operator<([[maybe_unused]] const ViewStmt& other) const noexcept
{
    return false;
}

ViewStmt& ViewStmt::operator=(ViewStmt&& other) noexcept
{
    if (this != &other)
    {
        view = std::exchange(other.view, nullptr);
        aliases = std::move(other.aliases);
        query = std::move(other.query);
        replace = std::exchange(other.replace, false);
        options = std::move(other.options);
        with_check_option = std::move(other.with_check_option);
    }
    return *this;
}

std::string ViewStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ViewStmt::swap(ViewStmt& other) noexcept
{
    using std::swap;
    swap(view, other.view);
    swap(aliases, other.aliases);
    swap(query, other.query);
    swap(replace, other.replace);
    swap(options, other.options);
    swap(with_check_option, other.with_check_option);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ViewStmt& value)
{
    stream << "ViewStmt(";
    stream << "view="; stream << " ptr of other struct" << (value.view == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",aliases=[" << value.aliases.size() << "][";
        for (const auto& it : value.aliases)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",query="; stream << value.query;
    stream << ",replace="; stream << (value.replace ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",with_check_option="; stream << value.with_check_option;
    stream << ")";
    return stream;
}

LoadStmt::LoadStmt()
    : filename()
{}

LoadStmt::LoadStmt(const std::string& arg_filename)
    : filename(arg_filename)
{}

LoadStmt::LoadStmt(LoadStmt&& other) noexcept
    : filename(std::move(other.filename))
{}

LoadStmt::~LoadStmt()
{
}

bool LoadStmt::operator==([[maybe_unused]] const LoadStmt& other) const noexcept
{
    return (
        true
        );
}

bool LoadStmt::operator<([[maybe_unused]] const LoadStmt& other) const noexcept
{
    return false;
}

LoadStmt& LoadStmt::operator=(LoadStmt&& other) noexcept
{
    if (this != &other)
    {
        filename = std::move(other.filename);
    }
    return *this;
}

std::string LoadStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void LoadStmt::swap(LoadStmt& other) noexcept
{
    using std::swap;
    swap(filename, other.filename);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const LoadStmt& value)
{
    stream << "LoadStmt(";
    stream << "filename="; stream << "\"" << value.filename << "\"";
    stream << ")";
    return stream;
}

CreateDomainStmt::CreateDomainStmt()
    : domainname()
    , type_name(nullptr)
    , coll_clause(nullptr)
    , constraints()
{}

CreateDomainStmt::CreateDomainStmt(std::vector<::pg_query::Node> arg_domainname, std::unique_ptr<::pg_query::TypeName> arg_type_name, std::unique_ptr<::pg_query::CollateClause> arg_coll_clause, std::vector<::pg_query::Node> arg_constraints)
    : domainname(std::move(arg_domainname))
    , type_name(arg_type_name.release())
    , coll_clause(arg_coll_clause.release())
    , constraints(std::move(arg_constraints))
{}

CreateDomainStmt::CreateDomainStmt(CreateDomainStmt&& other) noexcept
    : domainname(std::move(other.domainname))
    , type_name(std::exchange(other.type_name, nullptr))
    , coll_clause(std::exchange(other.coll_clause, nullptr))
    , constraints(std::move(other.constraints))
{}

CreateDomainStmt::~CreateDomainStmt()
{
    if (type_name) delete type_name;
    if (coll_clause) delete coll_clause;
}

bool CreateDomainStmt::operator==([[maybe_unused]] const CreateDomainStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateDomainStmt::operator<([[maybe_unused]] const CreateDomainStmt& other) const noexcept
{
    return false;
}

CreateDomainStmt& CreateDomainStmt::operator=(CreateDomainStmt&& other) noexcept
{
    if (this != &other)
    {
        domainname = std::move(other.domainname);
        type_name = std::exchange(other.type_name, nullptr);
        coll_clause = std::exchange(other.coll_clause, nullptr);
        constraints = std::move(other.constraints);
    }
    return *this;
}

std::string CreateDomainStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateDomainStmt::swap(CreateDomainStmt& other) noexcept
{
    using std::swap;
    swap(domainname, other.domainname);
    swap(type_name, other.type_name);
    swap(coll_clause, other.coll_clause);
    swap(constraints, other.constraints);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateDomainStmt& value)
{
    stream << "CreateDomainStmt(";
    {
        bool first = true;
        stream << "domainname=[" << value.domainname.size() << "][";
        for (const auto& it : value.domainname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",type_name="; stream << " ptr of other struct" << (value.type_name == nullptr ? "true" : "false");
    stream << ",coll_clause="; stream << " ptr of other struct" << (value.coll_clause == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",constraints=[" << value.constraints.size() << "][";
        for (const auto& it : value.constraints)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

CreatedbStmt::CreatedbStmt()
    : dbname()
    , options()
{}

CreatedbStmt::CreatedbStmt(const std::string& arg_dbname, std::vector<::pg_query::Node> arg_options)
    : dbname(arg_dbname)
    , options(std::move(arg_options))
{}

CreatedbStmt::CreatedbStmt(CreatedbStmt&& other) noexcept
    : dbname(std::move(other.dbname))
    , options(std::move(other.options))
{}

CreatedbStmt::~CreatedbStmt()
{
}

bool CreatedbStmt::operator==([[maybe_unused]] const CreatedbStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreatedbStmt::operator<([[maybe_unused]] const CreatedbStmt& other) const noexcept
{
    return false;
}

CreatedbStmt& CreatedbStmt::operator=(CreatedbStmt&& other) noexcept
{
    if (this != &other)
    {
        dbname = std::move(other.dbname);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreatedbStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreatedbStmt::swap(CreatedbStmt& other) noexcept
{
    using std::swap;
    swap(dbname, other.dbname);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreatedbStmt& value)
{
    stream << "CreatedbStmt(";
    stream << "dbname="; stream << "\"" << value.dbname << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

DropdbStmt::DropdbStmt()
    : dbname()
    , missing_ok(false)
    , options()
{}

DropdbStmt::DropdbStmt(const std::string& arg_dbname, bool arg_missing_ok, std::vector<::pg_query::Node> arg_options)
    : dbname(arg_dbname)
    , missing_ok(arg_missing_ok)
    , options(std::move(arg_options))
{}

DropdbStmt::DropdbStmt(DropdbStmt&& other) noexcept
    : dbname(std::move(other.dbname))
    , missing_ok(std::exchange(other.missing_ok, false))
    , options(std::move(other.options))
{}

DropdbStmt::~DropdbStmt()
{
}

bool DropdbStmt::operator==([[maybe_unused]] const DropdbStmt& other) const noexcept
{
    return (
        true
        );
}

bool DropdbStmt::operator<([[maybe_unused]] const DropdbStmt& other) const noexcept
{
    return false;
}

DropdbStmt& DropdbStmt::operator=(DropdbStmt&& other) noexcept
{
    if (this != &other)
    {
        dbname = std::move(other.dbname);
        missing_ok = std::exchange(other.missing_ok, false);
        options = std::move(other.options);
    }
    return *this;
}

std::string DropdbStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DropdbStmt::swap(DropdbStmt& other) noexcept
{
    using std::swap;
    swap(dbname, other.dbname);
    swap(missing_ok, other.missing_ok);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DropdbStmt& value)
{
    stream << "DropdbStmt(";
    stream << "dbname="; stream << "\"" << value.dbname << "\"";
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

VacuumStmt::VacuumStmt()
    : options()
    , rels()
    , is_vacuumcmd(false)
{}

VacuumStmt::VacuumStmt(std::vector<::pg_query::Node> arg_options, std::vector<::pg_query::Node> arg_rels, bool arg_is_vacuumcmd)
    : options(std::move(arg_options))
    , rels(std::move(arg_rels))
    , is_vacuumcmd(arg_is_vacuumcmd)
{}

VacuumStmt::VacuumStmt(VacuumStmt&& other) noexcept
    : options(std::move(other.options))
    , rels(std::move(other.rels))
    , is_vacuumcmd(std::exchange(other.is_vacuumcmd, false))
{}

VacuumStmt::~VacuumStmt()
{
}

bool VacuumStmt::operator==([[maybe_unused]] const VacuumStmt& other) const noexcept
{
    return (
        true
        );
}

bool VacuumStmt::operator<([[maybe_unused]] const VacuumStmt& other) const noexcept
{
    return false;
}

VacuumStmt& VacuumStmt::operator=(VacuumStmt&& other) noexcept
{
    if (this != &other)
    {
        options = std::move(other.options);
        rels = std::move(other.rels);
        is_vacuumcmd = std::exchange(other.is_vacuumcmd, false);
    }
    return *this;
}

std::string VacuumStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void VacuumStmt::swap(VacuumStmt& other) noexcept
{
    using std::swap;
    swap(options, other.options);
    swap(rels, other.rels);
    swap(is_vacuumcmd, other.is_vacuumcmd);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const VacuumStmt& value)
{
    stream << "VacuumStmt(";
    {
        bool first = true;
        stream << "options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",rels=[" << value.rels.size() << "][";
        for (const auto& it : value.rels)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",is_vacuumcmd="; stream << (value.is_vacuumcmd ? "true" : "false");
    stream << ")";
    return stream;
}

ExplainStmt::ExplainStmt()
    : query()
    , options()
{}

ExplainStmt::ExplainStmt(::pg_query::Node&& arg_query, std::vector<::pg_query::Node> arg_options)
    : query(std::move(arg_query))
    , options(std::move(arg_options))
{}

ExplainStmt::ExplainStmt(ExplainStmt&& other) noexcept
    : query(std::move(other.query))
    , options(std::move(other.options))
{}

ExplainStmt::~ExplainStmt()
{
}

bool ExplainStmt::operator==([[maybe_unused]] const ExplainStmt& other) const noexcept
{
    return (
        true
        );
}

bool ExplainStmt::operator<([[maybe_unused]] const ExplainStmt& other) const noexcept
{
    return false;
}

ExplainStmt& ExplainStmt::operator=(ExplainStmt&& other) noexcept
{
    if (this != &other)
    {
        query = std::move(other.query);
        options = std::move(other.options);
    }
    return *this;
}

std::string ExplainStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ExplainStmt::swap(ExplainStmt& other) noexcept
{
    using std::swap;
    swap(query, other.query);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ExplainStmt& value)
{
    stream << "ExplainStmt(";
    stream << "query="; stream << value.query;
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

CreateTableAsStmt::CreateTableAsStmt()
    : query()
    , into(nullptr)
    , relkind()
    , is_select_into(false)
    , if_not_exists(false)
{}

CreateTableAsStmt::CreateTableAsStmt(::pg_query::Node&& arg_query, std::unique_ptr<::pg_query::IntoClause> arg_into, ::pg_query::ObjectType&& arg_relkind, bool arg_is_select_into, bool arg_if_not_exists)
    : query(std::move(arg_query))
    , into(arg_into.release())
    , relkind(std::move(arg_relkind))
    , is_select_into(arg_is_select_into)
    , if_not_exists(arg_if_not_exists)
{}

CreateTableAsStmt::CreateTableAsStmt(CreateTableAsStmt&& other) noexcept
    : query(std::move(other.query))
    , into(std::exchange(other.into, nullptr))
    , relkind(std::move(other.relkind))
    , is_select_into(std::exchange(other.is_select_into, false))
    , if_not_exists(std::exchange(other.if_not_exists, false))
{}

CreateTableAsStmt::~CreateTableAsStmt()
{
    if (into) delete into;
}

bool CreateTableAsStmt::operator==([[maybe_unused]] const CreateTableAsStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateTableAsStmt::operator<([[maybe_unused]] const CreateTableAsStmt& other) const noexcept
{
    return false;
}

CreateTableAsStmt& CreateTableAsStmt::operator=(CreateTableAsStmt&& other) noexcept
{
    if (this != &other)
    {
        query = std::move(other.query);
        into = std::exchange(other.into, nullptr);
        relkind = std::move(other.relkind);
        is_select_into = std::exchange(other.is_select_into, false);
        if_not_exists = std::exchange(other.if_not_exists, false);
    }
    return *this;
}

std::string CreateTableAsStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateTableAsStmt::swap(CreateTableAsStmt& other) noexcept
{
    using std::swap;
    swap(query, other.query);
    swap(into, other.into);
    swap(relkind, other.relkind);
    swap(is_select_into, other.is_select_into);
    swap(if_not_exists, other.if_not_exists);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateTableAsStmt& value)
{
    stream << "CreateTableAsStmt(";
    stream << "query="; stream << value.query;
    stream << ",into="; stream << " ptr of other struct" << (value.into == nullptr ? "true" : "false");
    stream << ",relkind="; stream << value.relkind;
    stream << ",is_select_into="; stream << (value.is_select_into ? "true" : "false");
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    stream << ")";
    return stream;
}

CreateSeqStmt::CreateSeqStmt()
    : sequence(nullptr)
    , options()
    , owner_id((uint32_t)0ull)
    , for_identity(false)
    , if_not_exists(false)
{}

CreateSeqStmt::CreateSeqStmt(std::unique_ptr<::pg_query::RangeVar> arg_sequence, std::vector<::pg_query::Node> arg_options, uint32_t arg_owner_id, bool arg_for_identity, bool arg_if_not_exists)
    : sequence(arg_sequence.release())
    , options(std::move(arg_options))
    , owner_id(arg_owner_id)
    , for_identity(arg_for_identity)
    , if_not_exists(arg_if_not_exists)
{}

CreateSeqStmt::CreateSeqStmt(CreateSeqStmt&& other) noexcept
    : sequence(std::exchange(other.sequence, nullptr))
    , options(std::move(other.options))
    , owner_id(std::exchange(other.owner_id, (uint32_t)0ull))
    , for_identity(std::exchange(other.for_identity, false))
    , if_not_exists(std::exchange(other.if_not_exists, false))
{}

CreateSeqStmt::~CreateSeqStmt()
{
    if (sequence) delete sequence;
}

bool CreateSeqStmt::operator==([[maybe_unused]] const CreateSeqStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateSeqStmt::operator<([[maybe_unused]] const CreateSeqStmt& other) const noexcept
{
    return false;
}

CreateSeqStmt& CreateSeqStmt::operator=(CreateSeqStmt&& other) noexcept
{
    if (this != &other)
    {
        sequence = std::exchange(other.sequence, nullptr);
        options = std::move(other.options);
        owner_id = std::exchange(other.owner_id, (uint32_t)0ull);
        for_identity = std::exchange(other.for_identity, false);
        if_not_exists = std::exchange(other.if_not_exists, false);
    }
    return *this;
}

std::string CreateSeqStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateSeqStmt::swap(CreateSeqStmt& other) noexcept
{
    using std::swap;
    swap(sequence, other.sequence);
    swap(options, other.options);
    swap(owner_id, other.owner_id);
    swap(for_identity, other.for_identity);
    swap(if_not_exists, other.if_not_exists);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateSeqStmt& value)
{
    stream << "CreateSeqStmt(";
    stream << "sequence="; stream << " ptr of other struct" << (value.sequence == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",owner_id="; stream << value.owner_id;
    stream << ",for_identity="; stream << (value.for_identity ? "true" : "false");
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    stream << ")";
    return stream;
}

AlterSeqStmt::AlterSeqStmt()
    : sequence(nullptr)
    , options()
    , for_identity(false)
    , missing_ok(false)
{}

AlterSeqStmt::AlterSeqStmt(std::unique_ptr<::pg_query::RangeVar> arg_sequence, std::vector<::pg_query::Node> arg_options, bool arg_for_identity, bool arg_missing_ok)
    : sequence(arg_sequence.release())
    , options(std::move(arg_options))
    , for_identity(arg_for_identity)
    , missing_ok(arg_missing_ok)
{}

AlterSeqStmt::AlterSeqStmt(AlterSeqStmt&& other) noexcept
    : sequence(std::exchange(other.sequence, nullptr))
    , options(std::move(other.options))
    , for_identity(std::exchange(other.for_identity, false))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

AlterSeqStmt::~AlterSeqStmt()
{
    if (sequence) delete sequence;
}

bool AlterSeqStmt::operator==([[maybe_unused]] const AlterSeqStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterSeqStmt::operator<([[maybe_unused]] const AlterSeqStmt& other) const noexcept
{
    return false;
}

AlterSeqStmt& AlterSeqStmt::operator=(AlterSeqStmt&& other) noexcept
{
    if (this != &other)
    {
        sequence = std::exchange(other.sequence, nullptr);
        options = std::move(other.options);
        for_identity = std::exchange(other.for_identity, false);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string AlterSeqStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterSeqStmt::swap(AlterSeqStmt& other) noexcept
{
    using std::swap;
    swap(sequence, other.sequence);
    swap(options, other.options);
    swap(for_identity, other.for_identity);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterSeqStmt& value)
{
    stream << "AlterSeqStmt(";
    stream << "sequence="; stream << " ptr of other struct" << (value.sequence == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",for_identity="; stream << (value.for_identity ? "true" : "false");
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

VariableSetStmt::VariableSetStmt()
    : kind()
    , name()
    , args()
    , is_local(false)
{}

VariableSetStmt::VariableSetStmt(::pg_query::VariableSetKind&& arg_kind, const std::string& arg_name, std::vector<::pg_query::Node> arg_args, bool arg_is_local)
    : kind(std::move(arg_kind))
    , name(arg_name)
    , args(std::move(arg_args))
    , is_local(arg_is_local)
{}

VariableSetStmt::VariableSetStmt(VariableSetStmt&& other) noexcept
    : kind(std::move(other.kind))
    , name(std::move(other.name))
    , args(std::move(other.args))
    , is_local(std::exchange(other.is_local, false))
{}

VariableSetStmt::~VariableSetStmt()
{
}

bool VariableSetStmt::operator==([[maybe_unused]] const VariableSetStmt& other) const noexcept
{
    return (
        true
        );
}

bool VariableSetStmt::operator<([[maybe_unused]] const VariableSetStmt& other) const noexcept
{
    return false;
}

VariableSetStmt& VariableSetStmt::operator=(VariableSetStmt&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        name = std::move(other.name);
        args = std::move(other.args);
        is_local = std::exchange(other.is_local, false);
    }
    return *this;
}

std::string VariableSetStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void VariableSetStmt::swap(VariableSetStmt& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(name, other.name);
    swap(args, other.args);
    swap(is_local, other.is_local);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const VariableSetStmt& value)
{
    stream << "VariableSetStmt(";
    stream << "kind="; stream << value.kind;
    stream << ",name="; stream << "\"" << value.name << "\"";
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",is_local="; stream << (value.is_local ? "true" : "false");
    stream << ")";
    return stream;
}

VariableShowStmt::VariableShowStmt()
    : name()
{}

VariableShowStmt::VariableShowStmt(const std::string& arg_name)
    : name(arg_name)
{}

VariableShowStmt::VariableShowStmt(VariableShowStmt&& other) noexcept
    : name(std::move(other.name))
{}

VariableShowStmt::~VariableShowStmt()
{
}

bool VariableShowStmt::operator==([[maybe_unused]] const VariableShowStmt& other) const noexcept
{
    return (
        true
        );
}

bool VariableShowStmt::operator<([[maybe_unused]] const VariableShowStmt& other) const noexcept
{
    return false;
}

VariableShowStmt& VariableShowStmt::operator=(VariableShowStmt&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
    }
    return *this;
}

std::string VariableShowStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void VariableShowStmt::swap(VariableShowStmt& other) noexcept
{
    using std::swap;
    swap(name, other.name);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const VariableShowStmt& value)
{
    stream << "VariableShowStmt(";
    stream << "name="; stream << "\"" << value.name << "\"";
    stream << ")";
    return stream;
}

DiscardStmt::DiscardStmt()
    : target()
{}

DiscardStmt::DiscardStmt(::pg_query::DiscardMode&& arg_target)
    : target(std::move(arg_target))
{}

DiscardStmt::DiscardStmt(DiscardStmt&& other) noexcept
    : target(std::move(other.target))
{}

DiscardStmt::~DiscardStmt()
{
}

bool DiscardStmt::operator==([[maybe_unused]] const DiscardStmt& other) const noexcept
{
    return (
        true
        );
}

bool DiscardStmt::operator<([[maybe_unused]] const DiscardStmt& other) const noexcept
{
    return false;
}

DiscardStmt& DiscardStmt::operator=(DiscardStmt&& other) noexcept
{
    if (this != &other)
    {
        target = std::move(other.target);
    }
    return *this;
}

std::string DiscardStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DiscardStmt::swap(DiscardStmt& other) noexcept
{
    using std::swap;
    swap(target, other.target);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DiscardStmt& value)
{
    stream << "DiscardStmt(";
    stream << "target="; stream << value.target;
    stream << ")";
    return stream;
}

CreateTrigStmt::CreateTrigStmt()
    : trigname()
    , relation(nullptr)
    , funcname()
    , args()
    , row(false)
    , timing((int32_t)0ll)
    , events((int32_t)0ll)
    , columns()
    , when_clause()
    , isconstraint(false)
    , transition_rels()
    , deferrable(false)
    , initdeferred(false)
    , constrrel(nullptr)
{}

CreateTrigStmt::CreateTrigStmt(const std::string& arg_trigname, std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_funcname, std::vector<::pg_query::Node> arg_args, bool arg_row, int32_t arg_timing, int32_t arg_events, std::vector<::pg_query::Node> arg_columns, ::pg_query::Node&& arg_when_clause, bool arg_isconstraint, std::vector<::pg_query::Node> arg_transition_rels, bool arg_deferrable, bool arg_initdeferred, std::unique_ptr<::pg_query::RangeVar> arg_constrrel)
    : trigname(arg_trigname)
    , relation(arg_relation.release())
    , funcname(std::move(arg_funcname))
    , args(std::move(arg_args))
    , row(arg_row)
    , timing(arg_timing)
    , events(arg_events)
    , columns(std::move(arg_columns))
    , when_clause(std::move(arg_when_clause))
    , isconstraint(arg_isconstraint)
    , transition_rels(std::move(arg_transition_rels))
    , deferrable(arg_deferrable)
    , initdeferred(arg_initdeferred)
    , constrrel(arg_constrrel.release())
{}

CreateTrigStmt::CreateTrigStmt(CreateTrigStmt&& other) noexcept
    : trigname(std::move(other.trigname))
    , relation(std::exchange(other.relation, nullptr))
    , funcname(std::move(other.funcname))
    , args(std::move(other.args))
    , row(std::exchange(other.row, false))
    , timing(std::exchange(other.timing, (int32_t)0ll))
    , events(std::exchange(other.events, (int32_t)0ll))
    , columns(std::move(other.columns))
    , when_clause(std::move(other.when_clause))
    , isconstraint(std::exchange(other.isconstraint, false))
    , transition_rels(std::move(other.transition_rels))
    , deferrable(std::exchange(other.deferrable, false))
    , initdeferred(std::exchange(other.initdeferred, false))
    , constrrel(std::exchange(other.constrrel, nullptr))
{}

CreateTrigStmt::~CreateTrigStmt()
{
    if (relation) delete relation;
    if (constrrel) delete constrrel;
}

bool CreateTrigStmt::operator==([[maybe_unused]] const CreateTrigStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateTrigStmt::operator<([[maybe_unused]] const CreateTrigStmt& other) const noexcept
{
    return false;
}

CreateTrigStmt& CreateTrigStmt::operator=(CreateTrigStmt&& other) noexcept
{
    if (this != &other)
    {
        trigname = std::move(other.trigname);
        relation = std::exchange(other.relation, nullptr);
        funcname = std::move(other.funcname);
        args = std::move(other.args);
        row = std::exchange(other.row, false);
        timing = std::exchange(other.timing, (int32_t)0ll);
        events = std::exchange(other.events, (int32_t)0ll);
        columns = std::move(other.columns);
        when_clause = std::move(other.when_clause);
        isconstraint = std::exchange(other.isconstraint, false);
        transition_rels = std::move(other.transition_rels);
        deferrable = std::exchange(other.deferrable, false);
        initdeferred = std::exchange(other.initdeferred, false);
        constrrel = std::exchange(other.constrrel, nullptr);
    }
    return *this;
}

std::string CreateTrigStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateTrigStmt::swap(CreateTrigStmt& other) noexcept
{
    using std::swap;
    swap(trigname, other.trigname);
    swap(relation, other.relation);
    swap(funcname, other.funcname);
    swap(args, other.args);
    swap(row, other.row);
    swap(timing, other.timing);
    swap(events, other.events);
    swap(columns, other.columns);
    swap(when_clause, other.when_clause);
    swap(isconstraint, other.isconstraint);
    swap(transition_rels, other.transition_rels);
    swap(deferrable, other.deferrable);
    swap(initdeferred, other.initdeferred);
    swap(constrrel, other.constrrel);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateTrigStmt& value)
{
    stream << "CreateTrigStmt(";
    stream << "trigname="; stream << "\"" << value.trigname << "\"";
    stream << ",relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",funcname=[" << value.funcname.size() << "][";
        for (const auto& it : value.funcname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",row="; stream << (value.row ? "true" : "false");
    stream << ",timing="; stream << value.timing;
    stream << ",events="; stream << value.events;
    {
        bool first = true;
        stream << ",columns=[" << value.columns.size() << "][";
        for (const auto& it : value.columns)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",when_clause="; stream << value.when_clause;
    stream << ",isconstraint="; stream << (value.isconstraint ? "true" : "false");
    {
        bool first = true;
        stream << ",transition_rels=[" << value.transition_rels.size() << "][";
        for (const auto& it : value.transition_rels)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",deferrable="; stream << (value.deferrable ? "true" : "false");
    stream << ",initdeferred="; stream << (value.initdeferred ? "true" : "false");
    stream << ",constrrel="; stream << " ptr of other struct" << (value.constrrel == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

CreatePLangStmt::CreatePLangStmt()
    : replace(false)
    , plname()
    , plhandler()
    , plinline()
    , plvalidator()
    , pltrusted(false)
{}

CreatePLangStmt::CreatePLangStmt(bool arg_replace, const std::string& arg_plname, std::vector<::pg_query::Node> arg_plhandler, std::vector<::pg_query::Node> arg_plinline, std::vector<::pg_query::Node> arg_plvalidator, bool arg_pltrusted)
    : replace(arg_replace)
    , plname(arg_plname)
    , plhandler(std::move(arg_plhandler))
    , plinline(std::move(arg_plinline))
    , plvalidator(std::move(arg_plvalidator))
    , pltrusted(arg_pltrusted)
{}

CreatePLangStmt::CreatePLangStmt(CreatePLangStmt&& other) noexcept
    : replace(std::exchange(other.replace, false))
    , plname(std::move(other.plname))
    , plhandler(std::move(other.plhandler))
    , plinline(std::move(other.plinline))
    , plvalidator(std::move(other.plvalidator))
    , pltrusted(std::exchange(other.pltrusted, false))
{}

CreatePLangStmt::~CreatePLangStmt()
{
}

bool CreatePLangStmt::operator==([[maybe_unused]] const CreatePLangStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreatePLangStmt::operator<([[maybe_unused]] const CreatePLangStmt& other) const noexcept
{
    return false;
}

CreatePLangStmt& CreatePLangStmt::operator=(CreatePLangStmt&& other) noexcept
{
    if (this != &other)
    {
        replace = std::exchange(other.replace, false);
        plname = std::move(other.plname);
        plhandler = std::move(other.plhandler);
        plinline = std::move(other.plinline);
        plvalidator = std::move(other.plvalidator);
        pltrusted = std::exchange(other.pltrusted, false);
    }
    return *this;
}

std::string CreatePLangStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreatePLangStmt::swap(CreatePLangStmt& other) noexcept
{
    using std::swap;
    swap(replace, other.replace);
    swap(plname, other.plname);
    swap(plhandler, other.plhandler);
    swap(plinline, other.plinline);
    swap(plvalidator, other.plvalidator);
    swap(pltrusted, other.pltrusted);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreatePLangStmt& value)
{
    stream << "CreatePLangStmt(";
    stream << "replace="; stream << (value.replace ? "true" : "false");
    stream << ",plname="; stream << "\"" << value.plname << "\"";
    {
        bool first = true;
        stream << ",plhandler=[" << value.plhandler.size() << "][";
        for (const auto& it : value.plhandler)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",plinline=[" << value.plinline.size() << "][";
        for (const auto& it : value.plinline)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",plvalidator=[" << value.plvalidator.size() << "][";
        for (const auto& it : value.plvalidator)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",pltrusted="; stream << (value.pltrusted ? "true" : "false");
    stream << ")";
    return stream;
}

CreateRoleStmt::CreateRoleStmt()
    : stmt_type()
    , role()
    , options()
{}

CreateRoleStmt::CreateRoleStmt(::pg_query::RoleStmtType&& arg_stmt_type, const std::string& arg_role, std::vector<::pg_query::Node> arg_options)
    : stmt_type(std::move(arg_stmt_type))
    , role(arg_role)
    , options(std::move(arg_options))
{}

CreateRoleStmt::CreateRoleStmt(CreateRoleStmt&& other) noexcept
    : stmt_type(std::move(other.stmt_type))
    , role(std::move(other.role))
    , options(std::move(other.options))
{}

CreateRoleStmt::~CreateRoleStmt()
{
}

bool CreateRoleStmt::operator==([[maybe_unused]] const CreateRoleStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateRoleStmt::operator<([[maybe_unused]] const CreateRoleStmt& other) const noexcept
{
    return false;
}

CreateRoleStmt& CreateRoleStmt::operator=(CreateRoleStmt&& other) noexcept
{
    if (this != &other)
    {
        stmt_type = std::move(other.stmt_type);
        role = std::move(other.role);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreateRoleStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateRoleStmt::swap(CreateRoleStmt& other) noexcept
{
    using std::swap;
    swap(stmt_type, other.stmt_type);
    swap(role, other.role);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateRoleStmt& value)
{
    stream << "CreateRoleStmt(";
    stream << "stmt_type="; stream << value.stmt_type;
    stream << ",role="; stream << "\"" << value.role << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterRoleStmt::AlterRoleStmt()
    : role(nullptr)
    , options()
    , action((int32_t)0ll)
{}

AlterRoleStmt::AlterRoleStmt(std::unique_ptr<::pg_query::RoleSpec> arg_role, std::vector<::pg_query::Node> arg_options, int32_t arg_action)
    : role(arg_role.release())
    , options(std::move(arg_options))
    , action(arg_action)
{}

AlterRoleStmt::AlterRoleStmt(AlterRoleStmt&& other) noexcept
    : role(std::exchange(other.role, nullptr))
    , options(std::move(other.options))
    , action(std::exchange(other.action, (int32_t)0ll))
{}

AlterRoleStmt::~AlterRoleStmt()
{
    if (role) delete role;
}

bool AlterRoleStmt::operator==([[maybe_unused]] const AlterRoleStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterRoleStmt::operator<([[maybe_unused]] const AlterRoleStmt& other) const noexcept
{
    return false;
}

AlterRoleStmt& AlterRoleStmt::operator=(AlterRoleStmt&& other) noexcept
{
    if (this != &other)
    {
        role = std::exchange(other.role, nullptr);
        options = std::move(other.options);
        action = std::exchange(other.action, (int32_t)0ll);
    }
    return *this;
}

std::string AlterRoleStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterRoleStmt::swap(AlterRoleStmt& other) noexcept
{
    using std::swap;
    swap(role, other.role);
    swap(options, other.options);
    swap(action, other.action);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterRoleStmt& value)
{
    stream << "AlterRoleStmt(";
    stream << "role="; stream << " ptr of other struct" << (value.role == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",action="; stream << value.action;
    stream << ")";
    return stream;
}

DropRoleStmt::DropRoleStmt()
    : roles()
    , missing_ok(false)
{}

DropRoleStmt::DropRoleStmt(std::vector<::pg_query::Node> arg_roles, bool arg_missing_ok)
    : roles(std::move(arg_roles))
    , missing_ok(arg_missing_ok)
{}

DropRoleStmt::DropRoleStmt(DropRoleStmt&& other) noexcept
    : roles(std::move(other.roles))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

DropRoleStmt::~DropRoleStmt()
{
}

bool DropRoleStmt::operator==([[maybe_unused]] const DropRoleStmt& other) const noexcept
{
    return (
        true
        );
}

bool DropRoleStmt::operator<([[maybe_unused]] const DropRoleStmt& other) const noexcept
{
    return false;
}

DropRoleStmt& DropRoleStmt::operator=(DropRoleStmt&& other) noexcept
{
    if (this != &other)
    {
        roles = std::move(other.roles);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string DropRoleStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DropRoleStmt::swap(DropRoleStmt& other) noexcept
{
    using std::swap;
    swap(roles, other.roles);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DropRoleStmt& value)
{
    stream << "DropRoleStmt(";
    {
        bool first = true;
        stream << "roles=[" << value.roles.size() << "][";
        for (const auto& it : value.roles)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

LockStmt::LockStmt()
    : relations()
    , mode((int32_t)0ll)
    , nowait(false)
{}

LockStmt::LockStmt(std::vector<::pg_query::Node> arg_relations, int32_t arg_mode, bool arg_nowait)
    : relations(std::move(arg_relations))
    , mode(arg_mode)
    , nowait(arg_nowait)
{}

LockStmt::LockStmt(LockStmt&& other) noexcept
    : relations(std::move(other.relations))
    , mode(std::exchange(other.mode, (int32_t)0ll))
    , nowait(std::exchange(other.nowait, false))
{}

LockStmt::~LockStmt()
{
}

bool LockStmt::operator==([[maybe_unused]] const LockStmt& other) const noexcept
{
    return (
        true
        );
}

bool LockStmt::operator<([[maybe_unused]] const LockStmt& other) const noexcept
{
    return false;
}

LockStmt& LockStmt::operator=(LockStmt&& other) noexcept
{
    if (this != &other)
    {
        relations = std::move(other.relations);
        mode = std::exchange(other.mode, (int32_t)0ll);
        nowait = std::exchange(other.nowait, false);
    }
    return *this;
}

std::string LockStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void LockStmt::swap(LockStmt& other) noexcept
{
    using std::swap;
    swap(relations, other.relations);
    swap(mode, other.mode);
    swap(nowait, other.nowait);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const LockStmt& value)
{
    stream << "LockStmt(";
    {
        bool first = true;
        stream << "relations=[" << value.relations.size() << "][";
        for (const auto& it : value.relations)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",mode="; stream << value.mode;
    stream << ",nowait="; stream << (value.nowait ? "true" : "false");
    stream << ")";
    return stream;
}

ConstraintsSetStmt::ConstraintsSetStmt()
    : constraints()
    , deferred(false)
{}

ConstraintsSetStmt::ConstraintsSetStmt(std::vector<::pg_query::Node> arg_constraints, bool arg_deferred)
    : constraints(std::move(arg_constraints))
    , deferred(arg_deferred)
{}

ConstraintsSetStmt::ConstraintsSetStmt(ConstraintsSetStmt&& other) noexcept
    : constraints(std::move(other.constraints))
    , deferred(std::exchange(other.deferred, false))
{}

ConstraintsSetStmt::~ConstraintsSetStmt()
{
}

bool ConstraintsSetStmt::operator==([[maybe_unused]] const ConstraintsSetStmt& other) const noexcept
{
    return (
        true
        );
}

bool ConstraintsSetStmt::operator<([[maybe_unused]] const ConstraintsSetStmt& other) const noexcept
{
    return false;
}

ConstraintsSetStmt& ConstraintsSetStmt::operator=(ConstraintsSetStmt&& other) noexcept
{
    if (this != &other)
    {
        constraints = std::move(other.constraints);
        deferred = std::exchange(other.deferred, false);
    }
    return *this;
}

std::string ConstraintsSetStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ConstraintsSetStmt::swap(ConstraintsSetStmt& other) noexcept
{
    using std::swap;
    swap(constraints, other.constraints);
    swap(deferred, other.deferred);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ConstraintsSetStmt& value)
{
    stream << "ConstraintsSetStmt(";
    {
        bool first = true;
        stream << "constraints=[" << value.constraints.size() << "][";
        for (const auto& it : value.constraints)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",deferred="; stream << (value.deferred ? "true" : "false");
    stream << ")";
    return stream;
}

ReindexStmt::ReindexStmt()
    : kind()
    , relation(nullptr)
    , name()
    , options((int32_t)0ll)
    , concurrent(false)
{}

ReindexStmt::ReindexStmt(::pg_query::ReindexObjectType&& arg_kind, std::unique_ptr<::pg_query::RangeVar> arg_relation, const std::string& arg_name, int32_t arg_options, bool arg_concurrent)
    : kind(std::move(arg_kind))
    , relation(arg_relation.release())
    , name(arg_name)
    , options(arg_options)
    , concurrent(arg_concurrent)
{}

ReindexStmt::ReindexStmt(ReindexStmt&& other) noexcept
    : kind(std::move(other.kind))
    , relation(std::exchange(other.relation, nullptr))
    , name(std::move(other.name))
    , options(std::exchange(other.options, (int32_t)0ll))
    , concurrent(std::exchange(other.concurrent, false))
{}

ReindexStmt::~ReindexStmt()
{
    if (relation) delete relation;
}

bool ReindexStmt::operator==([[maybe_unused]] const ReindexStmt& other) const noexcept
{
    return (
        true
        );
}

bool ReindexStmt::operator<([[maybe_unused]] const ReindexStmt& other) const noexcept
{
    return false;
}

ReindexStmt& ReindexStmt::operator=(ReindexStmt&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        relation = std::exchange(other.relation, nullptr);
        name = std::move(other.name);
        options = std::exchange(other.options, (int32_t)0ll);
        concurrent = std::exchange(other.concurrent, false);
    }
    return *this;
}

std::string ReindexStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ReindexStmt::swap(ReindexStmt& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(relation, other.relation);
    swap(name, other.name);
    swap(options, other.options);
    swap(concurrent, other.concurrent);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ReindexStmt& value)
{
    stream << "ReindexStmt(";
    stream << "kind="; stream << value.kind;
    stream << ",relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",name="; stream << "\"" << value.name << "\"";
    stream << ",options="; stream << value.options;
    stream << ",concurrent="; stream << (value.concurrent ? "true" : "false");
    stream << ")";
    return stream;
}

CheckPointStmt::CheckPointStmt()
{}

CheckPointStmt::CheckPointStmt(CheckPointStmt&& other) noexcept
{}

CheckPointStmt::~CheckPointStmt()
{
}

bool CheckPointStmt::operator==([[maybe_unused]] const CheckPointStmt& other) const noexcept
{
    return (
        true
        );
}

bool CheckPointStmt::operator<([[maybe_unused]] const CheckPointStmt& other) const noexcept
{
    return false;
}

CheckPointStmt& CheckPointStmt::operator=(CheckPointStmt&& other) noexcept
{
    if (this != &other)
    {
    }
    return *this;
}

std::string CheckPointStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CheckPointStmt::swap(CheckPointStmt& other) noexcept
{
    using std::swap;
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CheckPointStmt& value)
{
    stream << "CheckPointStmt(";
    stream << ")";
    return stream;
}

CreateSchemaStmt::CreateSchemaStmt()
    : schemaname()
    , authrole(nullptr)
    , schema_elts()
    , if_not_exists(false)
{}

CreateSchemaStmt::CreateSchemaStmt(const std::string& arg_schemaname, std::unique_ptr<::pg_query::RoleSpec> arg_authrole, std::vector<::pg_query::Node> arg_schema_elts, bool arg_if_not_exists)
    : schemaname(arg_schemaname)
    , authrole(arg_authrole.release())
    , schema_elts(std::move(arg_schema_elts))
    , if_not_exists(arg_if_not_exists)
{}

CreateSchemaStmt::CreateSchemaStmt(CreateSchemaStmt&& other) noexcept
    : schemaname(std::move(other.schemaname))
    , authrole(std::exchange(other.authrole, nullptr))
    , schema_elts(std::move(other.schema_elts))
    , if_not_exists(std::exchange(other.if_not_exists, false))
{}

CreateSchemaStmt::~CreateSchemaStmt()
{
    if (authrole) delete authrole;
}

bool CreateSchemaStmt::operator==([[maybe_unused]] const CreateSchemaStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateSchemaStmt::operator<([[maybe_unused]] const CreateSchemaStmt& other) const noexcept
{
    return false;
}

CreateSchemaStmt& CreateSchemaStmt::operator=(CreateSchemaStmt&& other) noexcept
{
    if (this != &other)
    {
        schemaname = std::move(other.schemaname);
        authrole = std::exchange(other.authrole, nullptr);
        schema_elts = std::move(other.schema_elts);
        if_not_exists = std::exchange(other.if_not_exists, false);
    }
    return *this;
}

std::string CreateSchemaStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateSchemaStmt::swap(CreateSchemaStmt& other) noexcept
{
    using std::swap;
    swap(schemaname, other.schemaname);
    swap(authrole, other.authrole);
    swap(schema_elts, other.schema_elts);
    swap(if_not_exists, other.if_not_exists);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateSchemaStmt& value)
{
    stream << "CreateSchemaStmt(";
    stream << "schemaname="; stream << "\"" << value.schemaname << "\"";
    stream << ",authrole="; stream << " ptr of other struct" << (value.authrole == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",schema_elts=[" << value.schema_elts.size() << "][";
        for (const auto& it : value.schema_elts)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    stream << ")";
    return stream;
}

AlterDatabaseStmt::AlterDatabaseStmt()
    : dbname()
    , options()
{}

AlterDatabaseStmt::AlterDatabaseStmt(const std::string& arg_dbname, std::vector<::pg_query::Node> arg_options)
    : dbname(arg_dbname)
    , options(std::move(arg_options))
{}

AlterDatabaseStmt::AlterDatabaseStmt(AlterDatabaseStmt&& other) noexcept
    : dbname(std::move(other.dbname))
    , options(std::move(other.options))
{}

AlterDatabaseStmt::~AlterDatabaseStmt()
{
}

bool AlterDatabaseStmt::operator==([[maybe_unused]] const AlterDatabaseStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterDatabaseStmt::operator<([[maybe_unused]] const AlterDatabaseStmt& other) const noexcept
{
    return false;
}

AlterDatabaseStmt& AlterDatabaseStmt::operator=(AlterDatabaseStmt&& other) noexcept
{
    if (this != &other)
    {
        dbname = std::move(other.dbname);
        options = std::move(other.options);
    }
    return *this;
}

std::string AlterDatabaseStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterDatabaseStmt::swap(AlterDatabaseStmt& other) noexcept
{
    using std::swap;
    swap(dbname, other.dbname);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterDatabaseStmt& value)
{
    stream << "AlterDatabaseStmt(";
    stream << "dbname="; stream << "\"" << value.dbname << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterDatabaseSetStmt::AlterDatabaseSetStmt()
    : dbname()
    , setstmt(nullptr)
{}

AlterDatabaseSetStmt::AlterDatabaseSetStmt(const std::string& arg_dbname, std::unique_ptr<::pg_query::VariableSetStmt> arg_setstmt)
    : dbname(arg_dbname)
    , setstmt(arg_setstmt.release())
{}

AlterDatabaseSetStmt::AlterDatabaseSetStmt(AlterDatabaseSetStmt&& other) noexcept
    : dbname(std::move(other.dbname))
    , setstmt(std::exchange(other.setstmt, nullptr))
{}

AlterDatabaseSetStmt::~AlterDatabaseSetStmt()
{
    if (setstmt) delete setstmt;
}

bool AlterDatabaseSetStmt::operator==([[maybe_unused]] const AlterDatabaseSetStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterDatabaseSetStmt::operator<([[maybe_unused]] const AlterDatabaseSetStmt& other) const noexcept
{
    return false;
}

AlterDatabaseSetStmt& AlterDatabaseSetStmt::operator=(AlterDatabaseSetStmt&& other) noexcept
{
    if (this != &other)
    {
        dbname = std::move(other.dbname);
        setstmt = std::exchange(other.setstmt, nullptr);
    }
    return *this;
}

std::string AlterDatabaseSetStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterDatabaseSetStmt::swap(AlterDatabaseSetStmt& other) noexcept
{
    using std::swap;
    swap(dbname, other.dbname);
    swap(setstmt, other.setstmt);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterDatabaseSetStmt& value)
{
    stream << "AlterDatabaseSetStmt(";
    stream << "dbname="; stream << "\"" << value.dbname << "\"";
    stream << ",setstmt="; stream << " ptr of other struct" << (value.setstmt == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

AlterRoleSetStmt::AlterRoleSetStmt()
    : role(nullptr)
    , database()
    , setstmt(nullptr)
{}

AlterRoleSetStmt::AlterRoleSetStmt(std::unique_ptr<::pg_query::RoleSpec> arg_role, const std::string& arg_database, std::unique_ptr<::pg_query::VariableSetStmt> arg_setstmt)
    : role(arg_role.release())
    , database(arg_database)
    , setstmt(arg_setstmt.release())
{}

AlterRoleSetStmt::AlterRoleSetStmt(AlterRoleSetStmt&& other) noexcept
    : role(std::exchange(other.role, nullptr))
    , database(std::move(other.database))
    , setstmt(std::exchange(other.setstmt, nullptr))
{}

AlterRoleSetStmt::~AlterRoleSetStmt()
{
    if (role) delete role;
    if (setstmt) delete setstmt;
}

bool AlterRoleSetStmt::operator==([[maybe_unused]] const AlterRoleSetStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterRoleSetStmt::operator<([[maybe_unused]] const AlterRoleSetStmt& other) const noexcept
{
    return false;
}

AlterRoleSetStmt& AlterRoleSetStmt::operator=(AlterRoleSetStmt&& other) noexcept
{
    if (this != &other)
    {
        role = std::exchange(other.role, nullptr);
        database = std::move(other.database);
        setstmt = std::exchange(other.setstmt, nullptr);
    }
    return *this;
}

std::string AlterRoleSetStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterRoleSetStmt::swap(AlterRoleSetStmt& other) noexcept
{
    using std::swap;
    swap(role, other.role);
    swap(database, other.database);
    swap(setstmt, other.setstmt);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterRoleSetStmt& value)
{
    stream << "AlterRoleSetStmt(";
    stream << "role="; stream << " ptr of other struct" << (value.role == nullptr ? "true" : "false");
    stream << ",database="; stream << "\"" << value.database << "\"";
    stream << ",setstmt="; stream << " ptr of other struct" << (value.setstmt == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

CreateConversionStmt::CreateConversionStmt()
    : conversion_name()
    , for_encoding_name()
    , to_encoding_name()
    , func_name()
    , def(false)
{}

CreateConversionStmt::CreateConversionStmt(std::vector<::pg_query::Node> arg_conversion_name, const std::string& arg_for_encoding_name, const std::string& arg_to_encoding_name, std::vector<::pg_query::Node> arg_func_name, bool arg_def)
    : conversion_name(std::move(arg_conversion_name))
    , for_encoding_name(arg_for_encoding_name)
    , to_encoding_name(arg_to_encoding_name)
    , func_name(std::move(arg_func_name))
    , def(arg_def)
{}

CreateConversionStmt::CreateConversionStmt(CreateConversionStmt&& other) noexcept
    : conversion_name(std::move(other.conversion_name))
    , for_encoding_name(std::move(other.for_encoding_name))
    , to_encoding_name(std::move(other.to_encoding_name))
    , func_name(std::move(other.func_name))
    , def(std::exchange(other.def, false))
{}

CreateConversionStmt::~CreateConversionStmt()
{
}

bool CreateConversionStmt::operator==([[maybe_unused]] const CreateConversionStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateConversionStmt::operator<([[maybe_unused]] const CreateConversionStmt& other) const noexcept
{
    return false;
}

CreateConversionStmt& CreateConversionStmt::operator=(CreateConversionStmt&& other) noexcept
{
    if (this != &other)
    {
        conversion_name = std::move(other.conversion_name);
        for_encoding_name = std::move(other.for_encoding_name);
        to_encoding_name = std::move(other.to_encoding_name);
        func_name = std::move(other.func_name);
        def = std::exchange(other.def, false);
    }
    return *this;
}

std::string CreateConversionStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateConversionStmt::swap(CreateConversionStmt& other) noexcept
{
    using std::swap;
    swap(conversion_name, other.conversion_name);
    swap(for_encoding_name, other.for_encoding_name);
    swap(to_encoding_name, other.to_encoding_name);
    swap(func_name, other.func_name);
    swap(def, other.def);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateConversionStmt& value)
{
    stream << "CreateConversionStmt(";
    {
        bool first = true;
        stream << "conversion_name=[" << value.conversion_name.size() << "][";
        for (const auto& it : value.conversion_name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",for_encoding_name="; stream << "\"" << value.for_encoding_name << "\"";
    stream << ",to_encoding_name="; stream << "\"" << value.to_encoding_name << "\"";
    {
        bool first = true;
        stream << ",func_name=[" << value.func_name.size() << "][";
        for (const auto& it : value.func_name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",def="; stream << (value.def ? "true" : "false");
    stream << ")";
    return stream;
}

CreateCastStmt::CreateCastStmt()
    : sourcetype(nullptr)
    , targettype(nullptr)
    , func(nullptr)
    , context()
    , inout(false)
{}

CreateCastStmt::CreateCastStmt(std::unique_ptr<::pg_query::TypeName> arg_sourcetype, std::unique_ptr<::pg_query::TypeName> arg_targettype, std::unique_ptr<::pg_query::ObjectWithArgs> arg_func, ::pg_query::CoercionContext&& arg_context, bool arg_inout)
    : sourcetype(arg_sourcetype.release())
    , targettype(arg_targettype.release())
    , func(arg_func.release())
    , context(std::move(arg_context))
    , inout(arg_inout)
{}

CreateCastStmt::CreateCastStmt(CreateCastStmt&& other) noexcept
    : sourcetype(std::exchange(other.sourcetype, nullptr))
    , targettype(std::exchange(other.targettype, nullptr))
    , func(std::exchange(other.func, nullptr))
    , context(std::move(other.context))
    , inout(std::exchange(other.inout, false))
{}

CreateCastStmt::~CreateCastStmt()
{
    if (sourcetype) delete sourcetype;
    if (targettype) delete targettype;
    if (func) delete func;
}

bool CreateCastStmt::operator==([[maybe_unused]] const CreateCastStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateCastStmt::operator<([[maybe_unused]] const CreateCastStmt& other) const noexcept
{
    return false;
}

CreateCastStmt& CreateCastStmt::operator=(CreateCastStmt&& other) noexcept
{
    if (this != &other)
    {
        sourcetype = std::exchange(other.sourcetype, nullptr);
        targettype = std::exchange(other.targettype, nullptr);
        func = std::exchange(other.func, nullptr);
        context = std::move(other.context);
        inout = std::exchange(other.inout, false);
    }
    return *this;
}

std::string CreateCastStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateCastStmt::swap(CreateCastStmt& other) noexcept
{
    using std::swap;
    swap(sourcetype, other.sourcetype);
    swap(targettype, other.targettype);
    swap(func, other.func);
    swap(context, other.context);
    swap(inout, other.inout);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateCastStmt& value)
{
    stream << "CreateCastStmt(";
    stream << "sourcetype="; stream << " ptr of other struct" << (value.sourcetype == nullptr ? "true" : "false");
    stream << ",targettype="; stream << " ptr of other struct" << (value.targettype == nullptr ? "true" : "false");
    stream << ",func="; stream << " ptr of other struct" << (value.func == nullptr ? "true" : "false");
    stream << ",context="; stream << value.context;
    stream << ",inout="; stream << (value.inout ? "true" : "false");
    stream << ")";
    return stream;
}

CreateOpClassStmt::CreateOpClassStmt()
    : opclassname()
    , opfamilyname()
    , amname()
    , datatype(nullptr)
    , items()
    , is_default(false)
{}

CreateOpClassStmt::CreateOpClassStmt(std::vector<::pg_query::Node> arg_opclassname, std::vector<::pg_query::Node> arg_opfamilyname, const std::string& arg_amname, std::unique_ptr<::pg_query::TypeName> arg_datatype, std::vector<::pg_query::Node> arg_items, bool arg_is_default)
    : opclassname(std::move(arg_opclassname))
    , opfamilyname(std::move(arg_opfamilyname))
    , amname(arg_amname)
    , datatype(arg_datatype.release())
    , items(std::move(arg_items))
    , is_default(arg_is_default)
{}

CreateOpClassStmt::CreateOpClassStmt(CreateOpClassStmt&& other) noexcept
    : opclassname(std::move(other.opclassname))
    , opfamilyname(std::move(other.opfamilyname))
    , amname(std::move(other.amname))
    , datatype(std::exchange(other.datatype, nullptr))
    , items(std::move(other.items))
    , is_default(std::exchange(other.is_default, false))
{}

CreateOpClassStmt::~CreateOpClassStmt()
{
    if (datatype) delete datatype;
}

bool CreateOpClassStmt::operator==([[maybe_unused]] const CreateOpClassStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateOpClassStmt::operator<([[maybe_unused]] const CreateOpClassStmt& other) const noexcept
{
    return false;
}

CreateOpClassStmt& CreateOpClassStmt::operator=(CreateOpClassStmt&& other) noexcept
{
    if (this != &other)
    {
        opclassname = std::move(other.opclassname);
        opfamilyname = std::move(other.opfamilyname);
        amname = std::move(other.amname);
        datatype = std::exchange(other.datatype, nullptr);
        items = std::move(other.items);
        is_default = std::exchange(other.is_default, false);
    }
    return *this;
}

std::string CreateOpClassStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateOpClassStmt::swap(CreateOpClassStmt& other) noexcept
{
    using std::swap;
    swap(opclassname, other.opclassname);
    swap(opfamilyname, other.opfamilyname);
    swap(amname, other.amname);
    swap(datatype, other.datatype);
    swap(items, other.items);
    swap(is_default, other.is_default);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateOpClassStmt& value)
{
    stream << "CreateOpClassStmt(";
    {
        bool first = true;
        stream << "opclassname=[" << value.opclassname.size() << "][";
        for (const auto& it : value.opclassname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",opfamilyname=[" << value.opfamilyname.size() << "][";
        for (const auto& it : value.opfamilyname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",amname="; stream << "\"" << value.amname << "\"";
    stream << ",datatype="; stream << " ptr of other struct" << (value.datatype == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",items=[" << value.items.size() << "][";
        for (const auto& it : value.items)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",is_default="; stream << (value.is_default ? "true" : "false");
    stream << ")";
    return stream;
}

CreateOpFamilyStmt::CreateOpFamilyStmt()
    : opfamilyname()
    , amname()
{}

CreateOpFamilyStmt::CreateOpFamilyStmt(std::vector<::pg_query::Node> arg_opfamilyname, const std::string& arg_amname)
    : opfamilyname(std::move(arg_opfamilyname))
    , amname(arg_amname)
{}

CreateOpFamilyStmt::CreateOpFamilyStmt(CreateOpFamilyStmt&& other) noexcept
    : opfamilyname(std::move(other.opfamilyname))
    , amname(std::move(other.amname))
{}

CreateOpFamilyStmt::~CreateOpFamilyStmt()
{
}

bool CreateOpFamilyStmt::operator==([[maybe_unused]] const CreateOpFamilyStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateOpFamilyStmt::operator<([[maybe_unused]] const CreateOpFamilyStmt& other) const noexcept
{
    return false;
}

CreateOpFamilyStmt& CreateOpFamilyStmt::operator=(CreateOpFamilyStmt&& other) noexcept
{
    if (this != &other)
    {
        opfamilyname = std::move(other.opfamilyname);
        amname = std::move(other.amname);
    }
    return *this;
}

std::string CreateOpFamilyStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateOpFamilyStmt::swap(CreateOpFamilyStmt& other) noexcept
{
    using std::swap;
    swap(opfamilyname, other.opfamilyname);
    swap(amname, other.amname);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateOpFamilyStmt& value)
{
    stream << "CreateOpFamilyStmt(";
    {
        bool first = true;
        stream << "opfamilyname=[" << value.opfamilyname.size() << "][";
        for (const auto& it : value.opfamilyname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",amname="; stream << "\"" << value.amname << "\"";
    stream << ")";
    return stream;
}

AlterOpFamilyStmt::AlterOpFamilyStmt()
    : opfamilyname()
    , amname()
    , is_drop(false)
    , items()
{}

AlterOpFamilyStmt::AlterOpFamilyStmt(std::vector<::pg_query::Node> arg_opfamilyname, const std::string& arg_amname, bool arg_is_drop, std::vector<::pg_query::Node> arg_items)
    : opfamilyname(std::move(arg_opfamilyname))
    , amname(arg_amname)
    , is_drop(arg_is_drop)
    , items(std::move(arg_items))
{}

AlterOpFamilyStmt::AlterOpFamilyStmt(AlterOpFamilyStmt&& other) noexcept
    : opfamilyname(std::move(other.opfamilyname))
    , amname(std::move(other.amname))
    , is_drop(std::exchange(other.is_drop, false))
    , items(std::move(other.items))
{}

AlterOpFamilyStmt::~AlterOpFamilyStmt()
{
}

bool AlterOpFamilyStmt::operator==([[maybe_unused]] const AlterOpFamilyStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterOpFamilyStmt::operator<([[maybe_unused]] const AlterOpFamilyStmt& other) const noexcept
{
    return false;
}

AlterOpFamilyStmt& AlterOpFamilyStmt::operator=(AlterOpFamilyStmt&& other) noexcept
{
    if (this != &other)
    {
        opfamilyname = std::move(other.opfamilyname);
        amname = std::move(other.amname);
        is_drop = std::exchange(other.is_drop, false);
        items = std::move(other.items);
    }
    return *this;
}

std::string AlterOpFamilyStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterOpFamilyStmt::swap(AlterOpFamilyStmt& other) noexcept
{
    using std::swap;
    swap(opfamilyname, other.opfamilyname);
    swap(amname, other.amname);
    swap(is_drop, other.is_drop);
    swap(items, other.items);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterOpFamilyStmt& value)
{
    stream << "AlterOpFamilyStmt(";
    {
        bool first = true;
        stream << "opfamilyname=[" << value.opfamilyname.size() << "][";
        for (const auto& it : value.opfamilyname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",amname="; stream << "\"" << value.amname << "\"";
    stream << ",is_drop="; stream << (value.is_drop ? "true" : "false");
    {
        bool first = true;
        stream << ",items=[" << value.items.size() << "][";
        for (const auto& it : value.items)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

PrepareStmt::PrepareStmt()
    : name()
    , argtypes()
    , query()
{}

PrepareStmt::PrepareStmt(const std::string& arg_name, std::vector<::pg_query::Node> arg_argtypes, ::pg_query::Node&& arg_query)
    : name(arg_name)
    , argtypes(std::move(arg_argtypes))
    , query(std::move(arg_query))
{}

PrepareStmt::PrepareStmt(PrepareStmt&& other) noexcept
    : name(std::move(other.name))
    , argtypes(std::move(other.argtypes))
    , query(std::move(other.query))
{}

PrepareStmt::~PrepareStmt()
{
}

bool PrepareStmt::operator==([[maybe_unused]] const PrepareStmt& other) const noexcept
{
    return (
        true
        );
}

bool PrepareStmt::operator<([[maybe_unused]] const PrepareStmt& other) const noexcept
{
    return false;
}

PrepareStmt& PrepareStmt::operator=(PrepareStmt&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
        argtypes = std::move(other.argtypes);
        query = std::move(other.query);
    }
    return *this;
}

std::string PrepareStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void PrepareStmt::swap(PrepareStmt& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(argtypes, other.argtypes);
    swap(query, other.query);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const PrepareStmt& value)
{
    stream << "PrepareStmt(";
    stream << "name="; stream << "\"" << value.name << "\"";
    {
        bool first = true;
        stream << ",argtypes=[" << value.argtypes.size() << "][";
        for (const auto& it : value.argtypes)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",query="; stream << value.query;
    stream << ")";
    return stream;
}

ExecuteStmt::ExecuteStmt()
    : name()
    , params()
{}

ExecuteStmt::ExecuteStmt(const std::string& arg_name, std::vector<::pg_query::Node> arg_params)
    : name(arg_name)
    , params(std::move(arg_params))
{}

ExecuteStmt::ExecuteStmt(ExecuteStmt&& other) noexcept
    : name(std::move(other.name))
    , params(std::move(other.params))
{}

ExecuteStmt::~ExecuteStmt()
{
}

bool ExecuteStmt::operator==([[maybe_unused]] const ExecuteStmt& other) const noexcept
{
    return (
        true
        );
}

bool ExecuteStmt::operator<([[maybe_unused]] const ExecuteStmt& other) const noexcept
{
    return false;
}

ExecuteStmt& ExecuteStmt::operator=(ExecuteStmt&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
        params = std::move(other.params);
    }
    return *this;
}

std::string ExecuteStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ExecuteStmt::swap(ExecuteStmt& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(params, other.params);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ExecuteStmt& value)
{
    stream << "ExecuteStmt(";
    stream << "name="; stream << "\"" << value.name << "\"";
    {
        bool first = true;
        stream << ",params=[" << value.params.size() << "][";
        for (const auto& it : value.params)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

DeallocateStmt::DeallocateStmt()
    : name()
{}

DeallocateStmt::DeallocateStmt(const std::string& arg_name)
    : name(arg_name)
{}

DeallocateStmt::DeallocateStmt(DeallocateStmt&& other) noexcept
    : name(std::move(other.name))
{}

DeallocateStmt::~DeallocateStmt()
{
}

bool DeallocateStmt::operator==([[maybe_unused]] const DeallocateStmt& other) const noexcept
{
    return (
        true
        );
}

bool DeallocateStmt::operator<([[maybe_unused]] const DeallocateStmt& other) const noexcept
{
    return false;
}

DeallocateStmt& DeallocateStmt::operator=(DeallocateStmt&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
    }
    return *this;
}

std::string DeallocateStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DeallocateStmt::swap(DeallocateStmt& other) noexcept
{
    using std::swap;
    swap(name, other.name);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DeallocateStmt& value)
{
    stream << "DeallocateStmt(";
    stream << "name="; stream << "\"" << value.name << "\"";
    stream << ")";
    return stream;
}

DeclareCursorStmt::DeclareCursorStmt()
    : portalname()
    , options((int32_t)0ll)
    , query()
{}

DeclareCursorStmt::DeclareCursorStmt(const std::string& arg_portalname, int32_t arg_options, ::pg_query::Node&& arg_query)
    : portalname(arg_portalname)
    , options(arg_options)
    , query(std::move(arg_query))
{}

DeclareCursorStmt::DeclareCursorStmt(DeclareCursorStmt&& other) noexcept
    : portalname(std::move(other.portalname))
    , options(std::exchange(other.options, (int32_t)0ll))
    , query(std::move(other.query))
{}

DeclareCursorStmt::~DeclareCursorStmt()
{
}

bool DeclareCursorStmt::operator==([[maybe_unused]] const DeclareCursorStmt& other) const noexcept
{
    return (
        true
        );
}

bool DeclareCursorStmt::operator<([[maybe_unused]] const DeclareCursorStmt& other) const noexcept
{
    return false;
}

DeclareCursorStmt& DeclareCursorStmt::operator=(DeclareCursorStmt&& other) noexcept
{
    if (this != &other)
    {
        portalname = std::move(other.portalname);
        options = std::exchange(other.options, (int32_t)0ll);
        query = std::move(other.query);
    }
    return *this;
}

std::string DeclareCursorStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DeclareCursorStmt::swap(DeclareCursorStmt& other) noexcept
{
    using std::swap;
    swap(portalname, other.portalname);
    swap(options, other.options);
    swap(query, other.query);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DeclareCursorStmt& value)
{
    stream << "DeclareCursorStmt(";
    stream << "portalname="; stream << "\"" << value.portalname << "\"";
    stream << ",options="; stream << value.options;
    stream << ",query="; stream << value.query;
    stream << ")";
    return stream;
}

CreateTableSpaceStmt::CreateTableSpaceStmt()
    : tablespacename()
    , owner(nullptr)
    , location()
    , options()
{}

CreateTableSpaceStmt::CreateTableSpaceStmt(const std::string& arg_tablespacename, std::unique_ptr<::pg_query::RoleSpec> arg_owner, const std::string& arg_location, std::vector<::pg_query::Node> arg_options)
    : tablespacename(arg_tablespacename)
    , owner(arg_owner.release())
    , location(arg_location)
    , options(std::move(arg_options))
{}

CreateTableSpaceStmt::CreateTableSpaceStmt(CreateTableSpaceStmt&& other) noexcept
    : tablespacename(std::move(other.tablespacename))
    , owner(std::exchange(other.owner, nullptr))
    , location(std::move(other.location))
    , options(std::move(other.options))
{}

CreateTableSpaceStmt::~CreateTableSpaceStmt()
{
    if (owner) delete owner;
}

bool CreateTableSpaceStmt::operator==([[maybe_unused]] const CreateTableSpaceStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateTableSpaceStmt::operator<([[maybe_unused]] const CreateTableSpaceStmt& other) const noexcept
{
    return false;
}

CreateTableSpaceStmt& CreateTableSpaceStmt::operator=(CreateTableSpaceStmt&& other) noexcept
{
    if (this != &other)
    {
        tablespacename = std::move(other.tablespacename);
        owner = std::exchange(other.owner, nullptr);
        location = std::move(other.location);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreateTableSpaceStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateTableSpaceStmt::swap(CreateTableSpaceStmt& other) noexcept
{
    using std::swap;
    swap(tablespacename, other.tablespacename);
    swap(owner, other.owner);
    swap(location, other.location);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateTableSpaceStmt& value)
{
    stream << "CreateTableSpaceStmt(";
    stream << "tablespacename="; stream << "\"" << value.tablespacename << "\"";
    stream << ",owner="; stream << " ptr of other struct" << (value.owner == nullptr ? "true" : "false");
    stream << ",location="; stream << "\"" << value.location << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

DropTableSpaceStmt::DropTableSpaceStmt()
    : tablespacename()
    , missing_ok(false)
{}

DropTableSpaceStmt::DropTableSpaceStmt(const std::string& arg_tablespacename, bool arg_missing_ok)
    : tablespacename(arg_tablespacename)
    , missing_ok(arg_missing_ok)
{}

DropTableSpaceStmt::DropTableSpaceStmt(DropTableSpaceStmt&& other) noexcept
    : tablespacename(std::move(other.tablespacename))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

DropTableSpaceStmt::~DropTableSpaceStmt()
{
}

bool DropTableSpaceStmt::operator==([[maybe_unused]] const DropTableSpaceStmt& other) const noexcept
{
    return (
        true
        );
}

bool DropTableSpaceStmt::operator<([[maybe_unused]] const DropTableSpaceStmt& other) const noexcept
{
    return false;
}

DropTableSpaceStmt& DropTableSpaceStmt::operator=(DropTableSpaceStmt&& other) noexcept
{
    if (this != &other)
    {
        tablespacename = std::move(other.tablespacename);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string DropTableSpaceStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DropTableSpaceStmt::swap(DropTableSpaceStmt& other) noexcept
{
    using std::swap;
    swap(tablespacename, other.tablespacename);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DropTableSpaceStmt& value)
{
    stream << "DropTableSpaceStmt(";
    stream << "tablespacename="; stream << "\"" << value.tablespacename << "\"";
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

AlterObjectDependsStmt::AlterObjectDependsStmt()
    : object_type()
    , relation(nullptr)
    , object()
    , extname()
    , remove(false)
{}

AlterObjectDependsStmt::AlterObjectDependsStmt(::pg_query::ObjectType&& arg_object_type, std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_object, ::pg_query::Node&& arg_extname, bool arg_remove)
    : object_type(std::move(arg_object_type))
    , relation(arg_relation.release())
    , object(std::move(arg_object))
    , extname(std::move(arg_extname))
    , remove(arg_remove)
{}

AlterObjectDependsStmt::AlterObjectDependsStmt(AlterObjectDependsStmt&& other) noexcept
    : object_type(std::move(other.object_type))
    , relation(std::exchange(other.relation, nullptr))
    , object(std::move(other.object))
    , extname(std::move(other.extname))
    , remove(std::exchange(other.remove, false))
{}

AlterObjectDependsStmt::~AlterObjectDependsStmt()
{
    if (relation) delete relation;
}

bool AlterObjectDependsStmt::operator==([[maybe_unused]] const AlterObjectDependsStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterObjectDependsStmt::operator<([[maybe_unused]] const AlterObjectDependsStmt& other) const noexcept
{
    return false;
}

AlterObjectDependsStmt& AlterObjectDependsStmt::operator=(AlterObjectDependsStmt&& other) noexcept
{
    if (this != &other)
    {
        object_type = std::move(other.object_type);
        relation = std::exchange(other.relation, nullptr);
        object = std::move(other.object);
        extname = std::move(other.extname);
        remove = std::exchange(other.remove, false);
    }
    return *this;
}

std::string AlterObjectDependsStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterObjectDependsStmt::swap(AlterObjectDependsStmt& other) noexcept
{
    using std::swap;
    swap(object_type, other.object_type);
    swap(relation, other.relation);
    swap(object, other.object);
    swap(extname, other.extname);
    swap(remove, other.remove);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterObjectDependsStmt& value)
{
    stream << "AlterObjectDependsStmt(";
    stream << "object_type="; stream << value.object_type;
    stream << ",relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",object="; stream << value.object;
    stream << ",extname="; stream << value.extname;
    stream << ",remove="; stream << (value.remove ? "true" : "false");
    stream << ")";
    return stream;
}

AlterObjectSchemaStmt::AlterObjectSchemaStmt()
    : object_type()
    , relation(nullptr)
    , object()
    , newschema()
    , missing_ok(false)
{}

AlterObjectSchemaStmt::AlterObjectSchemaStmt(::pg_query::ObjectType&& arg_object_type, std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_object, const std::string& arg_newschema, bool arg_missing_ok)
    : object_type(std::move(arg_object_type))
    , relation(arg_relation.release())
    , object(std::move(arg_object))
    , newschema(arg_newschema)
    , missing_ok(arg_missing_ok)
{}

AlterObjectSchemaStmt::AlterObjectSchemaStmt(AlterObjectSchemaStmt&& other) noexcept
    : object_type(std::move(other.object_type))
    , relation(std::exchange(other.relation, nullptr))
    , object(std::move(other.object))
    , newschema(std::move(other.newschema))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

AlterObjectSchemaStmt::~AlterObjectSchemaStmt()
{
    if (relation) delete relation;
}

bool AlterObjectSchemaStmt::operator==([[maybe_unused]] const AlterObjectSchemaStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterObjectSchemaStmt::operator<([[maybe_unused]] const AlterObjectSchemaStmt& other) const noexcept
{
    return false;
}

AlterObjectSchemaStmt& AlterObjectSchemaStmt::operator=(AlterObjectSchemaStmt&& other) noexcept
{
    if (this != &other)
    {
        object_type = std::move(other.object_type);
        relation = std::exchange(other.relation, nullptr);
        object = std::move(other.object);
        newschema = std::move(other.newschema);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string AlterObjectSchemaStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterObjectSchemaStmt::swap(AlterObjectSchemaStmt& other) noexcept
{
    using std::swap;
    swap(object_type, other.object_type);
    swap(relation, other.relation);
    swap(object, other.object);
    swap(newschema, other.newschema);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterObjectSchemaStmt& value)
{
    stream << "AlterObjectSchemaStmt(";
    stream << "object_type="; stream << value.object_type;
    stream << ",relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",object="; stream << value.object;
    stream << ",newschema="; stream << "\"" << value.newschema << "\"";
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

AlterOwnerStmt::AlterOwnerStmt()
    : object_type()
    , relation(nullptr)
    , object()
    , newowner(nullptr)
{}

AlterOwnerStmt::AlterOwnerStmt(::pg_query::ObjectType&& arg_object_type, std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_object, std::unique_ptr<::pg_query::RoleSpec> arg_newowner)
    : object_type(std::move(arg_object_type))
    , relation(arg_relation.release())
    , object(std::move(arg_object))
    , newowner(arg_newowner.release())
{}

AlterOwnerStmt::AlterOwnerStmt(AlterOwnerStmt&& other) noexcept
    : object_type(std::move(other.object_type))
    , relation(std::exchange(other.relation, nullptr))
    , object(std::move(other.object))
    , newowner(std::exchange(other.newowner, nullptr))
{}

AlterOwnerStmt::~AlterOwnerStmt()
{
    if (relation) delete relation;
    if (newowner) delete newowner;
}

bool AlterOwnerStmt::operator==([[maybe_unused]] const AlterOwnerStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterOwnerStmt::operator<([[maybe_unused]] const AlterOwnerStmt& other) const noexcept
{
    return false;
}

AlterOwnerStmt& AlterOwnerStmt::operator=(AlterOwnerStmt&& other) noexcept
{
    if (this != &other)
    {
        object_type = std::move(other.object_type);
        relation = std::exchange(other.relation, nullptr);
        object = std::move(other.object);
        newowner = std::exchange(other.newowner, nullptr);
    }
    return *this;
}

std::string AlterOwnerStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterOwnerStmt::swap(AlterOwnerStmt& other) noexcept
{
    using std::swap;
    swap(object_type, other.object_type);
    swap(relation, other.relation);
    swap(object, other.object);
    swap(newowner, other.newowner);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterOwnerStmt& value)
{
    stream << "AlterOwnerStmt(";
    stream << "object_type="; stream << value.object_type;
    stream << ",relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",object="; stream << value.object;
    stream << ",newowner="; stream << " ptr of other struct" << (value.newowner == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

AlterOperatorStmt::AlterOperatorStmt()
    : opername(nullptr)
    , options()
{}

AlterOperatorStmt::AlterOperatorStmt(std::unique_ptr<::pg_query::ObjectWithArgs> arg_opername, std::vector<::pg_query::Node> arg_options)
    : opername(arg_opername.release())
    , options(std::move(arg_options))
{}

AlterOperatorStmt::AlterOperatorStmt(AlterOperatorStmt&& other) noexcept
    : opername(std::exchange(other.opername, nullptr))
    , options(std::move(other.options))
{}

AlterOperatorStmt::~AlterOperatorStmt()
{
    if (opername) delete opername;
}

bool AlterOperatorStmt::operator==([[maybe_unused]] const AlterOperatorStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterOperatorStmt::operator<([[maybe_unused]] const AlterOperatorStmt& other) const noexcept
{
    return false;
}

AlterOperatorStmt& AlterOperatorStmt::operator=(AlterOperatorStmt&& other) noexcept
{
    if (this != &other)
    {
        opername = std::exchange(other.opername, nullptr);
        options = std::move(other.options);
    }
    return *this;
}

std::string AlterOperatorStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterOperatorStmt::swap(AlterOperatorStmt& other) noexcept
{
    using std::swap;
    swap(opername, other.opername);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterOperatorStmt& value)
{
    stream << "AlterOperatorStmt(";
    stream << "opername="; stream << " ptr of other struct" << (value.opername == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterTypeStmt::AlterTypeStmt()
    : type_name()
    , options()
{}

AlterTypeStmt::AlterTypeStmt(std::vector<::pg_query::Node> arg_type_name, std::vector<::pg_query::Node> arg_options)
    : type_name(std::move(arg_type_name))
    , options(std::move(arg_options))
{}

AlterTypeStmt::AlterTypeStmt(AlterTypeStmt&& other) noexcept
    : type_name(std::move(other.type_name))
    , options(std::move(other.options))
{}

AlterTypeStmt::~AlterTypeStmt()
{
}

bool AlterTypeStmt::operator==([[maybe_unused]] const AlterTypeStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterTypeStmt::operator<([[maybe_unused]] const AlterTypeStmt& other) const noexcept
{
    return false;
}

AlterTypeStmt& AlterTypeStmt::operator=(AlterTypeStmt&& other) noexcept
{
    if (this != &other)
    {
        type_name = std::move(other.type_name);
        options = std::move(other.options);
    }
    return *this;
}

std::string AlterTypeStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterTypeStmt::swap(AlterTypeStmt& other) noexcept
{
    using std::swap;
    swap(type_name, other.type_name);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterTypeStmt& value)
{
    stream << "AlterTypeStmt(";
    {
        bool first = true;
        stream << "type_name=[" << value.type_name.size() << "][";
        for (const auto& it : value.type_name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

DropOwnedStmt::DropOwnedStmt()
    : roles()
    , behavior()
{}

DropOwnedStmt::DropOwnedStmt(std::vector<::pg_query::Node> arg_roles, ::pg_query::DropBehavior&& arg_behavior)
    : roles(std::move(arg_roles))
    , behavior(std::move(arg_behavior))
{}

DropOwnedStmt::DropOwnedStmt(DropOwnedStmt&& other) noexcept
    : roles(std::move(other.roles))
    , behavior(std::move(other.behavior))
{}

DropOwnedStmt::~DropOwnedStmt()
{
}

bool DropOwnedStmt::operator==([[maybe_unused]] const DropOwnedStmt& other) const noexcept
{
    return (
        true
        );
}

bool DropOwnedStmt::operator<([[maybe_unused]] const DropOwnedStmt& other) const noexcept
{
    return false;
}

DropOwnedStmt& DropOwnedStmt::operator=(DropOwnedStmt&& other) noexcept
{
    if (this != &other)
    {
        roles = std::move(other.roles);
        behavior = std::move(other.behavior);
    }
    return *this;
}

std::string DropOwnedStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DropOwnedStmt::swap(DropOwnedStmt& other) noexcept
{
    using std::swap;
    swap(roles, other.roles);
    swap(behavior, other.behavior);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DropOwnedStmt& value)
{
    stream << "DropOwnedStmt(";
    {
        bool first = true;
        stream << "roles=[" << value.roles.size() << "][";
        for (const auto& it : value.roles)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",behavior="; stream << value.behavior;
    stream << ")";
    return stream;
}

ReassignOwnedStmt::ReassignOwnedStmt()
    : roles()
    , newrole(nullptr)
{}

ReassignOwnedStmt::ReassignOwnedStmt(std::vector<::pg_query::Node> arg_roles, std::unique_ptr<::pg_query::RoleSpec> arg_newrole)
    : roles(std::move(arg_roles))
    , newrole(arg_newrole.release())
{}

ReassignOwnedStmt::ReassignOwnedStmt(ReassignOwnedStmt&& other) noexcept
    : roles(std::move(other.roles))
    , newrole(std::exchange(other.newrole, nullptr))
{}

ReassignOwnedStmt::~ReassignOwnedStmt()
{
    if (newrole) delete newrole;
}

bool ReassignOwnedStmt::operator==([[maybe_unused]] const ReassignOwnedStmt& other) const noexcept
{
    return (
        true
        );
}

bool ReassignOwnedStmt::operator<([[maybe_unused]] const ReassignOwnedStmt& other) const noexcept
{
    return false;
}

ReassignOwnedStmt& ReassignOwnedStmt::operator=(ReassignOwnedStmt&& other) noexcept
{
    if (this != &other)
    {
        roles = std::move(other.roles);
        newrole = std::exchange(other.newrole, nullptr);
    }
    return *this;
}

std::string ReassignOwnedStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ReassignOwnedStmt::swap(ReassignOwnedStmt& other) noexcept
{
    using std::swap;
    swap(roles, other.roles);
    swap(newrole, other.newrole);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ReassignOwnedStmt& value)
{
    stream << "ReassignOwnedStmt(";
    {
        bool first = true;
        stream << "roles=[" << value.roles.size() << "][";
        for (const auto& it : value.roles)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",newrole="; stream << " ptr of other struct" << (value.newrole == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

CompositeTypeStmt::CompositeTypeStmt()
    : typevar(nullptr)
    , coldeflist()
{}

CompositeTypeStmt::CompositeTypeStmt(std::unique_ptr<::pg_query::RangeVar> arg_typevar, std::vector<::pg_query::Node> arg_coldeflist)
    : typevar(arg_typevar.release())
    , coldeflist(std::move(arg_coldeflist))
{}

CompositeTypeStmt::CompositeTypeStmt(CompositeTypeStmt&& other) noexcept
    : typevar(std::exchange(other.typevar, nullptr))
    , coldeflist(std::move(other.coldeflist))
{}

CompositeTypeStmt::~CompositeTypeStmt()
{
    if (typevar) delete typevar;
}

bool CompositeTypeStmt::operator==([[maybe_unused]] const CompositeTypeStmt& other) const noexcept
{
    return (
        true
        );
}

bool CompositeTypeStmt::operator<([[maybe_unused]] const CompositeTypeStmt& other) const noexcept
{
    return false;
}

CompositeTypeStmt& CompositeTypeStmt::operator=(CompositeTypeStmt&& other) noexcept
{
    if (this != &other)
    {
        typevar = std::exchange(other.typevar, nullptr);
        coldeflist = std::move(other.coldeflist);
    }
    return *this;
}

std::string CompositeTypeStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CompositeTypeStmt::swap(CompositeTypeStmt& other) noexcept
{
    using std::swap;
    swap(typevar, other.typevar);
    swap(coldeflist, other.coldeflist);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CompositeTypeStmt& value)
{
    stream << "CompositeTypeStmt(";
    stream << "typevar="; stream << " ptr of other struct" << (value.typevar == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",coldeflist=[" << value.coldeflist.size() << "][";
        for (const auto& it : value.coldeflist)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

CreateEnumStmt::CreateEnumStmt()
    : type_name()
    , vals()
{}

CreateEnumStmt::CreateEnumStmt(std::vector<::pg_query::Node> arg_type_name, std::vector<::pg_query::Node> arg_vals)
    : type_name(std::move(arg_type_name))
    , vals(std::move(arg_vals))
{}

CreateEnumStmt::CreateEnumStmt(CreateEnumStmt&& other) noexcept
    : type_name(std::move(other.type_name))
    , vals(std::move(other.vals))
{}

CreateEnumStmt::~CreateEnumStmt()
{
}

bool CreateEnumStmt::operator==([[maybe_unused]] const CreateEnumStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateEnumStmt::operator<([[maybe_unused]] const CreateEnumStmt& other) const noexcept
{
    return false;
}

CreateEnumStmt& CreateEnumStmt::operator=(CreateEnumStmt&& other) noexcept
{
    if (this != &other)
    {
        type_name = std::move(other.type_name);
        vals = std::move(other.vals);
    }
    return *this;
}

std::string CreateEnumStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateEnumStmt::swap(CreateEnumStmt& other) noexcept
{
    using std::swap;
    swap(type_name, other.type_name);
    swap(vals, other.vals);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateEnumStmt& value)
{
    stream << "CreateEnumStmt(";
    {
        bool first = true;
        stream << "type_name=[" << value.type_name.size() << "][";
        for (const auto& it : value.type_name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",vals=[" << value.vals.size() << "][";
        for (const auto& it : value.vals)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

CreateRangeStmt::CreateRangeStmt()
    : type_name()
    , params()
{}

CreateRangeStmt::CreateRangeStmt(std::vector<::pg_query::Node> arg_type_name, std::vector<::pg_query::Node> arg_params)
    : type_name(std::move(arg_type_name))
    , params(std::move(arg_params))
{}

CreateRangeStmt::CreateRangeStmt(CreateRangeStmt&& other) noexcept
    : type_name(std::move(other.type_name))
    , params(std::move(other.params))
{}

CreateRangeStmt::~CreateRangeStmt()
{
}

bool CreateRangeStmt::operator==([[maybe_unused]] const CreateRangeStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateRangeStmt::operator<([[maybe_unused]] const CreateRangeStmt& other) const noexcept
{
    return false;
}

CreateRangeStmt& CreateRangeStmt::operator=(CreateRangeStmt&& other) noexcept
{
    if (this != &other)
    {
        type_name = std::move(other.type_name);
        params = std::move(other.params);
    }
    return *this;
}

std::string CreateRangeStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateRangeStmt::swap(CreateRangeStmt& other) noexcept
{
    using std::swap;
    swap(type_name, other.type_name);
    swap(params, other.params);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateRangeStmt& value)
{
    stream << "CreateRangeStmt(";
    {
        bool first = true;
        stream << "type_name=[" << value.type_name.size() << "][";
        for (const auto& it : value.type_name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",params=[" << value.params.size() << "][";
        for (const auto& it : value.params)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterEnumStmt::AlterEnumStmt()
    : type_name()
    , old_val()
    , new_val()
    , new_val_neighbor()
    , new_val_is_after(false)
    , skip_if_new_val_exists(false)
{}

AlterEnumStmt::AlterEnumStmt(std::vector<::pg_query::Node> arg_type_name, const std::string& arg_old_val, const std::string& arg_new_val, const std::string& arg_new_val_neighbor, bool arg_new_val_is_after, bool arg_skip_if_new_val_exists)
    : type_name(std::move(arg_type_name))
    , old_val(arg_old_val)
    , new_val(arg_new_val)
    , new_val_neighbor(arg_new_val_neighbor)
    , new_val_is_after(arg_new_val_is_after)
    , skip_if_new_val_exists(arg_skip_if_new_val_exists)
{}

AlterEnumStmt::AlterEnumStmt(AlterEnumStmt&& other) noexcept
    : type_name(std::move(other.type_name))
    , old_val(std::move(other.old_val))
    , new_val(std::move(other.new_val))
    , new_val_neighbor(std::move(other.new_val_neighbor))
    , new_val_is_after(std::exchange(other.new_val_is_after, false))
    , skip_if_new_val_exists(std::exchange(other.skip_if_new_val_exists, false))
{}

AlterEnumStmt::~AlterEnumStmt()
{
}

bool AlterEnumStmt::operator==([[maybe_unused]] const AlterEnumStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterEnumStmt::operator<([[maybe_unused]] const AlterEnumStmt& other) const noexcept
{
    return false;
}

AlterEnumStmt& AlterEnumStmt::operator=(AlterEnumStmt&& other) noexcept
{
    if (this != &other)
    {
        type_name = std::move(other.type_name);
        old_val = std::move(other.old_val);
        new_val = std::move(other.new_val);
        new_val_neighbor = std::move(other.new_val_neighbor);
        new_val_is_after = std::exchange(other.new_val_is_after, false);
        skip_if_new_val_exists = std::exchange(other.skip_if_new_val_exists, false);
    }
    return *this;
}

std::string AlterEnumStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterEnumStmt::swap(AlterEnumStmt& other) noexcept
{
    using std::swap;
    swap(type_name, other.type_name);
    swap(old_val, other.old_val);
    swap(new_val, other.new_val);
    swap(new_val_neighbor, other.new_val_neighbor);
    swap(new_val_is_after, other.new_val_is_after);
    swap(skip_if_new_val_exists, other.skip_if_new_val_exists);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterEnumStmt& value)
{
    stream << "AlterEnumStmt(";
    {
        bool first = true;
        stream << "type_name=[" << value.type_name.size() << "][";
        for (const auto& it : value.type_name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",old_val="; stream << "\"" << value.old_val << "\"";
    stream << ",new_val="; stream << "\"" << value.new_val << "\"";
    stream << ",new_val_neighbor="; stream << "\"" << value.new_val_neighbor << "\"";
    stream << ",new_val_is_after="; stream << (value.new_val_is_after ? "true" : "false");
    stream << ",skip_if_new_val_exists="; stream << (value.skip_if_new_val_exists ? "true" : "false");
    stream << ")";
    return stream;
}

AlterTSDictionaryStmt::AlterTSDictionaryStmt()
    : dictname()
    , options()
{}

AlterTSDictionaryStmt::AlterTSDictionaryStmt(std::vector<::pg_query::Node> arg_dictname, std::vector<::pg_query::Node> arg_options)
    : dictname(std::move(arg_dictname))
    , options(std::move(arg_options))
{}

AlterTSDictionaryStmt::AlterTSDictionaryStmt(AlterTSDictionaryStmt&& other) noexcept
    : dictname(std::move(other.dictname))
    , options(std::move(other.options))
{}

AlterTSDictionaryStmt::~AlterTSDictionaryStmt()
{
}

bool AlterTSDictionaryStmt::operator==([[maybe_unused]] const AlterTSDictionaryStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterTSDictionaryStmt::operator<([[maybe_unused]] const AlterTSDictionaryStmt& other) const noexcept
{
    return false;
}

AlterTSDictionaryStmt& AlterTSDictionaryStmt::operator=(AlterTSDictionaryStmt&& other) noexcept
{
    if (this != &other)
    {
        dictname = std::move(other.dictname);
        options = std::move(other.options);
    }
    return *this;
}

std::string AlterTSDictionaryStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterTSDictionaryStmt::swap(AlterTSDictionaryStmt& other) noexcept
{
    using std::swap;
    swap(dictname, other.dictname);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterTSDictionaryStmt& value)
{
    stream << "AlterTSDictionaryStmt(";
    {
        bool first = true;
        stream << "dictname=[" << value.dictname.size() << "][";
        for (const auto& it : value.dictname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterTSConfigurationStmt::AlterTSConfigurationStmt()
    : kind()
    , cfgname()
    , tokentype()
    , dicts()
    , override(false)
    , replace(false)
    , missing_ok(false)
{}

AlterTSConfigurationStmt::AlterTSConfigurationStmt(::pg_query::AlterTSConfigType&& arg_kind, std::vector<::pg_query::Node> arg_cfgname, std::vector<::pg_query::Node> arg_tokentype, std::vector<::pg_query::Node> arg_dicts, bool arg_override, bool arg_replace, bool arg_missing_ok)
    : kind(std::move(arg_kind))
    , cfgname(std::move(arg_cfgname))
    , tokentype(std::move(arg_tokentype))
    , dicts(std::move(arg_dicts))
    , override(arg_override)
    , replace(arg_replace)
    , missing_ok(arg_missing_ok)
{}

AlterTSConfigurationStmt::AlterTSConfigurationStmt(AlterTSConfigurationStmt&& other) noexcept
    : kind(std::move(other.kind))
    , cfgname(std::move(other.cfgname))
    , tokentype(std::move(other.tokentype))
    , dicts(std::move(other.dicts))
    , override(std::exchange(other.override, false))
    , replace(std::exchange(other.replace, false))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

AlterTSConfigurationStmt::~AlterTSConfigurationStmt()
{
}

bool AlterTSConfigurationStmt::operator==([[maybe_unused]] const AlterTSConfigurationStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterTSConfigurationStmt::operator<([[maybe_unused]] const AlterTSConfigurationStmt& other) const noexcept
{
    return false;
}

AlterTSConfigurationStmt& AlterTSConfigurationStmt::operator=(AlterTSConfigurationStmt&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        cfgname = std::move(other.cfgname);
        tokentype = std::move(other.tokentype);
        dicts = std::move(other.dicts);
        override = std::exchange(other.override, false);
        replace = std::exchange(other.replace, false);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string AlterTSConfigurationStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterTSConfigurationStmt::swap(AlterTSConfigurationStmt& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(cfgname, other.cfgname);
    swap(tokentype, other.tokentype);
    swap(dicts, other.dicts);
    swap(override, other.override);
    swap(replace, other.replace);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterTSConfigurationStmt& value)
{
    stream << "AlterTSConfigurationStmt(";
    stream << "kind="; stream << value.kind;
    {
        bool first = true;
        stream << ",cfgname=[" << value.cfgname.size() << "][";
        for (const auto& it : value.cfgname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",tokentype=[" << value.tokentype.size() << "][";
        for (const auto& it : value.tokentype)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",dicts=[" << value.dicts.size() << "][";
        for (const auto& it : value.dicts)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",override="; stream << (value.override ? "true" : "false");
    stream << ",replace="; stream << (value.replace ? "true" : "false");
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

CreateFdwStmt::CreateFdwStmt()
    : fdwname()
    , func_options()
    , options()
{}

CreateFdwStmt::CreateFdwStmt(const std::string& arg_fdwname, std::vector<::pg_query::Node> arg_func_options, std::vector<::pg_query::Node> arg_options)
    : fdwname(arg_fdwname)
    , func_options(std::move(arg_func_options))
    , options(std::move(arg_options))
{}

CreateFdwStmt::CreateFdwStmt(CreateFdwStmt&& other) noexcept
    : fdwname(std::move(other.fdwname))
    , func_options(std::move(other.func_options))
    , options(std::move(other.options))
{}

CreateFdwStmt::~CreateFdwStmt()
{
}

bool CreateFdwStmt::operator==([[maybe_unused]] const CreateFdwStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateFdwStmt::operator<([[maybe_unused]] const CreateFdwStmt& other) const noexcept
{
    return false;
}

CreateFdwStmt& CreateFdwStmt::operator=(CreateFdwStmt&& other) noexcept
{
    if (this != &other)
    {
        fdwname = std::move(other.fdwname);
        func_options = std::move(other.func_options);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreateFdwStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateFdwStmt::swap(CreateFdwStmt& other) noexcept
{
    using std::swap;
    swap(fdwname, other.fdwname);
    swap(func_options, other.func_options);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateFdwStmt& value)
{
    stream << "CreateFdwStmt(";
    stream << "fdwname="; stream << "\"" << value.fdwname << "\"";
    {
        bool first = true;
        stream << ",func_options=[" << value.func_options.size() << "][";
        for (const auto& it : value.func_options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterFdwStmt::AlterFdwStmt()
    : fdwname()
    , func_options()
    , options()
{}

AlterFdwStmt::AlterFdwStmt(const std::string& arg_fdwname, std::vector<::pg_query::Node> arg_func_options, std::vector<::pg_query::Node> arg_options)
    : fdwname(arg_fdwname)
    , func_options(std::move(arg_func_options))
    , options(std::move(arg_options))
{}

AlterFdwStmt::AlterFdwStmt(AlterFdwStmt&& other) noexcept
    : fdwname(std::move(other.fdwname))
    , func_options(std::move(other.func_options))
    , options(std::move(other.options))
{}

AlterFdwStmt::~AlterFdwStmt()
{
}

bool AlterFdwStmt::operator==([[maybe_unused]] const AlterFdwStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterFdwStmt::operator<([[maybe_unused]] const AlterFdwStmt& other) const noexcept
{
    return false;
}

AlterFdwStmt& AlterFdwStmt::operator=(AlterFdwStmt&& other) noexcept
{
    if (this != &other)
    {
        fdwname = std::move(other.fdwname);
        func_options = std::move(other.func_options);
        options = std::move(other.options);
    }
    return *this;
}

std::string AlterFdwStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterFdwStmt::swap(AlterFdwStmt& other) noexcept
{
    using std::swap;
    swap(fdwname, other.fdwname);
    swap(func_options, other.func_options);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterFdwStmt& value)
{
    stream << "AlterFdwStmt(";
    stream << "fdwname="; stream << "\"" << value.fdwname << "\"";
    {
        bool first = true;
        stream << ",func_options=[" << value.func_options.size() << "][";
        for (const auto& it : value.func_options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

CreateForeignServerStmt::CreateForeignServerStmt()
    : servername()
    , servertype()
    , version()
    , fdwname()
    , if_not_exists(false)
    , options()
{}

CreateForeignServerStmt::CreateForeignServerStmt(const std::string& arg_servername, const std::string& arg_servertype, const std::string& arg_version, const std::string& arg_fdwname, bool arg_if_not_exists, std::vector<::pg_query::Node> arg_options)
    : servername(arg_servername)
    , servertype(arg_servertype)
    , version(arg_version)
    , fdwname(arg_fdwname)
    , if_not_exists(arg_if_not_exists)
    , options(std::move(arg_options))
{}

CreateForeignServerStmt::CreateForeignServerStmt(CreateForeignServerStmt&& other) noexcept
    : servername(std::move(other.servername))
    , servertype(std::move(other.servertype))
    , version(std::move(other.version))
    , fdwname(std::move(other.fdwname))
    , if_not_exists(std::exchange(other.if_not_exists, false))
    , options(std::move(other.options))
{}

CreateForeignServerStmt::~CreateForeignServerStmt()
{
}

bool CreateForeignServerStmt::operator==([[maybe_unused]] const CreateForeignServerStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateForeignServerStmt::operator<([[maybe_unused]] const CreateForeignServerStmt& other) const noexcept
{
    return false;
}

CreateForeignServerStmt& CreateForeignServerStmt::operator=(CreateForeignServerStmt&& other) noexcept
{
    if (this != &other)
    {
        servername = std::move(other.servername);
        servertype = std::move(other.servertype);
        version = std::move(other.version);
        fdwname = std::move(other.fdwname);
        if_not_exists = std::exchange(other.if_not_exists, false);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreateForeignServerStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateForeignServerStmt::swap(CreateForeignServerStmt& other) noexcept
{
    using std::swap;
    swap(servername, other.servername);
    swap(servertype, other.servertype);
    swap(version, other.version);
    swap(fdwname, other.fdwname);
    swap(if_not_exists, other.if_not_exists);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateForeignServerStmt& value)
{
    stream << "CreateForeignServerStmt(";
    stream << "servername="; stream << "\"" << value.servername << "\"";
    stream << ",servertype="; stream << "\"" << value.servertype << "\"";
    stream << ",version="; stream << "\"" << value.version << "\"";
    stream << ",fdwname="; stream << "\"" << value.fdwname << "\"";
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterForeignServerStmt::AlterForeignServerStmt()
    : servername()
    , version()
    , options()
    , has_version(false)
{}

AlterForeignServerStmt::AlterForeignServerStmt(const std::string& arg_servername, const std::string& arg_version, std::vector<::pg_query::Node> arg_options, bool arg_has_version)
    : servername(arg_servername)
    , version(arg_version)
    , options(std::move(arg_options))
    , has_version(arg_has_version)
{}

AlterForeignServerStmt::AlterForeignServerStmt(AlterForeignServerStmt&& other) noexcept
    : servername(std::move(other.servername))
    , version(std::move(other.version))
    , options(std::move(other.options))
    , has_version(std::exchange(other.has_version, false))
{}

AlterForeignServerStmt::~AlterForeignServerStmt()
{
}

bool AlterForeignServerStmt::operator==([[maybe_unused]] const AlterForeignServerStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterForeignServerStmt::operator<([[maybe_unused]] const AlterForeignServerStmt& other) const noexcept
{
    return false;
}

AlterForeignServerStmt& AlterForeignServerStmt::operator=(AlterForeignServerStmt&& other) noexcept
{
    if (this != &other)
    {
        servername = std::move(other.servername);
        version = std::move(other.version);
        options = std::move(other.options);
        has_version = std::exchange(other.has_version, false);
    }
    return *this;
}

std::string AlterForeignServerStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterForeignServerStmt::swap(AlterForeignServerStmt& other) noexcept
{
    using std::swap;
    swap(servername, other.servername);
    swap(version, other.version);
    swap(options, other.options);
    swap(has_version, other.has_version);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterForeignServerStmt& value)
{
    stream << "AlterForeignServerStmt(";
    stream << "servername="; stream << "\"" << value.servername << "\"";
    stream << ",version="; stream << "\"" << value.version << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",has_version="; stream << (value.has_version ? "true" : "false");
    stream << ")";
    return stream;
}

CreateUserMappingStmt::CreateUserMappingStmt()
    : user(nullptr)
    , servername()
    , if_not_exists(false)
    , options()
{}

CreateUserMappingStmt::CreateUserMappingStmt(std::unique_ptr<::pg_query::RoleSpec> arg_user, const std::string& arg_servername, bool arg_if_not_exists, std::vector<::pg_query::Node> arg_options)
    : user(arg_user.release())
    , servername(arg_servername)
    , if_not_exists(arg_if_not_exists)
    , options(std::move(arg_options))
{}

CreateUserMappingStmt::CreateUserMappingStmt(CreateUserMappingStmt&& other) noexcept
    : user(std::exchange(other.user, nullptr))
    , servername(std::move(other.servername))
    , if_not_exists(std::exchange(other.if_not_exists, false))
    , options(std::move(other.options))
{}

CreateUserMappingStmt::~CreateUserMappingStmt()
{
    if (user) delete user;
}

bool CreateUserMappingStmt::operator==([[maybe_unused]] const CreateUserMappingStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateUserMappingStmt::operator<([[maybe_unused]] const CreateUserMappingStmt& other) const noexcept
{
    return false;
}

CreateUserMappingStmt& CreateUserMappingStmt::operator=(CreateUserMappingStmt&& other) noexcept
{
    if (this != &other)
    {
        user = std::exchange(other.user, nullptr);
        servername = std::move(other.servername);
        if_not_exists = std::exchange(other.if_not_exists, false);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreateUserMappingStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateUserMappingStmt::swap(CreateUserMappingStmt& other) noexcept
{
    using std::swap;
    swap(user, other.user);
    swap(servername, other.servername);
    swap(if_not_exists, other.if_not_exists);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateUserMappingStmt& value)
{
    stream << "CreateUserMappingStmt(";
    stream << "user="; stream << " ptr of other struct" << (value.user == nullptr ? "true" : "false");
    stream << ",servername="; stream << "\"" << value.servername << "\"";
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterUserMappingStmt::AlterUserMappingStmt()
    : user(nullptr)
    , servername()
    , options()
{}

AlterUserMappingStmt::AlterUserMappingStmt(std::unique_ptr<::pg_query::RoleSpec> arg_user, const std::string& arg_servername, std::vector<::pg_query::Node> arg_options)
    : user(arg_user.release())
    , servername(arg_servername)
    , options(std::move(arg_options))
{}

AlterUserMappingStmt::AlterUserMappingStmt(AlterUserMappingStmt&& other) noexcept
    : user(std::exchange(other.user, nullptr))
    , servername(std::move(other.servername))
    , options(std::move(other.options))
{}

AlterUserMappingStmt::~AlterUserMappingStmt()
{
    if (user) delete user;
}

bool AlterUserMappingStmt::operator==([[maybe_unused]] const AlterUserMappingStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterUserMappingStmt::operator<([[maybe_unused]] const AlterUserMappingStmt& other) const noexcept
{
    return false;
}

AlterUserMappingStmt& AlterUserMappingStmt::operator=(AlterUserMappingStmt&& other) noexcept
{
    if (this != &other)
    {
        user = std::exchange(other.user, nullptr);
        servername = std::move(other.servername);
        options = std::move(other.options);
    }
    return *this;
}

std::string AlterUserMappingStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterUserMappingStmt::swap(AlterUserMappingStmt& other) noexcept
{
    using std::swap;
    swap(user, other.user);
    swap(servername, other.servername);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterUserMappingStmt& value)
{
    stream << "AlterUserMappingStmt(";
    stream << "user="; stream << " ptr of other struct" << (value.user == nullptr ? "true" : "false");
    stream << ",servername="; stream << "\"" << value.servername << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

DropUserMappingStmt::DropUserMappingStmt()
    : user(nullptr)
    , servername()
    , missing_ok(false)
{}

DropUserMappingStmt::DropUserMappingStmt(std::unique_ptr<::pg_query::RoleSpec> arg_user, const std::string& arg_servername, bool arg_missing_ok)
    : user(arg_user.release())
    , servername(arg_servername)
    , missing_ok(arg_missing_ok)
{}

DropUserMappingStmt::DropUserMappingStmt(DropUserMappingStmt&& other) noexcept
    : user(std::exchange(other.user, nullptr))
    , servername(std::move(other.servername))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

DropUserMappingStmt::~DropUserMappingStmt()
{
    if (user) delete user;
}

bool DropUserMappingStmt::operator==([[maybe_unused]] const DropUserMappingStmt& other) const noexcept
{
    return (
        true
        );
}

bool DropUserMappingStmt::operator<([[maybe_unused]] const DropUserMappingStmt& other) const noexcept
{
    return false;
}

DropUserMappingStmt& DropUserMappingStmt::operator=(DropUserMappingStmt&& other) noexcept
{
    if (this != &other)
    {
        user = std::exchange(other.user, nullptr);
        servername = std::move(other.servername);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string DropUserMappingStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DropUserMappingStmt::swap(DropUserMappingStmt& other) noexcept
{
    using std::swap;
    swap(user, other.user);
    swap(servername, other.servername);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DropUserMappingStmt& value)
{
    stream << "DropUserMappingStmt(";
    stream << "user="; stream << " ptr of other struct" << (value.user == nullptr ? "true" : "false");
    stream << ",servername="; stream << "\"" << value.servername << "\"";
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

AlterTableSpaceOptionsStmt::AlterTableSpaceOptionsStmt()
    : tablespacename()
    , options()
    , is_reset(false)
{}

AlterTableSpaceOptionsStmt::AlterTableSpaceOptionsStmt(const std::string& arg_tablespacename, std::vector<::pg_query::Node> arg_options, bool arg_is_reset)
    : tablespacename(arg_tablespacename)
    , options(std::move(arg_options))
    , is_reset(arg_is_reset)
{}

AlterTableSpaceOptionsStmt::AlterTableSpaceOptionsStmt(AlterTableSpaceOptionsStmt&& other) noexcept
    : tablespacename(std::move(other.tablespacename))
    , options(std::move(other.options))
    , is_reset(std::exchange(other.is_reset, false))
{}

AlterTableSpaceOptionsStmt::~AlterTableSpaceOptionsStmt()
{
}

bool AlterTableSpaceOptionsStmt::operator==([[maybe_unused]] const AlterTableSpaceOptionsStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterTableSpaceOptionsStmt::operator<([[maybe_unused]] const AlterTableSpaceOptionsStmt& other) const noexcept
{
    return false;
}

AlterTableSpaceOptionsStmt& AlterTableSpaceOptionsStmt::operator=(AlterTableSpaceOptionsStmt&& other) noexcept
{
    if (this != &other)
    {
        tablespacename = std::move(other.tablespacename);
        options = std::move(other.options);
        is_reset = std::exchange(other.is_reset, false);
    }
    return *this;
}

std::string AlterTableSpaceOptionsStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterTableSpaceOptionsStmt::swap(AlterTableSpaceOptionsStmt& other) noexcept
{
    using std::swap;
    swap(tablespacename, other.tablespacename);
    swap(options, other.options);
    swap(is_reset, other.is_reset);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterTableSpaceOptionsStmt& value)
{
    stream << "AlterTableSpaceOptionsStmt(";
    stream << "tablespacename="; stream << "\"" << value.tablespacename << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",is_reset="; stream << (value.is_reset ? "true" : "false");
    stream << ")";
    return stream;
}

AlterTableMoveAllStmt::AlterTableMoveAllStmt()
    : orig_tablespacename()
    , objtype()
    , roles()
    , new_tablespacename()
    , nowait(false)
{}

AlterTableMoveAllStmt::AlterTableMoveAllStmt(const std::string& arg_orig_tablespacename, ::pg_query::ObjectType&& arg_objtype, std::vector<::pg_query::Node> arg_roles, const std::string& arg_new_tablespacename, bool arg_nowait)
    : orig_tablespacename(arg_orig_tablespacename)
    , objtype(std::move(arg_objtype))
    , roles(std::move(arg_roles))
    , new_tablespacename(arg_new_tablespacename)
    , nowait(arg_nowait)
{}

AlterTableMoveAllStmt::AlterTableMoveAllStmt(AlterTableMoveAllStmt&& other) noexcept
    : orig_tablespacename(std::move(other.orig_tablespacename))
    , objtype(std::move(other.objtype))
    , roles(std::move(other.roles))
    , new_tablespacename(std::move(other.new_tablespacename))
    , nowait(std::exchange(other.nowait, false))
{}

AlterTableMoveAllStmt::~AlterTableMoveAllStmt()
{
}

bool AlterTableMoveAllStmt::operator==([[maybe_unused]] const AlterTableMoveAllStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterTableMoveAllStmt::operator<([[maybe_unused]] const AlterTableMoveAllStmt& other) const noexcept
{
    return false;
}

AlterTableMoveAllStmt& AlterTableMoveAllStmt::operator=(AlterTableMoveAllStmt&& other) noexcept
{
    if (this != &other)
    {
        orig_tablespacename = std::move(other.orig_tablespacename);
        objtype = std::move(other.objtype);
        roles = std::move(other.roles);
        new_tablespacename = std::move(other.new_tablespacename);
        nowait = std::exchange(other.nowait, false);
    }
    return *this;
}

std::string AlterTableMoveAllStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterTableMoveAllStmt::swap(AlterTableMoveAllStmt& other) noexcept
{
    using std::swap;
    swap(orig_tablespacename, other.orig_tablespacename);
    swap(objtype, other.objtype);
    swap(roles, other.roles);
    swap(new_tablespacename, other.new_tablespacename);
    swap(nowait, other.nowait);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterTableMoveAllStmt& value)
{
    stream << "AlterTableMoveAllStmt(";
    stream << "orig_tablespacename="; stream << "\"" << value.orig_tablespacename << "\"";
    stream << ",objtype="; stream << value.objtype;
    {
        bool first = true;
        stream << ",roles=[" << value.roles.size() << "][";
        for (const auto& it : value.roles)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",new_tablespacename="; stream << "\"" << value.new_tablespacename << "\"";
    stream << ",nowait="; stream << (value.nowait ? "true" : "false");
    stream << ")";
    return stream;
}

SecLabelStmt::SecLabelStmt()
    : objtype()
    , object()
    , provider()
    , label()
{}

SecLabelStmt::SecLabelStmt(::pg_query::ObjectType&& arg_objtype, ::pg_query::Node&& arg_object, const std::string& arg_provider, const std::string& arg_label)
    : objtype(std::move(arg_objtype))
    , object(std::move(arg_object))
    , provider(arg_provider)
    , label(arg_label)
{}

SecLabelStmt::SecLabelStmt(SecLabelStmt&& other) noexcept
    : objtype(std::move(other.objtype))
    , object(std::move(other.object))
    , provider(std::move(other.provider))
    , label(std::move(other.label))
{}

SecLabelStmt::~SecLabelStmt()
{
}

bool SecLabelStmt::operator==([[maybe_unused]] const SecLabelStmt& other) const noexcept
{
    return (
        true
        );
}

bool SecLabelStmt::operator<([[maybe_unused]] const SecLabelStmt& other) const noexcept
{
    return false;
}

SecLabelStmt& SecLabelStmt::operator=(SecLabelStmt&& other) noexcept
{
    if (this != &other)
    {
        objtype = std::move(other.objtype);
        object = std::move(other.object);
        provider = std::move(other.provider);
        label = std::move(other.label);
    }
    return *this;
}

std::string SecLabelStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SecLabelStmt::swap(SecLabelStmt& other) noexcept
{
    using std::swap;
    swap(objtype, other.objtype);
    swap(object, other.object);
    swap(provider, other.provider);
    swap(label, other.label);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SecLabelStmt& value)
{
    stream << "SecLabelStmt(";
    stream << "objtype="; stream << value.objtype;
    stream << ",object="; stream << value.object;
    stream << ",provider="; stream << "\"" << value.provider << "\"";
    stream << ",label="; stream << "\"" << value.label << "\"";
    stream << ")";
    return stream;
}

CreateForeignTableStmt::CreateForeignTableStmt()
    : base_stmt()
    , servername()
    , options()
{}

CreateForeignTableStmt::CreateForeignTableStmt(::pg_query::CreateStmt&& arg_base_stmt, const std::string& arg_servername, std::vector<::pg_query::Node> arg_options)
    : base_stmt(std::move(arg_base_stmt))
    , servername(arg_servername)
    , options(std::move(arg_options))
{}

CreateForeignTableStmt::CreateForeignTableStmt(CreateForeignTableStmt&& other) noexcept
    : base_stmt(std::move(other.base_stmt))
    , servername(std::move(other.servername))
    , options(std::move(other.options))
{}

CreateForeignTableStmt::~CreateForeignTableStmt()
{
}

bool CreateForeignTableStmt::operator==([[maybe_unused]] const CreateForeignTableStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateForeignTableStmt::operator<([[maybe_unused]] const CreateForeignTableStmt& other) const noexcept
{
    return false;
}

CreateForeignTableStmt& CreateForeignTableStmt::operator=(CreateForeignTableStmt&& other) noexcept
{
    if (this != &other)
    {
        base_stmt = std::move(other.base_stmt);
        servername = std::move(other.servername);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreateForeignTableStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateForeignTableStmt::swap(CreateForeignTableStmt& other) noexcept
{
    using std::swap;
    swap(base_stmt, other.base_stmt);
    swap(servername, other.servername);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateForeignTableStmt& value)
{
    stream << "CreateForeignTableStmt(";
    stream << "base_stmt="; stream << value.base_stmt;
    stream << ",servername="; stream << "\"" << value.servername << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

ImportForeignSchemaStmt::ImportForeignSchemaStmt()
    : server_name()
    , remote_schema()
    , local_schema()
    , list_type()
    , table_list()
    , options()
{}

ImportForeignSchemaStmt::ImportForeignSchemaStmt(const std::string& arg_server_name, const std::string& arg_remote_schema, const std::string& arg_local_schema, ::pg_query::ImportForeignSchemaType&& arg_list_type, std::vector<::pg_query::Node> arg_table_list, std::vector<::pg_query::Node> arg_options)
    : server_name(arg_server_name)
    , remote_schema(arg_remote_schema)
    , local_schema(arg_local_schema)
    , list_type(std::move(arg_list_type))
    , table_list(std::move(arg_table_list))
    , options(std::move(arg_options))
{}

ImportForeignSchemaStmt::ImportForeignSchemaStmt(ImportForeignSchemaStmt&& other) noexcept
    : server_name(std::move(other.server_name))
    , remote_schema(std::move(other.remote_schema))
    , local_schema(std::move(other.local_schema))
    , list_type(std::move(other.list_type))
    , table_list(std::move(other.table_list))
    , options(std::move(other.options))
{}

ImportForeignSchemaStmt::~ImportForeignSchemaStmt()
{
}

bool ImportForeignSchemaStmt::operator==([[maybe_unused]] const ImportForeignSchemaStmt& other) const noexcept
{
    return (
        true
        );
}

bool ImportForeignSchemaStmt::operator<([[maybe_unused]] const ImportForeignSchemaStmt& other) const noexcept
{
    return false;
}

ImportForeignSchemaStmt& ImportForeignSchemaStmt::operator=(ImportForeignSchemaStmt&& other) noexcept
{
    if (this != &other)
    {
        server_name = std::move(other.server_name);
        remote_schema = std::move(other.remote_schema);
        local_schema = std::move(other.local_schema);
        list_type = std::move(other.list_type);
        table_list = std::move(other.table_list);
        options = std::move(other.options);
    }
    return *this;
}

std::string ImportForeignSchemaStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ImportForeignSchemaStmt::swap(ImportForeignSchemaStmt& other) noexcept
{
    using std::swap;
    swap(server_name, other.server_name);
    swap(remote_schema, other.remote_schema);
    swap(local_schema, other.local_schema);
    swap(list_type, other.list_type);
    swap(table_list, other.table_list);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ImportForeignSchemaStmt& value)
{
    stream << "ImportForeignSchemaStmt(";
    stream << "server_name="; stream << "\"" << value.server_name << "\"";
    stream << ",remote_schema="; stream << "\"" << value.remote_schema << "\"";
    stream << ",local_schema="; stream << "\"" << value.local_schema << "\"";
    stream << ",list_type="; stream << value.list_type;
    {
        bool first = true;
        stream << ",table_list=[" << value.table_list.size() << "][";
        for (const auto& it : value.table_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

CreateExtensionStmt::CreateExtensionStmt()
    : extname()
    , if_not_exists(false)
    , options()
{}

CreateExtensionStmt::CreateExtensionStmt(const std::string& arg_extname, bool arg_if_not_exists, std::vector<::pg_query::Node> arg_options)
    : extname(arg_extname)
    , if_not_exists(arg_if_not_exists)
    , options(std::move(arg_options))
{}

CreateExtensionStmt::CreateExtensionStmt(CreateExtensionStmt&& other) noexcept
    : extname(std::move(other.extname))
    , if_not_exists(std::exchange(other.if_not_exists, false))
    , options(std::move(other.options))
{}

CreateExtensionStmt::~CreateExtensionStmt()
{
}

bool CreateExtensionStmt::operator==([[maybe_unused]] const CreateExtensionStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateExtensionStmt::operator<([[maybe_unused]] const CreateExtensionStmt& other) const noexcept
{
    return false;
}

CreateExtensionStmt& CreateExtensionStmt::operator=(CreateExtensionStmt&& other) noexcept
{
    if (this != &other)
    {
        extname = std::move(other.extname);
        if_not_exists = std::exchange(other.if_not_exists, false);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreateExtensionStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateExtensionStmt::swap(CreateExtensionStmt& other) noexcept
{
    using std::swap;
    swap(extname, other.extname);
    swap(if_not_exists, other.if_not_exists);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateExtensionStmt& value)
{
    stream << "CreateExtensionStmt(";
    stream << "extname="; stream << "\"" << value.extname << "\"";
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterExtensionStmt::AlterExtensionStmt()
    : extname()
    , options()
{}

AlterExtensionStmt::AlterExtensionStmt(const std::string& arg_extname, std::vector<::pg_query::Node> arg_options)
    : extname(arg_extname)
    , options(std::move(arg_options))
{}

AlterExtensionStmt::AlterExtensionStmt(AlterExtensionStmt&& other) noexcept
    : extname(std::move(other.extname))
    , options(std::move(other.options))
{}

AlterExtensionStmt::~AlterExtensionStmt()
{
}

bool AlterExtensionStmt::operator==([[maybe_unused]] const AlterExtensionStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterExtensionStmt::operator<([[maybe_unused]] const AlterExtensionStmt& other) const noexcept
{
    return false;
}

AlterExtensionStmt& AlterExtensionStmt::operator=(AlterExtensionStmt&& other) noexcept
{
    if (this != &other)
    {
        extname = std::move(other.extname);
        options = std::move(other.options);
    }
    return *this;
}

std::string AlterExtensionStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterExtensionStmt::swap(AlterExtensionStmt& other) noexcept
{
    using std::swap;
    swap(extname, other.extname);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterExtensionStmt& value)
{
    stream << "AlterExtensionStmt(";
    stream << "extname="; stream << "\"" << value.extname << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterExtensionContentsStmt::AlterExtensionContentsStmt()
    : extname()
    , action((int32_t)0ll)
    , objtype()
    , object()
{}

AlterExtensionContentsStmt::AlterExtensionContentsStmt(const std::string& arg_extname, int32_t arg_action, ::pg_query::ObjectType&& arg_objtype, ::pg_query::Node&& arg_object)
    : extname(arg_extname)
    , action(arg_action)
    , objtype(std::move(arg_objtype))
    , object(std::move(arg_object))
{}

AlterExtensionContentsStmt::AlterExtensionContentsStmt(AlterExtensionContentsStmt&& other) noexcept
    : extname(std::move(other.extname))
    , action(std::exchange(other.action, (int32_t)0ll))
    , objtype(std::move(other.objtype))
    , object(std::move(other.object))
{}

AlterExtensionContentsStmt::~AlterExtensionContentsStmt()
{
}

bool AlterExtensionContentsStmt::operator==([[maybe_unused]] const AlterExtensionContentsStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterExtensionContentsStmt::operator<([[maybe_unused]] const AlterExtensionContentsStmt& other) const noexcept
{
    return false;
}

AlterExtensionContentsStmt& AlterExtensionContentsStmt::operator=(AlterExtensionContentsStmt&& other) noexcept
{
    if (this != &other)
    {
        extname = std::move(other.extname);
        action = std::exchange(other.action, (int32_t)0ll);
        objtype = std::move(other.objtype);
        object = std::move(other.object);
    }
    return *this;
}

std::string AlterExtensionContentsStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterExtensionContentsStmt::swap(AlterExtensionContentsStmt& other) noexcept
{
    using std::swap;
    swap(extname, other.extname);
    swap(action, other.action);
    swap(objtype, other.objtype);
    swap(object, other.object);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterExtensionContentsStmt& value)
{
    stream << "AlterExtensionContentsStmt(";
    stream << "extname="; stream << "\"" << value.extname << "\"";
    stream << ",action="; stream << value.action;
    stream << ",objtype="; stream << value.objtype;
    stream << ",object="; stream << value.object;
    stream << ")";
    return stream;
}

CreateEventTrigStmt::CreateEventTrigStmt()
    : trigname()
    , eventname()
    , whenclause()
    , funcname()
{}

CreateEventTrigStmt::CreateEventTrigStmt(const std::string& arg_trigname, const std::string& arg_eventname, std::vector<::pg_query::Node> arg_whenclause, std::vector<::pg_query::Node> arg_funcname)
    : trigname(arg_trigname)
    , eventname(arg_eventname)
    , whenclause(std::move(arg_whenclause))
    , funcname(std::move(arg_funcname))
{}

CreateEventTrigStmt::CreateEventTrigStmt(CreateEventTrigStmt&& other) noexcept
    : trigname(std::move(other.trigname))
    , eventname(std::move(other.eventname))
    , whenclause(std::move(other.whenclause))
    , funcname(std::move(other.funcname))
{}

CreateEventTrigStmt::~CreateEventTrigStmt()
{
}

bool CreateEventTrigStmt::operator==([[maybe_unused]] const CreateEventTrigStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateEventTrigStmt::operator<([[maybe_unused]] const CreateEventTrigStmt& other) const noexcept
{
    return false;
}

CreateEventTrigStmt& CreateEventTrigStmt::operator=(CreateEventTrigStmt&& other) noexcept
{
    if (this != &other)
    {
        trigname = std::move(other.trigname);
        eventname = std::move(other.eventname);
        whenclause = std::move(other.whenclause);
        funcname = std::move(other.funcname);
    }
    return *this;
}

std::string CreateEventTrigStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateEventTrigStmt::swap(CreateEventTrigStmt& other) noexcept
{
    using std::swap;
    swap(trigname, other.trigname);
    swap(eventname, other.eventname);
    swap(whenclause, other.whenclause);
    swap(funcname, other.funcname);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateEventTrigStmt& value)
{
    stream << "CreateEventTrigStmt(";
    stream << "trigname="; stream << "\"" << value.trigname << "\"";
    stream << ",eventname="; stream << "\"" << value.eventname << "\"";
    {
        bool first = true;
        stream << ",whenclause=[" << value.whenclause.size() << "][";
        for (const auto& it : value.whenclause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",funcname=[" << value.funcname.size() << "][";
        for (const auto& it : value.funcname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterEventTrigStmt::AlterEventTrigStmt()
    : trigname()
    , tgenabled()
{}

AlterEventTrigStmt::AlterEventTrigStmt(const std::string& arg_trigname, const std::string& arg_tgenabled)
    : trigname(arg_trigname)
    , tgenabled(arg_tgenabled)
{}

AlterEventTrigStmt::AlterEventTrigStmt(AlterEventTrigStmt&& other) noexcept
    : trigname(std::move(other.trigname))
    , tgenabled(std::move(other.tgenabled))
{}

AlterEventTrigStmt::~AlterEventTrigStmt()
{
}

bool AlterEventTrigStmt::operator==([[maybe_unused]] const AlterEventTrigStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterEventTrigStmt::operator<([[maybe_unused]] const AlterEventTrigStmt& other) const noexcept
{
    return false;
}

AlterEventTrigStmt& AlterEventTrigStmt::operator=(AlterEventTrigStmt&& other) noexcept
{
    if (this != &other)
    {
        trigname = std::move(other.trigname);
        tgenabled = std::move(other.tgenabled);
    }
    return *this;
}

std::string AlterEventTrigStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterEventTrigStmt::swap(AlterEventTrigStmt& other) noexcept
{
    using std::swap;
    swap(trigname, other.trigname);
    swap(tgenabled, other.tgenabled);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterEventTrigStmt& value)
{
    stream << "AlterEventTrigStmt(";
    stream << "trigname="; stream << "\"" << value.trigname << "\"";
    stream << ",tgenabled="; stream << "\"" << value.tgenabled << "\"";
    stream << ")";
    return stream;
}

RefreshMatViewStmt::RefreshMatViewStmt()
    : concurrent(false)
    , skip_data(false)
    , relation(nullptr)
{}

RefreshMatViewStmt::RefreshMatViewStmt(bool arg_concurrent, bool arg_skip_data, std::unique_ptr<::pg_query::RangeVar> arg_relation)
    : concurrent(arg_concurrent)
    , skip_data(arg_skip_data)
    , relation(arg_relation.release())
{}

RefreshMatViewStmt::RefreshMatViewStmt(RefreshMatViewStmt&& other) noexcept
    : concurrent(std::exchange(other.concurrent, false))
    , skip_data(std::exchange(other.skip_data, false))
    , relation(std::exchange(other.relation, nullptr))
{}

RefreshMatViewStmt::~RefreshMatViewStmt()
{
    if (relation) delete relation;
}

bool RefreshMatViewStmt::operator==([[maybe_unused]] const RefreshMatViewStmt& other) const noexcept
{
    return (
        true
        );
}

bool RefreshMatViewStmt::operator<([[maybe_unused]] const RefreshMatViewStmt& other) const noexcept
{
    return false;
}

RefreshMatViewStmt& RefreshMatViewStmt::operator=(RefreshMatViewStmt&& other) noexcept
{
    if (this != &other)
    {
        concurrent = std::exchange(other.concurrent, false);
        skip_data = std::exchange(other.skip_data, false);
        relation = std::exchange(other.relation, nullptr);
    }
    return *this;
}

std::string RefreshMatViewStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RefreshMatViewStmt::swap(RefreshMatViewStmt& other) noexcept
{
    using std::swap;
    swap(concurrent, other.concurrent);
    swap(skip_data, other.skip_data);
    swap(relation, other.relation);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RefreshMatViewStmt& value)
{
    stream << "RefreshMatViewStmt(";
    stream << "concurrent="; stream << (value.concurrent ? "true" : "false");
    stream << ",skip_data="; stream << (value.skip_data ? "true" : "false");
    stream << ",relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

ReplicaIdentityStmt::ReplicaIdentityStmt()
    : identity_type()
    , name()
{}

ReplicaIdentityStmt::ReplicaIdentityStmt(const std::string& arg_identity_type, const std::string& arg_name)
    : identity_type(arg_identity_type)
    , name(arg_name)
{}

ReplicaIdentityStmt::ReplicaIdentityStmt(ReplicaIdentityStmt&& other) noexcept
    : identity_type(std::move(other.identity_type))
    , name(std::move(other.name))
{}

ReplicaIdentityStmt::~ReplicaIdentityStmt()
{
}

bool ReplicaIdentityStmt::operator==([[maybe_unused]] const ReplicaIdentityStmt& other) const noexcept
{
    return (
        true
        );
}

bool ReplicaIdentityStmt::operator<([[maybe_unused]] const ReplicaIdentityStmt& other) const noexcept
{
    return false;
}

ReplicaIdentityStmt& ReplicaIdentityStmt::operator=(ReplicaIdentityStmt&& other) noexcept
{
    if (this != &other)
    {
        identity_type = std::move(other.identity_type);
        name = std::move(other.name);
    }
    return *this;
}

std::string ReplicaIdentityStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ReplicaIdentityStmt::swap(ReplicaIdentityStmt& other) noexcept
{
    using std::swap;
    swap(identity_type, other.identity_type);
    swap(name, other.name);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ReplicaIdentityStmt& value)
{
    stream << "ReplicaIdentityStmt(";
    stream << "identity_type="; stream << "\"" << value.identity_type << "\"";
    stream << ",name="; stream << "\"" << value.name << "\"";
    stream << ")";
    return stream;
}

AlterSystemStmt::AlterSystemStmt()
    : setstmt(nullptr)
{}

AlterSystemStmt::AlterSystemStmt(std::unique_ptr<::pg_query::VariableSetStmt> arg_setstmt)
    : setstmt(arg_setstmt.release())
{}

AlterSystemStmt::AlterSystemStmt(AlterSystemStmt&& other) noexcept
    : setstmt(std::exchange(other.setstmt, nullptr))
{}

AlterSystemStmt::~AlterSystemStmt()
{
    if (setstmt) delete setstmt;
}

bool AlterSystemStmt::operator==([[maybe_unused]] const AlterSystemStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterSystemStmt::operator<([[maybe_unused]] const AlterSystemStmt& other) const noexcept
{
    return false;
}

AlterSystemStmt& AlterSystemStmt::operator=(AlterSystemStmt&& other) noexcept
{
    if (this != &other)
    {
        setstmt = std::exchange(other.setstmt, nullptr);
    }
    return *this;
}

std::string AlterSystemStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterSystemStmt::swap(AlterSystemStmt& other) noexcept
{
    using std::swap;
    swap(setstmt, other.setstmt);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterSystemStmt& value)
{
    stream << "AlterSystemStmt(";
    stream << "setstmt="; stream << " ptr of other struct" << (value.setstmt == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

CreatePolicyStmt::CreatePolicyStmt()
    : policy_name()
    , table(nullptr)
    , cmd_name()
    , permissive(false)
    , roles()
    , qual()
    , with_check()
{}

CreatePolicyStmt::CreatePolicyStmt(const std::string& arg_policy_name, std::unique_ptr<::pg_query::RangeVar> arg_table, const std::string& arg_cmd_name, bool arg_permissive, std::vector<::pg_query::Node> arg_roles, ::pg_query::Node&& arg_qual, ::pg_query::Node&& arg_with_check)
    : policy_name(arg_policy_name)
    , table(arg_table.release())
    , cmd_name(arg_cmd_name)
    , permissive(arg_permissive)
    , roles(std::move(arg_roles))
    , qual(std::move(arg_qual))
    , with_check(std::move(arg_with_check))
{}

CreatePolicyStmt::CreatePolicyStmt(CreatePolicyStmt&& other) noexcept
    : policy_name(std::move(other.policy_name))
    , table(std::exchange(other.table, nullptr))
    , cmd_name(std::move(other.cmd_name))
    , permissive(std::exchange(other.permissive, false))
    , roles(std::move(other.roles))
    , qual(std::move(other.qual))
    , with_check(std::move(other.with_check))
{}

CreatePolicyStmt::~CreatePolicyStmt()
{
    if (table) delete table;
}

bool CreatePolicyStmt::operator==([[maybe_unused]] const CreatePolicyStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreatePolicyStmt::operator<([[maybe_unused]] const CreatePolicyStmt& other) const noexcept
{
    return false;
}

CreatePolicyStmt& CreatePolicyStmt::operator=(CreatePolicyStmt&& other) noexcept
{
    if (this != &other)
    {
        policy_name = std::move(other.policy_name);
        table = std::exchange(other.table, nullptr);
        cmd_name = std::move(other.cmd_name);
        permissive = std::exchange(other.permissive, false);
        roles = std::move(other.roles);
        qual = std::move(other.qual);
        with_check = std::move(other.with_check);
    }
    return *this;
}

std::string CreatePolicyStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreatePolicyStmt::swap(CreatePolicyStmt& other) noexcept
{
    using std::swap;
    swap(policy_name, other.policy_name);
    swap(table, other.table);
    swap(cmd_name, other.cmd_name);
    swap(permissive, other.permissive);
    swap(roles, other.roles);
    swap(qual, other.qual);
    swap(with_check, other.with_check);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreatePolicyStmt& value)
{
    stream << "CreatePolicyStmt(";
    stream << "policy_name="; stream << "\"" << value.policy_name << "\"";
    stream << ",table="; stream << " ptr of other struct" << (value.table == nullptr ? "true" : "false");
    stream << ",cmd_name="; stream << "\"" << value.cmd_name << "\"";
    stream << ",permissive="; stream << (value.permissive ? "true" : "false");
    {
        bool first = true;
        stream << ",roles=[" << value.roles.size() << "][";
        for (const auto& it : value.roles)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",qual="; stream << value.qual;
    stream << ",with_check="; stream << value.with_check;
    stream << ")";
    return stream;
}

AlterPolicyStmt::AlterPolicyStmt()
    : policy_name()
    , table(nullptr)
    , roles()
    , qual()
    , with_check()
{}

AlterPolicyStmt::AlterPolicyStmt(const std::string& arg_policy_name, std::unique_ptr<::pg_query::RangeVar> arg_table, std::vector<::pg_query::Node> arg_roles, ::pg_query::Node&& arg_qual, ::pg_query::Node&& arg_with_check)
    : policy_name(arg_policy_name)
    , table(arg_table.release())
    , roles(std::move(arg_roles))
    , qual(std::move(arg_qual))
    , with_check(std::move(arg_with_check))
{}

AlterPolicyStmt::AlterPolicyStmt(AlterPolicyStmt&& other) noexcept
    : policy_name(std::move(other.policy_name))
    , table(std::exchange(other.table, nullptr))
    , roles(std::move(other.roles))
    , qual(std::move(other.qual))
    , with_check(std::move(other.with_check))
{}

AlterPolicyStmt::~AlterPolicyStmt()
{
    if (table) delete table;
}

bool AlterPolicyStmt::operator==([[maybe_unused]] const AlterPolicyStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterPolicyStmt::operator<([[maybe_unused]] const AlterPolicyStmt& other) const noexcept
{
    return false;
}

AlterPolicyStmt& AlterPolicyStmt::operator=(AlterPolicyStmt&& other) noexcept
{
    if (this != &other)
    {
        policy_name = std::move(other.policy_name);
        table = std::exchange(other.table, nullptr);
        roles = std::move(other.roles);
        qual = std::move(other.qual);
        with_check = std::move(other.with_check);
    }
    return *this;
}

std::string AlterPolicyStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterPolicyStmt::swap(AlterPolicyStmt& other) noexcept
{
    using std::swap;
    swap(policy_name, other.policy_name);
    swap(table, other.table);
    swap(roles, other.roles);
    swap(qual, other.qual);
    swap(with_check, other.with_check);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterPolicyStmt& value)
{
    stream << "AlterPolicyStmt(";
    stream << "policy_name="; stream << "\"" << value.policy_name << "\"";
    stream << ",table="; stream << " ptr of other struct" << (value.table == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",roles=[" << value.roles.size() << "][";
        for (const auto& it : value.roles)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",qual="; stream << value.qual;
    stream << ",with_check="; stream << value.with_check;
    stream << ")";
    return stream;
}

CreateTransformStmt::CreateTransformStmt()
    : replace(false)
    , type_name(nullptr)
    , lang()
    , fromsql(nullptr)
    , tosql(nullptr)
{}

CreateTransformStmt::CreateTransformStmt(bool arg_replace, std::unique_ptr<::pg_query::TypeName> arg_type_name, const std::string& arg_lang, std::unique_ptr<::pg_query::ObjectWithArgs> arg_fromsql, std::unique_ptr<::pg_query::ObjectWithArgs> arg_tosql)
    : replace(arg_replace)
    , type_name(arg_type_name.release())
    , lang(arg_lang)
    , fromsql(arg_fromsql.release())
    , tosql(arg_tosql.release())
{}

CreateTransformStmt::CreateTransformStmt(CreateTransformStmt&& other) noexcept
    : replace(std::exchange(other.replace, false))
    , type_name(std::exchange(other.type_name, nullptr))
    , lang(std::move(other.lang))
    , fromsql(std::exchange(other.fromsql, nullptr))
    , tosql(std::exchange(other.tosql, nullptr))
{}

CreateTransformStmt::~CreateTransformStmt()
{
    if (type_name) delete type_name;
    if (fromsql) delete fromsql;
    if (tosql) delete tosql;
}

bool CreateTransformStmt::operator==([[maybe_unused]] const CreateTransformStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateTransformStmt::operator<([[maybe_unused]] const CreateTransformStmt& other) const noexcept
{
    return false;
}

CreateTransformStmt& CreateTransformStmt::operator=(CreateTransformStmt&& other) noexcept
{
    if (this != &other)
    {
        replace = std::exchange(other.replace, false);
        type_name = std::exchange(other.type_name, nullptr);
        lang = std::move(other.lang);
        fromsql = std::exchange(other.fromsql, nullptr);
        tosql = std::exchange(other.tosql, nullptr);
    }
    return *this;
}

std::string CreateTransformStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateTransformStmt::swap(CreateTransformStmt& other) noexcept
{
    using std::swap;
    swap(replace, other.replace);
    swap(type_name, other.type_name);
    swap(lang, other.lang);
    swap(fromsql, other.fromsql);
    swap(tosql, other.tosql);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateTransformStmt& value)
{
    stream << "CreateTransformStmt(";
    stream << "replace="; stream << (value.replace ? "true" : "false");
    stream << ",type_name="; stream << " ptr of other struct" << (value.type_name == nullptr ? "true" : "false");
    stream << ",lang="; stream << "\"" << value.lang << "\"";
    stream << ",fromsql="; stream << " ptr of other struct" << (value.fromsql == nullptr ? "true" : "false");
    stream << ",tosql="; stream << " ptr of other struct" << (value.tosql == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

CreateAmStmt::CreateAmStmt()
    : amname()
    , handler_name()
    , amtype()
{}

CreateAmStmt::CreateAmStmt(const std::string& arg_amname, std::vector<::pg_query::Node> arg_handler_name, const std::string& arg_amtype)
    : amname(arg_amname)
    , handler_name(std::move(arg_handler_name))
    , amtype(arg_amtype)
{}

CreateAmStmt::CreateAmStmt(CreateAmStmt&& other) noexcept
    : amname(std::move(other.amname))
    , handler_name(std::move(other.handler_name))
    , amtype(std::move(other.amtype))
{}

CreateAmStmt::~CreateAmStmt()
{
}

bool CreateAmStmt::operator==([[maybe_unused]] const CreateAmStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateAmStmt::operator<([[maybe_unused]] const CreateAmStmt& other) const noexcept
{
    return false;
}

CreateAmStmt& CreateAmStmt::operator=(CreateAmStmt&& other) noexcept
{
    if (this != &other)
    {
        amname = std::move(other.amname);
        handler_name = std::move(other.handler_name);
        amtype = std::move(other.amtype);
    }
    return *this;
}

std::string CreateAmStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateAmStmt::swap(CreateAmStmt& other) noexcept
{
    using std::swap;
    swap(amname, other.amname);
    swap(handler_name, other.handler_name);
    swap(amtype, other.amtype);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateAmStmt& value)
{
    stream << "CreateAmStmt(";
    stream << "amname="; stream << "\"" << value.amname << "\"";
    {
        bool first = true;
        stream << ",handler_name=[" << value.handler_name.size() << "][";
        for (const auto& it : value.handler_name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",amtype="; stream << "\"" << value.amtype << "\"";
    stream << ")";
    return stream;
}

CreatePublicationStmt::CreatePublicationStmt()
    : pubname()
    , options()
    , tables()
    , for_all_tables(false)
{}

CreatePublicationStmt::CreatePublicationStmt(const std::string& arg_pubname, std::vector<::pg_query::Node> arg_options, std::vector<::pg_query::Node> arg_tables, bool arg_for_all_tables)
    : pubname(arg_pubname)
    , options(std::move(arg_options))
    , tables(std::move(arg_tables))
    , for_all_tables(arg_for_all_tables)
{}

CreatePublicationStmt::CreatePublicationStmt(CreatePublicationStmt&& other) noexcept
    : pubname(std::move(other.pubname))
    , options(std::move(other.options))
    , tables(std::move(other.tables))
    , for_all_tables(std::exchange(other.for_all_tables, false))
{}

CreatePublicationStmt::~CreatePublicationStmt()
{
}

bool CreatePublicationStmt::operator==([[maybe_unused]] const CreatePublicationStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreatePublicationStmt::operator<([[maybe_unused]] const CreatePublicationStmt& other) const noexcept
{
    return false;
}

CreatePublicationStmt& CreatePublicationStmt::operator=(CreatePublicationStmt&& other) noexcept
{
    if (this != &other)
    {
        pubname = std::move(other.pubname);
        options = std::move(other.options);
        tables = std::move(other.tables);
        for_all_tables = std::exchange(other.for_all_tables, false);
    }
    return *this;
}

std::string CreatePublicationStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreatePublicationStmt::swap(CreatePublicationStmt& other) noexcept
{
    using std::swap;
    swap(pubname, other.pubname);
    swap(options, other.options);
    swap(tables, other.tables);
    swap(for_all_tables, other.for_all_tables);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreatePublicationStmt& value)
{
    stream << "CreatePublicationStmt(";
    stream << "pubname="; stream << "\"" << value.pubname << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",tables=[" << value.tables.size() << "][";
        for (const auto& it : value.tables)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",for_all_tables="; stream << (value.for_all_tables ? "true" : "false");
    stream << ")";
    return stream;
}

AlterPublicationStmt::AlterPublicationStmt()
    : pubname()
    , options()
    , tables()
    , for_all_tables(false)
    , table_action()
{}

AlterPublicationStmt::AlterPublicationStmt(const std::string& arg_pubname, std::vector<::pg_query::Node> arg_options, std::vector<::pg_query::Node> arg_tables, bool arg_for_all_tables, ::pg_query::DefElemAction&& arg_table_action)
    : pubname(arg_pubname)
    , options(std::move(arg_options))
    , tables(std::move(arg_tables))
    , for_all_tables(arg_for_all_tables)
    , table_action(std::move(arg_table_action))
{}

AlterPublicationStmt::AlterPublicationStmt(AlterPublicationStmt&& other) noexcept
    : pubname(std::move(other.pubname))
    , options(std::move(other.options))
    , tables(std::move(other.tables))
    , for_all_tables(std::exchange(other.for_all_tables, false))
    , table_action(std::move(other.table_action))
{}

AlterPublicationStmt::~AlterPublicationStmt()
{
}

bool AlterPublicationStmt::operator==([[maybe_unused]] const AlterPublicationStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterPublicationStmt::operator<([[maybe_unused]] const AlterPublicationStmt& other) const noexcept
{
    return false;
}

AlterPublicationStmt& AlterPublicationStmt::operator=(AlterPublicationStmt&& other) noexcept
{
    if (this != &other)
    {
        pubname = std::move(other.pubname);
        options = std::move(other.options);
        tables = std::move(other.tables);
        for_all_tables = std::exchange(other.for_all_tables, false);
        table_action = std::move(other.table_action);
    }
    return *this;
}

std::string AlterPublicationStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterPublicationStmt::swap(AlterPublicationStmt& other) noexcept
{
    using std::swap;
    swap(pubname, other.pubname);
    swap(options, other.options);
    swap(tables, other.tables);
    swap(for_all_tables, other.for_all_tables);
    swap(table_action, other.table_action);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterPublicationStmt& value)
{
    stream << "AlterPublicationStmt(";
    stream << "pubname="; stream << "\"" << value.pubname << "\"";
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",tables=[" << value.tables.size() << "][";
        for (const auto& it : value.tables)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",for_all_tables="; stream << (value.for_all_tables ? "true" : "false");
    stream << ",table_action="; stream << value.table_action;
    stream << ")";
    return stream;
}

CreateSubscriptionStmt::CreateSubscriptionStmt()
    : subname()
    , conninfo()
    , publication()
    , options()
{}

CreateSubscriptionStmt::CreateSubscriptionStmt(const std::string& arg_subname, const std::string& arg_conninfo, std::vector<::pg_query::Node> arg_publication, std::vector<::pg_query::Node> arg_options)
    : subname(arg_subname)
    , conninfo(arg_conninfo)
    , publication(std::move(arg_publication))
    , options(std::move(arg_options))
{}

CreateSubscriptionStmt::CreateSubscriptionStmt(CreateSubscriptionStmt&& other) noexcept
    : subname(std::move(other.subname))
    , conninfo(std::move(other.conninfo))
    , publication(std::move(other.publication))
    , options(std::move(other.options))
{}

CreateSubscriptionStmt::~CreateSubscriptionStmt()
{
}

bool CreateSubscriptionStmt::operator==([[maybe_unused]] const CreateSubscriptionStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateSubscriptionStmt::operator<([[maybe_unused]] const CreateSubscriptionStmt& other) const noexcept
{
    return false;
}

CreateSubscriptionStmt& CreateSubscriptionStmt::operator=(CreateSubscriptionStmt&& other) noexcept
{
    if (this != &other)
    {
        subname = std::move(other.subname);
        conninfo = std::move(other.conninfo);
        publication = std::move(other.publication);
        options = std::move(other.options);
    }
    return *this;
}

std::string CreateSubscriptionStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateSubscriptionStmt::swap(CreateSubscriptionStmt& other) noexcept
{
    using std::swap;
    swap(subname, other.subname);
    swap(conninfo, other.conninfo);
    swap(publication, other.publication);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateSubscriptionStmt& value)
{
    stream << "CreateSubscriptionStmt(";
    stream << "subname="; stream << "\"" << value.subname << "\"";
    stream << ",conninfo="; stream << "\"" << value.conninfo << "\"";
    {
        bool first = true;
        stream << ",publication=[" << value.publication.size() << "][";
        for (const auto& it : value.publication)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

AlterSubscriptionStmt::AlterSubscriptionStmt()
    : kind()
    , subname()
    , conninfo()
    , publication()
    , options()
{}

AlterSubscriptionStmt::AlterSubscriptionStmt(::pg_query::AlterSubscriptionType&& arg_kind, const std::string& arg_subname, const std::string& arg_conninfo, std::vector<::pg_query::Node> arg_publication, std::vector<::pg_query::Node> arg_options)
    : kind(std::move(arg_kind))
    , subname(arg_subname)
    , conninfo(arg_conninfo)
    , publication(std::move(arg_publication))
    , options(std::move(arg_options))
{}

AlterSubscriptionStmt::AlterSubscriptionStmt(AlterSubscriptionStmt&& other) noexcept
    : kind(std::move(other.kind))
    , subname(std::move(other.subname))
    , conninfo(std::move(other.conninfo))
    , publication(std::move(other.publication))
    , options(std::move(other.options))
{}

AlterSubscriptionStmt::~AlterSubscriptionStmt()
{
}

bool AlterSubscriptionStmt::operator==([[maybe_unused]] const AlterSubscriptionStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterSubscriptionStmt::operator<([[maybe_unused]] const AlterSubscriptionStmt& other) const noexcept
{
    return false;
}

AlterSubscriptionStmt& AlterSubscriptionStmt::operator=(AlterSubscriptionStmt&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        subname = std::move(other.subname);
        conninfo = std::move(other.conninfo);
        publication = std::move(other.publication);
        options = std::move(other.options);
    }
    return *this;
}

std::string AlterSubscriptionStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterSubscriptionStmt::swap(AlterSubscriptionStmt& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(subname, other.subname);
    swap(conninfo, other.conninfo);
    swap(publication, other.publication);
    swap(options, other.options);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterSubscriptionStmt& value)
{
    stream << "AlterSubscriptionStmt(";
    stream << "kind="; stream << value.kind;
    stream << ",subname="; stream << "\"" << value.subname << "\"";
    stream << ",conninfo="; stream << "\"" << value.conninfo << "\"";
    {
        bool first = true;
        stream << ",publication=[" << value.publication.size() << "][";
        for (const auto& it : value.publication)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

DropSubscriptionStmt::DropSubscriptionStmt()
    : subname()
    , missing_ok(false)
    , behavior()
{}

DropSubscriptionStmt::DropSubscriptionStmt(const std::string& arg_subname, bool arg_missing_ok, ::pg_query::DropBehavior&& arg_behavior)
    : subname(arg_subname)
    , missing_ok(arg_missing_ok)
    , behavior(std::move(arg_behavior))
{}

DropSubscriptionStmt::DropSubscriptionStmt(DropSubscriptionStmt&& other) noexcept
    : subname(std::move(other.subname))
    , missing_ok(std::exchange(other.missing_ok, false))
    , behavior(std::move(other.behavior))
{}

DropSubscriptionStmt::~DropSubscriptionStmt()
{
}

bool DropSubscriptionStmt::operator==([[maybe_unused]] const DropSubscriptionStmt& other) const noexcept
{
    return (
        true
        );
}

bool DropSubscriptionStmt::operator<([[maybe_unused]] const DropSubscriptionStmt& other) const noexcept
{
    return false;
}

DropSubscriptionStmt& DropSubscriptionStmt::operator=(DropSubscriptionStmt&& other) noexcept
{
    if (this != &other)
    {
        subname = std::move(other.subname);
        missing_ok = std::exchange(other.missing_ok, false);
        behavior = std::move(other.behavior);
    }
    return *this;
}

std::string DropSubscriptionStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DropSubscriptionStmt::swap(DropSubscriptionStmt& other) noexcept
{
    using std::swap;
    swap(subname, other.subname);
    swap(missing_ok, other.missing_ok);
    swap(behavior, other.behavior);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DropSubscriptionStmt& value)
{
    stream << "DropSubscriptionStmt(";
    stream << "subname="; stream << "\"" << value.subname << "\"";
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ",behavior="; stream << value.behavior;
    stream << ")";
    return stream;
}

CreateStatsStmt::CreateStatsStmt()
    : defnames()
    , stat_types()
    , exprs()
    , relations()
    , stxcomment()
    , if_not_exists(false)
{}

CreateStatsStmt::CreateStatsStmt(std::vector<::pg_query::Node> arg_defnames, std::vector<::pg_query::Node> arg_stat_types, std::vector<::pg_query::Node> arg_exprs, std::vector<::pg_query::Node> arg_relations, const std::string& arg_stxcomment, bool arg_if_not_exists)
    : defnames(std::move(arg_defnames))
    , stat_types(std::move(arg_stat_types))
    , exprs(std::move(arg_exprs))
    , relations(std::move(arg_relations))
    , stxcomment(arg_stxcomment)
    , if_not_exists(arg_if_not_exists)
{}

CreateStatsStmt::CreateStatsStmt(CreateStatsStmt&& other) noexcept
    : defnames(std::move(other.defnames))
    , stat_types(std::move(other.stat_types))
    , exprs(std::move(other.exprs))
    , relations(std::move(other.relations))
    , stxcomment(std::move(other.stxcomment))
    , if_not_exists(std::exchange(other.if_not_exists, false))
{}

CreateStatsStmt::~CreateStatsStmt()
{
}

bool CreateStatsStmt::operator==([[maybe_unused]] const CreateStatsStmt& other) const noexcept
{
    return (
        true
        );
}

bool CreateStatsStmt::operator<([[maybe_unused]] const CreateStatsStmt& other) const noexcept
{
    return false;
}

CreateStatsStmt& CreateStatsStmt::operator=(CreateStatsStmt&& other) noexcept
{
    if (this != &other)
    {
        defnames = std::move(other.defnames);
        stat_types = std::move(other.stat_types);
        exprs = std::move(other.exprs);
        relations = std::move(other.relations);
        stxcomment = std::move(other.stxcomment);
        if_not_exists = std::exchange(other.if_not_exists, false);
    }
    return *this;
}

std::string CreateStatsStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateStatsStmt::swap(CreateStatsStmt& other) noexcept
{
    using std::swap;
    swap(defnames, other.defnames);
    swap(stat_types, other.stat_types);
    swap(exprs, other.exprs);
    swap(relations, other.relations);
    swap(stxcomment, other.stxcomment);
    swap(if_not_exists, other.if_not_exists);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateStatsStmt& value)
{
    stream << "CreateStatsStmt(";
    {
        bool first = true;
        stream << "defnames=[" << value.defnames.size() << "][";
        for (const auto& it : value.defnames)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",stat_types=[" << value.stat_types.size() << "][";
        for (const auto& it : value.stat_types)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",exprs=[" << value.exprs.size() << "][";
        for (const auto& it : value.exprs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",relations=[" << value.relations.size() << "][";
        for (const auto& it : value.relations)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",stxcomment="; stream << "\"" << value.stxcomment << "\"";
    stream << ",if_not_exists="; stream << (value.if_not_exists ? "true" : "false");
    stream << ")";
    return stream;
}

AlterCollationStmt::AlterCollationStmt()
    : collname()
{}

AlterCollationStmt::AlterCollationStmt(std::vector<::pg_query::Node> arg_collname)
    : collname(std::move(arg_collname))
{}

AlterCollationStmt::AlterCollationStmt(AlterCollationStmt&& other) noexcept
    : collname(std::move(other.collname))
{}

AlterCollationStmt::~AlterCollationStmt()
{
}

bool AlterCollationStmt::operator==([[maybe_unused]] const AlterCollationStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterCollationStmt::operator<([[maybe_unused]] const AlterCollationStmt& other) const noexcept
{
    return false;
}

AlterCollationStmt& AlterCollationStmt::operator=(AlterCollationStmt&& other) noexcept
{
    if (this != &other)
    {
        collname = std::move(other.collname);
    }
    return *this;
}

std::string AlterCollationStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterCollationStmt::swap(AlterCollationStmt& other) noexcept
{
    using std::swap;
    swap(collname, other.collname);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterCollationStmt& value)
{
    stream << "AlterCollationStmt(";
    {
        bool first = true;
        stream << "collname=[" << value.collname.size() << "][";
        for (const auto& it : value.collname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

CallStmt::CallStmt()
    : funccall(nullptr)
    , funcexpr(nullptr)
{}

CallStmt::CallStmt(std::unique_ptr<::pg_query::FuncCall> arg_funccall, std::unique_ptr<::pg_query::FuncExpr> arg_funcexpr)
    : funccall(arg_funccall.release())
    , funcexpr(arg_funcexpr.release())
{}

CallStmt::CallStmt(CallStmt&& other) noexcept
    : funccall(std::exchange(other.funccall, nullptr))
    , funcexpr(std::exchange(other.funcexpr, nullptr))
{}

CallStmt::~CallStmt()
{
    if (funccall) delete funccall;
    if (funcexpr) delete funcexpr;
}

bool CallStmt::operator==([[maybe_unused]] const CallStmt& other) const noexcept
{
    return (
        true
        );
}

bool CallStmt::operator<([[maybe_unused]] const CallStmt& other) const noexcept
{
    return false;
}

CallStmt& CallStmt::operator=(CallStmt&& other) noexcept
{
    if (this != &other)
    {
        funccall = std::exchange(other.funccall, nullptr);
        funcexpr = std::exchange(other.funcexpr, nullptr);
    }
    return *this;
}

std::string CallStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CallStmt::swap(CallStmt& other) noexcept
{
    using std::swap;
    swap(funccall, other.funccall);
    swap(funcexpr, other.funcexpr);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CallStmt& value)
{
    stream << "CallStmt(";
    stream << "funccall="; stream << " ptr of other struct" << (value.funccall == nullptr ? "true" : "false");
    stream << ",funcexpr="; stream << " ptr of other struct" << (value.funcexpr == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

AlterStatsStmt::AlterStatsStmt()
    : defnames()
    , stxstattarget((int32_t)0ll)
    , missing_ok(false)
{}

AlterStatsStmt::AlterStatsStmt(std::vector<::pg_query::Node> arg_defnames, int32_t arg_stxstattarget, bool arg_missing_ok)
    : defnames(std::move(arg_defnames))
    , stxstattarget(arg_stxstattarget)
    , missing_ok(arg_missing_ok)
{}

AlterStatsStmt::AlterStatsStmt(AlterStatsStmt&& other) noexcept
    : defnames(std::move(other.defnames))
    , stxstattarget(std::exchange(other.stxstattarget, (int32_t)0ll))
    , missing_ok(std::exchange(other.missing_ok, false))
{}

AlterStatsStmt::~AlterStatsStmt()
{
}

bool AlterStatsStmt::operator==([[maybe_unused]] const AlterStatsStmt& other) const noexcept
{
    return (
        true
        );
}

bool AlterStatsStmt::operator<([[maybe_unused]] const AlterStatsStmt& other) const noexcept
{
    return false;
}

AlterStatsStmt& AlterStatsStmt::operator=(AlterStatsStmt&& other) noexcept
{
    if (this != &other)
    {
        defnames = std::move(other.defnames);
        stxstattarget = std::exchange(other.stxstattarget, (int32_t)0ll);
        missing_ok = std::exchange(other.missing_ok, false);
    }
    return *this;
}

std::string AlterStatsStmt::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AlterStatsStmt::swap(AlterStatsStmt& other) noexcept
{
    using std::swap;
    swap(defnames, other.defnames);
    swap(stxstattarget, other.stxstattarget);
    swap(missing_ok, other.missing_ok);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AlterStatsStmt& value)
{
    stream << "AlterStatsStmt(";
    {
        bool first = true;
        stream << "defnames=[" << value.defnames.size() << "][";
        for (const auto& it : value.defnames)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",stxstattarget="; stream << value.stxstattarget;
    stream << ",missing_ok="; stream << (value.missing_ok ? "true" : "false");
    stream << ")";
    return stream;
}

A_Expr::A_Expr()
    : kind()
    , name()
    , lexpr()
    , rexpr()
    , location((int32_t)0ll)
{}

A_Expr::A_Expr(::pg_query::A_Expr_Kind&& arg_kind, std::vector<::pg_query::Node> arg_name, ::pg_query::Node&& arg_lexpr, ::pg_query::Node&& arg_rexpr, int32_t arg_location)
    : kind(std::move(arg_kind))
    , name(std::move(arg_name))
    , lexpr(std::move(arg_lexpr))
    , rexpr(std::move(arg_rexpr))
    , location(arg_location)
{}

A_Expr::A_Expr(A_Expr&& other) noexcept
    : kind(std::move(other.kind))
    , name(std::move(other.name))
    , lexpr(std::move(other.lexpr))
    , rexpr(std::move(other.rexpr))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

A_Expr::~A_Expr()
{
}

bool A_Expr::operator==([[maybe_unused]] const A_Expr& other) const noexcept
{
    return (
        true
        );
}

bool A_Expr::operator<([[maybe_unused]] const A_Expr& other) const noexcept
{
    return false;
}

A_Expr& A_Expr::operator=(A_Expr&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        name = std::move(other.name);
        lexpr = std::move(other.lexpr);
        rexpr = std::move(other.rexpr);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string A_Expr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void A_Expr::swap(A_Expr& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(name, other.name);
    swap(lexpr, other.lexpr);
    swap(rexpr, other.rexpr);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const A_Expr& value)
{
    stream << "A_Expr(";
    stream << "kind="; stream << value.kind;
    {
        bool first = true;
        stream << ",name=[" << value.name.size() << "][";
        for (const auto& it : value.name)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",lexpr="; stream << value.lexpr;
    stream << ",rexpr="; stream << value.rexpr;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

ColumnRef::ColumnRef()
    : fields()
    , location((int32_t)0ll)
{}

ColumnRef::ColumnRef(std::vector<::pg_query::Node> arg_fields, int32_t arg_location)
    : fields(std::move(arg_fields))
    , location(arg_location)
{}

ColumnRef::ColumnRef(ColumnRef&& other) noexcept
    : fields(std::move(other.fields))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

ColumnRef::~ColumnRef()
{
}

bool ColumnRef::operator==([[maybe_unused]] const ColumnRef& other) const noexcept
{
    return (
        true
        );
}

bool ColumnRef::operator<([[maybe_unused]] const ColumnRef& other) const noexcept
{
    return false;
}

ColumnRef& ColumnRef::operator=(ColumnRef&& other) noexcept
{
    if (this != &other)
    {
        fields = std::move(other.fields);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string ColumnRef::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ColumnRef::swap(ColumnRef& other) noexcept
{
    using std::swap;
    swap(fields, other.fields);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ColumnRef& value)
{
    stream << "ColumnRef(";
    {
        bool first = true;
        stream << "fields=[" << value.fields.size() << "][";
        for (const auto& it : value.fields)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

ParamRef::ParamRef()
    : number((int32_t)0ll)
    , location((int32_t)0ll)
{}

ParamRef::ParamRef(int32_t arg_number, int32_t arg_location)
    : number(arg_number)
    , location(arg_location)
{}

ParamRef::ParamRef(ParamRef&& other) noexcept
    : number(std::exchange(other.number, (int32_t)0ll))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

ParamRef::~ParamRef()
{
}

bool ParamRef::operator==([[maybe_unused]] const ParamRef& other) const noexcept
{
    return (
        true
        );
}

bool ParamRef::operator<([[maybe_unused]] const ParamRef& other) const noexcept
{
    return false;
}

ParamRef& ParamRef::operator=(ParamRef&& other) noexcept
{
    if (this != &other)
    {
        number = std::exchange(other.number, (int32_t)0ll);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string ParamRef::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ParamRef::swap(ParamRef& other) noexcept
{
    using std::swap;
    swap(number, other.number);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ParamRef& value)
{
    stream << "ParamRef(";
    stream << "number="; stream << value.number;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

A_Const::A_Const()
    : val()
    , location((int32_t)0ll)
{}

A_Const::A_Const(::pg_query::Node&& arg_val, int32_t arg_location)
    : val(std::move(arg_val))
    , location(arg_location)
{}

A_Const::A_Const(A_Const&& other) noexcept
    : val(std::move(other.val))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

A_Const::~A_Const()
{
}

bool A_Const::operator==([[maybe_unused]] const A_Const& other) const noexcept
{
    return (
        true
        );
}

bool A_Const::operator<([[maybe_unused]] const A_Const& other) const noexcept
{
    return false;
}

A_Const& A_Const::operator=(A_Const&& other) noexcept
{
    if (this != &other)
    {
        val = std::move(other.val);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string A_Const::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void A_Const::swap(A_Const& other) noexcept
{
    using std::swap;
    swap(val, other.val);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const A_Const& value)
{
    stream << "A_Const(";
    stream << "val="; stream << value.val;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

FuncCall::FuncCall()
    : funcname()
    , args()
    , agg_order()
    , agg_filter()
    , agg_within_group(false)
    , agg_star(false)
    , agg_distinct(false)
    , func_variadic(false)
    , over(nullptr)
    , location((int32_t)0ll)
{}

FuncCall::FuncCall(std::vector<::pg_query::Node> arg_funcname, std::vector<::pg_query::Node> arg_args, std::vector<::pg_query::Node> arg_agg_order, ::pg_query::Node&& arg_agg_filter, bool arg_agg_within_group, bool arg_agg_star, bool arg_agg_distinct, bool arg_func_variadic, std::unique_ptr<::pg_query::WindowDef> arg_over, int32_t arg_location)
    : funcname(std::move(arg_funcname))
    , args(std::move(arg_args))
    , agg_order(std::move(arg_agg_order))
    , agg_filter(std::move(arg_agg_filter))
    , agg_within_group(arg_agg_within_group)
    , agg_star(arg_agg_star)
    , agg_distinct(arg_agg_distinct)
    , func_variadic(arg_func_variadic)
    , over(arg_over.release())
    , location(arg_location)
{}

FuncCall::FuncCall(FuncCall&& other) noexcept
    : funcname(std::move(other.funcname))
    , args(std::move(other.args))
    , agg_order(std::move(other.agg_order))
    , agg_filter(std::move(other.agg_filter))
    , agg_within_group(std::exchange(other.agg_within_group, false))
    , agg_star(std::exchange(other.agg_star, false))
    , agg_distinct(std::exchange(other.agg_distinct, false))
    , func_variadic(std::exchange(other.func_variadic, false))
    , over(std::exchange(other.over, nullptr))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

FuncCall::~FuncCall()
{
    if (over) delete over;
}

bool FuncCall::operator==([[maybe_unused]] const FuncCall& other) const noexcept
{
    return (
        true
        );
}

bool FuncCall::operator<([[maybe_unused]] const FuncCall& other) const noexcept
{
    return false;
}

FuncCall& FuncCall::operator=(FuncCall&& other) noexcept
{
    if (this != &other)
    {
        funcname = std::move(other.funcname);
        args = std::move(other.args);
        agg_order = std::move(other.agg_order);
        agg_filter = std::move(other.agg_filter);
        agg_within_group = std::exchange(other.agg_within_group, false);
        agg_star = std::exchange(other.agg_star, false);
        agg_distinct = std::exchange(other.agg_distinct, false);
        func_variadic = std::exchange(other.func_variadic, false);
        over = std::exchange(other.over, nullptr);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string FuncCall::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void FuncCall::swap(FuncCall& other) noexcept
{
    using std::swap;
    swap(funcname, other.funcname);
    swap(args, other.args);
    swap(agg_order, other.agg_order);
    swap(agg_filter, other.agg_filter);
    swap(agg_within_group, other.agg_within_group);
    swap(agg_star, other.agg_star);
    swap(agg_distinct, other.agg_distinct);
    swap(func_variadic, other.func_variadic);
    swap(over, other.over);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const FuncCall& value)
{
    stream << "FuncCall(";
    {
        bool first = true;
        stream << "funcname=[" << value.funcname.size() << "][";
        for (const auto& it : value.funcname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",agg_order=[" << value.agg_order.size() << "][";
        for (const auto& it : value.agg_order)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",agg_filter="; stream << value.agg_filter;
    stream << ",agg_within_group="; stream << (value.agg_within_group ? "true" : "false");
    stream << ",agg_star="; stream << (value.agg_star ? "true" : "false");
    stream << ",agg_distinct="; stream << (value.agg_distinct ? "true" : "false");
    stream << ",func_variadic="; stream << (value.func_variadic ? "true" : "false");
    stream << ",over="; stream << " ptr of other struct" << (value.over == nullptr ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

A_Star::A_Star()
{}

A_Star::A_Star(A_Star&& other) noexcept
{}

A_Star::~A_Star()
{
}

bool A_Star::operator==([[maybe_unused]] const A_Star& other) const noexcept
{
    return (
        true
        );
}

bool A_Star::operator<([[maybe_unused]] const A_Star& other) const noexcept
{
    return false;
}

A_Star& A_Star::operator=(A_Star&& other) noexcept
{
    if (this != &other)
    {
    }
    return *this;
}

std::string A_Star::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void A_Star::swap(A_Star& other) noexcept
{
    using std::swap;
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const A_Star& value)
{
    stream << "A_Star(";
    stream << ")";
    return stream;
}

A_Indices::A_Indices()
    : is_slice(false)
    , lidx()
    , uidx()
{}

A_Indices::A_Indices(bool arg_is_slice, ::pg_query::Node&& arg_lidx, ::pg_query::Node&& arg_uidx)
    : is_slice(arg_is_slice)
    , lidx(std::move(arg_lidx))
    , uidx(std::move(arg_uidx))
{}

A_Indices::A_Indices(A_Indices&& other) noexcept
    : is_slice(std::exchange(other.is_slice, false))
    , lidx(std::move(other.lidx))
    , uidx(std::move(other.uidx))
{}

A_Indices::~A_Indices()
{
}

bool A_Indices::operator==([[maybe_unused]] const A_Indices& other) const noexcept
{
    return (
        true
        );
}

bool A_Indices::operator<([[maybe_unused]] const A_Indices& other) const noexcept
{
    return false;
}

A_Indices& A_Indices::operator=(A_Indices&& other) noexcept
{
    if (this != &other)
    {
        is_slice = std::exchange(other.is_slice, false);
        lidx = std::move(other.lidx);
        uidx = std::move(other.uidx);
    }
    return *this;
}

std::string A_Indices::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void A_Indices::swap(A_Indices& other) noexcept
{
    using std::swap;
    swap(is_slice, other.is_slice);
    swap(lidx, other.lidx);
    swap(uidx, other.uidx);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const A_Indices& value)
{
    stream << "A_Indices(";
    stream << "is_slice="; stream << (value.is_slice ? "true" : "false");
    stream << ",lidx="; stream << value.lidx;
    stream << ",uidx="; stream << value.uidx;
    stream << ")";
    return stream;
}

A_Indirection::A_Indirection()
    : arg()
    , indirection()
{}

A_Indirection::A_Indirection(::pg_query::Node&& arg_arg, std::vector<::pg_query::Node> arg_indirection)
    : arg(std::move(arg_arg))
    , indirection(std::move(arg_indirection))
{}

A_Indirection::A_Indirection(A_Indirection&& other) noexcept
    : arg(std::move(other.arg))
    , indirection(std::move(other.indirection))
{}

A_Indirection::~A_Indirection()
{
}

bool A_Indirection::operator==([[maybe_unused]] const A_Indirection& other) const noexcept
{
    return (
        true
        );
}

bool A_Indirection::operator<([[maybe_unused]] const A_Indirection& other) const noexcept
{
    return false;
}

A_Indirection& A_Indirection::operator=(A_Indirection&& other) noexcept
{
    if (this != &other)
    {
        arg = std::move(other.arg);
        indirection = std::move(other.indirection);
    }
    return *this;
}

std::string A_Indirection::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void A_Indirection::swap(A_Indirection& other) noexcept
{
    using std::swap;
    swap(arg, other.arg);
    swap(indirection, other.indirection);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const A_Indirection& value)
{
    stream << "A_Indirection(";
    stream << "arg="; stream << value.arg;
    {
        bool first = true;
        stream << ",indirection=[" << value.indirection.size() << "][";
        for (const auto& it : value.indirection)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

A_ArrayExpr::A_ArrayExpr()
    : elements()
    , location((int32_t)0ll)
{}

A_ArrayExpr::A_ArrayExpr(std::vector<::pg_query::Node> arg_elements, int32_t arg_location)
    : elements(std::move(arg_elements))
    , location(arg_location)
{}

A_ArrayExpr::A_ArrayExpr(A_ArrayExpr&& other) noexcept
    : elements(std::move(other.elements))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

A_ArrayExpr::~A_ArrayExpr()
{
}

bool A_ArrayExpr::operator==([[maybe_unused]] const A_ArrayExpr& other) const noexcept
{
    return (
        true
        );
}

bool A_ArrayExpr::operator<([[maybe_unused]] const A_ArrayExpr& other) const noexcept
{
    return false;
}

A_ArrayExpr& A_ArrayExpr::operator=(A_ArrayExpr&& other) noexcept
{
    if (this != &other)
    {
        elements = std::move(other.elements);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string A_ArrayExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void A_ArrayExpr::swap(A_ArrayExpr& other) noexcept
{
    using std::swap;
    swap(elements, other.elements);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const A_ArrayExpr& value)
{
    stream << "A_ArrayExpr(";
    {
        bool first = true;
        stream << "elements=[" << value.elements.size() << "][";
        for (const auto& it : value.elements)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

ResTarget::ResTarget()
    : name()
    , indirection()
    , val()
    , location((int32_t)0ll)
{}

ResTarget::ResTarget(const std::string& arg_name, std::vector<::pg_query::Node> arg_indirection, ::pg_query::Node&& arg_val, int32_t arg_location)
    : name(arg_name)
    , indirection(std::move(arg_indirection))
    , val(std::move(arg_val))
    , location(arg_location)
{}

ResTarget::ResTarget(ResTarget&& other) noexcept
    : name(std::move(other.name))
    , indirection(std::move(other.indirection))
    , val(std::move(other.val))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

ResTarget::~ResTarget()
{
}

bool ResTarget::operator==([[maybe_unused]] const ResTarget& other) const noexcept
{
    return (
        true
        );
}

bool ResTarget::operator<([[maybe_unused]] const ResTarget& other) const noexcept
{
    return false;
}

ResTarget& ResTarget::operator=(ResTarget&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
        indirection = std::move(other.indirection);
        val = std::move(other.val);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string ResTarget::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ResTarget::swap(ResTarget& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(indirection, other.indirection);
    swap(val, other.val);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ResTarget& value)
{
    stream << "ResTarget(";
    stream << "name="; stream << "\"" << value.name << "\"";
    {
        bool first = true;
        stream << ",indirection=[" << value.indirection.size() << "][";
        for (const auto& it : value.indirection)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",val="; stream << value.val;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

MultiAssignRef::MultiAssignRef()
    : source()
    , colno((int32_t)0ll)
    , ncolumns((int32_t)0ll)
{}

MultiAssignRef::MultiAssignRef(::pg_query::Node&& arg_source, int32_t arg_colno, int32_t arg_ncolumns)
    : source(std::move(arg_source))
    , colno(arg_colno)
    , ncolumns(arg_ncolumns)
{}

MultiAssignRef::MultiAssignRef(MultiAssignRef&& other) noexcept
    : source(std::move(other.source))
    , colno(std::exchange(other.colno, (int32_t)0ll))
    , ncolumns(std::exchange(other.ncolumns, (int32_t)0ll))
{}

MultiAssignRef::~MultiAssignRef()
{
}

bool MultiAssignRef::operator==([[maybe_unused]] const MultiAssignRef& other) const noexcept
{
    return (
        true
        );
}

bool MultiAssignRef::operator<([[maybe_unused]] const MultiAssignRef& other) const noexcept
{
    return false;
}

MultiAssignRef& MultiAssignRef::operator=(MultiAssignRef&& other) noexcept
{
    if (this != &other)
    {
        source = std::move(other.source);
        colno = std::exchange(other.colno, (int32_t)0ll);
        ncolumns = std::exchange(other.ncolumns, (int32_t)0ll);
    }
    return *this;
}

std::string MultiAssignRef::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void MultiAssignRef::swap(MultiAssignRef& other) noexcept
{
    using std::swap;
    swap(source, other.source);
    swap(colno, other.colno);
    swap(ncolumns, other.ncolumns);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const MultiAssignRef& value)
{
    stream << "MultiAssignRef(";
    stream << "source="; stream << value.source;
    stream << ",colno="; stream << value.colno;
    stream << ",ncolumns="; stream << value.ncolumns;
    stream << ")";
    return stream;
}

TypeCast::TypeCast()
    : arg()
    , type_name(nullptr)
    , location((int32_t)0ll)
{}

TypeCast::TypeCast(::pg_query::Node&& arg_arg, std::unique_ptr<::pg_query::TypeName> arg_type_name, int32_t arg_location)
    : arg(std::move(arg_arg))
    , type_name(arg_type_name.release())
    , location(arg_location)
{}

TypeCast::TypeCast(TypeCast&& other) noexcept
    : arg(std::move(other.arg))
    , type_name(std::exchange(other.type_name, nullptr))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

TypeCast::~TypeCast()
{
    if (type_name) delete type_name;
}

bool TypeCast::operator==([[maybe_unused]] const TypeCast& other) const noexcept
{
    return (
        true
        );
}

bool TypeCast::operator<([[maybe_unused]] const TypeCast& other) const noexcept
{
    return false;
}

TypeCast& TypeCast::operator=(TypeCast&& other) noexcept
{
    if (this != &other)
    {
        arg = std::move(other.arg);
        type_name = std::exchange(other.type_name, nullptr);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string TypeCast::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void TypeCast::swap(TypeCast& other) noexcept
{
    using std::swap;
    swap(arg, other.arg);
    swap(type_name, other.type_name);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const TypeCast& value)
{
    stream << "TypeCast(";
    stream << "arg="; stream << value.arg;
    stream << ",type_name="; stream << " ptr of other struct" << (value.type_name == nullptr ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CollateClause::CollateClause()
    : arg()
    , collname()
    , location((int32_t)0ll)
{}

CollateClause::CollateClause(::pg_query::Node&& arg_arg, std::vector<::pg_query::Node> arg_collname, int32_t arg_location)
    : arg(std::move(arg_arg))
    , collname(std::move(arg_collname))
    , location(arg_location)
{}

CollateClause::CollateClause(CollateClause&& other) noexcept
    : arg(std::move(other.arg))
    , collname(std::move(other.collname))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

CollateClause::~CollateClause()
{
}

bool CollateClause::operator==([[maybe_unused]] const CollateClause& other) const noexcept
{
    return (
        true
        );
}

bool CollateClause::operator<([[maybe_unused]] const CollateClause& other) const noexcept
{
    return false;
}

CollateClause& CollateClause::operator=(CollateClause&& other) noexcept
{
    if (this != &other)
    {
        arg = std::move(other.arg);
        collname = std::move(other.collname);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string CollateClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CollateClause::swap(CollateClause& other) noexcept
{
    using std::swap;
    swap(arg, other.arg);
    swap(collname, other.collname);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CollateClause& value)
{
    stream << "CollateClause(";
    stream << "arg="; stream << value.arg;
    {
        bool first = true;
        stream << ",collname=[" << value.collname.size() << "][";
        for (const auto& it : value.collname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

SortBy::SortBy()
    : node()
    , sortby_dir()
    , sortby_nulls()
    , use_op()
    , location((int32_t)0ll)
{}

SortBy::SortBy(::pg_query::Node&& arg_node, ::pg_query::SortByDir&& arg_sortby_dir, ::pg_query::SortByNulls&& arg_sortby_nulls, std::vector<::pg_query::Node> arg_use_op, int32_t arg_location)
    : node(std::move(arg_node))
    , sortby_dir(std::move(arg_sortby_dir))
    , sortby_nulls(std::move(arg_sortby_nulls))
    , use_op(std::move(arg_use_op))
    , location(arg_location)
{}

SortBy::SortBy(SortBy&& other) noexcept
    : node(std::move(other.node))
    , sortby_dir(std::move(other.sortby_dir))
    , sortby_nulls(std::move(other.sortby_nulls))
    , use_op(std::move(other.use_op))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

SortBy::~SortBy()
{
}

bool SortBy::operator==([[maybe_unused]] const SortBy& other) const noexcept
{
    return (
        true
        );
}

bool SortBy::operator<([[maybe_unused]] const SortBy& other) const noexcept
{
    return false;
}

SortBy& SortBy::operator=(SortBy&& other) noexcept
{
    if (this != &other)
    {
        node = std::move(other.node);
        sortby_dir = std::move(other.sortby_dir);
        sortby_nulls = std::move(other.sortby_nulls);
        use_op = std::move(other.use_op);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string SortBy::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SortBy::swap(SortBy& other) noexcept
{
    using std::swap;
    swap(node, other.node);
    swap(sortby_dir, other.sortby_dir);
    swap(sortby_nulls, other.sortby_nulls);
    swap(use_op, other.use_op);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SortBy& value)
{
    stream << "SortBy(";
    stream << "node="; stream << value.node;
    stream << ",sortby_dir="; stream << value.sortby_dir;
    stream << ",sortby_nulls="; stream << value.sortby_nulls;
    {
        bool first = true;
        stream << ",use_op=[" << value.use_op.size() << "][";
        for (const auto& it : value.use_op)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

WindowDef::WindowDef()
    : name()
    , refname()
    , partition_clause()
    , order_clause()
    , frame_options((int32_t)0ll)
    , start_offset()
    , end_offset()
    , location((int32_t)0ll)
{}

WindowDef::WindowDef(const std::string& arg_name, const std::string& arg_refname, std::vector<::pg_query::Node> arg_partition_clause, std::vector<::pg_query::Node> arg_order_clause, int32_t arg_frame_options, ::pg_query::Node&& arg_start_offset, ::pg_query::Node&& arg_end_offset, int32_t arg_location)
    : name(arg_name)
    , refname(arg_refname)
    , partition_clause(std::move(arg_partition_clause))
    , order_clause(std::move(arg_order_clause))
    , frame_options(arg_frame_options)
    , start_offset(std::move(arg_start_offset))
    , end_offset(std::move(arg_end_offset))
    , location(arg_location)
{}

WindowDef::WindowDef(WindowDef&& other) noexcept
    : name(std::move(other.name))
    , refname(std::move(other.refname))
    , partition_clause(std::move(other.partition_clause))
    , order_clause(std::move(other.order_clause))
    , frame_options(std::exchange(other.frame_options, (int32_t)0ll))
    , start_offset(std::move(other.start_offset))
    , end_offset(std::move(other.end_offset))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

WindowDef::~WindowDef()
{
}

bool WindowDef::operator==([[maybe_unused]] const WindowDef& other) const noexcept
{
    return (
        true
        );
}

bool WindowDef::operator<([[maybe_unused]] const WindowDef& other) const noexcept
{
    return false;
}

WindowDef& WindowDef::operator=(WindowDef&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
        refname = std::move(other.refname);
        partition_clause = std::move(other.partition_clause);
        order_clause = std::move(other.order_clause);
        frame_options = std::exchange(other.frame_options, (int32_t)0ll);
        start_offset = std::move(other.start_offset);
        end_offset = std::move(other.end_offset);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string WindowDef::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void WindowDef::swap(WindowDef& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(refname, other.refname);
    swap(partition_clause, other.partition_clause);
    swap(order_clause, other.order_clause);
    swap(frame_options, other.frame_options);
    swap(start_offset, other.start_offset);
    swap(end_offset, other.end_offset);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const WindowDef& value)
{
    stream << "WindowDef(";
    stream << "name="; stream << "\"" << value.name << "\"";
    stream << ",refname="; stream << "\"" << value.refname << "\"";
    {
        bool first = true;
        stream << ",partition_clause=[" << value.partition_clause.size() << "][";
        for (const auto& it : value.partition_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",order_clause=[" << value.order_clause.size() << "][";
        for (const auto& it : value.order_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",frame_options="; stream << value.frame_options;
    stream << ",start_offset="; stream << value.start_offset;
    stream << ",end_offset="; stream << value.end_offset;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

RangeSubselect::RangeSubselect()
    : lateral(false)
    , subquery()
    , alias(nullptr)
{}

RangeSubselect::RangeSubselect(bool arg_lateral, ::pg_query::Node&& arg_subquery, std::unique_ptr<::pg_query::Alias> arg_alias)
    : lateral(arg_lateral)
    , subquery(std::move(arg_subquery))
    , alias(arg_alias.release())
{}

RangeSubselect::RangeSubselect(RangeSubselect&& other) noexcept
    : lateral(std::exchange(other.lateral, false))
    , subquery(std::move(other.subquery))
    , alias(std::exchange(other.alias, nullptr))
{}

RangeSubselect::~RangeSubselect()
{
    if (alias) delete alias;
}

bool RangeSubselect::operator==([[maybe_unused]] const RangeSubselect& other) const noexcept
{
    return (
        true
        );
}

bool RangeSubselect::operator<([[maybe_unused]] const RangeSubselect& other) const noexcept
{
    return false;
}

RangeSubselect& RangeSubselect::operator=(RangeSubselect&& other) noexcept
{
    if (this != &other)
    {
        lateral = std::exchange(other.lateral, false);
        subquery = std::move(other.subquery);
        alias = std::exchange(other.alias, nullptr);
    }
    return *this;
}

std::string RangeSubselect::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RangeSubselect::swap(RangeSubselect& other) noexcept
{
    using std::swap;
    swap(lateral, other.lateral);
    swap(subquery, other.subquery);
    swap(alias, other.alias);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RangeSubselect& value)
{
    stream << "RangeSubselect(";
    stream << "lateral="; stream << (value.lateral ? "true" : "false");
    stream << ",subquery="; stream << value.subquery;
    stream << ",alias="; stream << " ptr of other struct" << (value.alias == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

RangeFunction::RangeFunction()
    : lateral(false)
    , ordinality(false)
    , is_rowsfrom(false)
    , functions()
    , alias(nullptr)
    , coldeflist()
{}

RangeFunction::RangeFunction(bool arg_lateral, bool arg_ordinality, bool arg_is_rowsfrom, std::vector<::pg_query::Node> arg_functions, std::unique_ptr<::pg_query::Alias> arg_alias, std::vector<::pg_query::Node> arg_coldeflist)
    : lateral(arg_lateral)
    , ordinality(arg_ordinality)
    , is_rowsfrom(arg_is_rowsfrom)
    , functions(std::move(arg_functions))
    , alias(arg_alias.release())
    , coldeflist(std::move(arg_coldeflist))
{}

RangeFunction::RangeFunction(RangeFunction&& other) noexcept
    : lateral(std::exchange(other.lateral, false))
    , ordinality(std::exchange(other.ordinality, false))
    , is_rowsfrom(std::exchange(other.is_rowsfrom, false))
    , functions(std::move(other.functions))
    , alias(std::exchange(other.alias, nullptr))
    , coldeflist(std::move(other.coldeflist))
{}

RangeFunction::~RangeFunction()
{
    if (alias) delete alias;
}

bool RangeFunction::operator==([[maybe_unused]] const RangeFunction& other) const noexcept
{
    return (
        true
        );
}

bool RangeFunction::operator<([[maybe_unused]] const RangeFunction& other) const noexcept
{
    return false;
}

RangeFunction& RangeFunction::operator=(RangeFunction&& other) noexcept
{
    if (this != &other)
    {
        lateral = std::exchange(other.lateral, false);
        ordinality = std::exchange(other.ordinality, false);
        is_rowsfrom = std::exchange(other.is_rowsfrom, false);
        functions = std::move(other.functions);
        alias = std::exchange(other.alias, nullptr);
        coldeflist = std::move(other.coldeflist);
    }
    return *this;
}

std::string RangeFunction::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RangeFunction::swap(RangeFunction& other) noexcept
{
    using std::swap;
    swap(lateral, other.lateral);
    swap(ordinality, other.ordinality);
    swap(is_rowsfrom, other.is_rowsfrom);
    swap(functions, other.functions);
    swap(alias, other.alias);
    swap(coldeflist, other.coldeflist);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RangeFunction& value)
{
    stream << "RangeFunction(";
    stream << "lateral="; stream << (value.lateral ? "true" : "false");
    stream << ",ordinality="; stream << (value.ordinality ? "true" : "false");
    stream << ",is_rowsfrom="; stream << (value.is_rowsfrom ? "true" : "false");
    {
        bool first = true;
        stream << ",functions=[" << value.functions.size() << "][";
        for (const auto& it : value.functions)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",alias="; stream << " ptr of other struct" << (value.alias == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",coldeflist=[" << value.coldeflist.size() << "][";
        for (const auto& it : value.coldeflist)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

RangeTableSample::RangeTableSample()
    : relation()
    , method()
    , args()
    , repeatable()
    , location((int32_t)0ll)
{}

RangeTableSample::RangeTableSample(::pg_query::Node&& arg_relation, std::vector<::pg_query::Node> arg_method, std::vector<::pg_query::Node> arg_args, ::pg_query::Node&& arg_repeatable, int32_t arg_location)
    : relation(std::move(arg_relation))
    , method(std::move(arg_method))
    , args(std::move(arg_args))
    , repeatable(std::move(arg_repeatable))
    , location(arg_location)
{}

RangeTableSample::RangeTableSample(RangeTableSample&& other) noexcept
    : relation(std::move(other.relation))
    , method(std::move(other.method))
    , args(std::move(other.args))
    , repeatable(std::move(other.repeatable))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

RangeTableSample::~RangeTableSample()
{
}

bool RangeTableSample::operator==([[maybe_unused]] const RangeTableSample& other) const noexcept
{
    return (
        true
        );
}

bool RangeTableSample::operator<([[maybe_unused]] const RangeTableSample& other) const noexcept
{
    return false;
}

RangeTableSample& RangeTableSample::operator=(RangeTableSample&& other) noexcept
{
    if (this != &other)
    {
        relation = std::move(other.relation);
        method = std::move(other.method);
        args = std::move(other.args);
        repeatable = std::move(other.repeatable);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string RangeTableSample::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RangeTableSample::swap(RangeTableSample& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(method, other.method);
    swap(args, other.args);
    swap(repeatable, other.repeatable);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RangeTableSample& value)
{
    stream << "RangeTableSample(";
    stream << "relation="; stream << value.relation;
    {
        bool first = true;
        stream << ",method=[" << value.method.size() << "][";
        for (const auto& it : value.method)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",repeatable="; stream << value.repeatable;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

RangeTableFunc::RangeTableFunc()
    : lateral(false)
    , docexpr()
    , rowexpr()
    , namespaces()
    , columns()
    , alias(nullptr)
    , location((int32_t)0ll)
{}

RangeTableFunc::RangeTableFunc(bool arg_lateral, ::pg_query::Node&& arg_docexpr, ::pg_query::Node&& arg_rowexpr, std::vector<::pg_query::Node> arg_namespaces, std::vector<::pg_query::Node> arg_columns, std::unique_ptr<::pg_query::Alias> arg_alias, int32_t arg_location)
    : lateral(arg_lateral)
    , docexpr(std::move(arg_docexpr))
    , rowexpr(std::move(arg_rowexpr))
    , namespaces(std::move(arg_namespaces))
    , columns(std::move(arg_columns))
    , alias(arg_alias.release())
    , location(arg_location)
{}

RangeTableFunc::RangeTableFunc(RangeTableFunc&& other) noexcept
    : lateral(std::exchange(other.lateral, false))
    , docexpr(std::move(other.docexpr))
    , rowexpr(std::move(other.rowexpr))
    , namespaces(std::move(other.namespaces))
    , columns(std::move(other.columns))
    , alias(std::exchange(other.alias, nullptr))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

RangeTableFunc::~RangeTableFunc()
{
    if (alias) delete alias;
}

bool RangeTableFunc::operator==([[maybe_unused]] const RangeTableFunc& other) const noexcept
{
    return (
        true
        );
}

bool RangeTableFunc::operator<([[maybe_unused]] const RangeTableFunc& other) const noexcept
{
    return false;
}

RangeTableFunc& RangeTableFunc::operator=(RangeTableFunc&& other) noexcept
{
    if (this != &other)
    {
        lateral = std::exchange(other.lateral, false);
        docexpr = std::move(other.docexpr);
        rowexpr = std::move(other.rowexpr);
        namespaces = std::move(other.namespaces);
        columns = std::move(other.columns);
        alias = std::exchange(other.alias, nullptr);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string RangeTableFunc::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RangeTableFunc::swap(RangeTableFunc& other) noexcept
{
    using std::swap;
    swap(lateral, other.lateral);
    swap(docexpr, other.docexpr);
    swap(rowexpr, other.rowexpr);
    swap(namespaces, other.namespaces);
    swap(columns, other.columns);
    swap(alias, other.alias);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RangeTableFunc& value)
{
    stream << "RangeTableFunc(";
    stream << "lateral="; stream << (value.lateral ? "true" : "false");
    stream << ",docexpr="; stream << value.docexpr;
    stream << ",rowexpr="; stream << value.rowexpr;
    {
        bool first = true;
        stream << ",namespaces=[" << value.namespaces.size() << "][";
        for (const auto& it : value.namespaces)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",columns=[" << value.columns.size() << "][";
        for (const auto& it : value.columns)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",alias="; stream << " ptr of other struct" << (value.alias == nullptr ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

RangeTableFuncCol::RangeTableFuncCol()
    : colname()
    , type_name(nullptr)
    , for_ordinality(false)
    , is_not_null(false)
    , colexpr()
    , coldefexpr()
    , location((int32_t)0ll)
{}

RangeTableFuncCol::RangeTableFuncCol(const std::string& arg_colname, std::unique_ptr<::pg_query::TypeName> arg_type_name, bool arg_for_ordinality, bool arg_is_not_null, ::pg_query::Node&& arg_colexpr, ::pg_query::Node&& arg_coldefexpr, int32_t arg_location)
    : colname(arg_colname)
    , type_name(arg_type_name.release())
    , for_ordinality(arg_for_ordinality)
    , is_not_null(arg_is_not_null)
    , colexpr(std::move(arg_colexpr))
    , coldefexpr(std::move(arg_coldefexpr))
    , location(arg_location)
{}

RangeTableFuncCol::RangeTableFuncCol(RangeTableFuncCol&& other) noexcept
    : colname(std::move(other.colname))
    , type_name(std::exchange(other.type_name, nullptr))
    , for_ordinality(std::exchange(other.for_ordinality, false))
    , is_not_null(std::exchange(other.is_not_null, false))
    , colexpr(std::move(other.colexpr))
    , coldefexpr(std::move(other.coldefexpr))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

RangeTableFuncCol::~RangeTableFuncCol()
{
    if (type_name) delete type_name;
}

bool RangeTableFuncCol::operator==([[maybe_unused]] const RangeTableFuncCol& other) const noexcept
{
    return (
        true
        );
}

bool RangeTableFuncCol::operator<([[maybe_unused]] const RangeTableFuncCol& other) const noexcept
{
    return false;
}

RangeTableFuncCol& RangeTableFuncCol::operator=(RangeTableFuncCol&& other) noexcept
{
    if (this != &other)
    {
        colname = std::move(other.colname);
        type_name = std::exchange(other.type_name, nullptr);
        for_ordinality = std::exchange(other.for_ordinality, false);
        is_not_null = std::exchange(other.is_not_null, false);
        colexpr = std::move(other.colexpr);
        coldefexpr = std::move(other.coldefexpr);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string RangeTableFuncCol::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RangeTableFuncCol::swap(RangeTableFuncCol& other) noexcept
{
    using std::swap;
    swap(colname, other.colname);
    swap(type_name, other.type_name);
    swap(for_ordinality, other.for_ordinality);
    swap(is_not_null, other.is_not_null);
    swap(colexpr, other.colexpr);
    swap(coldefexpr, other.coldefexpr);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RangeTableFuncCol& value)
{
    stream << "RangeTableFuncCol(";
    stream << "colname="; stream << "\"" << value.colname << "\"";
    stream << ",type_name="; stream << " ptr of other struct" << (value.type_name == nullptr ? "true" : "false");
    stream << ",for_ordinality="; stream << (value.for_ordinality ? "true" : "false");
    stream << ",is_not_null="; stream << (value.is_not_null ? "true" : "false");
    stream << ",colexpr="; stream << value.colexpr;
    stream << ",coldefexpr="; stream << value.coldefexpr;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

TypeName::TypeName()
    : names()
    , type_oid((uint32_t)0ull)
    , setof(false)
    , pct_type(false)
    , typmods()
    , typemod((int32_t)0ll)
    , array_bounds()
    , location((int32_t)0ll)
{}

TypeName::TypeName(std::vector<::pg_query::Node> arg_names, uint32_t arg_type_oid, bool arg_setof, bool arg_pct_type, std::vector<::pg_query::Node> arg_typmods, int32_t arg_typemod, std::vector<::pg_query::Node> arg_array_bounds, int32_t arg_location)
    : names(std::move(arg_names))
    , type_oid(arg_type_oid)
    , setof(arg_setof)
    , pct_type(arg_pct_type)
    , typmods(std::move(arg_typmods))
    , typemod(arg_typemod)
    , array_bounds(std::move(arg_array_bounds))
    , location(arg_location)
{}

TypeName::TypeName(TypeName&& other) noexcept
    : names(std::move(other.names))
    , type_oid(std::exchange(other.type_oid, (uint32_t)0ull))
    , setof(std::exchange(other.setof, false))
    , pct_type(std::exchange(other.pct_type, false))
    , typmods(std::move(other.typmods))
    , typemod(std::exchange(other.typemod, (int32_t)0ll))
    , array_bounds(std::move(other.array_bounds))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

TypeName::~TypeName()
{
}

bool TypeName::operator==([[maybe_unused]] const TypeName& other) const noexcept
{
    return (
        true
        );
}

bool TypeName::operator<([[maybe_unused]] const TypeName& other) const noexcept
{
    return false;
}

TypeName& TypeName::operator=(TypeName&& other) noexcept
{
    if (this != &other)
    {
        names = std::move(other.names);
        type_oid = std::exchange(other.type_oid, (uint32_t)0ull);
        setof = std::exchange(other.setof, false);
        pct_type = std::exchange(other.pct_type, false);
        typmods = std::move(other.typmods);
        typemod = std::exchange(other.typemod, (int32_t)0ll);
        array_bounds = std::move(other.array_bounds);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string TypeName::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void TypeName::swap(TypeName& other) noexcept
{
    using std::swap;
    swap(names, other.names);
    swap(type_oid, other.type_oid);
    swap(setof, other.setof);
    swap(pct_type, other.pct_type);
    swap(typmods, other.typmods);
    swap(typemod, other.typemod);
    swap(array_bounds, other.array_bounds);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const TypeName& value)
{
    stream << "TypeName(";
    {
        bool first = true;
        stream << "names=[" << value.names.size() << "][";
        for (const auto& it : value.names)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",type_oid="; stream << value.type_oid;
    stream << ",setof="; stream << (value.setof ? "true" : "false");
    stream << ",pct_type="; stream << (value.pct_type ? "true" : "false");
    {
        bool first = true;
        stream << ",typmods=[" << value.typmods.size() << "][";
        for (const auto& it : value.typmods)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",typemod="; stream << value.typemod;
    {
        bool first = true;
        stream << ",array_bounds=[" << value.array_bounds.size() << "][";
        for (const auto& it : value.array_bounds)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

ColumnDef::ColumnDef()
    : colname()
    , type_name(nullptr)
    , inhcount((int32_t)0ll)
    , is_local(false)
    , is_not_null(false)
    , is_from_type(false)
    , storage()
    , raw_default()
    , cooked_default()
    , identity()
    , identity_sequence(nullptr)
    , generated()
    , coll_clause(nullptr)
    , coll_oid((uint32_t)0ull)
    , constraints()
    , fdwoptions()
    , location((int32_t)0ll)
{}

ColumnDef::ColumnDef(const std::string& arg_colname, std::unique_ptr<::pg_query::TypeName> arg_type_name, int32_t arg_inhcount, bool arg_is_local, bool arg_is_not_null, bool arg_is_from_type, const std::string& arg_storage, ::pg_query::Node&& arg_raw_default, ::pg_query::Node&& arg_cooked_default, const std::string& arg_identity, std::unique_ptr<::pg_query::RangeVar> arg_identity_sequence, const std::string& arg_generated, std::unique_ptr<::pg_query::CollateClause> arg_coll_clause, uint32_t arg_coll_oid, std::vector<::pg_query::Node> arg_constraints, std::vector<::pg_query::Node> arg_fdwoptions, int32_t arg_location)
    : colname(arg_colname)
    , type_name(arg_type_name.release())
    , inhcount(arg_inhcount)
    , is_local(arg_is_local)
    , is_not_null(arg_is_not_null)
    , is_from_type(arg_is_from_type)
    , storage(arg_storage)
    , raw_default(std::move(arg_raw_default))
    , cooked_default(std::move(arg_cooked_default))
    , identity(arg_identity)
    , identity_sequence(arg_identity_sequence.release())
    , generated(arg_generated)
    , coll_clause(arg_coll_clause.release())
    , coll_oid(arg_coll_oid)
    , constraints(std::move(arg_constraints))
    , fdwoptions(std::move(arg_fdwoptions))
    , location(arg_location)
{}

ColumnDef::ColumnDef(ColumnDef&& other) noexcept
    : colname(std::move(other.colname))
    , type_name(std::exchange(other.type_name, nullptr))
    , inhcount(std::exchange(other.inhcount, (int32_t)0ll))
    , is_local(std::exchange(other.is_local, false))
    , is_not_null(std::exchange(other.is_not_null, false))
    , is_from_type(std::exchange(other.is_from_type, false))
    , storage(std::move(other.storage))
    , raw_default(std::move(other.raw_default))
    , cooked_default(std::move(other.cooked_default))
    , identity(std::move(other.identity))
    , identity_sequence(std::exchange(other.identity_sequence, nullptr))
    , generated(std::move(other.generated))
    , coll_clause(std::exchange(other.coll_clause, nullptr))
    , coll_oid(std::exchange(other.coll_oid, (uint32_t)0ull))
    , constraints(std::move(other.constraints))
    , fdwoptions(std::move(other.fdwoptions))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

ColumnDef::~ColumnDef()
{
    if (type_name) delete type_name;
    if (identity_sequence) delete identity_sequence;
    if (coll_clause) delete coll_clause;
}

bool ColumnDef::operator==([[maybe_unused]] const ColumnDef& other) const noexcept
{
    return (
        true
        );
}

bool ColumnDef::operator<([[maybe_unused]] const ColumnDef& other) const noexcept
{
    return false;
}

ColumnDef& ColumnDef::operator=(ColumnDef&& other) noexcept
{
    if (this != &other)
    {
        colname = std::move(other.colname);
        type_name = std::exchange(other.type_name, nullptr);
        inhcount = std::exchange(other.inhcount, (int32_t)0ll);
        is_local = std::exchange(other.is_local, false);
        is_not_null = std::exchange(other.is_not_null, false);
        is_from_type = std::exchange(other.is_from_type, false);
        storage = std::move(other.storage);
        raw_default = std::move(other.raw_default);
        cooked_default = std::move(other.cooked_default);
        identity = std::move(other.identity);
        identity_sequence = std::exchange(other.identity_sequence, nullptr);
        generated = std::move(other.generated);
        coll_clause = std::exchange(other.coll_clause, nullptr);
        coll_oid = std::exchange(other.coll_oid, (uint32_t)0ull);
        constraints = std::move(other.constraints);
        fdwoptions = std::move(other.fdwoptions);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string ColumnDef::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ColumnDef::swap(ColumnDef& other) noexcept
{
    using std::swap;
    swap(colname, other.colname);
    swap(type_name, other.type_name);
    swap(inhcount, other.inhcount);
    swap(is_local, other.is_local);
    swap(is_not_null, other.is_not_null);
    swap(is_from_type, other.is_from_type);
    swap(storage, other.storage);
    swap(raw_default, other.raw_default);
    swap(cooked_default, other.cooked_default);
    swap(identity, other.identity);
    swap(identity_sequence, other.identity_sequence);
    swap(generated, other.generated);
    swap(coll_clause, other.coll_clause);
    swap(coll_oid, other.coll_oid);
    swap(constraints, other.constraints);
    swap(fdwoptions, other.fdwoptions);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ColumnDef& value)
{
    stream << "ColumnDef(";
    stream << "colname="; stream << "\"" << value.colname << "\"";
    stream << ",type_name="; stream << " ptr of other struct" << (value.type_name == nullptr ? "true" : "false");
    stream << ",inhcount="; stream << value.inhcount;
    stream << ",is_local="; stream << (value.is_local ? "true" : "false");
    stream << ",is_not_null="; stream << (value.is_not_null ? "true" : "false");
    stream << ",is_from_type="; stream << (value.is_from_type ? "true" : "false");
    stream << ",storage="; stream << "\"" << value.storage << "\"";
    stream << ",raw_default="; stream << value.raw_default;
    stream << ",cooked_default="; stream << value.cooked_default;
    stream << ",identity="; stream << "\"" << value.identity << "\"";
    stream << ",identity_sequence="; stream << " ptr of other struct" << (value.identity_sequence == nullptr ? "true" : "false");
    stream << ",generated="; stream << "\"" << value.generated << "\"";
    stream << ",coll_clause="; stream << " ptr of other struct" << (value.coll_clause == nullptr ? "true" : "false");
    stream << ",coll_oid="; stream << value.coll_oid;
    {
        bool first = true;
        stream << ",constraints=[" << value.constraints.size() << "][";
        for (const auto& it : value.constraints)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",fdwoptions=[" << value.fdwoptions.size() << "][";
        for (const auto& it : value.fdwoptions)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

IndexElem::IndexElem()
    : name()
    , expr()
    , indexcolname()
    , collation()
    , opclass()
    , opclassopts()
    , ordering()
    , nulls_ordering()
{}

IndexElem::IndexElem(const std::string& arg_name, ::pg_query::Node&& arg_expr, const std::string& arg_indexcolname, std::vector<::pg_query::Node> arg_collation, std::vector<::pg_query::Node> arg_opclass, std::vector<::pg_query::Node> arg_opclassopts, ::pg_query::SortByDir&& arg_ordering, ::pg_query::SortByNulls&& arg_nulls_ordering)
    : name(arg_name)
    , expr(std::move(arg_expr))
    , indexcolname(arg_indexcolname)
    , collation(std::move(arg_collation))
    , opclass(std::move(arg_opclass))
    , opclassopts(std::move(arg_opclassopts))
    , ordering(std::move(arg_ordering))
    , nulls_ordering(std::move(arg_nulls_ordering))
{}

IndexElem::IndexElem(IndexElem&& other) noexcept
    : name(std::move(other.name))
    , expr(std::move(other.expr))
    , indexcolname(std::move(other.indexcolname))
    , collation(std::move(other.collation))
    , opclass(std::move(other.opclass))
    , opclassopts(std::move(other.opclassopts))
    , ordering(std::move(other.ordering))
    , nulls_ordering(std::move(other.nulls_ordering))
{}

IndexElem::~IndexElem()
{
}

bool IndexElem::operator==([[maybe_unused]] const IndexElem& other) const noexcept
{
    return (
        true
        );
}

bool IndexElem::operator<([[maybe_unused]] const IndexElem& other) const noexcept
{
    return false;
}

IndexElem& IndexElem::operator=(IndexElem&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
        expr = std::move(other.expr);
        indexcolname = std::move(other.indexcolname);
        collation = std::move(other.collation);
        opclass = std::move(other.opclass);
        opclassopts = std::move(other.opclassopts);
        ordering = std::move(other.ordering);
        nulls_ordering = std::move(other.nulls_ordering);
    }
    return *this;
}

std::string IndexElem::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void IndexElem::swap(IndexElem& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(expr, other.expr);
    swap(indexcolname, other.indexcolname);
    swap(collation, other.collation);
    swap(opclass, other.opclass);
    swap(opclassopts, other.opclassopts);
    swap(ordering, other.ordering);
    swap(nulls_ordering, other.nulls_ordering);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const IndexElem& value)
{
    stream << "IndexElem(";
    stream << "name="; stream << "\"" << value.name << "\"";
    stream << ",expr="; stream << value.expr;
    stream << ",indexcolname="; stream << "\"" << value.indexcolname << "\"";
    {
        bool first = true;
        stream << ",collation=[" << value.collation.size() << "][";
        for (const auto& it : value.collation)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",opclass=[" << value.opclass.size() << "][";
        for (const auto& it : value.opclass)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",opclassopts=[" << value.opclassopts.size() << "][";
        for (const auto& it : value.opclassopts)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",ordering="; stream << value.ordering;
    stream << ",nulls_ordering="; stream << value.nulls_ordering;
    stream << ")";
    return stream;
}

Constraint::Constraint()
    : contype()
    , conname()
    , deferrable(false)
    , initdeferred(false)
    , location((int32_t)0ll)
    , is_no_inherit(false)
    , raw_expr()
    , cooked_expr()
    , generated_when()
    , keys()
    , including()
    , exclusions()
    , options()
    , indexname()
    , indexspace()
    , reset_default_tblspc(false)
    , access_method()
    , where_clause()
    , pktable(nullptr)
    , fk_attrs()
    , pk_attrs()
    , fk_matchtype()
    , fk_upd_action()
    , fk_del_action()
    , old_conpfeqop()
    , old_pktable_oid((uint32_t)0ull)
    , skip_validation(false)
    , initially_valid(false)
{}

Constraint::Constraint(::pg_query::ConstrType&& arg_contype, const std::string& arg_conname, bool arg_deferrable, bool arg_initdeferred, int32_t arg_location, bool arg_is_no_inherit, ::pg_query::Node&& arg_raw_expr, const std::string& arg_cooked_expr, const std::string& arg_generated_when, std::vector<::pg_query::Node> arg_keys, std::vector<::pg_query::Node> arg_including, std::vector<::pg_query::Node> arg_exclusions, std::vector<::pg_query::Node> arg_options, const std::string& arg_indexname, const std::string& arg_indexspace, bool arg_reset_default_tblspc, const std::string& arg_access_method, ::pg_query::Node&& arg_where_clause, std::unique_ptr<::pg_query::RangeVar> arg_pktable, std::vector<::pg_query::Node> arg_fk_attrs, std::vector<::pg_query::Node> arg_pk_attrs, const std::string& arg_fk_matchtype, const std::string& arg_fk_upd_action, const std::string& arg_fk_del_action, std::vector<::pg_query::Node> arg_old_conpfeqop, uint32_t arg_old_pktable_oid, bool arg_skip_validation, bool arg_initially_valid)
    : contype(std::move(arg_contype))
    , conname(arg_conname)
    , deferrable(arg_deferrable)
    , initdeferred(arg_initdeferred)
    , location(arg_location)
    , is_no_inherit(arg_is_no_inherit)
    , raw_expr(std::move(arg_raw_expr))
    , cooked_expr(arg_cooked_expr)
    , generated_when(arg_generated_when)
    , keys(std::move(arg_keys))
    , including(std::move(arg_including))
    , exclusions(std::move(arg_exclusions))
    , options(std::move(arg_options))
    , indexname(arg_indexname)
    , indexspace(arg_indexspace)
    , reset_default_tblspc(arg_reset_default_tblspc)
    , access_method(arg_access_method)
    , where_clause(std::move(arg_where_clause))
    , pktable(arg_pktable.release())
    , fk_attrs(std::move(arg_fk_attrs))
    , pk_attrs(std::move(arg_pk_attrs))
    , fk_matchtype(arg_fk_matchtype)
    , fk_upd_action(arg_fk_upd_action)
    , fk_del_action(arg_fk_del_action)
    , old_conpfeqop(std::move(arg_old_conpfeqop))
    , old_pktable_oid(arg_old_pktable_oid)
    , skip_validation(arg_skip_validation)
    , initially_valid(arg_initially_valid)
{}

Constraint::Constraint(Constraint&& other) noexcept
    : contype(std::move(other.contype))
    , conname(std::move(other.conname))
    , deferrable(std::exchange(other.deferrable, false))
    , initdeferred(std::exchange(other.initdeferred, false))
    , location(std::exchange(other.location, (int32_t)0ll))
    , is_no_inherit(std::exchange(other.is_no_inherit, false))
    , raw_expr(std::move(other.raw_expr))
    , cooked_expr(std::move(other.cooked_expr))
    , generated_when(std::move(other.generated_when))
    , keys(std::move(other.keys))
    , including(std::move(other.including))
    , exclusions(std::move(other.exclusions))
    , options(std::move(other.options))
    , indexname(std::move(other.indexname))
    , indexspace(std::move(other.indexspace))
    , reset_default_tblspc(std::exchange(other.reset_default_tblspc, false))
    , access_method(std::move(other.access_method))
    , where_clause(std::move(other.where_clause))
    , pktable(std::exchange(other.pktable, nullptr))
    , fk_attrs(std::move(other.fk_attrs))
    , pk_attrs(std::move(other.pk_attrs))
    , fk_matchtype(std::move(other.fk_matchtype))
    , fk_upd_action(std::move(other.fk_upd_action))
    , fk_del_action(std::move(other.fk_del_action))
    , old_conpfeqop(std::move(other.old_conpfeqop))
    , old_pktable_oid(std::exchange(other.old_pktable_oid, (uint32_t)0ull))
    , skip_validation(std::exchange(other.skip_validation, false))
    , initially_valid(std::exchange(other.initially_valid, false))
{}

Constraint::~Constraint()
{
    if (pktable) delete pktable;
}

bool Constraint::operator==([[maybe_unused]] const Constraint& other) const noexcept
{
    return (
        true
        );
}

bool Constraint::operator<([[maybe_unused]] const Constraint& other) const noexcept
{
    return false;
}

Constraint& Constraint::operator=(Constraint&& other) noexcept
{
    if (this != &other)
    {
        contype = std::move(other.contype);
        conname = std::move(other.conname);
        deferrable = std::exchange(other.deferrable, false);
        initdeferred = std::exchange(other.initdeferred, false);
        location = std::exchange(other.location, (int32_t)0ll);
        is_no_inherit = std::exchange(other.is_no_inherit, false);
        raw_expr = std::move(other.raw_expr);
        cooked_expr = std::move(other.cooked_expr);
        generated_when = std::move(other.generated_when);
        keys = std::move(other.keys);
        including = std::move(other.including);
        exclusions = std::move(other.exclusions);
        options = std::move(other.options);
        indexname = std::move(other.indexname);
        indexspace = std::move(other.indexspace);
        reset_default_tblspc = std::exchange(other.reset_default_tblspc, false);
        access_method = std::move(other.access_method);
        where_clause = std::move(other.where_clause);
        pktable = std::exchange(other.pktable, nullptr);
        fk_attrs = std::move(other.fk_attrs);
        pk_attrs = std::move(other.pk_attrs);
        fk_matchtype = std::move(other.fk_matchtype);
        fk_upd_action = std::move(other.fk_upd_action);
        fk_del_action = std::move(other.fk_del_action);
        old_conpfeqop = std::move(other.old_conpfeqop);
        old_pktable_oid = std::exchange(other.old_pktable_oid, (uint32_t)0ull);
        skip_validation = std::exchange(other.skip_validation, false);
        initially_valid = std::exchange(other.initially_valid, false);
    }
    return *this;
}

std::string Constraint::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Constraint::swap(Constraint& other) noexcept
{
    using std::swap;
    swap(contype, other.contype);
    swap(conname, other.conname);
    swap(deferrable, other.deferrable);
    swap(initdeferred, other.initdeferred);
    swap(location, other.location);
    swap(is_no_inherit, other.is_no_inherit);
    swap(raw_expr, other.raw_expr);
    swap(cooked_expr, other.cooked_expr);
    swap(generated_when, other.generated_when);
    swap(keys, other.keys);
    swap(including, other.including);
    swap(exclusions, other.exclusions);
    swap(options, other.options);
    swap(indexname, other.indexname);
    swap(indexspace, other.indexspace);
    swap(reset_default_tblspc, other.reset_default_tblspc);
    swap(access_method, other.access_method);
    swap(where_clause, other.where_clause);
    swap(pktable, other.pktable);
    swap(fk_attrs, other.fk_attrs);
    swap(pk_attrs, other.pk_attrs);
    swap(fk_matchtype, other.fk_matchtype);
    swap(fk_upd_action, other.fk_upd_action);
    swap(fk_del_action, other.fk_del_action);
    swap(old_conpfeqop, other.old_conpfeqop);
    swap(old_pktable_oid, other.old_pktable_oid);
    swap(skip_validation, other.skip_validation);
    swap(initially_valid, other.initially_valid);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Constraint& value)
{
    stream << "Constraint(";
    stream << "contype="; stream << value.contype;
    stream << ",conname="; stream << "\"" << value.conname << "\"";
    stream << ",deferrable="; stream << (value.deferrable ? "true" : "false");
    stream << ",initdeferred="; stream << (value.initdeferred ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ",is_no_inherit="; stream << (value.is_no_inherit ? "true" : "false");
    stream << ",raw_expr="; stream << value.raw_expr;
    stream << ",cooked_expr="; stream << "\"" << value.cooked_expr << "\"";
    stream << ",generated_when="; stream << "\"" << value.generated_when << "\"";
    {
        bool first = true;
        stream << ",keys=[" << value.keys.size() << "][";
        for (const auto& it : value.keys)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",including=[" << value.including.size() << "][";
        for (const auto& it : value.including)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",exclusions=[" << value.exclusions.size() << "][";
        for (const auto& it : value.exclusions)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",options=[" << value.options.size() << "][";
        for (const auto& it : value.options)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",indexname="; stream << "\"" << value.indexname << "\"";
    stream << ",indexspace="; stream << "\"" << value.indexspace << "\"";
    stream << ",reset_default_tblspc="; stream << (value.reset_default_tblspc ? "true" : "false");
    stream << ",access_method="; stream << "\"" << value.access_method << "\"";
    stream << ",where_clause="; stream << value.where_clause;
    stream << ",pktable="; stream << " ptr of other struct" << (value.pktable == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",fk_attrs=[" << value.fk_attrs.size() << "][";
        for (const auto& it : value.fk_attrs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",pk_attrs=[" << value.pk_attrs.size() << "][";
        for (const auto& it : value.pk_attrs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",fk_matchtype="; stream << "\"" << value.fk_matchtype << "\"";
    stream << ",fk_upd_action="; stream << "\"" << value.fk_upd_action << "\"";
    stream << ",fk_del_action="; stream << "\"" << value.fk_del_action << "\"";
    {
        bool first = true;
        stream << ",old_conpfeqop=[" << value.old_conpfeqop.size() << "][";
        for (const auto& it : value.old_conpfeqop)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",old_pktable_oid="; stream << value.old_pktable_oid;
    stream << ",skip_validation="; stream << (value.skip_validation ? "true" : "false");
    stream << ",initially_valid="; stream << (value.initially_valid ? "true" : "false");
    stream << ")";
    return stream;
}

DefElem::DefElem()
    : defnamespace()
    , defname()
    , arg()
    , defaction()
    , location((int32_t)0ll)
{}

DefElem::DefElem(const std::string& arg_defnamespace, const std::string& arg_defname, ::pg_query::Node&& arg_arg, ::pg_query::DefElemAction&& arg_defaction, int32_t arg_location)
    : defnamespace(arg_defnamespace)
    , defname(arg_defname)
    , arg(std::move(arg_arg))
    , defaction(std::move(arg_defaction))
    , location(arg_location)
{}

DefElem::DefElem(DefElem&& other) noexcept
    : defnamespace(std::move(other.defnamespace))
    , defname(std::move(other.defname))
    , arg(std::move(other.arg))
    , defaction(std::move(other.defaction))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

DefElem::~DefElem()
{
}

bool DefElem::operator==([[maybe_unused]] const DefElem& other) const noexcept
{
    return (
        true
        );
}

bool DefElem::operator<([[maybe_unused]] const DefElem& other) const noexcept
{
    return false;
}

DefElem& DefElem::operator=(DefElem&& other) noexcept
{
    if (this != &other)
    {
        defnamespace = std::move(other.defnamespace);
        defname = std::move(other.defname);
        arg = std::move(other.arg);
        defaction = std::move(other.defaction);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string DefElem::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void DefElem::swap(DefElem& other) noexcept
{
    using std::swap;
    swap(defnamespace, other.defnamespace);
    swap(defname, other.defname);
    swap(arg, other.arg);
    swap(defaction, other.defaction);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const DefElem& value)
{
    stream << "DefElem(";
    stream << "defnamespace="; stream << "\"" << value.defnamespace << "\"";
    stream << ",defname="; stream << "\"" << value.defname << "\"";
    stream << ",arg="; stream << value.arg;
    stream << ",defaction="; stream << value.defaction;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

RangeTblEntry::RangeTblEntry()
    : rtekind()
    , relid((uint32_t)0ull)
    , relkind()
    , rellockmode((int32_t)0ll)
    , tablesample(nullptr)
    , subquery(nullptr)
    , security_barrier(false)
    , jointype()
    , joinmergedcols((int32_t)0ll)
    , joinaliasvars()
    , joinleftcols()
    , joinrightcols()
    , functions()
    , funcordinality(false)
    , tablefunc(nullptr)
    , values_lists()
    , ctename()
    , ctelevelsup((uint32_t)0ull)
    , self_reference(false)
    , coltypes()
    , coltypmods()
    , colcollations()
    , enrname()
    , enrtuples(0.0)
    , alias(nullptr)
    , eref(nullptr)
    , lateral(false)
    , inh(false)
    , in_from_cl(false)
    , required_perms((uint32_t)0ull)
    , check_as_user((uint32_t)0ull)
    , selected_cols()
    , inserted_cols()
    , updated_cols()
    , extra_updated_cols()
    , security_quals()
{}

RangeTblEntry::RangeTblEntry(::pg_query::RTEKind&& arg_rtekind, uint32_t arg_relid, const std::string& arg_relkind, int32_t arg_rellockmode, std::unique_ptr<::pg_query::TableSampleClause> arg_tablesample, std::unique_ptr<::pg_query::Query> arg_subquery, bool arg_security_barrier, ::pg_query::JoinType&& arg_jointype, int32_t arg_joinmergedcols, std::vector<::pg_query::Node> arg_joinaliasvars, std::vector<::pg_query::Node> arg_joinleftcols, std::vector<::pg_query::Node> arg_joinrightcols, std::vector<::pg_query::Node> arg_functions, bool arg_funcordinality, std::unique_ptr<::pg_query::TableFunc> arg_tablefunc, std::vector<::pg_query::Node> arg_values_lists, const std::string& arg_ctename, uint32_t arg_ctelevelsup, bool arg_self_reference, std::vector<::pg_query::Node> arg_coltypes, std::vector<::pg_query::Node> arg_coltypmods, std::vector<::pg_query::Node> arg_colcollations, const std::string& arg_enrname, double arg_enrtuples, std::unique_ptr<::pg_query::Alias> arg_alias, std::unique_ptr<::pg_query::Alias> arg_eref, bool arg_lateral, bool arg_inh, bool arg_in_from_cl, uint32_t arg_required_perms, uint32_t arg_check_as_user, std::vector<uint64_t> arg_selected_cols, std::vector<uint64_t> arg_inserted_cols, std::vector<uint64_t> arg_updated_cols, std::vector<uint64_t> arg_extra_updated_cols, std::vector<::pg_query::Node> arg_security_quals)
    : rtekind(std::move(arg_rtekind))
    , relid(arg_relid)
    , relkind(arg_relkind)
    , rellockmode(arg_rellockmode)
    , tablesample(arg_tablesample.release())
    , subquery(arg_subquery.release())
    , security_barrier(arg_security_barrier)
    , jointype(std::move(arg_jointype))
    , joinmergedcols(arg_joinmergedcols)
    , joinaliasvars(std::move(arg_joinaliasvars))
    , joinleftcols(std::move(arg_joinleftcols))
    , joinrightcols(std::move(arg_joinrightcols))
    , functions(std::move(arg_functions))
    , funcordinality(arg_funcordinality)
    , tablefunc(arg_tablefunc.release())
    , values_lists(std::move(arg_values_lists))
    , ctename(arg_ctename)
    , ctelevelsup(arg_ctelevelsup)
    , self_reference(arg_self_reference)
    , coltypes(std::move(arg_coltypes))
    , coltypmods(std::move(arg_coltypmods))
    , colcollations(std::move(arg_colcollations))
    , enrname(arg_enrname)
    , enrtuples(arg_enrtuples)
    , alias(arg_alias.release())
    , eref(arg_eref.release())
    , lateral(arg_lateral)
    , inh(arg_inh)
    , in_from_cl(arg_in_from_cl)
    , required_perms(arg_required_perms)
    , check_as_user(arg_check_as_user)
    , selected_cols(arg_selected_cols)
    , inserted_cols(arg_inserted_cols)
    , updated_cols(arg_updated_cols)
    , extra_updated_cols(arg_extra_updated_cols)
    , security_quals(std::move(arg_security_quals))
{}

RangeTblEntry::RangeTblEntry(RangeTblEntry&& other) noexcept
    : rtekind(std::move(other.rtekind))
    , relid(std::exchange(other.relid, (uint32_t)0ull))
    , relkind(std::move(other.relkind))
    , rellockmode(std::exchange(other.rellockmode, (int32_t)0ll))
    , tablesample(std::exchange(other.tablesample, nullptr))
    , subquery(std::exchange(other.subquery, nullptr))
    , security_barrier(std::exchange(other.security_barrier, false))
    , jointype(std::move(other.jointype))
    , joinmergedcols(std::exchange(other.joinmergedcols, (int32_t)0ll))
    , joinaliasvars(std::move(other.joinaliasvars))
    , joinleftcols(std::move(other.joinleftcols))
    , joinrightcols(std::move(other.joinrightcols))
    , functions(std::move(other.functions))
    , funcordinality(std::exchange(other.funcordinality, false))
    , tablefunc(std::exchange(other.tablefunc, nullptr))
    , values_lists(std::move(other.values_lists))
    , ctename(std::move(other.ctename))
    , ctelevelsup(std::exchange(other.ctelevelsup, (uint32_t)0ull))
    , self_reference(std::exchange(other.self_reference, false))
    , coltypes(std::move(other.coltypes))
    , coltypmods(std::move(other.coltypmods))
    , colcollations(std::move(other.colcollations))
    , enrname(std::move(other.enrname))
    , enrtuples(std::exchange(other.enrtuples, 0.0))
    , alias(std::exchange(other.alias, nullptr))
    , eref(std::exchange(other.eref, nullptr))
    , lateral(std::exchange(other.lateral, false))
    , inh(std::exchange(other.inh, false))
    , in_from_cl(std::exchange(other.in_from_cl, false))
    , required_perms(std::exchange(other.required_perms, (uint32_t)0ull))
    , check_as_user(std::exchange(other.check_as_user, (uint32_t)0ull))
    , selected_cols(std::move(other.selected_cols))
    , inserted_cols(std::move(other.inserted_cols))
    , updated_cols(std::move(other.updated_cols))
    , extra_updated_cols(std::move(other.extra_updated_cols))
    , security_quals(std::move(other.security_quals))
{}

RangeTblEntry::~RangeTblEntry()
{
    if (tablesample) delete tablesample;
    if (subquery) delete subquery;
    if (tablefunc) delete tablefunc;
    if (alias) delete alias;
    if (eref) delete eref;
}

bool RangeTblEntry::operator==([[maybe_unused]] const RangeTblEntry& other) const noexcept
{
    return (
        true
        );
}

bool RangeTblEntry::operator<([[maybe_unused]] const RangeTblEntry& other) const noexcept
{
    return false;
}

RangeTblEntry& RangeTblEntry::operator=(RangeTblEntry&& other) noexcept
{
    if (this != &other)
    {
        rtekind = std::move(other.rtekind);
        relid = std::exchange(other.relid, (uint32_t)0ull);
        relkind = std::move(other.relkind);
        rellockmode = std::exchange(other.rellockmode, (int32_t)0ll);
        tablesample = std::exchange(other.tablesample, nullptr);
        subquery = std::exchange(other.subquery, nullptr);
        security_barrier = std::exchange(other.security_barrier, false);
        jointype = std::move(other.jointype);
        joinmergedcols = std::exchange(other.joinmergedcols, (int32_t)0ll);
        joinaliasvars = std::move(other.joinaliasvars);
        joinleftcols = std::move(other.joinleftcols);
        joinrightcols = std::move(other.joinrightcols);
        functions = std::move(other.functions);
        funcordinality = std::exchange(other.funcordinality, false);
        tablefunc = std::exchange(other.tablefunc, nullptr);
        values_lists = std::move(other.values_lists);
        ctename = std::move(other.ctename);
        ctelevelsup = std::exchange(other.ctelevelsup, (uint32_t)0ull);
        self_reference = std::exchange(other.self_reference, false);
        coltypes = std::move(other.coltypes);
        coltypmods = std::move(other.coltypmods);
        colcollations = std::move(other.colcollations);
        enrname = std::move(other.enrname);
        enrtuples = std::exchange(other.enrtuples, 0.0);
        alias = std::exchange(other.alias, nullptr);
        eref = std::exchange(other.eref, nullptr);
        lateral = std::exchange(other.lateral, false);
        inh = std::exchange(other.inh, false);
        in_from_cl = std::exchange(other.in_from_cl, false);
        required_perms = std::exchange(other.required_perms, (uint32_t)0ull);
        check_as_user = std::exchange(other.check_as_user, (uint32_t)0ull);
        selected_cols = std::move(other.selected_cols);
        inserted_cols = std::move(other.inserted_cols);
        updated_cols = std::move(other.updated_cols);
        extra_updated_cols = std::move(other.extra_updated_cols);
        security_quals = std::move(other.security_quals);
    }
    return *this;
}

std::string RangeTblEntry::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RangeTblEntry::swap(RangeTblEntry& other) noexcept
{
    using std::swap;
    swap(rtekind, other.rtekind);
    swap(relid, other.relid);
    swap(relkind, other.relkind);
    swap(rellockmode, other.rellockmode);
    swap(tablesample, other.tablesample);
    swap(subquery, other.subquery);
    swap(security_barrier, other.security_barrier);
    swap(jointype, other.jointype);
    swap(joinmergedcols, other.joinmergedcols);
    swap(joinaliasvars, other.joinaliasvars);
    swap(joinleftcols, other.joinleftcols);
    swap(joinrightcols, other.joinrightcols);
    swap(functions, other.functions);
    swap(funcordinality, other.funcordinality);
    swap(tablefunc, other.tablefunc);
    swap(values_lists, other.values_lists);
    swap(ctename, other.ctename);
    swap(ctelevelsup, other.ctelevelsup);
    swap(self_reference, other.self_reference);
    swap(coltypes, other.coltypes);
    swap(coltypmods, other.coltypmods);
    swap(colcollations, other.colcollations);
    swap(enrname, other.enrname);
    swap(enrtuples, other.enrtuples);
    swap(alias, other.alias);
    swap(eref, other.eref);
    swap(lateral, other.lateral);
    swap(inh, other.inh);
    swap(in_from_cl, other.in_from_cl);
    swap(required_perms, other.required_perms);
    swap(check_as_user, other.check_as_user);
    swap(selected_cols, other.selected_cols);
    swap(inserted_cols, other.inserted_cols);
    swap(updated_cols, other.updated_cols);
    swap(extra_updated_cols, other.extra_updated_cols);
    swap(security_quals, other.security_quals);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RangeTblEntry& value)
{
    stream << "RangeTblEntry(";
    stream << "rtekind="; stream << value.rtekind;
    stream << ",relid="; stream << value.relid;
    stream << ",relkind="; stream << "\"" << value.relkind << "\"";
    stream << ",rellockmode="; stream << value.rellockmode;
    stream << ",tablesample="; stream << " ptr of other struct" << (value.tablesample == nullptr ? "true" : "false");
    stream << ",subquery="; stream << " ptr of other struct" << (value.subquery == nullptr ? "true" : "false");
    stream << ",security_barrier="; stream << (value.security_barrier ? "true" : "false");
    stream << ",jointype="; stream << value.jointype;
    stream << ",joinmergedcols="; stream << value.joinmergedcols;
    {
        bool first = true;
        stream << ",joinaliasvars=[" << value.joinaliasvars.size() << "][";
        for (const auto& it : value.joinaliasvars)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",joinleftcols=[" << value.joinleftcols.size() << "][";
        for (const auto& it : value.joinleftcols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",joinrightcols=[" << value.joinrightcols.size() << "][";
        for (const auto& it : value.joinrightcols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",functions=[" << value.functions.size() << "][";
        for (const auto& it : value.functions)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",funcordinality="; stream << (value.funcordinality ? "true" : "false");
    stream << ",tablefunc="; stream << " ptr of other struct" << (value.tablefunc == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",values_lists=[" << value.values_lists.size() << "][";
        for (const auto& it : value.values_lists)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",ctename="; stream << "\"" << value.ctename << "\"";
    stream << ",ctelevelsup="; stream << value.ctelevelsup;
    stream << ",self_reference="; stream << (value.self_reference ? "true" : "false");
    {
        bool first = true;
        stream << ",coltypes=[" << value.coltypes.size() << "][";
        for (const auto& it : value.coltypes)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",coltypmods=[" << value.coltypmods.size() << "][";
        for (const auto& it : value.coltypmods)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",colcollations=[" << value.colcollations.size() << "][";
        for (const auto& it : value.colcollations)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",enrname="; stream << "\"" << value.enrname << "\"";
    stream << ",enrtuples="; stream << value.enrtuples;
    stream << ",alias="; stream << " ptr of other struct" << (value.alias == nullptr ? "true" : "false");
    stream << ",eref="; stream << " ptr of other struct" << (value.eref == nullptr ? "true" : "false");
    stream << ",lateral="; stream << (value.lateral ? "true" : "false");
    stream << ",inh="; stream << (value.inh ? "true" : "false");
    stream << ",in_from_cl="; stream << (value.in_from_cl ? "true" : "false");
    stream << ",required_perms="; stream << value.required_perms;
    stream << ",check_as_user="; stream << value.check_as_user;
    {
        bool first = true;
        stream << ",selected_cols=[" << value.selected_cols.size() << "][";
        for (const auto& it : value.selected_cols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",inserted_cols=[" << value.inserted_cols.size() << "][";
        for (const auto& it : value.inserted_cols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",updated_cols=[" << value.updated_cols.size() << "][";
        for (const auto& it : value.updated_cols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",extra_updated_cols=[" << value.extra_updated_cols.size() << "][";
        for (const auto& it : value.extra_updated_cols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",security_quals=[" << value.security_quals.size() << "][";
        for (const auto& it : value.security_quals)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

RangeTblFunction::RangeTblFunction()
    : funcexpr()
    , funccolcount((int32_t)0ll)
    , funccolnames()
    , funccoltypes()
    , funccoltypmods()
    , funccolcollations()
    , funcparams()
{}

RangeTblFunction::RangeTblFunction(::pg_query::Node&& arg_funcexpr, int32_t arg_funccolcount, std::vector<::pg_query::Node> arg_funccolnames, std::vector<::pg_query::Node> arg_funccoltypes, std::vector<::pg_query::Node> arg_funccoltypmods, std::vector<::pg_query::Node> arg_funccolcollations, std::vector<uint64_t> arg_funcparams)
    : funcexpr(std::move(arg_funcexpr))
    , funccolcount(arg_funccolcount)
    , funccolnames(std::move(arg_funccolnames))
    , funccoltypes(std::move(arg_funccoltypes))
    , funccoltypmods(std::move(arg_funccoltypmods))
    , funccolcollations(std::move(arg_funccolcollations))
    , funcparams(arg_funcparams)
{}

RangeTblFunction::RangeTblFunction(RangeTblFunction&& other) noexcept
    : funcexpr(std::move(other.funcexpr))
    , funccolcount(std::exchange(other.funccolcount, (int32_t)0ll))
    , funccolnames(std::move(other.funccolnames))
    , funccoltypes(std::move(other.funccoltypes))
    , funccoltypmods(std::move(other.funccoltypmods))
    , funccolcollations(std::move(other.funccolcollations))
    , funcparams(std::move(other.funcparams))
{}

RangeTblFunction::~RangeTblFunction()
{
}

bool RangeTblFunction::operator==([[maybe_unused]] const RangeTblFunction& other) const noexcept
{
    return (
        true
        );
}

bool RangeTblFunction::operator<([[maybe_unused]] const RangeTblFunction& other) const noexcept
{
    return false;
}

RangeTblFunction& RangeTblFunction::operator=(RangeTblFunction&& other) noexcept
{
    if (this != &other)
    {
        funcexpr = std::move(other.funcexpr);
        funccolcount = std::exchange(other.funccolcount, (int32_t)0ll);
        funccolnames = std::move(other.funccolnames);
        funccoltypes = std::move(other.funccoltypes);
        funccoltypmods = std::move(other.funccoltypmods);
        funccolcollations = std::move(other.funccolcollations);
        funcparams = std::move(other.funcparams);
    }
    return *this;
}

std::string RangeTblFunction::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RangeTblFunction::swap(RangeTblFunction& other) noexcept
{
    using std::swap;
    swap(funcexpr, other.funcexpr);
    swap(funccolcount, other.funccolcount);
    swap(funccolnames, other.funccolnames);
    swap(funccoltypes, other.funccoltypes);
    swap(funccoltypmods, other.funccoltypmods);
    swap(funccolcollations, other.funccolcollations);
    swap(funcparams, other.funcparams);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RangeTblFunction& value)
{
    stream << "RangeTblFunction(";
    stream << "funcexpr="; stream << value.funcexpr;
    stream << ",funccolcount="; stream << value.funccolcount;
    {
        bool first = true;
        stream << ",funccolnames=[" << value.funccolnames.size() << "][";
        for (const auto& it : value.funccolnames)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",funccoltypes=[" << value.funccoltypes.size() << "][";
        for (const auto& it : value.funccoltypes)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",funccoltypmods=[" << value.funccoltypmods.size() << "][";
        for (const auto& it : value.funccoltypmods)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",funccolcollations=[" << value.funccolcollations.size() << "][";
        for (const auto& it : value.funccolcollations)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",funcparams=[" << value.funcparams.size() << "][";
        for (const auto& it : value.funcparams)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

TableSampleClause::TableSampleClause()
    : tsmhandler((uint32_t)0ull)
    , args()
    , repeatable()
{}

TableSampleClause::TableSampleClause(uint32_t arg_tsmhandler, std::vector<::pg_query::Node> arg_args, ::pg_query::Node&& arg_repeatable)
    : tsmhandler(arg_tsmhandler)
    , args(std::move(arg_args))
    , repeatable(std::move(arg_repeatable))
{}

TableSampleClause::TableSampleClause(TableSampleClause&& other) noexcept
    : tsmhandler(std::exchange(other.tsmhandler, (uint32_t)0ull))
    , args(std::move(other.args))
    , repeatable(std::move(other.repeatable))
{}

TableSampleClause::~TableSampleClause()
{
}

bool TableSampleClause::operator==([[maybe_unused]] const TableSampleClause& other) const noexcept
{
    return (
        true
        );
}

bool TableSampleClause::operator<([[maybe_unused]] const TableSampleClause& other) const noexcept
{
    return false;
}

TableSampleClause& TableSampleClause::operator=(TableSampleClause&& other) noexcept
{
    if (this != &other)
    {
        tsmhandler = std::exchange(other.tsmhandler, (uint32_t)0ull);
        args = std::move(other.args);
        repeatable = std::move(other.repeatable);
    }
    return *this;
}

std::string TableSampleClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void TableSampleClause::swap(TableSampleClause& other) noexcept
{
    using std::swap;
    swap(tsmhandler, other.tsmhandler);
    swap(args, other.args);
    swap(repeatable, other.repeatable);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const TableSampleClause& value)
{
    stream << "TableSampleClause(";
    stream << "tsmhandler="; stream << value.tsmhandler;
    {
        bool first = true;
        stream << ",args=[" << value.args.size() << "][";
        for (const auto& it : value.args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",repeatable="; stream << value.repeatable;
    stream << ")";
    return stream;
}

WithCheckOption::WithCheckOption()
    : kind()
    , relname()
    , polname()
    , qual()
    , cascaded(false)
{}

WithCheckOption::WithCheckOption(::pg_query::WCOKind&& arg_kind, const std::string& arg_relname, const std::string& arg_polname, ::pg_query::Node&& arg_qual, bool arg_cascaded)
    : kind(std::move(arg_kind))
    , relname(arg_relname)
    , polname(arg_polname)
    , qual(std::move(arg_qual))
    , cascaded(arg_cascaded)
{}

WithCheckOption::WithCheckOption(WithCheckOption&& other) noexcept
    : kind(std::move(other.kind))
    , relname(std::move(other.relname))
    , polname(std::move(other.polname))
    , qual(std::move(other.qual))
    , cascaded(std::exchange(other.cascaded, false))
{}

WithCheckOption::~WithCheckOption()
{
}

bool WithCheckOption::operator==([[maybe_unused]] const WithCheckOption& other) const noexcept
{
    return (
        true
        );
}

bool WithCheckOption::operator<([[maybe_unused]] const WithCheckOption& other) const noexcept
{
    return false;
}

WithCheckOption& WithCheckOption::operator=(WithCheckOption&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        relname = std::move(other.relname);
        polname = std::move(other.polname);
        qual = std::move(other.qual);
        cascaded = std::exchange(other.cascaded, false);
    }
    return *this;
}

std::string WithCheckOption::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void WithCheckOption::swap(WithCheckOption& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(relname, other.relname);
    swap(polname, other.polname);
    swap(qual, other.qual);
    swap(cascaded, other.cascaded);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const WithCheckOption& value)
{
    stream << "WithCheckOption(";
    stream << "kind="; stream << value.kind;
    stream << ",relname="; stream << "\"" << value.relname << "\"";
    stream << ",polname="; stream << "\"" << value.polname << "\"";
    stream << ",qual="; stream << value.qual;
    stream << ",cascaded="; stream << (value.cascaded ? "true" : "false");
    stream << ")";
    return stream;
}

SortGroupClause::SortGroupClause()
    : tle_sort_group_ref((uint32_t)0ull)
    , eqop((uint32_t)0ull)
    , sortop((uint32_t)0ull)
    , nulls_first(false)
    , hashable(false)
{}

SortGroupClause::SortGroupClause(uint32_t arg_tle_sort_group_ref, uint32_t arg_eqop, uint32_t arg_sortop, bool arg_nulls_first, bool arg_hashable)
    : tle_sort_group_ref(arg_tle_sort_group_ref)
    , eqop(arg_eqop)
    , sortop(arg_sortop)
    , nulls_first(arg_nulls_first)
    , hashable(arg_hashable)
{}

SortGroupClause::SortGroupClause(SortGroupClause&& other) noexcept
    : tle_sort_group_ref(std::exchange(other.tle_sort_group_ref, (uint32_t)0ull))
    , eqop(std::exchange(other.eqop, (uint32_t)0ull))
    , sortop(std::exchange(other.sortop, (uint32_t)0ull))
    , nulls_first(std::exchange(other.nulls_first, false))
    , hashable(std::exchange(other.hashable, false))
{}

SortGroupClause::~SortGroupClause()
{
}

bool SortGroupClause::operator==([[maybe_unused]] const SortGroupClause& other) const noexcept
{
    return (
        true
        );
}

bool SortGroupClause::operator<([[maybe_unused]] const SortGroupClause& other) const noexcept
{
    return false;
}

SortGroupClause& SortGroupClause::operator=(SortGroupClause&& other) noexcept
{
    if (this != &other)
    {
        tle_sort_group_ref = std::exchange(other.tle_sort_group_ref, (uint32_t)0ull);
        eqop = std::exchange(other.eqop, (uint32_t)0ull);
        sortop = std::exchange(other.sortop, (uint32_t)0ull);
        nulls_first = std::exchange(other.nulls_first, false);
        hashable = std::exchange(other.hashable, false);
    }
    return *this;
}

std::string SortGroupClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void SortGroupClause::swap(SortGroupClause& other) noexcept
{
    using std::swap;
    swap(tle_sort_group_ref, other.tle_sort_group_ref);
    swap(eqop, other.eqop);
    swap(sortop, other.sortop);
    swap(nulls_first, other.nulls_first);
    swap(hashable, other.hashable);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const SortGroupClause& value)
{
    stream << "SortGroupClause(";
    stream << "tle_sort_group_ref="; stream << value.tle_sort_group_ref;
    stream << ",eqop="; stream << value.eqop;
    stream << ",sortop="; stream << value.sortop;
    stream << ",nulls_first="; stream << (value.nulls_first ? "true" : "false");
    stream << ",hashable="; stream << (value.hashable ? "true" : "false");
    stream << ")";
    return stream;
}

GroupingSet::GroupingSet()
    : kind()
    , content()
    , location((int32_t)0ll)
{}

GroupingSet::GroupingSet(::pg_query::GroupingSetKind&& arg_kind, std::vector<::pg_query::Node> arg_content, int32_t arg_location)
    : kind(std::move(arg_kind))
    , content(std::move(arg_content))
    , location(arg_location)
{}

GroupingSet::GroupingSet(GroupingSet&& other) noexcept
    : kind(std::move(other.kind))
    , content(std::move(other.content))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

GroupingSet::~GroupingSet()
{
}

bool GroupingSet::operator==([[maybe_unused]] const GroupingSet& other) const noexcept
{
    return (
        true
        );
}

bool GroupingSet::operator<([[maybe_unused]] const GroupingSet& other) const noexcept
{
    return false;
}

GroupingSet& GroupingSet::operator=(GroupingSet&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        content = std::move(other.content);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string GroupingSet::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void GroupingSet::swap(GroupingSet& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(content, other.content);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const GroupingSet& value)
{
    stream << "GroupingSet(";
    stream << "kind="; stream << value.kind;
    {
        bool first = true;
        stream << ",content=[" << value.content.size() << "][";
        for (const auto& it : value.content)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

WindowClause::WindowClause()
    : name()
    , refname()
    , partition_clause()
    , order_clause()
    , frame_options((int32_t)0ll)
    , start_offset()
    , end_offset()
    , start_in_range_func((uint32_t)0ull)
    , end_in_range_func((uint32_t)0ull)
    , in_range_coll((uint32_t)0ull)
    , in_range_asc(false)
    , in_range_nulls_first(false)
    , winref((uint32_t)0ull)
    , copied_order(false)
{}

WindowClause::WindowClause(const std::string& arg_name, const std::string& arg_refname, std::vector<::pg_query::Node> arg_partition_clause, std::vector<::pg_query::Node> arg_order_clause, int32_t arg_frame_options, ::pg_query::Node&& arg_start_offset, ::pg_query::Node&& arg_end_offset, uint32_t arg_start_in_range_func, uint32_t arg_end_in_range_func, uint32_t arg_in_range_coll, bool arg_in_range_asc, bool arg_in_range_nulls_first, uint32_t arg_winref, bool arg_copied_order)
    : name(arg_name)
    , refname(arg_refname)
    , partition_clause(std::move(arg_partition_clause))
    , order_clause(std::move(arg_order_clause))
    , frame_options(arg_frame_options)
    , start_offset(std::move(arg_start_offset))
    , end_offset(std::move(arg_end_offset))
    , start_in_range_func(arg_start_in_range_func)
    , end_in_range_func(arg_end_in_range_func)
    , in_range_coll(arg_in_range_coll)
    , in_range_asc(arg_in_range_asc)
    , in_range_nulls_first(arg_in_range_nulls_first)
    , winref(arg_winref)
    , copied_order(arg_copied_order)
{}

WindowClause::WindowClause(WindowClause&& other) noexcept
    : name(std::move(other.name))
    , refname(std::move(other.refname))
    , partition_clause(std::move(other.partition_clause))
    , order_clause(std::move(other.order_clause))
    , frame_options(std::exchange(other.frame_options, (int32_t)0ll))
    , start_offset(std::move(other.start_offset))
    , end_offset(std::move(other.end_offset))
    , start_in_range_func(std::exchange(other.start_in_range_func, (uint32_t)0ull))
    , end_in_range_func(std::exchange(other.end_in_range_func, (uint32_t)0ull))
    , in_range_coll(std::exchange(other.in_range_coll, (uint32_t)0ull))
    , in_range_asc(std::exchange(other.in_range_asc, false))
    , in_range_nulls_first(std::exchange(other.in_range_nulls_first, false))
    , winref(std::exchange(other.winref, (uint32_t)0ull))
    , copied_order(std::exchange(other.copied_order, false))
{}

WindowClause::~WindowClause()
{
}

bool WindowClause::operator==([[maybe_unused]] const WindowClause& other) const noexcept
{
    return (
        true
        );
}

bool WindowClause::operator<([[maybe_unused]] const WindowClause& other) const noexcept
{
    return false;
}

WindowClause& WindowClause::operator=(WindowClause&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
        refname = std::move(other.refname);
        partition_clause = std::move(other.partition_clause);
        order_clause = std::move(other.order_clause);
        frame_options = std::exchange(other.frame_options, (int32_t)0ll);
        start_offset = std::move(other.start_offset);
        end_offset = std::move(other.end_offset);
        start_in_range_func = std::exchange(other.start_in_range_func, (uint32_t)0ull);
        end_in_range_func = std::exchange(other.end_in_range_func, (uint32_t)0ull);
        in_range_coll = std::exchange(other.in_range_coll, (uint32_t)0ull);
        in_range_asc = std::exchange(other.in_range_asc, false);
        in_range_nulls_first = std::exchange(other.in_range_nulls_first, false);
        winref = std::exchange(other.winref, (uint32_t)0ull);
        copied_order = std::exchange(other.copied_order, false);
    }
    return *this;
}

std::string WindowClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void WindowClause::swap(WindowClause& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(refname, other.refname);
    swap(partition_clause, other.partition_clause);
    swap(order_clause, other.order_clause);
    swap(frame_options, other.frame_options);
    swap(start_offset, other.start_offset);
    swap(end_offset, other.end_offset);
    swap(start_in_range_func, other.start_in_range_func);
    swap(end_in_range_func, other.end_in_range_func);
    swap(in_range_coll, other.in_range_coll);
    swap(in_range_asc, other.in_range_asc);
    swap(in_range_nulls_first, other.in_range_nulls_first);
    swap(winref, other.winref);
    swap(copied_order, other.copied_order);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const WindowClause& value)
{
    stream << "WindowClause(";
    stream << "name="; stream << "\"" << value.name << "\"";
    stream << ",refname="; stream << "\"" << value.refname << "\"";
    {
        bool first = true;
        stream << ",partition_clause=[" << value.partition_clause.size() << "][";
        for (const auto& it : value.partition_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",order_clause=[" << value.order_clause.size() << "][";
        for (const auto& it : value.order_clause)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",frame_options="; stream << value.frame_options;
    stream << ",start_offset="; stream << value.start_offset;
    stream << ",end_offset="; stream << value.end_offset;
    stream << ",start_in_range_func="; stream << value.start_in_range_func;
    stream << ",end_in_range_func="; stream << value.end_in_range_func;
    stream << ",in_range_coll="; stream << value.in_range_coll;
    stream << ",in_range_asc="; stream << (value.in_range_asc ? "true" : "false");
    stream << ",in_range_nulls_first="; stream << (value.in_range_nulls_first ? "true" : "false");
    stream << ",winref="; stream << value.winref;
    stream << ",copied_order="; stream << (value.copied_order ? "true" : "false");
    stream << ")";
    return stream;
}

ObjectWithArgs::ObjectWithArgs()
    : objname()
    , objargs()
    , args_unspecified(false)
{}

ObjectWithArgs::ObjectWithArgs(std::vector<::pg_query::Node> arg_objname, std::vector<::pg_query::Node> arg_objargs, bool arg_args_unspecified)
    : objname(std::move(arg_objname))
    , objargs(std::move(arg_objargs))
    , args_unspecified(arg_args_unspecified)
{}

ObjectWithArgs::ObjectWithArgs(ObjectWithArgs&& other) noexcept
    : objname(std::move(other.objname))
    , objargs(std::move(other.objargs))
    , args_unspecified(std::exchange(other.args_unspecified, false))
{}

ObjectWithArgs::~ObjectWithArgs()
{
}

bool ObjectWithArgs::operator==([[maybe_unused]] const ObjectWithArgs& other) const noexcept
{
    return (
        true
        );
}

bool ObjectWithArgs::operator<([[maybe_unused]] const ObjectWithArgs& other) const noexcept
{
    return false;
}

ObjectWithArgs& ObjectWithArgs::operator=(ObjectWithArgs&& other) noexcept
{
    if (this != &other)
    {
        objname = std::move(other.objname);
        objargs = std::move(other.objargs);
        args_unspecified = std::exchange(other.args_unspecified, false);
    }
    return *this;
}

std::string ObjectWithArgs::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ObjectWithArgs::swap(ObjectWithArgs& other) noexcept
{
    using std::swap;
    swap(objname, other.objname);
    swap(objargs, other.objargs);
    swap(args_unspecified, other.args_unspecified);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ObjectWithArgs& value)
{
    stream << "ObjectWithArgs(";
    {
        bool first = true;
        stream << "objname=[" << value.objname.size() << "][";
        for (const auto& it : value.objname)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",objargs=[" << value.objargs.size() << "][";
        for (const auto& it : value.objargs)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",args_unspecified="; stream << (value.args_unspecified ? "true" : "false");
    stream << ")";
    return stream;
}

AccessPriv::AccessPriv()
    : priv_name()
    , cols()
{}

AccessPriv::AccessPriv(const std::string& arg_priv_name, std::vector<::pg_query::Node> arg_cols)
    : priv_name(arg_priv_name)
    , cols(std::move(arg_cols))
{}

AccessPriv::AccessPriv(AccessPriv&& other) noexcept
    : priv_name(std::move(other.priv_name))
    , cols(std::move(other.cols))
{}

AccessPriv::~AccessPriv()
{
}

bool AccessPriv::operator==([[maybe_unused]] const AccessPriv& other) const noexcept
{
    return (
        true
        );
}

bool AccessPriv::operator<([[maybe_unused]] const AccessPriv& other) const noexcept
{
    return false;
}

AccessPriv& AccessPriv::operator=(AccessPriv&& other) noexcept
{
    if (this != &other)
    {
        priv_name = std::move(other.priv_name);
        cols = std::move(other.cols);
    }
    return *this;
}

std::string AccessPriv::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void AccessPriv::swap(AccessPriv& other) noexcept
{
    using std::swap;
    swap(priv_name, other.priv_name);
    swap(cols, other.cols);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const AccessPriv& value)
{
    stream << "AccessPriv(";
    stream << "priv_name="; stream << "\"" << value.priv_name << "\"";
    {
        bool first = true;
        stream << ",cols=[" << value.cols.size() << "][";
        for (const auto& it : value.cols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

CreateOpClassItem::CreateOpClassItem()
    : itemtype((int32_t)0ll)
    , name(nullptr)
    , number((int32_t)0ll)
    , order_family()
    , class_args()
    , storedtype(nullptr)
{}

CreateOpClassItem::CreateOpClassItem(int32_t arg_itemtype, std::unique_ptr<::pg_query::ObjectWithArgs> arg_name, int32_t arg_number, std::vector<::pg_query::Node> arg_order_family, std::vector<::pg_query::Node> arg_class_args, std::unique_ptr<::pg_query::TypeName> arg_storedtype)
    : itemtype(arg_itemtype)
    , name(arg_name.release())
    , number(arg_number)
    , order_family(std::move(arg_order_family))
    , class_args(std::move(arg_class_args))
    , storedtype(arg_storedtype.release())
{}

CreateOpClassItem::CreateOpClassItem(CreateOpClassItem&& other) noexcept
    : itemtype(std::exchange(other.itemtype, (int32_t)0ll))
    , name(std::exchange(other.name, nullptr))
    , number(std::exchange(other.number, (int32_t)0ll))
    , order_family(std::move(other.order_family))
    , class_args(std::move(other.class_args))
    , storedtype(std::exchange(other.storedtype, nullptr))
{}

CreateOpClassItem::~CreateOpClassItem()
{
    if (name) delete name;
    if (storedtype) delete storedtype;
}

bool CreateOpClassItem::operator==([[maybe_unused]] const CreateOpClassItem& other) const noexcept
{
    return (
        true
        );
}

bool CreateOpClassItem::operator<([[maybe_unused]] const CreateOpClassItem& other) const noexcept
{
    return false;
}

CreateOpClassItem& CreateOpClassItem::operator=(CreateOpClassItem&& other) noexcept
{
    if (this != &other)
    {
        itemtype = std::exchange(other.itemtype, (int32_t)0ll);
        name = std::exchange(other.name, nullptr);
        number = std::exchange(other.number, (int32_t)0ll);
        order_family = std::move(other.order_family);
        class_args = std::move(other.class_args);
        storedtype = std::exchange(other.storedtype, nullptr);
    }
    return *this;
}

std::string CreateOpClassItem::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CreateOpClassItem::swap(CreateOpClassItem& other) noexcept
{
    using std::swap;
    swap(itemtype, other.itemtype);
    swap(name, other.name);
    swap(number, other.number);
    swap(order_family, other.order_family);
    swap(class_args, other.class_args);
    swap(storedtype, other.storedtype);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CreateOpClassItem& value)
{
    stream << "CreateOpClassItem(";
    stream << "itemtype="; stream << value.itemtype;
    stream << ",name="; stream << " ptr of other struct" << (value.name == nullptr ? "true" : "false");
    stream << ",number="; stream << value.number;
    {
        bool first = true;
        stream << ",order_family=[" << value.order_family.size() << "][";
        for (const auto& it : value.order_family)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",class_args=[" << value.class_args.size() << "][";
        for (const auto& it : value.class_args)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",storedtype="; stream << " ptr of other struct" << (value.storedtype == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

TableLikeClause::TableLikeClause()
    : relation(nullptr)
    , options((uint32_t)0ull)
    , relation_oid((uint32_t)0ull)
{}

TableLikeClause::TableLikeClause(std::unique_ptr<::pg_query::RangeVar> arg_relation, uint32_t arg_options, uint32_t arg_relation_oid)
    : relation(arg_relation.release())
    , options(arg_options)
    , relation_oid(arg_relation_oid)
{}

TableLikeClause::TableLikeClause(TableLikeClause&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , options(std::exchange(other.options, (uint32_t)0ull))
    , relation_oid(std::exchange(other.relation_oid, (uint32_t)0ull))
{}

TableLikeClause::~TableLikeClause()
{
    if (relation) delete relation;
}

bool TableLikeClause::operator==([[maybe_unused]] const TableLikeClause& other) const noexcept
{
    return (
        true
        );
}

bool TableLikeClause::operator<([[maybe_unused]] const TableLikeClause& other) const noexcept
{
    return false;
}

TableLikeClause& TableLikeClause::operator=(TableLikeClause&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        options = std::exchange(other.options, (uint32_t)0ull);
        relation_oid = std::exchange(other.relation_oid, (uint32_t)0ull);
    }
    return *this;
}

std::string TableLikeClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void TableLikeClause::swap(TableLikeClause& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(options, other.options);
    swap(relation_oid, other.relation_oid);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const TableLikeClause& value)
{
    stream << "TableLikeClause(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",options="; stream << value.options;
    stream << ",relation_oid="; stream << value.relation_oid;
    stream << ")";
    return stream;
}

FunctionParameter::FunctionParameter()
    : name()
    , arg_type(nullptr)
    , mode()
    , defexpr()
{}

FunctionParameter::FunctionParameter(const std::string& arg_name, std::unique_ptr<::pg_query::TypeName> arg_arg_type, ::pg_query::FunctionParameterMode&& arg_mode, ::pg_query::Node&& arg_defexpr)
    : name(arg_name)
    , arg_type(arg_arg_type.release())
    , mode(std::move(arg_mode))
    , defexpr(std::move(arg_defexpr))
{}

FunctionParameter::FunctionParameter(FunctionParameter&& other) noexcept
    : name(std::move(other.name))
    , arg_type(std::exchange(other.arg_type, nullptr))
    , mode(std::move(other.mode))
    , defexpr(std::move(other.defexpr))
{}

FunctionParameter::~FunctionParameter()
{
    if (arg_type) delete arg_type;
}

bool FunctionParameter::operator==([[maybe_unused]] const FunctionParameter& other) const noexcept
{
    return (
        true
        );
}

bool FunctionParameter::operator<([[maybe_unused]] const FunctionParameter& other) const noexcept
{
    return false;
}

FunctionParameter& FunctionParameter::operator=(FunctionParameter&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
        arg_type = std::exchange(other.arg_type, nullptr);
        mode = std::move(other.mode);
        defexpr = std::move(other.defexpr);
    }
    return *this;
}

std::string FunctionParameter::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void FunctionParameter::swap(FunctionParameter& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(arg_type, other.arg_type);
    swap(mode, other.mode);
    swap(defexpr, other.defexpr);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const FunctionParameter& value)
{
    stream << "FunctionParameter(";
    stream << "name="; stream << "\"" << value.name << "\"";
    stream << ",arg_type="; stream << " ptr of other struct" << (value.arg_type == nullptr ? "true" : "false");
    stream << ",mode="; stream << value.mode;
    stream << ",defexpr="; stream << value.defexpr;
    stream << ")";
    return stream;
}

LockingClause::LockingClause()
    : locked_rels()
    , strength()
    , wait_policy()
{}

LockingClause::LockingClause(std::vector<::pg_query::Node> arg_locked_rels, ::pg_query::LockClauseStrength&& arg_strength, ::pg_query::LockWaitPolicy&& arg_wait_policy)
    : locked_rels(std::move(arg_locked_rels))
    , strength(std::move(arg_strength))
    , wait_policy(std::move(arg_wait_policy))
{}

LockingClause::LockingClause(LockingClause&& other) noexcept
    : locked_rels(std::move(other.locked_rels))
    , strength(std::move(other.strength))
    , wait_policy(std::move(other.wait_policy))
{}

LockingClause::~LockingClause()
{
}

bool LockingClause::operator==([[maybe_unused]] const LockingClause& other) const noexcept
{
    return (
        true
        );
}

bool LockingClause::operator<([[maybe_unused]] const LockingClause& other) const noexcept
{
    return false;
}

LockingClause& LockingClause::operator=(LockingClause&& other) noexcept
{
    if (this != &other)
    {
        locked_rels = std::move(other.locked_rels);
        strength = std::move(other.strength);
        wait_policy = std::move(other.wait_policy);
    }
    return *this;
}

std::string LockingClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void LockingClause::swap(LockingClause& other) noexcept
{
    using std::swap;
    swap(locked_rels, other.locked_rels);
    swap(strength, other.strength);
    swap(wait_policy, other.wait_policy);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const LockingClause& value)
{
    stream << "LockingClause(";
    {
        bool first = true;
        stream << "locked_rels=[" << value.locked_rels.size() << "][";
        for (const auto& it : value.locked_rels)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",strength="; stream << value.strength;
    stream << ",wait_policy="; stream << value.wait_policy;
    stream << ")";
    return stream;
}

RowMarkClause::RowMarkClause()
    : rti((uint32_t)0ull)
    , strength()
    , wait_policy()
    , pushed_down(false)
{}

RowMarkClause::RowMarkClause(uint32_t arg_rti, ::pg_query::LockClauseStrength&& arg_strength, ::pg_query::LockWaitPolicy&& arg_wait_policy, bool arg_pushed_down)
    : rti(arg_rti)
    , strength(std::move(arg_strength))
    , wait_policy(std::move(arg_wait_policy))
    , pushed_down(arg_pushed_down)
{}

RowMarkClause::RowMarkClause(RowMarkClause&& other) noexcept
    : rti(std::exchange(other.rti, (uint32_t)0ull))
    , strength(std::move(other.strength))
    , wait_policy(std::move(other.wait_policy))
    , pushed_down(std::exchange(other.pushed_down, false))
{}

RowMarkClause::~RowMarkClause()
{
}

bool RowMarkClause::operator==([[maybe_unused]] const RowMarkClause& other) const noexcept
{
    return (
        true
        );
}

bool RowMarkClause::operator<([[maybe_unused]] const RowMarkClause& other) const noexcept
{
    return false;
}

RowMarkClause& RowMarkClause::operator=(RowMarkClause&& other) noexcept
{
    if (this != &other)
    {
        rti = std::exchange(other.rti, (uint32_t)0ull);
        strength = std::move(other.strength);
        wait_policy = std::move(other.wait_policy);
        pushed_down = std::exchange(other.pushed_down, false);
    }
    return *this;
}

std::string RowMarkClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RowMarkClause::swap(RowMarkClause& other) noexcept
{
    using std::swap;
    swap(rti, other.rti);
    swap(strength, other.strength);
    swap(wait_policy, other.wait_policy);
    swap(pushed_down, other.pushed_down);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RowMarkClause& value)
{
    stream << "RowMarkClause(";
    stream << "rti="; stream << value.rti;
    stream << ",strength="; stream << value.strength;
    stream << ",wait_policy="; stream << value.wait_policy;
    stream << ",pushed_down="; stream << (value.pushed_down ? "true" : "false");
    stream << ")";
    return stream;
}

XmlSerialize::XmlSerialize()
    : xmloption()
    , expr()
    , type_name(nullptr)
    , location((int32_t)0ll)
{}

XmlSerialize::XmlSerialize(::pg_query::XmlOptionType&& arg_xmloption, ::pg_query::Node&& arg_expr, std::unique_ptr<::pg_query::TypeName> arg_type_name, int32_t arg_location)
    : xmloption(std::move(arg_xmloption))
    , expr(std::move(arg_expr))
    , type_name(arg_type_name.release())
    , location(arg_location)
{}

XmlSerialize::XmlSerialize(XmlSerialize&& other) noexcept
    : xmloption(std::move(other.xmloption))
    , expr(std::move(other.expr))
    , type_name(std::exchange(other.type_name, nullptr))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

XmlSerialize::~XmlSerialize()
{
    if (type_name) delete type_name;
}

bool XmlSerialize::operator==([[maybe_unused]] const XmlSerialize& other) const noexcept
{
    return (
        true
        );
}

bool XmlSerialize::operator<([[maybe_unused]] const XmlSerialize& other) const noexcept
{
    return false;
}

XmlSerialize& XmlSerialize::operator=(XmlSerialize&& other) noexcept
{
    if (this != &other)
    {
        xmloption = std::move(other.xmloption);
        expr = std::move(other.expr);
        type_name = std::exchange(other.type_name, nullptr);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string XmlSerialize::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void XmlSerialize::swap(XmlSerialize& other) noexcept
{
    using std::swap;
    swap(xmloption, other.xmloption);
    swap(expr, other.expr);
    swap(type_name, other.type_name);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const XmlSerialize& value)
{
    stream << "XmlSerialize(";
    stream << "xmloption="; stream << value.xmloption;
    stream << ",expr="; stream << value.expr;
    stream << ",type_name="; stream << " ptr of other struct" << (value.type_name == nullptr ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

WithClause::WithClause()
    : ctes()
    , recursive(false)
    , location((int32_t)0ll)
{}

WithClause::WithClause(std::vector<::pg_query::Node> arg_ctes, bool arg_recursive, int32_t arg_location)
    : ctes(std::move(arg_ctes))
    , recursive(arg_recursive)
    , location(arg_location)
{}

WithClause::WithClause(WithClause&& other) noexcept
    : ctes(std::move(other.ctes))
    , recursive(std::exchange(other.recursive, false))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

WithClause::~WithClause()
{
}

bool WithClause::operator==([[maybe_unused]] const WithClause& other) const noexcept
{
    return (
        true
        );
}

bool WithClause::operator<([[maybe_unused]] const WithClause& other) const noexcept
{
    return false;
}

WithClause& WithClause::operator=(WithClause&& other) noexcept
{
    if (this != &other)
    {
        ctes = std::move(other.ctes);
        recursive = std::exchange(other.recursive, false);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string WithClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void WithClause::swap(WithClause& other) noexcept
{
    using std::swap;
    swap(ctes, other.ctes);
    swap(recursive, other.recursive);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const WithClause& value)
{
    stream << "WithClause(";
    {
        bool first = true;
        stream << "ctes=[" << value.ctes.size() << "][";
        for (const auto& it : value.ctes)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",recursive="; stream << (value.recursive ? "true" : "false");
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

InferClause::InferClause()
    : index_elems()
    , where_clause()
    , conname()
    , location((int32_t)0ll)
{}

InferClause::InferClause(std::vector<::pg_query::Node> arg_index_elems, ::pg_query::Node&& arg_where_clause, const std::string& arg_conname, int32_t arg_location)
    : index_elems(std::move(arg_index_elems))
    , where_clause(std::move(arg_where_clause))
    , conname(arg_conname)
    , location(arg_location)
{}

InferClause::InferClause(InferClause&& other) noexcept
    : index_elems(std::move(other.index_elems))
    , where_clause(std::move(other.where_clause))
    , conname(std::move(other.conname))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

InferClause::~InferClause()
{
}

bool InferClause::operator==([[maybe_unused]] const InferClause& other) const noexcept
{
    return (
        true
        );
}

bool InferClause::operator<([[maybe_unused]] const InferClause& other) const noexcept
{
    return false;
}

InferClause& InferClause::operator=(InferClause&& other) noexcept
{
    if (this != &other)
    {
        index_elems = std::move(other.index_elems);
        where_clause = std::move(other.where_clause);
        conname = std::move(other.conname);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string InferClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void InferClause::swap(InferClause& other) noexcept
{
    using std::swap;
    swap(index_elems, other.index_elems);
    swap(where_clause, other.where_clause);
    swap(conname, other.conname);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const InferClause& value)
{
    stream << "InferClause(";
    {
        bool first = true;
        stream << "index_elems=[" << value.index_elems.size() << "][";
        for (const auto& it : value.index_elems)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",where_clause="; stream << value.where_clause;
    stream << ",conname="; stream << "\"" << value.conname << "\"";
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

OnConflictClause::OnConflictClause()
    : action()
    , infer(nullptr)
    , target_list()
    , where_clause()
    , location((int32_t)0ll)
{}

OnConflictClause::OnConflictClause(::pg_query::OnConflictAction&& arg_action, std::unique_ptr<::pg_query::InferClause> arg_infer, std::vector<::pg_query::Node> arg_target_list, ::pg_query::Node&& arg_where_clause, int32_t arg_location)
    : action(std::move(arg_action))
    , infer(arg_infer.release())
    , target_list(std::move(arg_target_list))
    , where_clause(std::move(arg_where_clause))
    , location(arg_location)
{}

OnConflictClause::OnConflictClause(OnConflictClause&& other) noexcept
    : action(std::move(other.action))
    , infer(std::exchange(other.infer, nullptr))
    , target_list(std::move(other.target_list))
    , where_clause(std::move(other.where_clause))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

OnConflictClause::~OnConflictClause()
{
    if (infer) delete infer;
}

bool OnConflictClause::operator==([[maybe_unused]] const OnConflictClause& other) const noexcept
{
    return (
        true
        );
}

bool OnConflictClause::operator<([[maybe_unused]] const OnConflictClause& other) const noexcept
{
    return false;
}

OnConflictClause& OnConflictClause::operator=(OnConflictClause&& other) noexcept
{
    if (this != &other)
    {
        action = std::move(other.action);
        infer = std::exchange(other.infer, nullptr);
        target_list = std::move(other.target_list);
        where_clause = std::move(other.where_clause);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string OnConflictClause::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void OnConflictClause::swap(OnConflictClause& other) noexcept
{
    using std::swap;
    swap(action, other.action);
    swap(infer, other.infer);
    swap(target_list, other.target_list);
    swap(where_clause, other.where_clause);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const OnConflictClause& value)
{
    stream << "OnConflictClause(";
    stream << "action="; stream << value.action;
    stream << ",infer="; stream << " ptr of other struct" << (value.infer == nullptr ? "true" : "false");
    {
        bool first = true;
        stream << ",target_list=[" << value.target_list.size() << "][";
        for (const auto& it : value.target_list)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",where_clause="; stream << value.where_clause;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

CommonTableExpr::CommonTableExpr()
    : ctename()
    , aliascolnames()
    , ctematerialized()
    , ctequery()
    , location((int32_t)0ll)
    , cterecursive(false)
    , cterefcount((int32_t)0ll)
    , ctecolnames()
    , ctecoltypes()
    , ctecoltypmods()
    , ctecolcollations()
{}

CommonTableExpr::CommonTableExpr(const std::string& arg_ctename, std::vector<::pg_query::Node> arg_aliascolnames, ::pg_query::CTEMaterialize&& arg_ctematerialized, ::pg_query::Node&& arg_ctequery, int32_t arg_location, bool arg_cterecursive, int32_t arg_cterefcount, std::vector<::pg_query::Node> arg_ctecolnames, std::vector<::pg_query::Node> arg_ctecoltypes, std::vector<::pg_query::Node> arg_ctecoltypmods, std::vector<::pg_query::Node> arg_ctecolcollations)
    : ctename(arg_ctename)
    , aliascolnames(std::move(arg_aliascolnames))
    , ctematerialized(std::move(arg_ctematerialized))
    , ctequery(std::move(arg_ctequery))
    , location(arg_location)
    , cterecursive(arg_cterecursive)
    , cterefcount(arg_cterefcount)
    , ctecolnames(std::move(arg_ctecolnames))
    , ctecoltypes(std::move(arg_ctecoltypes))
    , ctecoltypmods(std::move(arg_ctecoltypmods))
    , ctecolcollations(std::move(arg_ctecolcollations))
{}

CommonTableExpr::CommonTableExpr(CommonTableExpr&& other) noexcept
    : ctename(std::move(other.ctename))
    , aliascolnames(std::move(other.aliascolnames))
    , ctematerialized(std::move(other.ctematerialized))
    , ctequery(std::move(other.ctequery))
    , location(std::exchange(other.location, (int32_t)0ll))
    , cterecursive(std::exchange(other.cterecursive, false))
    , cterefcount(std::exchange(other.cterefcount, (int32_t)0ll))
    , ctecolnames(std::move(other.ctecolnames))
    , ctecoltypes(std::move(other.ctecoltypes))
    , ctecoltypmods(std::move(other.ctecoltypmods))
    , ctecolcollations(std::move(other.ctecolcollations))
{}

CommonTableExpr::~CommonTableExpr()
{
}

bool CommonTableExpr::operator==([[maybe_unused]] const CommonTableExpr& other) const noexcept
{
    return (
        true
        );
}

bool CommonTableExpr::operator<([[maybe_unused]] const CommonTableExpr& other) const noexcept
{
    return false;
}

CommonTableExpr& CommonTableExpr::operator=(CommonTableExpr&& other) noexcept
{
    if (this != &other)
    {
        ctename = std::move(other.ctename);
        aliascolnames = std::move(other.aliascolnames);
        ctematerialized = std::move(other.ctematerialized);
        ctequery = std::move(other.ctequery);
        location = std::exchange(other.location, (int32_t)0ll);
        cterecursive = std::exchange(other.cterecursive, false);
        cterefcount = std::exchange(other.cterefcount, (int32_t)0ll);
        ctecolnames = std::move(other.ctecolnames);
        ctecoltypes = std::move(other.ctecoltypes);
        ctecoltypmods = std::move(other.ctecoltypmods);
        ctecolcollations = std::move(other.ctecolcollations);
    }
    return *this;
}

std::string CommonTableExpr::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CommonTableExpr::swap(CommonTableExpr& other) noexcept
{
    using std::swap;
    swap(ctename, other.ctename);
    swap(aliascolnames, other.aliascolnames);
    swap(ctematerialized, other.ctematerialized);
    swap(ctequery, other.ctequery);
    swap(location, other.location);
    swap(cterecursive, other.cterecursive);
    swap(cterefcount, other.cterefcount);
    swap(ctecolnames, other.ctecolnames);
    swap(ctecoltypes, other.ctecoltypes);
    swap(ctecoltypmods, other.ctecoltypmods);
    swap(ctecolcollations, other.ctecolcollations);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CommonTableExpr& value)
{
    stream << "CommonTableExpr(";
    stream << "ctename="; stream << "\"" << value.ctename << "\"";
    {
        bool first = true;
        stream << ",aliascolnames=[" << value.aliascolnames.size() << "][";
        for (const auto& it : value.aliascolnames)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",ctematerialized="; stream << value.ctematerialized;
    stream << ",ctequery="; stream << value.ctequery;
    stream << ",location="; stream << value.location;
    stream << ",cterecursive="; stream << (value.cterecursive ? "true" : "false");
    stream << ",cterefcount="; stream << value.cterefcount;
    {
        bool first = true;
        stream << ",ctecolnames=[" << value.ctecolnames.size() << "][";
        for (const auto& it : value.ctecolnames)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",ctecoltypes=[" << value.ctecoltypes.size() << "][";
        for (const auto& it : value.ctecoltypes)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",ctecoltypmods=[" << value.ctecoltypmods.size() << "][";
        for (const auto& it : value.ctecoltypmods)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",ctecolcollations=[" << value.ctecolcollations.size() << "][";
        for (const auto& it : value.ctecolcollations)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

RoleSpec::RoleSpec()
    : roletype()
    , rolename()
    , location((int32_t)0ll)
{}

RoleSpec::RoleSpec(::pg_query::RoleSpecType&& arg_roletype, const std::string& arg_rolename, int32_t arg_location)
    : roletype(std::move(arg_roletype))
    , rolename(arg_rolename)
    , location(arg_location)
{}

RoleSpec::RoleSpec(RoleSpec&& other) noexcept
    : roletype(std::move(other.roletype))
    , rolename(std::move(other.rolename))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

RoleSpec::~RoleSpec()
{
}

bool RoleSpec::operator==([[maybe_unused]] const RoleSpec& other) const noexcept
{
    return (
        true
        );
}

bool RoleSpec::operator<([[maybe_unused]] const RoleSpec& other) const noexcept
{
    return false;
}

RoleSpec& RoleSpec::operator=(RoleSpec&& other) noexcept
{
    if (this != &other)
    {
        roletype = std::move(other.roletype);
        rolename = std::move(other.rolename);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string RoleSpec::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void RoleSpec::swap(RoleSpec& other) noexcept
{
    using std::swap;
    swap(roletype, other.roletype);
    swap(rolename, other.rolename);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const RoleSpec& value)
{
    stream << "RoleSpec(";
    stream << "roletype="; stream << value.roletype;
    stream << ",rolename="; stream << "\"" << value.rolename << "\"";
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

TriggerTransition::TriggerTransition()
    : name()
    , is_new(false)
    , is_table(false)
{}

TriggerTransition::TriggerTransition(const std::string& arg_name, bool arg_is_new, bool arg_is_table)
    : name(arg_name)
    , is_new(arg_is_new)
    , is_table(arg_is_table)
{}

TriggerTransition::TriggerTransition(TriggerTransition&& other) noexcept
    : name(std::move(other.name))
    , is_new(std::exchange(other.is_new, false))
    , is_table(std::exchange(other.is_table, false))
{}

TriggerTransition::~TriggerTransition()
{
}

bool TriggerTransition::operator==([[maybe_unused]] const TriggerTransition& other) const noexcept
{
    return (
        true
        );
}

bool TriggerTransition::operator<([[maybe_unused]] const TriggerTransition& other) const noexcept
{
    return false;
}

TriggerTransition& TriggerTransition::operator=(TriggerTransition&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
        is_new = std::exchange(other.is_new, false);
        is_table = std::exchange(other.is_table, false);
    }
    return *this;
}

std::string TriggerTransition::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void TriggerTransition::swap(TriggerTransition& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(is_new, other.is_new);
    swap(is_table, other.is_table);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const TriggerTransition& value)
{
    stream << "TriggerTransition(";
    stream << "name="; stream << "\"" << value.name << "\"";
    stream << ",is_new="; stream << (value.is_new ? "true" : "false");
    stream << ",is_table="; stream << (value.is_table ? "true" : "false");
    stream << ")";
    return stream;
}

PartitionElem::PartitionElem()
    : name()
    , expr()
    , collation()
    , opclass()
    , location((int32_t)0ll)
{}

PartitionElem::PartitionElem(const std::string& arg_name, ::pg_query::Node&& arg_expr, std::vector<::pg_query::Node> arg_collation, std::vector<::pg_query::Node> arg_opclass, int32_t arg_location)
    : name(arg_name)
    , expr(std::move(arg_expr))
    , collation(std::move(arg_collation))
    , opclass(std::move(arg_opclass))
    , location(arg_location)
{}

PartitionElem::PartitionElem(PartitionElem&& other) noexcept
    : name(std::move(other.name))
    , expr(std::move(other.expr))
    , collation(std::move(other.collation))
    , opclass(std::move(other.opclass))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

PartitionElem::~PartitionElem()
{
}

bool PartitionElem::operator==([[maybe_unused]] const PartitionElem& other) const noexcept
{
    return (
        true
        );
}

bool PartitionElem::operator<([[maybe_unused]] const PartitionElem& other) const noexcept
{
    return false;
}

PartitionElem& PartitionElem::operator=(PartitionElem&& other) noexcept
{
    if (this != &other)
    {
        name = std::move(other.name);
        expr = std::move(other.expr);
        collation = std::move(other.collation);
        opclass = std::move(other.opclass);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string PartitionElem::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void PartitionElem::swap(PartitionElem& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(expr, other.expr);
    swap(collation, other.collation);
    swap(opclass, other.opclass);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const PartitionElem& value)
{
    stream << "PartitionElem(";
    stream << "name="; stream << "\"" << value.name << "\"";
    stream << ",expr="; stream << value.expr;
    {
        bool first = true;
        stream << ",collation=[" << value.collation.size() << "][";
        for (const auto& it : value.collation)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",opclass=[" << value.opclass.size() << "][";
        for (const auto& it : value.opclass)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

PartitionSpec::PartitionSpec()
    : strategy()
    , part_params()
    , location((int32_t)0ll)
{}

PartitionSpec::PartitionSpec(const std::string& arg_strategy, std::vector<::pg_query::Node> arg_part_params, int32_t arg_location)
    : strategy(arg_strategy)
    , part_params(std::move(arg_part_params))
    , location(arg_location)
{}

PartitionSpec::PartitionSpec(PartitionSpec&& other) noexcept
    : strategy(std::move(other.strategy))
    , part_params(std::move(other.part_params))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

PartitionSpec::~PartitionSpec()
{
}

bool PartitionSpec::operator==([[maybe_unused]] const PartitionSpec& other) const noexcept
{
    return (
        true
        );
}

bool PartitionSpec::operator<([[maybe_unused]] const PartitionSpec& other) const noexcept
{
    return false;
}

PartitionSpec& PartitionSpec::operator=(PartitionSpec&& other) noexcept
{
    if (this != &other)
    {
        strategy = std::move(other.strategy);
        part_params = std::move(other.part_params);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string PartitionSpec::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void PartitionSpec::swap(PartitionSpec& other) noexcept
{
    using std::swap;
    swap(strategy, other.strategy);
    swap(part_params, other.part_params);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const PartitionSpec& value)
{
    stream << "PartitionSpec(";
    stream << "strategy="; stream << "\"" << value.strategy << "\"";
    {
        bool first = true;
        stream << ",part_params=[" << value.part_params.size() << "][";
        for (const auto& it : value.part_params)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

PartitionBoundSpec::PartitionBoundSpec()
    : strategy()
    , is_default(false)
    , modulus((int32_t)0ll)
    , remainder((int32_t)0ll)
    , listdatums()
    , lowerdatums()
    , upperdatums()
    , location((int32_t)0ll)
{}

PartitionBoundSpec::PartitionBoundSpec(const std::string& arg_strategy, bool arg_is_default, int32_t arg_modulus, int32_t arg_remainder, std::vector<::pg_query::Node> arg_listdatums, std::vector<::pg_query::Node> arg_lowerdatums, std::vector<::pg_query::Node> arg_upperdatums, int32_t arg_location)
    : strategy(arg_strategy)
    , is_default(arg_is_default)
    , modulus(arg_modulus)
    , remainder(arg_remainder)
    , listdatums(std::move(arg_listdatums))
    , lowerdatums(std::move(arg_lowerdatums))
    , upperdatums(std::move(arg_upperdatums))
    , location(arg_location)
{}

PartitionBoundSpec::PartitionBoundSpec(PartitionBoundSpec&& other) noexcept
    : strategy(std::move(other.strategy))
    , is_default(std::exchange(other.is_default, false))
    , modulus(std::exchange(other.modulus, (int32_t)0ll))
    , remainder(std::exchange(other.remainder, (int32_t)0ll))
    , listdatums(std::move(other.listdatums))
    , lowerdatums(std::move(other.lowerdatums))
    , upperdatums(std::move(other.upperdatums))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

PartitionBoundSpec::~PartitionBoundSpec()
{
}

bool PartitionBoundSpec::operator==([[maybe_unused]] const PartitionBoundSpec& other) const noexcept
{
    return (
        true
        );
}

bool PartitionBoundSpec::operator<([[maybe_unused]] const PartitionBoundSpec& other) const noexcept
{
    return false;
}

PartitionBoundSpec& PartitionBoundSpec::operator=(PartitionBoundSpec&& other) noexcept
{
    if (this != &other)
    {
        strategy = std::move(other.strategy);
        is_default = std::exchange(other.is_default, false);
        modulus = std::exchange(other.modulus, (int32_t)0ll);
        remainder = std::exchange(other.remainder, (int32_t)0ll);
        listdatums = std::move(other.listdatums);
        lowerdatums = std::move(other.lowerdatums);
        upperdatums = std::move(other.upperdatums);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string PartitionBoundSpec::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void PartitionBoundSpec::swap(PartitionBoundSpec& other) noexcept
{
    using std::swap;
    swap(strategy, other.strategy);
    swap(is_default, other.is_default);
    swap(modulus, other.modulus);
    swap(remainder, other.remainder);
    swap(listdatums, other.listdatums);
    swap(lowerdatums, other.lowerdatums);
    swap(upperdatums, other.upperdatums);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const PartitionBoundSpec& value)
{
    stream << "PartitionBoundSpec(";
    stream << "strategy="; stream << "\"" << value.strategy << "\"";
    stream << ",is_default="; stream << (value.is_default ? "true" : "false");
    stream << ",modulus="; stream << value.modulus;
    stream << ",remainder="; stream << value.remainder;
    {
        bool first = true;
        stream << ",listdatums=[" << value.listdatums.size() << "][";
        for (const auto& it : value.listdatums)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",lowerdatums=[" << value.lowerdatums.size() << "][";
        for (const auto& it : value.lowerdatums)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",upperdatums=[" << value.upperdatums.size() << "][";
        for (const auto& it : value.upperdatums)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

PartitionRangeDatum::PartitionRangeDatum()
    : kind()
    , value()
    , location((int32_t)0ll)
{}

PartitionRangeDatum::PartitionRangeDatum(::pg_query::PartitionRangeDatumKind&& arg_kind, ::pg_query::Node&& arg_value, int32_t arg_location)
    : kind(std::move(arg_kind))
    , value(std::move(arg_value))
    , location(arg_location)
{}

PartitionRangeDatum::PartitionRangeDatum(PartitionRangeDatum&& other) noexcept
    : kind(std::move(other.kind))
    , value(std::move(other.value))
    , location(std::exchange(other.location, (int32_t)0ll))
{}

PartitionRangeDatum::~PartitionRangeDatum()
{
}

bool PartitionRangeDatum::operator==([[maybe_unused]] const PartitionRangeDatum& other) const noexcept
{
    return (
        true
        );
}

bool PartitionRangeDatum::operator<([[maybe_unused]] const PartitionRangeDatum& other) const noexcept
{
    return false;
}

PartitionRangeDatum& PartitionRangeDatum::operator=(PartitionRangeDatum&& other) noexcept
{
    if (this != &other)
    {
        kind = std::move(other.kind);
        value = std::move(other.value);
        location = std::exchange(other.location, (int32_t)0ll);
    }
    return *this;
}

std::string PartitionRangeDatum::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void PartitionRangeDatum::swap(PartitionRangeDatum& other) noexcept
{
    using std::swap;
    swap(kind, other.kind);
    swap(value, other.value);
    swap(location, other.location);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const PartitionRangeDatum& value)
{
    stream << "PartitionRangeDatum(";
    stream << "kind="; stream << value.kind;
    stream << ",value="; stream << value.value;
    stream << ",location="; stream << value.location;
    stream << ")";
    return stream;
}

PartitionCmd::PartitionCmd()
    : name(nullptr)
    , bound(nullptr)
{}

PartitionCmd::PartitionCmd(std::unique_ptr<::pg_query::RangeVar> arg_name, std::unique_ptr<::pg_query::PartitionBoundSpec> arg_bound)
    : name(arg_name.release())
    , bound(arg_bound.release())
{}

PartitionCmd::PartitionCmd(PartitionCmd&& other) noexcept
    : name(std::exchange(other.name, nullptr))
    , bound(std::exchange(other.bound, nullptr))
{}

PartitionCmd::~PartitionCmd()
{
    if (name) delete name;
    if (bound) delete bound;
}

bool PartitionCmd::operator==([[maybe_unused]] const PartitionCmd& other) const noexcept
{
    return (
        true
        );
}

bool PartitionCmd::operator<([[maybe_unused]] const PartitionCmd& other) const noexcept
{
    return false;
}

PartitionCmd& PartitionCmd::operator=(PartitionCmd&& other) noexcept
{
    if (this != &other)
    {
        name = std::exchange(other.name, nullptr);
        bound = std::exchange(other.bound, nullptr);
    }
    return *this;
}

std::string PartitionCmd::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void PartitionCmd::swap(PartitionCmd& other) noexcept
{
    using std::swap;
    swap(name, other.name);
    swap(bound, other.bound);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const PartitionCmd& value)
{
    stream << "PartitionCmd(";
    stream << "name="; stream << " ptr of other struct" << (value.name == nullptr ? "true" : "false");
    stream << ",bound="; stream << " ptr of other struct" << (value.bound == nullptr ? "true" : "false");
    stream << ")";
    return stream;
}

VacuumRelation::VacuumRelation()
    : relation(nullptr)
    , oid((uint32_t)0ull)
    , va_cols()
{}

VacuumRelation::VacuumRelation(std::unique_ptr<::pg_query::RangeVar> arg_relation, uint32_t arg_oid, std::vector<::pg_query::Node> arg_va_cols)
    : relation(arg_relation.release())
    , oid(arg_oid)
    , va_cols(std::move(arg_va_cols))
{}

VacuumRelation::VacuumRelation(VacuumRelation&& other) noexcept
    : relation(std::exchange(other.relation, nullptr))
    , oid(std::exchange(other.oid, (uint32_t)0ull))
    , va_cols(std::move(other.va_cols))
{}

VacuumRelation::~VacuumRelation()
{
    if (relation) delete relation;
}

bool VacuumRelation::operator==([[maybe_unused]] const VacuumRelation& other) const noexcept
{
    return (
        true
        );
}

bool VacuumRelation::operator<([[maybe_unused]] const VacuumRelation& other) const noexcept
{
    return false;
}

VacuumRelation& VacuumRelation::operator=(VacuumRelation&& other) noexcept
{
    if (this != &other)
    {
        relation = std::exchange(other.relation, nullptr);
        oid = std::exchange(other.oid, (uint32_t)0ull);
        va_cols = std::move(other.va_cols);
    }
    return *this;
}

std::string VacuumRelation::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void VacuumRelation::swap(VacuumRelation& other) noexcept
{
    using std::swap;
    swap(relation, other.relation);
    swap(oid, other.oid);
    swap(va_cols, other.va_cols);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const VacuumRelation& value)
{
    stream << "VacuumRelation(";
    stream << "relation="; stream << " ptr of other struct" << (value.relation == nullptr ? "true" : "false");
    stream << ",oid="; stream << value.oid;
    {
        bool first = true;
        stream << ",va_cols=[" << value.va_cols.size() << "][";
        for (const auto& it : value.va_cols)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

InlineCodeBlock::InlineCodeBlock()
    : source_text()
    , lang_oid((uint32_t)0ull)
    , lang_is_trusted(false)
    , atomic(false)
{}

InlineCodeBlock::InlineCodeBlock(const std::string& arg_source_text, uint32_t arg_lang_oid, bool arg_lang_is_trusted, bool arg_atomic)
    : source_text(arg_source_text)
    , lang_oid(arg_lang_oid)
    , lang_is_trusted(arg_lang_is_trusted)
    , atomic(arg_atomic)
{}

InlineCodeBlock::InlineCodeBlock(InlineCodeBlock&& other) noexcept
    : source_text(std::move(other.source_text))
    , lang_oid(std::exchange(other.lang_oid, (uint32_t)0ull))
    , lang_is_trusted(std::exchange(other.lang_is_trusted, false))
    , atomic(std::exchange(other.atomic, false))
{}

InlineCodeBlock::~InlineCodeBlock()
{
}

bool InlineCodeBlock::operator==([[maybe_unused]] const InlineCodeBlock& other) const noexcept
{
    return (
        true
        );
}

bool InlineCodeBlock::operator<([[maybe_unused]] const InlineCodeBlock& other) const noexcept
{
    return false;
}

InlineCodeBlock& InlineCodeBlock::operator=(InlineCodeBlock&& other) noexcept
{
    if (this != &other)
    {
        source_text = std::move(other.source_text);
        lang_oid = std::exchange(other.lang_oid, (uint32_t)0ull);
        lang_is_trusted = std::exchange(other.lang_is_trusted, false);
        atomic = std::exchange(other.atomic, false);
    }
    return *this;
}

std::string InlineCodeBlock::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void InlineCodeBlock::swap(InlineCodeBlock& other) noexcept
{
    using std::swap;
    swap(source_text, other.source_text);
    swap(lang_oid, other.lang_oid);
    swap(lang_is_trusted, other.lang_is_trusted);
    swap(atomic, other.atomic);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const InlineCodeBlock& value)
{
    stream << "InlineCodeBlock(";
    stream << "source_text="; stream << "\"" << value.source_text << "\"";
    stream << ",lang_oid="; stream << value.lang_oid;
    stream << ",lang_is_trusted="; stream << (value.lang_is_trusted ? "true" : "false");
    stream << ",atomic="; stream << (value.atomic ? "true" : "false");
    stream << ")";
    return stream;
}

CallContext::CallContext()
    : atomic(false)
{}

CallContext::CallContext(bool arg_atomic)
    : atomic(arg_atomic)
{}

CallContext::CallContext(CallContext&& other) noexcept
    : atomic(std::exchange(other.atomic, false))
{}

CallContext::~CallContext()
{
}

bool CallContext::operator==([[maybe_unused]] const CallContext& other) const noexcept
{
    return (
        true
        );
}

bool CallContext::operator<([[maybe_unused]] const CallContext& other) const noexcept
{
    return false;
}

CallContext& CallContext::operator=(CallContext&& other) noexcept
{
    if (this != &other)
    {
        atomic = std::exchange(other.atomic, false);
    }
    return *this;
}

std::string CallContext::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void CallContext::swap(CallContext& other) noexcept
{
    using std::swap;
    swap(atomic, other.atomic);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const CallContext& value)
{
    stream << "CallContext(";
    stream << "atomic="; stream << (value.atomic ? "true" : "false");
    stream << ")";
    return stream;
}

ScanToken::ScanToken()
    : start((int32_t)0ll)
    , end((int32_t)0ll)
    , token()
    , keyword_kind()
{}

ScanToken::ScanToken(int32_t arg_start, int32_t arg_end, ::pg_query::Token&& arg_token, ::pg_query::KeywordKind&& arg_keyword_kind)
    : start(arg_start)
    , end(arg_end)
    , token(std::move(arg_token))
    , keyword_kind(std::move(arg_keyword_kind))
{}

ScanToken::ScanToken(ScanToken&& other) noexcept
    : start(std::exchange(other.start, (int32_t)0ll))
    , end(std::exchange(other.end, (int32_t)0ll))
    , token(std::move(other.token))
    , keyword_kind(std::move(other.keyword_kind))
{}

ScanToken::~ScanToken()
{
}

bool ScanToken::operator==([[maybe_unused]] const ScanToken& other) const noexcept
{
    return (
        true
        );
}

bool ScanToken::operator<([[maybe_unused]] const ScanToken& other) const noexcept
{
    return false;
}

ScanToken& ScanToken::operator=(ScanToken&& other) noexcept
{
    if (this != &other)
    {
        start = std::exchange(other.start, (int32_t)0ll);
        end = std::exchange(other.end, (int32_t)0ll);
        token = std::move(other.token);
        keyword_kind = std::move(other.keyword_kind);
    }
    return *this;
}

std::string ScanToken::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ScanToken::swap(ScanToken& other) noexcept
{
    using std::swap;
    swap(start, other.start);
    swap(end, other.end);
    swap(token, other.token);
    swap(keyword_kind, other.keyword_kind);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ScanToken& value)
{
    stream << "ScanToken(";
    stream << "start="; stream << value.start;
    stream << ",end="; stream << value.end;
    stream << ",token="; stream << value.token;
    stream << ",keyword_kind="; stream << value.keyword_kind;
    stream << ")";
    return stream;
}

ParseResult::ParseResult()
    : version((int32_t)0ll)
    , stmts()
{}

ParseResult::ParseResult(int32_t arg_version, std::vector<::pg_query::RawStmt> arg_stmts)
    : version(arg_version)
    , stmts(std::move(arg_stmts))
{}

ParseResult::ParseResult(ParseResult&& other) noexcept
    : version(std::exchange(other.version, (int32_t)0ll))
    , stmts(std::move(other.stmts))
{}

ParseResult::~ParseResult()
{
}

bool ParseResult::operator==([[maybe_unused]] const ParseResult& other) const noexcept
{
    return (
        true
        );
}

bool ParseResult::operator<([[maybe_unused]] const ParseResult& other) const noexcept
{
    return false;
}

ParseResult& ParseResult::operator=(ParseResult&& other) noexcept
{
    if (this != &other)
    {
        version = std::exchange(other.version, (int32_t)0ll);
        stmts = std::move(other.stmts);
    }
    return *this;
}

std::string ParseResult::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ParseResult::swap(ParseResult& other) noexcept
{
    using std::swap;
    swap(version, other.version);
    swap(stmts, other.stmts);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ParseResult& value)
{
    stream << "ParseResult(";
    stream << "version="; stream << value.version;
    {
        bool first = true;
        stream << ",stmts=[" << value.stmts.size() << "][";
        for (const auto& it : value.stmts)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

ScanResult::ScanResult()
    : version((int32_t)0ll)
    , tokens()
{}

ScanResult::ScanResult(int32_t arg_version, std::vector<::pg_query::ScanToken> arg_tokens)
    : version(arg_version)
    , tokens(std::move(arg_tokens))
{}

ScanResult::ScanResult(ScanResult&& other) noexcept
    : version(std::exchange(other.version, (int32_t)0ll))
    , tokens(std::move(other.tokens))
{}

ScanResult::~ScanResult()
{
}

bool ScanResult::operator==([[maybe_unused]] const ScanResult& other) const noexcept
{
    return (
        true
        );
}

bool ScanResult::operator<([[maybe_unused]] const ScanResult& other) const noexcept
{
    return false;
}

ScanResult& ScanResult::operator=(ScanResult&& other) noexcept
{
    if (this != &other)
    {
        version = std::exchange(other.version, (int32_t)0ll);
        tokens = std::move(other.tokens);
    }
    return *this;
}

std::string ScanResult::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void ScanResult::swap(ScanResult& other) noexcept
{
    using std::swap;
    swap(version, other.version);
    swap(tokens, other.tokens);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const ScanResult& value)
{
    stream << "ScanResult(";
    stream << "version="; stream << value.version;
    {
        bool first = true;
        stream << ",tokens=[" << value.tokens.size() << "][";
        for (const auto& it : value.tokens)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

} // namespace pg_query
