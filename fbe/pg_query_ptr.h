// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: pg_query.fbe
// Version: 1.7.0.0

#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace pg_query {
using namespace FBE;
} // namespace pg_query

namespace FBE {
using namespace ::pg_query;
} // namespace FBE

#include "fbe_ptr.h"

namespace pg_query {

enum class OverridingKind
{
    OVERRIDING_KIND_UNDEFINED = (int32_t)0ll,
    OVERRIDING_NOT_SET = (int32_t)1ll,
    OVERRIDING_USER_VALUE = (int32_t)2ll,
    OVERRIDING_SYSTEM_VALUE = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] OverridingKind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, OverridingKind value);
#endif

enum class QuerySource
{
    QUERY_SOURCE_UNDEFINED = (int32_t)0ll,
    QSRC_ORIGINAL = (int32_t)1ll,
    QSRC_PARSER = (int32_t)2ll,
    QSRC_INSTEAD_RULE = (int32_t)3ll,
    QSRC_QUAL_INSTEAD_RULE = (int32_t)4ll,
    QSRC_NON_INSTEAD_RULE = (int32_t)5ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] QuerySource value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, QuerySource value);
#endif

enum class SortByDir
{
    SORT_BY_DIR_UNDEFINED = (int32_t)0ll,
    SORTBY_DEFAULT = (int32_t)1ll,
    SORTBY_ASC = (int32_t)2ll,
    SORTBY_DESC = (int32_t)3ll,
    SORTBY_USING = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SortByDir value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, SortByDir value);
#endif

enum class SortByNulls
{
    SORT_BY_NULLS_UNDEFINED = (int32_t)0ll,
    SORTBY_NULLS_DEFAULT = (int32_t)1ll,
    SORTBY_NULLS_FIRST = (int32_t)2ll,
    SORTBY_NULLS_LAST = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SortByNulls value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, SortByNulls value);
#endif

enum class A_Expr_Kind
{
    A_EXPR_KIND_UNDEFINED = (int32_t)0ll,
    AEXPR_OP = (int32_t)1ll,
    AEXPR_OP_ANY = (int32_t)2ll,
    AEXPR_OP_ALL = (int32_t)3ll,
    AEXPR_DISTINCT = (int32_t)4ll,
    AEXPR_NOT_DISTINCT = (int32_t)5ll,
    AEXPR_NULLIF = (int32_t)6ll,
    AEXPR_OF = (int32_t)7ll,
    AEXPR_IN = (int32_t)8ll,
    AEXPR_LIKE = (int32_t)9ll,
    AEXPR_ILIKE = (int32_t)10ll,
    AEXPR_SIMILAR = (int32_t)11ll,
    AEXPR_BETWEEN = (int32_t)12ll,
    AEXPR_NOT_BETWEEN = (int32_t)13ll,
    AEXPR_BETWEEN_SYM = (int32_t)14ll,
    AEXPR_NOT_BETWEEN_SYM = (int32_t)15ll,
    AEXPR_PAREN = (int32_t)16ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] A_Expr_Kind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, A_Expr_Kind value);
#endif

enum class RoleSpecType
{
    ROLE_SPEC_TYPE_UNDEFINED = (int32_t)0ll,
    ROLESPEC_CSTRING = (int32_t)1ll,
    ROLESPEC_CURRENT_USER = (int32_t)2ll,
    ROLESPEC_SESSION_USER = (int32_t)3ll,
    ROLESPEC_PUBLIC = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] RoleSpecType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, RoleSpecType value);
#endif

enum class TableLikeOption
{
    TABLE_LIKE_OPTION_UNDEFINED = (int32_t)0ll,
    CREATE_TABLE_LIKE_COMMENTS = (int32_t)1ll,
    CREATE_TABLE_LIKE_CONSTRAINTS = (int32_t)2ll,
    CREATE_TABLE_LIKE_DEFAULTS = (int32_t)3ll,
    CREATE_TABLE_LIKE_GENERATED = (int32_t)4ll,
    CREATE_TABLE_LIKE_IDENTITY = (int32_t)5ll,
    CREATE_TABLE_LIKE_INDEXES = (int32_t)6ll,
    CREATE_TABLE_LIKE_STATISTICS = (int32_t)7ll,
    CREATE_TABLE_LIKE_STORAGE = (int32_t)8ll,
    CREATE_TABLE_LIKE_ALL = (int32_t)9ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] TableLikeOption value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, TableLikeOption value);
#endif

enum class DefElemAction
{
    DEF_ELEM_ACTION_UNDEFINED = (int32_t)0ll,
    DEFELEM_UNSPEC = (int32_t)1ll,
    DEFELEM_SET = (int32_t)2ll,
    DEFELEM_ADD = (int32_t)3ll,
    DEFELEM_DROP = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] DefElemAction value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, DefElemAction value);
#endif

enum class PartitionRangeDatumKind
{
    PARTITION_RANGE_DATUM_KIND_UNDEFINED = (int32_t)0ll,
    PARTITION_RANGE_DATUM_MINVALUE = (int32_t)1ll,
    PARTITION_RANGE_DATUM_VALUE = (int32_t)2ll,
    PARTITION_RANGE_DATUM_MAXVALUE = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] PartitionRangeDatumKind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, PartitionRangeDatumKind value);
#endif

enum class RTEKind
{
    RTEKIND_UNDEFINED = (int32_t)0ll,
    RTE_RELATION = (int32_t)1ll,
    RTE_SUBQUERY = (int32_t)2ll,
    RTE_JOIN = (int32_t)3ll,
    RTE_FUNCTION = (int32_t)4ll,
    RTE_TABLEFUNC = (int32_t)5ll,
    RTE_VALUES = (int32_t)6ll,
    RTE_CTE = (int32_t)7ll,
    RTE_NAMEDTUPLESTORE = (int32_t)8ll,
    RTE_RESULT = (int32_t)9ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] RTEKind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, RTEKind value);
#endif

enum class WCOKind
{
    WCOKIND_UNDEFINED = (int32_t)0ll,
    WCO_VIEW_CHECK = (int32_t)1ll,
    WCO_RLS_INSERT_CHECK = (int32_t)2ll,
    WCO_RLS_UPDATE_CHECK = (int32_t)3ll,
    WCO_RLS_CONFLICT_CHECK = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] WCOKind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, WCOKind value);
#endif

enum class GroupingSetKind
{
    GROUPING_SET_KIND_UNDEFINED = (int32_t)0ll,
    GROUPING_SET_EMPTY = (int32_t)1ll,
    GROUPING_SET_SIMPLE = (int32_t)2ll,
    GROUPING_SET_ROLLUP = (int32_t)3ll,
    GROUPING_SET_CUBE = (int32_t)4ll,
    GROUPING_SET_SETS = (int32_t)5ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] GroupingSetKind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, GroupingSetKind value);
#endif

enum class CTEMaterialize
{
    CTEMATERIALIZE_UNDEFINED = (int32_t)0ll,
    CTEMaterializeDefault = (int32_t)1ll,
    CTEMaterializeAlways = (int32_t)2ll,
    CTEMaterializeNever = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] CTEMaterialize value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, CTEMaterialize value);
#endif

enum class SetOperation
{
    SET_OPERATION_UNDEFINED = (int32_t)0ll,
    SETOP_NONE = (int32_t)1ll,
    SETOP_UNION = (int32_t)2ll,
    SETOP_INTERSECT = (int32_t)3ll,
    SETOP_EXCEPT = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SetOperation value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, SetOperation value);
#endif

enum class ObjectType
{
    OBJECT_TYPE_UNDEFINED = (int32_t)0ll,
    OBJECT_ACCESS_METHOD = (int32_t)1ll,
    OBJECT_AGGREGATE = (int32_t)2ll,
    OBJECT_AMOP = (int32_t)3ll,
    OBJECT_AMPROC = (int32_t)4ll,
    OBJECT_ATTRIBUTE = (int32_t)5ll,
    OBJECT_CAST = (int32_t)6ll,
    OBJECT_COLUMN = (int32_t)7ll,
    OBJECT_COLLATION = (int32_t)8ll,
    OBJECT_CONVERSION = (int32_t)9ll,
    OBJECT_DATABASE = (int32_t)10ll,
    OBJECT_DEFAULT = (int32_t)11ll,
    OBJECT_DEFACL = (int32_t)12ll,
    OBJECT_DOMAIN = (int32_t)13ll,
    OBJECT_DOMCONSTRAINT = (int32_t)14ll,
    OBJECT_EVENT_TRIGGER = (int32_t)15ll,
    OBJECT_EXTENSION = (int32_t)16ll,
    OBJECT_FDW = (int32_t)17ll,
    OBJECT_FOREIGN_SERVER = (int32_t)18ll,
    OBJECT_FOREIGN_TABLE = (int32_t)19ll,
    OBJECT_FUNCTION = (int32_t)20ll,
    OBJECT_INDEX = (int32_t)21ll,
    OBJECT_LANGUAGE = (int32_t)22ll,
    OBJECT_LARGEOBJECT = (int32_t)23ll,
    OBJECT_MATVIEW = (int32_t)24ll,
    OBJECT_OPCLASS = (int32_t)25ll,
    OBJECT_OPERATOR = (int32_t)26ll,
    OBJECT_OPFAMILY = (int32_t)27ll,
    OBJECT_POLICY = (int32_t)28ll,
    OBJECT_PROCEDURE = (int32_t)29ll,
    OBJECT_PUBLICATION = (int32_t)30ll,
    OBJECT_PUBLICATION_REL = (int32_t)31ll,
    OBJECT_ROLE = (int32_t)32ll,
    OBJECT_ROUTINE = (int32_t)33ll,
    OBJECT_RULE = (int32_t)34ll,
    OBJECT_SCHEMA = (int32_t)35ll,
    OBJECT_SEQUENCE = (int32_t)36ll,
    OBJECT_SUBSCRIPTION = (int32_t)37ll,
    OBJECT_STATISTIC_EXT = (int32_t)38ll,
    OBJECT_TABCONSTRAINT = (int32_t)39ll,
    OBJECT_TABLE = (int32_t)40ll,
    OBJECT_TABLESPACE = (int32_t)41ll,
    OBJECT_TRANSFORM = (int32_t)42ll,
    OBJECT_TRIGGER = (int32_t)43ll,
    OBJECT_TSCONFIGURATION = (int32_t)44ll,
    OBJECT_TSDICTIONARY = (int32_t)45ll,
    OBJECT_TSPARSER = (int32_t)46ll,
    OBJECT_TSTEMPLATE = (int32_t)47ll,
    OBJECT_TYPE = (int32_t)48ll,
    OBJECT_USER_MAPPING = (int32_t)49ll,
    OBJECT_VIEW = (int32_t)50ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ObjectType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, ObjectType value);
#endif

enum class DropBehavior
{
    DROP_BEHAVIOR_UNDEFINED = (int32_t)0ll,
    DROP_RESTRICT = (int32_t)1ll,
    DROP_CASCADE = (int32_t)2ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] DropBehavior value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, DropBehavior value);
#endif

enum class AlterTableType
{
    ALTER_TABLE_TYPE_UNDEFINED = (int32_t)0ll,
    AT_AddColumn = (int32_t)1ll,
    AT_AddColumnRecurse = (int32_t)2ll,
    AT_AddColumnToView = (int32_t)3ll,
    AT_ColumnDefault = (int32_t)4ll,
    AT_CookedColumnDefault = (int32_t)5ll,
    AT_DropNotNull = (int32_t)6ll,
    AT_SetNotNull = (int32_t)7ll,
    AT_DropExpression = (int32_t)8ll,
    AT_CheckNotNull = (int32_t)9ll,
    AT_SetStatistics = (int32_t)10ll,
    AT_SetOptions = (int32_t)11ll,
    AT_ResetOptions = (int32_t)12ll,
    AT_SetStorage = (int32_t)13ll,
    AT_DropColumn = (int32_t)14ll,
    AT_DropColumnRecurse = (int32_t)15ll,
    AT_AddIndex = (int32_t)16ll,
    AT_ReAddIndex = (int32_t)17ll,
    AT_AddConstraint = (int32_t)18ll,
    AT_AddConstraintRecurse = (int32_t)19ll,
    AT_ReAddConstraint = (int32_t)20ll,
    AT_ReAddDomainConstraint = (int32_t)21ll,
    AT_AlterConstraint = (int32_t)22ll,
    AT_ValidateConstraint = (int32_t)23ll,
    AT_ValidateConstraintRecurse = (int32_t)24ll,
    AT_AddIndexConstraint = (int32_t)25ll,
    AT_DropConstraint = (int32_t)26ll,
    AT_DropConstraintRecurse = (int32_t)27ll,
    AT_ReAddComment = (int32_t)28ll,
    AT_AlterColumnType = (int32_t)29ll,
    AT_AlterColumnGenericOptions = (int32_t)30ll,
    AT_ChangeOwner = (int32_t)31ll,
    AT_ClusterOn = (int32_t)32ll,
    AT_DropCluster = (int32_t)33ll,
    AT_SetLogged = (int32_t)34ll,
    AT_SetUnLogged = (int32_t)35ll,
    AT_DropOids = (int32_t)36ll,
    AT_SetTableSpace = (int32_t)37ll,
    AT_SetRelOptions = (int32_t)38ll,
    AT_ResetRelOptions = (int32_t)39ll,
    AT_ReplaceRelOptions = (int32_t)40ll,
    AT_EnableTrig = (int32_t)41ll,
    AT_EnableAlwaysTrig = (int32_t)42ll,
    AT_EnableReplicaTrig = (int32_t)43ll,
    AT_DisableTrig = (int32_t)44ll,
    AT_EnableTrigAll = (int32_t)45ll,
    AT_DisableTrigAll = (int32_t)46ll,
    AT_EnableTrigUser = (int32_t)47ll,
    AT_DisableTrigUser = (int32_t)48ll,
    AT_EnableRule = (int32_t)49ll,
    AT_EnableAlwaysRule = (int32_t)50ll,
    AT_EnableReplicaRule = (int32_t)51ll,
    AT_DisableRule = (int32_t)52ll,
    AT_AddInherit = (int32_t)53ll,
    AT_DropInherit = (int32_t)54ll,
    AT_AddOf = (int32_t)55ll,
    AT_DropOf = (int32_t)56ll,
    AT_ReplicaIdentity = (int32_t)57ll,
    AT_EnableRowSecurity = (int32_t)58ll,
    AT_DisableRowSecurity = (int32_t)59ll,
    AT_ForceRowSecurity = (int32_t)60ll,
    AT_NoForceRowSecurity = (int32_t)61ll,
    AT_GenericOptions = (int32_t)62ll,
    AT_AttachPartition = (int32_t)63ll,
    AT_DetachPartition = (int32_t)64ll,
    AT_AddIdentity = (int32_t)65ll,
    AT_SetIdentity = (int32_t)66ll,
    AT_DropIdentity = (int32_t)67ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AlterTableType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, AlterTableType value);
#endif

enum class GrantTargetType
{
    GRANT_TARGET_TYPE_UNDEFINED = (int32_t)0ll,
    ACL_TARGET_OBJECT = (int32_t)1ll,
    ACL_TARGET_ALL_IN_SCHEMA = (int32_t)2ll,
    ACL_TARGET_DEFAULTS = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] GrantTargetType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, GrantTargetType value);
#endif

enum class VariableSetKind
{
    VARIABLE_SET_KIND_UNDEFINED = (int32_t)0ll,
    VAR_SET_VALUE = (int32_t)1ll,
    VAR_SET_DEFAULT = (int32_t)2ll,
    VAR_SET_CURRENT = (int32_t)3ll,
    VAR_SET_MULTI = (int32_t)4ll,
    VAR_RESET = (int32_t)5ll,
    VAR_RESET_ALL = (int32_t)6ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] VariableSetKind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, VariableSetKind value);
#endif

enum class ConstrType
{
    CONSTR_TYPE_UNDEFINED = (int32_t)0ll,
    CONSTR_NULL = (int32_t)1ll,
    CONSTR_NOTNULL = (int32_t)2ll,
    CONSTR_DEFAULT = (int32_t)3ll,
    CONSTR_IDENTITY = (int32_t)4ll,
    CONSTR_GENERATED = (int32_t)5ll,
    CONSTR_CHECK = (int32_t)6ll,
    CONSTR_PRIMARY = (int32_t)7ll,
    CONSTR_UNIQUE = (int32_t)8ll,
    CONSTR_EXCLUSION = (int32_t)9ll,
    CONSTR_FOREIGN = (int32_t)10ll,
    CONSTR_ATTR_DEFERRABLE = (int32_t)11ll,
    CONSTR_ATTR_NOT_DEFERRABLE = (int32_t)12ll,
    CONSTR_ATTR_DEFERRED = (int32_t)13ll,
    CONSTR_ATTR_IMMEDIATE = (int32_t)14ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ConstrType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, ConstrType value);
#endif

enum class ImportForeignSchemaType
{
    IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED = (int32_t)0ll,
    FDW_IMPORT_SCHEMA_ALL = (int32_t)1ll,
    FDW_IMPORT_SCHEMA_LIMIT_TO = (int32_t)2ll,
    FDW_IMPORT_SCHEMA_EXCEPT = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ImportForeignSchemaType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, ImportForeignSchemaType value);
#endif

enum class RoleStmtType
{
    ROLE_STMT_TYPE_UNDEFINED = (int32_t)0ll,
    ROLESTMT_ROLE = (int32_t)1ll,
    ROLESTMT_USER = (int32_t)2ll,
    ROLESTMT_GROUP = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] RoleStmtType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, RoleStmtType value);
#endif

enum class FetchDirection
{
    FETCH_DIRECTION_UNDEFINED = (int32_t)0ll,
    FETCH_FORWARD = (int32_t)1ll,
    FETCH_BACKWARD = (int32_t)2ll,
    FETCH_ABSOLUTE = (int32_t)3ll,
    FETCH_RELATIVE = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] FetchDirection value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, FetchDirection value);
#endif

enum class FunctionParameterMode
{
    FUNCTION_PARAMETER_MODE_UNDEFINED = (int32_t)0ll,
    FUNC_PARAM_IN = (int32_t)1ll,
    FUNC_PARAM_OUT = (int32_t)2ll,
    FUNC_PARAM_INOUT = (int32_t)3ll,
    FUNC_PARAM_VARIADIC = (int32_t)4ll,
    FUNC_PARAM_TABLE = (int32_t)5ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] FunctionParameterMode value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, FunctionParameterMode value);
#endif

enum class TransactionStmtKind
{
    TRANSACTION_STMT_KIND_UNDEFINED = (int32_t)0ll,
    TRANS_STMT_BEGIN = (int32_t)1ll,
    TRANS_STMT_START = (int32_t)2ll,
    TRANS_STMT_COMMIT = (int32_t)3ll,
    TRANS_STMT_ROLLBACK = (int32_t)4ll,
    TRANS_STMT_SAVEPOINT = (int32_t)5ll,
    TRANS_STMT_RELEASE = (int32_t)6ll,
    TRANS_STMT_ROLLBACK_TO = (int32_t)7ll,
    TRANS_STMT_PREPARE = (int32_t)8ll,
    TRANS_STMT_COMMIT_PREPARED = (int32_t)9ll,
    TRANS_STMT_ROLLBACK_PREPARED = (int32_t)10ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] TransactionStmtKind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, TransactionStmtKind value);
#endif

enum class ViewCheckOption
{
    VIEW_CHECK_OPTION_UNDEFINED = (int32_t)0ll,
    NO_CHECK_OPTION = (int32_t)1ll,
    LOCAL_CHECK_OPTION = (int32_t)2ll,
    CASCADED_CHECK_OPTION = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ViewCheckOption value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, ViewCheckOption value);
#endif

enum class ClusterOption
{
    CLUSTER_OPTION_UNDEFINED = (int32_t)0ll,
    CLUOPT_RECHECK = (int32_t)1ll,
    CLUOPT_VERBOSE = (int32_t)2ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ClusterOption value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, ClusterOption value);
#endif

enum class DiscardMode
{
    DISCARD_MODE_UNDEFINED = (int32_t)0ll,
    DISCARD_ALL = (int32_t)1ll,
    DISCARD_PLANS = (int32_t)2ll,
    DISCARD_SEQUENCES = (int32_t)3ll,
    DISCARD_TEMP = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] DiscardMode value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, DiscardMode value);
#endif

enum class ReindexObjectType
{
    REINDEX_OBJECT_TYPE_UNDEFINED = (int32_t)0ll,
    REINDEX_OBJECT_INDEX = (int32_t)1ll,
    REINDEX_OBJECT_TABLE = (int32_t)2ll,
    REINDEX_OBJECT_SCHEMA = (int32_t)3ll,
    REINDEX_OBJECT_SYSTEM = (int32_t)4ll,
    REINDEX_OBJECT_DATABASE = (int32_t)5ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ReindexObjectType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, ReindexObjectType value);
#endif

enum class AlterTSConfigType
{
    ALTER_TSCONFIG_TYPE_UNDEFINED = (int32_t)0ll,
    ALTER_TSCONFIG_ADD_MAPPING = (int32_t)1ll,
    ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN = (int32_t)2ll,
    ALTER_TSCONFIG_REPLACE_DICT = (int32_t)3ll,
    ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN = (int32_t)4ll,
    ALTER_TSCONFIG_DROP_MAPPING = (int32_t)5ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AlterTSConfigType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, AlterTSConfigType value);
#endif

enum class AlterSubscriptionType
{
    ALTER_SUBSCRIPTION_TYPE_UNDEFINED = (int32_t)0ll,
    ALTER_SUBSCRIPTION_OPTIONS = (int32_t)1ll,
    ALTER_SUBSCRIPTION_CONNECTION = (int32_t)2ll,
    ALTER_SUBSCRIPTION_PUBLICATION = (int32_t)3ll,
    ALTER_SUBSCRIPTION_REFRESH = (int32_t)4ll,
    ALTER_SUBSCRIPTION_ENABLED = (int32_t)5ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AlterSubscriptionType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, AlterSubscriptionType value);
#endif

enum class OnCommitAction
{
    ON_COMMIT_ACTION_UNDEFINED = (int32_t)0ll,
    ONCOMMIT_NOOP = (int32_t)1ll,
    ONCOMMIT_PRESERVE_ROWS = (int32_t)2ll,
    ONCOMMIT_DELETE_ROWS = (int32_t)3ll,
    ONCOMMIT_DROP = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] OnCommitAction value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, OnCommitAction value);
#endif

enum class ParamKind
{
    PARAM_KIND_UNDEFINED = (int32_t)0ll,
    PARAM_EXTERN = (int32_t)1ll,
    PARAM_EXEC = (int32_t)2ll,
    PARAM_SUBLINK = (int32_t)3ll,
    PARAM_MULTIEXPR = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] ParamKind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, ParamKind value);
#endif

enum class CoercionContext
{
    COERCION_CONTEXT_UNDEFINED = (int32_t)0ll,
    COERCION_IMPLICIT = (int32_t)1ll,
    COERCION_ASSIGNMENT = (int32_t)2ll,
    COERCION_EXPLICIT = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] CoercionContext value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, CoercionContext value);
#endif

enum class CoercionForm
{
    COERCION_FORM_UNDEFINED = (int32_t)0ll,
    COERCE_EXPLICIT_CALL = (int32_t)1ll,
    COERCE_EXPLICIT_CAST = (int32_t)2ll,
    COERCE_IMPLICIT_CAST = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] CoercionForm value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, CoercionForm value);
#endif

enum class BoolExprType
{
    BOOL_EXPR_TYPE_UNDEFINED = (int32_t)0ll,
    AND_EXPR = (int32_t)1ll,
    OR_EXPR = (int32_t)2ll,
    NOT_EXPR = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] BoolExprType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, BoolExprType value);
#endif

enum class SubLinkType
{
    SUB_LINK_TYPE_UNDEFINED = (int32_t)0ll,
    EXISTS_SUBLINK = (int32_t)1ll,
    ALL_SUBLINK = (int32_t)2ll,
    ANY_SUBLINK = (int32_t)3ll,
    ROWCOMPARE_SUBLINK = (int32_t)4ll,
    EXPR_SUBLINK = (int32_t)5ll,
    MULTIEXPR_SUBLINK = (int32_t)6ll,
    ARRAY_SUBLINK = (int32_t)7ll,
    CTE_SUBLINK = (int32_t)8ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SubLinkType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, SubLinkType value);
#endif

enum class RowCompareType
{
    ROW_COMPARE_TYPE_UNDEFINED = (int32_t)0ll,
    ROWCOMPARE_LT = (int32_t)1ll,
    ROWCOMPARE_LE = (int32_t)2ll,
    ROWCOMPARE_EQ = (int32_t)3ll,
    ROWCOMPARE_GE = (int32_t)4ll,
    ROWCOMPARE_GT = (int32_t)5ll,
    ROWCOMPARE_NE = (int32_t)6ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] RowCompareType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, RowCompareType value);
#endif

enum class MinMaxOp
{
    MIN_MAX_OP_UNDEFINED = (int32_t)0ll,
    IS_GREATEST = (int32_t)1ll,
    IS_LEAST = (int32_t)2ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] MinMaxOp value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, MinMaxOp value);
#endif

enum class SQLValueFunctionOp
{
    SQLVALUE_FUNCTION_OP_UNDEFINED = (int32_t)0ll,
    SVFOP_CURRENT_DATE = (int32_t)1ll,
    SVFOP_CURRENT_TIME = (int32_t)2ll,
    SVFOP_CURRENT_TIME_N = (int32_t)3ll,
    SVFOP_CURRENT_TIMESTAMP = (int32_t)4ll,
    SVFOP_CURRENT_TIMESTAMP_N = (int32_t)5ll,
    SVFOP_LOCALTIME = (int32_t)6ll,
    SVFOP_LOCALTIME_N = (int32_t)7ll,
    SVFOP_LOCALTIMESTAMP = (int32_t)8ll,
    SVFOP_LOCALTIMESTAMP_N = (int32_t)9ll,
    SVFOP_CURRENT_ROLE = (int32_t)10ll,
    SVFOP_CURRENT_USER = (int32_t)11ll,
    SVFOP_USER = (int32_t)12ll,
    SVFOP_SESSION_USER = (int32_t)13ll,
    SVFOP_CURRENT_CATALOG = (int32_t)14ll,
    SVFOP_CURRENT_SCHEMA = (int32_t)15ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SQLValueFunctionOp value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, SQLValueFunctionOp value);
#endif

enum class XmlExprOp
{
    XML_EXPR_OP_UNDEFINED = (int32_t)0ll,
    IS_XMLCONCAT = (int32_t)1ll,
    IS_XMLELEMENT = (int32_t)2ll,
    IS_XMLFOREST = (int32_t)3ll,
    IS_XMLPARSE = (int32_t)4ll,
    IS_XMLPI = (int32_t)5ll,
    IS_XMLROOT = (int32_t)6ll,
    IS_XMLSERIALIZE = (int32_t)7ll,
    IS_DOCUMENT = (int32_t)8ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] XmlExprOp value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, XmlExprOp value);
#endif

enum class XmlOptionType
{
    XML_OPTION_TYPE_UNDEFINED = (int32_t)0ll,
    XMLOPTION_DOCUMENT = (int32_t)1ll,
    XMLOPTION_CONTENT = (int32_t)2ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] XmlOptionType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, XmlOptionType value);
#endif

enum class NullTestType
{
    NULL_TEST_TYPE_UNDEFINED = (int32_t)0ll,
    IS_NULL = (int32_t)1ll,
    IS_NOT_NULL = (int32_t)2ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] NullTestType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, NullTestType value);
#endif

enum class BoolTestType
{
    BOOL_TEST_TYPE_UNDEFINED = (int32_t)0ll,
    IS_TRUE = (int32_t)1ll,
    IS_NOT_TRUE = (int32_t)2ll,
    IS_FALSE = (int32_t)3ll,
    IS_NOT_FALSE = (int32_t)4ll,
    IS_UNKNOWN = (int32_t)5ll,
    IS_NOT_UNKNOWN = (int32_t)6ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] BoolTestType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, BoolTestType value);
#endif

enum class CmdType
{
    CMD_TYPE_UNDEFINED = (int32_t)0ll,
    CMD_UNKNOWN = (int32_t)1ll,
    CMD_SELECT = (int32_t)2ll,
    CMD_UPDATE = (int32_t)3ll,
    CMD_INSERT = (int32_t)4ll,
    CMD_DELETE = (int32_t)5ll,
    CMD_UTILITY = (int32_t)6ll,
    CMD_NOTHING = (int32_t)7ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] CmdType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, CmdType value);
#endif

enum class JoinType
{
    JOIN_TYPE_UNDEFINED = (int32_t)0ll,
    JOIN_INNER = (int32_t)1ll,
    JOIN_LEFT = (int32_t)2ll,
    JOIN_FULL = (int32_t)3ll,
    JOIN_RIGHT = (int32_t)4ll,
    JOIN_SEMI = (int32_t)5ll,
    JOIN_ANTI = (int32_t)6ll,
    JOIN_UNIQUE_OUTER = (int32_t)7ll,
    JOIN_UNIQUE_INNER = (int32_t)8ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] JoinType value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, JoinType value);
#endif

enum class AggStrategy
{
    AGG_STRATEGY_UNDEFINED = (int32_t)0ll,
    AGG_PLAIN = (int32_t)1ll,
    AGG_SORTED = (int32_t)2ll,
    AGG_HASHED = (int32_t)3ll,
    AGG_MIXED = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AggStrategy value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, AggStrategy value);
#endif

enum class AggSplit
{
    AGG_SPLIT_UNDEFINED = (int32_t)0ll,
    AGGSPLIT_SIMPLE = (int32_t)1ll,
    AGGSPLIT_INITIAL_SERIAL = (int32_t)2ll,
    AGGSPLIT_FINAL_DESERIAL = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] AggSplit value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, AggSplit value);
#endif

enum class SetOpCmd
{
    SET_OP_CMD_UNDEFINED = (int32_t)0ll,
    SETOPCMD_INTERSECT = (int32_t)1ll,
    SETOPCMD_INTERSECT_ALL = (int32_t)2ll,
    SETOPCMD_EXCEPT = (int32_t)3ll,
    SETOPCMD_EXCEPT_ALL = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SetOpCmd value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, SetOpCmd value);
#endif

enum class SetOpStrategy
{
    SET_OP_STRATEGY_UNDEFINED = (int32_t)0ll,
    SETOP_SORTED = (int32_t)1ll,
    SETOP_HASHED = (int32_t)2ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] SetOpStrategy value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, SetOpStrategy value);
#endif

enum class OnConflictAction
{
    ON_CONFLICT_ACTION_UNDEFINED = (int32_t)0ll,
    ONCONFLICT_NONE = (int32_t)1ll,
    ONCONFLICT_NOTHING = (int32_t)2ll,
    ONCONFLICT_UPDATE = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] OnConflictAction value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, OnConflictAction value);
#endif

enum class LimitOption
{
    LIMIT_OPTION_UNDEFINED = (int32_t)0ll,
    LIMIT_OPTION_DEFAULT = (int32_t)1ll,
    LIMIT_OPTION_COUNT = (int32_t)2ll,
    LIMIT_OPTION_WITH_TIES = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] LimitOption value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, LimitOption value);
#endif

enum class LockClauseStrength
{
    LOCK_CLAUSE_STRENGTH_UNDEFINED = (int32_t)0ll,
    LCS_NONE = (int32_t)1ll,
    LCS_FORKEYSHARE = (int32_t)2ll,
    LCS_FORSHARE = (int32_t)3ll,
    LCS_FORNOKEYUPDATE = (int32_t)4ll,
    LCS_FORUPDATE = (int32_t)5ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] LockClauseStrength value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, LockClauseStrength value);
#endif

enum class LockWaitPolicy
{
    LOCK_WAIT_POLICY_UNDEFINED = (int32_t)0ll,
    LockWaitBlock = (int32_t)1ll,
    LockWaitSkip = (int32_t)2ll,
    LockWaitError = (int32_t)3ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] LockWaitPolicy value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, LockWaitPolicy value);
#endif

enum class LockTupleMode
{
    LOCK_TUPLE_MODE_UNDEFINED = (int32_t)0ll,
    LockTupleKeyShare = (int32_t)1ll,
    LockTupleShare = (int32_t)2ll,
    LockTupleNoKeyExclusive = (int32_t)3ll,
    LockTupleExclusive = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] LockTupleMode value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, LockTupleMode value);
#endif

enum class KeywordKind
{
    NO_KEYWORD = (int32_t)0ll,
    UNRESERVED_KEYWORD = (int32_t)1ll,
    COL_NAME_KEYWORD = (int32_t)2ll,
    TYPE_FUNC_NAME_KEYWORD = (int32_t)3ll,
    RESERVED_KEYWORD = (int32_t)4ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] KeywordKind value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, KeywordKind value);
#endif

enum class Token
{
    NUL = (int32_t)0ll,
    ASCII_37 = (int32_t)37ll,
    ASCII_40 = (int32_t)40ll,
    ASCII_41 = (int32_t)41ll,
    ASCII_42 = (int32_t)42ll,
    ASCII_43 = (int32_t)43ll,
    ASCII_44 = (int32_t)44ll,
    ASCII_45 = (int32_t)45ll,
    ASCII_46 = (int32_t)46ll,
    ASCII_47 = (int32_t)47ll,
    ASCII_58 = (int32_t)58ll,
    ASCII_59 = (int32_t)59ll,
    ASCII_60 = (int32_t)60ll,
    ASCII_61 = (int32_t)61ll,
    ASCII_62 = (int32_t)62ll,
    ASCII_63 = (int32_t)63ll,
    ASCII_91 = (int32_t)91ll,
    ASCII_92 = (int32_t)92ll,
    ASCII_93 = (int32_t)93ll,
    ASCII_94 = (int32_t)94ll,
    IDENT = (int32_t)258ll,
    UIDENT = (int32_t)259ll,
    FCONST = (int32_t)260ll,
    SCONST = (int32_t)261ll,
    USCONST = (int32_t)262ll,
    BCONST = (int32_t)263ll,
    XCONST = (int32_t)264ll,
    Op = (int32_t)265ll,
    ICONST = (int32_t)266ll,
    PARAM = (int32_t)267ll,
    TYPECAST = (int32_t)268ll,
    DOT_DOT = (int32_t)269ll,
    COLON_EQUALS = (int32_t)270ll,
    EQUALS_GREATER = (int32_t)271ll,
    LESS_EQUALS = (int32_t)272ll,
    GREATER_EQUALS = (int32_t)273ll,
    NOT_EQUALS = (int32_t)274ll,
    SQL_COMMENT = (int32_t)275ll,
    C_COMMENT = (int32_t)276ll,
    ABORT_P = (int32_t)277ll,
    ABSOLUTE_P = (int32_t)278ll,
    ACCESS = (int32_t)279ll,
    ACTION = (int32_t)280ll,
    ADD_P = (int32_t)281ll,
    ADMIN = (int32_t)282ll,
    AFTER = (int32_t)283ll,
    AGGREGATE = (int32_t)284ll,
    ALL = (int32_t)285ll,
    ALSO = (int32_t)286ll,
    ALTER = (int32_t)287ll,
    ALWAYS = (int32_t)288ll,
    ANALYSE = (int32_t)289ll,
    ANALYZE = (int32_t)290ll,
    AND = (int32_t)291ll,
    ANY = (int32_t)292ll,
    ARRAY = (int32_t)293ll,
    AS = (int32_t)294ll,
    ASC = (int32_t)295ll,
    ASSERTION = (int32_t)296ll,
    ASSIGNMENT = (int32_t)297ll,
    ASYMMETRIC = (int32_t)298ll,
    AT = (int32_t)299ll,
    ATTACH = (int32_t)300ll,
    ATTRIBUTE = (int32_t)301ll,
    AUTHORIZATION = (int32_t)302ll,
    BACKWARD = (int32_t)303ll,
    BEFORE = (int32_t)304ll,
    BEGIN_P = (int32_t)305ll,
    BETWEEN = (int32_t)306ll,
    BIGINT = (int32_t)307ll,
    BINARY = (int32_t)308ll,
    BIT = (int32_t)309ll,
    BOOLEAN_P = (int32_t)310ll,
    BOTH = (int32_t)311ll,
    BY = (int32_t)312ll,
    CACHE = (int32_t)313ll,
    CALL = (int32_t)314ll,
    CALLED = (int32_t)315ll,
    CASCADE = (int32_t)316ll,
    CASCADED = (int32_t)317ll,
    CASE = (int32_t)318ll,
    CAST = (int32_t)319ll,
    CATALOG_P = (int32_t)320ll,
    CHAIN = (int32_t)321ll,
    CHAR_P = (int32_t)322ll,
    CHARACTER = (int32_t)323ll,
    CHARACTERISTICS = (int32_t)324ll,
    CHECK = (int32_t)325ll,
    CHECKPOINT = (int32_t)326ll,
    CLASS = (int32_t)327ll,
    CLOSE = (int32_t)328ll,
    CLUSTER = (int32_t)329ll,
    COALESCE = (int32_t)330ll,
    COLLATE = (int32_t)331ll,
    COLLATION = (int32_t)332ll,
    COLUMN = (int32_t)333ll,
    COLUMNS = (int32_t)334ll,
    COMMENT = (int32_t)335ll,
    COMMENTS = (int32_t)336ll,
    COMMIT = (int32_t)337ll,
    COMMITTED = (int32_t)338ll,
    CONCURRENTLY = (int32_t)339ll,
    CONFIGURATION = (int32_t)340ll,
    CONFLICT = (int32_t)341ll,
    CONNECTION = (int32_t)342ll,
    CONSTRAINT = (int32_t)343ll,
    CONSTRAINTS = (int32_t)344ll,
    CONTENT_P = (int32_t)345ll,
    CONTINUE_P = (int32_t)346ll,
    CONVERSION_P = (int32_t)347ll,
    COPY = (int32_t)348ll,
    COST = (int32_t)349ll,
    CREATE = (int32_t)350ll,
    CROSS = (int32_t)351ll,
    CSV = (int32_t)352ll,
    CUBE = (int32_t)353ll,
    CURRENT_P = (int32_t)354ll,
    CURRENT_CATALOG = (int32_t)355ll,
    CURRENT_DATE = (int32_t)356ll,
    CURRENT_ROLE = (int32_t)357ll,
    CURRENT_SCHEMA = (int32_t)358ll,
    CURRENT_TIME = (int32_t)359ll,
    CURRENT_TIMESTAMP = (int32_t)360ll,
    CURRENT_USER = (int32_t)361ll,
    CURSOR = (int32_t)362ll,
    CYCLE = (int32_t)363ll,
    DATA_P = (int32_t)364ll,
    DATABASE = (int32_t)365ll,
    DAY_P = (int32_t)366ll,
    DEALLOCATE = (int32_t)367ll,
    DEC = (int32_t)368ll,
    DECIMAL_P = (int32_t)369ll,
    DECLARE = (int32_t)370ll,
    DEFAULT = (int32_t)371ll,
    DEFAULTS = (int32_t)372ll,
    DEFERRABLE = (int32_t)373ll,
    DEFERRED = (int32_t)374ll,
    DEFINER = (int32_t)375ll,
    DELETE_P = (int32_t)376ll,
    DELIMITER = (int32_t)377ll,
    DELIMITERS = (int32_t)378ll,
    DEPENDS = (int32_t)379ll,
    DESC = (int32_t)380ll,
    DETACH = (int32_t)381ll,
    DICTIONARY = (int32_t)382ll,
    DISABLE_P = (int32_t)383ll,
    DISCARD = (int32_t)384ll,
    DISTINCT = (int32_t)385ll,
    DO = (int32_t)386ll,
    DOCUMENT_P = (int32_t)387ll,
    DOMAIN_P = (int32_t)388ll,
    DOUBLE_P = (int32_t)389ll,
    DROP = (int32_t)390ll,
    EACH = (int32_t)391ll,
    ELSE = (int32_t)392ll,
    ENABLE_P = (int32_t)393ll,
    ENCODING = (int32_t)394ll,
    ENCRYPTED = (int32_t)395ll,
    END_P = (int32_t)396ll,
    ENUM_P = (int32_t)397ll,
    ESCAPE = (int32_t)398ll,
    EVENT = (int32_t)399ll,
    EXCEPT = (int32_t)400ll,
    EXCLUDE = (int32_t)401ll,
    EXCLUDING = (int32_t)402ll,
    EXCLUSIVE = (int32_t)403ll,
    EXECUTE = (int32_t)404ll,
    EXISTS = (int32_t)405ll,
    EXPLAIN = (int32_t)406ll,
    EXPRESSION = (int32_t)407ll,
    EXTENSION = (int32_t)408ll,
    EXTERNAL = (int32_t)409ll,
    EXTRACT = (int32_t)410ll,
    FALSE_P = (int32_t)411ll,
    FAMILY = (int32_t)412ll,
    FETCH = (int32_t)413ll,
    FILTER = (int32_t)414ll,
    FIRST_P = (int32_t)415ll,
    FLOAT_P = (int32_t)416ll,
    FOLLOWING = (int32_t)417ll,
    FOR = (int32_t)418ll,
    FORCE = (int32_t)419ll,
    FOREIGN = (int32_t)420ll,
    FORWARD = (int32_t)421ll,
    FREEZE = (int32_t)422ll,
    FROM = (int32_t)423ll,
    FULL = (int32_t)424ll,
    FUNCTION = (int32_t)425ll,
    FUNCTIONS = (int32_t)426ll,
    GENERATED = (int32_t)427ll,
    GLOBAL = (int32_t)428ll,
    GRANT = (int32_t)429ll,
    GRANTED = (int32_t)430ll,
    GREATEST = (int32_t)431ll,
    GROUP_P = (int32_t)432ll,
    GROUPING = (int32_t)433ll,
    GROUPS = (int32_t)434ll,
    HANDLER = (int32_t)435ll,
    HAVING = (int32_t)436ll,
    HEADER_P = (int32_t)437ll,
    HOLD = (int32_t)438ll,
    HOUR_P = (int32_t)439ll,
    IDENTITY_P = (int32_t)440ll,
    IF_P = (int32_t)441ll,
    ILIKE = (int32_t)442ll,
    IMMEDIATE = (int32_t)443ll,
    IMMUTABLE = (int32_t)444ll,
    IMPLICIT_P = (int32_t)445ll,
    IMPORT_P = (int32_t)446ll,
    IN_P = (int32_t)447ll,
    INCLUDE = (int32_t)448ll,
    INCLUDING = (int32_t)449ll,
    INCREMENT = (int32_t)450ll,
    INDEX = (int32_t)451ll,
    INDEXES = (int32_t)452ll,
    INHERIT = (int32_t)453ll,
    INHERITS = (int32_t)454ll,
    INITIALLY = (int32_t)455ll,
    INLINE_P = (int32_t)456ll,
    INNER_P = (int32_t)457ll,
    INOUT = (int32_t)458ll,
    INPUT_P = (int32_t)459ll,
    INSENSITIVE = (int32_t)460ll,
    INSERT = (int32_t)461ll,
    INSTEAD = (int32_t)462ll,
    INT_P = (int32_t)463ll,
    INTEGER = (int32_t)464ll,
    INTERSECT = (int32_t)465ll,
    INTERVAL = (int32_t)466ll,
    INTO = (int32_t)467ll,
    INVOKER = (int32_t)468ll,
    IS = (int32_t)469ll,
    ISNULL = (int32_t)470ll,
    ISOLATION = (int32_t)471ll,
    JOIN = (int32_t)472ll,
    KEY = (int32_t)473ll,
    LABEL = (int32_t)474ll,
    LANGUAGE = (int32_t)475ll,
    LARGE_P = (int32_t)476ll,
    LAST_P = (int32_t)477ll,
    LATERAL_P = (int32_t)478ll,
    LEADING = (int32_t)479ll,
    LEAKPROOF = (int32_t)480ll,
    LEAST = (int32_t)481ll,
    LEFT = (int32_t)482ll,
    LEVEL = (int32_t)483ll,
    LIKE = (int32_t)484ll,
    LIMIT = (int32_t)485ll,
    LISTEN = (int32_t)486ll,
    LOAD = (int32_t)487ll,
    LOCAL = (int32_t)488ll,
    LOCALTIME = (int32_t)489ll,
    LOCALTIMESTAMP = (int32_t)490ll,
    LOCATION = (int32_t)491ll,
    LOCK_P = (int32_t)492ll,
    LOCKED = (int32_t)493ll,
    LOGGED = (int32_t)494ll,
    MAPPING = (int32_t)495ll,
    MATCH = (int32_t)496ll,
    MATERIALIZED = (int32_t)497ll,
    MAXVALUE = (int32_t)498ll,
    METHOD = (int32_t)499ll,
    MINUTE_P = (int32_t)500ll,
    MINVALUE = (int32_t)501ll,
    MODE = (int32_t)502ll,
    MONTH_P = (int32_t)503ll,
    MOVE = (int32_t)504ll,
    NAME_P = (int32_t)505ll,
    NAMES = (int32_t)506ll,
    NATIONAL = (int32_t)507ll,
    NATURAL = (int32_t)508ll,
    NCHAR = (int32_t)509ll,
    NEW = (int32_t)510ll,
    NEXT = (int32_t)511ll,
    NFC = (int32_t)512ll,
    NFD = (int32_t)513ll,
    NFKC = (int32_t)514ll,
    NFKD = (int32_t)515ll,
    NO = (int32_t)516ll,
    NONE = (int32_t)517ll,
    NORMALIZE = (int32_t)518ll,
    NORMALIZED = (int32_t)519ll,
    NOT = (int32_t)520ll,
    NOTHING = (int32_t)521ll,
    NOTIFY = (int32_t)522ll,
    NOTNULL = (int32_t)523ll,
    NOWAIT = (int32_t)524ll,
    NULL_P = (int32_t)525ll,
    NULLIF = (int32_t)526ll,
    NULLS_P = (int32_t)527ll,
    NUMERIC = (int32_t)528ll,
    OBJECT_P = (int32_t)529ll,
    OF = (int32_t)530ll,
    OFF = (int32_t)531ll,
    OFFSET = (int32_t)532ll,
    OIDS = (int32_t)533ll,
    OLD = (int32_t)534ll,
    ON = (int32_t)535ll,
    ONLY = (int32_t)536ll,
    OPERATOR = (int32_t)537ll,
    OPTION = (int32_t)538ll,
    OPTIONS = (int32_t)539ll,
    OR = (int32_t)540ll,
    ORDER = (int32_t)541ll,
    ORDINALITY = (int32_t)542ll,
    OTHERS = (int32_t)543ll,
    OUT_P = (int32_t)544ll,
    OUTER_P = (int32_t)545ll,
    OVER = (int32_t)546ll,
    OVERLAPS = (int32_t)547ll,
    OVERLAY = (int32_t)548ll,
    OVERRIDING = (int32_t)549ll,
    OWNED = (int32_t)550ll,
    OWNER = (int32_t)551ll,
    PARALLEL = (int32_t)552ll,
    PARSER = (int32_t)553ll,
    PARTIAL = (int32_t)554ll,
    PARTITION = (int32_t)555ll,
    PASSING = (int32_t)556ll,
    PASSWORD = (int32_t)557ll,
    PLACING = (int32_t)558ll,
    PLANS = (int32_t)559ll,
    POLICY = (int32_t)560ll,
    POSITION = (int32_t)561ll,
    PRECEDING = (int32_t)562ll,
    PRECISION = (int32_t)563ll,
    PRESERVE = (int32_t)564ll,
    PREPARE = (int32_t)565ll,
    PREPARED = (int32_t)566ll,
    PRIMARY = (int32_t)567ll,
    PRIOR = (int32_t)568ll,
    PRIVILEGES = (int32_t)569ll,
    PROCEDURAL = (int32_t)570ll,
    PROCEDURE = (int32_t)571ll,
    PROCEDURES = (int32_t)572ll,
    PROGRAM = (int32_t)573ll,
    PUBLICATION = (int32_t)574ll,
    QUOTE = (int32_t)575ll,
    RANGE = (int32_t)576ll,
    READ = (int32_t)577ll,
    REAL = (int32_t)578ll,
    REASSIGN = (int32_t)579ll,
    RECHECK = (int32_t)580ll,
    RECURSIVE = (int32_t)581ll,
    REF = (int32_t)582ll,
    REFERENCES = (int32_t)583ll,
    REFERENCING = (int32_t)584ll,
    REFRESH = (int32_t)585ll,
    REINDEX = (int32_t)586ll,
    RELATIVE_P = (int32_t)587ll,
    RELEASE = (int32_t)588ll,
    RENAME = (int32_t)589ll,
    REPEATABLE = (int32_t)590ll,
    REPLACE = (int32_t)591ll,
    REPLICA = (int32_t)592ll,
    RESET = (int32_t)593ll,
    RESTART = (int32_t)594ll,
    RESTRICT = (int32_t)595ll,
    RETURNING = (int32_t)596ll,
    RETURNS = (int32_t)597ll,
    REVOKE = (int32_t)598ll,
    RIGHT = (int32_t)599ll,
    ROLE = (int32_t)600ll,
    ROLLBACK = (int32_t)601ll,
    ROLLUP = (int32_t)602ll,
    ROUTINE = (int32_t)603ll,
    ROUTINES = (int32_t)604ll,
    ROW = (int32_t)605ll,
    ROWS = (int32_t)606ll,
    RULE = (int32_t)607ll,
    SAVEPOINT = (int32_t)608ll,
    SCHEMA = (int32_t)609ll,
    SCHEMAS = (int32_t)610ll,
    SCROLL = (int32_t)611ll,
    SEARCH = (int32_t)612ll,
    SECOND_P = (int32_t)613ll,
    SECURITY = (int32_t)614ll,
    SELECT = (int32_t)615ll,
    SEQUENCE = (int32_t)616ll,
    SEQUENCES = (int32_t)617ll,
    SERIALIZABLE = (int32_t)618ll,
    SERVER = (int32_t)619ll,
    SESSION = (int32_t)620ll,
    SESSION_USER = (int32_t)621ll,
    SET = (int32_t)622ll,
    SETS = (int32_t)623ll,
    SETOF = (int32_t)624ll,
    SHARE = (int32_t)625ll,
    SHOW = (int32_t)626ll,
    SIMILAR = (int32_t)627ll,
    SIMPLE = (int32_t)628ll,
    SKIP = (int32_t)629ll,
    SMALLINT = (int32_t)630ll,
    SNAPSHOT = (int32_t)631ll,
    SOME = (int32_t)632ll,
    SQL_P = (int32_t)633ll,
    STABLE = (int32_t)634ll,
    STANDALONE_P = (int32_t)635ll,
    START = (int32_t)636ll,
    STATEMENT = (int32_t)637ll,
    STATISTICS = (int32_t)638ll,
    STDIN = (int32_t)639ll,
    STDOUT = (int32_t)640ll,
    STORAGE = (int32_t)641ll,
    STORED = (int32_t)642ll,
    STRICT_P = (int32_t)643ll,
    STRIP_P = (int32_t)644ll,
    SUBSCRIPTION = (int32_t)645ll,
    SUBSTRING = (int32_t)646ll,
    SUPPORT = (int32_t)647ll,
    SYMMETRIC = (int32_t)648ll,
    SYSID = (int32_t)649ll,
    SYSTEM_P = (int32_t)650ll,
    TABLE = (int32_t)651ll,
    TABLES = (int32_t)652ll,
    TABLESAMPLE = (int32_t)653ll,
    TABLESPACE = (int32_t)654ll,
    TEMP = (int32_t)655ll,
    TEMPLATE = (int32_t)656ll,
    TEMPORARY = (int32_t)657ll,
    TEXT_P = (int32_t)658ll,
    THEN = (int32_t)659ll,
    TIES = (int32_t)660ll,
    TIME = (int32_t)661ll,
    TIMESTAMP = (int32_t)662ll,
    TO = (int32_t)663ll,
    TRAILING = (int32_t)664ll,
    TRANSACTION = (int32_t)665ll,
    TRANSFORM = (int32_t)666ll,
    TREAT = (int32_t)667ll,
    TRIGGER = (int32_t)668ll,
    TRIM = (int32_t)669ll,
    TRUE_P = (int32_t)670ll,
    TRUNCATE = (int32_t)671ll,
    TRUSTED = (int32_t)672ll,
    TYPE_P = (int32_t)673ll,
    TYPES_P = (int32_t)674ll,
    UESCAPE = (int32_t)675ll,
    UNBOUNDED = (int32_t)676ll,
    UNCOMMITTED = (int32_t)677ll,
    UNENCRYPTED = (int32_t)678ll,
    UNION = (int32_t)679ll,
    UNIQUE = (int32_t)680ll,
    UNKNOWN = (int32_t)681ll,
    UNLISTEN = (int32_t)682ll,
    UNLOGGED = (int32_t)683ll,
    UNTIL = (int32_t)684ll,
    UPDATE = (int32_t)685ll,
    USER = (int32_t)686ll,
    USING = (int32_t)687ll,
    VACUUM = (int32_t)688ll,
    VALID = (int32_t)689ll,
    VALIDATE = (int32_t)690ll,
    VALIDATOR = (int32_t)691ll,
    VALUE_P = (int32_t)692ll,
    VALUES = (int32_t)693ll,
    VARCHAR = (int32_t)694ll,
    VARIADIC = (int32_t)695ll,
    VARYING = (int32_t)696ll,
    VERBOSE = (int32_t)697ll,
    VERSION_P = (int32_t)698ll,
    VIEW = (int32_t)699ll,
    VIEWS = (int32_t)700ll,
    VOLATILE = (int32_t)701ll,
    WHEN = (int32_t)702ll,
    WHERE = (int32_t)703ll,
    WHITESPACE_P = (int32_t)704ll,
    WINDOW = (int32_t)705ll,
    WITH = (int32_t)706ll,
    WITHIN = (int32_t)707ll,
    WITHOUT = (int32_t)708ll,
    WORK = (int32_t)709ll,
    WRAPPER = (int32_t)710ll,
    WRITE = (int32_t)711ll,
    XML_P = (int32_t)712ll,
    XMLATTRIBUTES = (int32_t)713ll,
    XMLCONCAT = (int32_t)714ll,
    XMLELEMENT = (int32_t)715ll,
    XMLEXISTS = (int32_t)716ll,
    XMLFOREST = (int32_t)717ll,
    XMLNAMESPACES = (int32_t)718ll,
    XMLPARSE = (int32_t)719ll,
    XMLPI = (int32_t)720ll,
    XMLROOT = (int32_t)721ll,
    XMLSERIALIZE = (int32_t)722ll,
    XMLTABLE = (int32_t)723ll,
    YEAR_P = (int32_t)724ll,
    YES_P = (int32_t)725ll,
    ZONE = (int32_t)726ll,
    NOT_LA = (int32_t)727ll,
    NULLS_LA = (int32_t)728ll,
    WITH_LA = (int32_t)729ll,
    POSTFIXOP = (int32_t)730ll,
    UMINUS = (int32_t)731ll,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] Token value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, Token value);
#endif
// forward declaration
struct Integer;
struct Float;
struct String;
struct BitString;
struct Null;
struct List;
struct OidList;
struct IntList;
struct Alias;
struct RangeVar;
struct TableFunc;
struct Expr;
struct Var;
struct Param;
struct Aggref;
struct GroupingFunc;
struct WindowFunc;
struct SubscriptingRef;
struct FuncExpr;
struct NamedArgExpr;
struct OpExpr;
struct DistinctExpr;
struct NullIfExpr;
struct ScalarArrayOpExpr;
struct BoolExpr;
struct SubLink;
struct SubPlan;
struct AlternativeSubPlan;
struct FieldSelect;
struct FieldStore;
struct RelabelType;
struct CoerceViaIO;
struct ArrayCoerceExpr;
struct ConvertRowtypeExpr;
struct CollateExpr;
struct CaseExpr;
struct CaseWhen;
struct CaseTestExpr;
struct ArrayExpr;
struct RowExpr;
struct RowCompareExpr;
struct CoalesceExpr;
struct MinMaxExpr;
struct SQLValueFunction;
struct XmlExpr;
struct NullTest;
struct BooleanTest;
struct CoerceToDomain;
struct CoerceToDomainValue;
struct SetToDefault;
struct CurrentOfExpr;
struct NextValueExpr;
struct InferenceElem;
struct TargetEntry;
struct RangeTblRef;
struct JoinExpr;
struct FromExpr;
struct OnConflictExpr;
struct IntoClause;
struct RawStmt;
struct Query;
struct InsertStmt;
struct DeleteStmt;
struct UpdateStmt;
struct SelectStmt;
struct AlterTableStmt;
struct AlterTableCmd;
struct AlterDomainStmt;
struct SetOperationStmt;
struct GrantStmt;
struct GrantRoleStmt;
struct AlterDefaultPrivilegesStmt;
struct ClosePortalStmt;
struct ClusterStmt;
struct CopyStmt;
struct CreateStmt;
struct DefineStmt;
struct DropStmt;
struct TruncateStmt;
struct CommentStmt;
struct FetchStmt;
struct IndexStmt;
struct CreateFunctionStmt;
struct AlterFunctionStmt;
struct DoStmt;
struct RenameStmt;
struct RuleStmt;
struct NotifyStmt;
struct ListenStmt;
struct UnlistenStmt;
struct TransactionStmt;
struct ViewStmt;
struct LoadStmt;
struct CreateDomainStmt;
struct CreatedbStmt;
struct DropdbStmt;
struct VacuumStmt;
struct ExplainStmt;
struct CreateTableAsStmt;
struct CreateSeqStmt;
struct AlterSeqStmt;
struct VariableSetStmt;
struct VariableShowStmt;
struct DiscardStmt;
struct CreateTrigStmt;
struct CreatePLangStmt;
struct CreateRoleStmt;
struct AlterRoleStmt;
struct DropRoleStmt;
struct LockStmt;
struct ConstraintsSetStmt;
struct ReindexStmt;
struct CheckPointStmt;
struct CreateSchemaStmt;
struct AlterDatabaseStmt;
struct AlterDatabaseSetStmt;
struct AlterRoleSetStmt;
struct CreateConversionStmt;
struct CreateCastStmt;
struct CreateOpClassStmt;
struct CreateOpFamilyStmt;
struct AlterOpFamilyStmt;
struct PrepareStmt;
struct ExecuteStmt;
struct DeallocateStmt;
struct DeclareCursorStmt;
struct CreateTableSpaceStmt;
struct DropTableSpaceStmt;
struct AlterObjectDependsStmt;
struct AlterObjectSchemaStmt;
struct AlterOwnerStmt;
struct AlterOperatorStmt;
struct AlterTypeStmt;
struct DropOwnedStmt;
struct ReassignOwnedStmt;
struct CompositeTypeStmt;
struct CreateEnumStmt;
struct CreateRangeStmt;
struct AlterEnumStmt;
struct AlterTSDictionaryStmt;
struct AlterTSConfigurationStmt;
struct CreateFdwStmt;
struct AlterFdwStmt;
struct CreateForeignServerStmt;
struct AlterForeignServerStmt;
struct CreateUserMappingStmt;
struct AlterUserMappingStmt;
struct DropUserMappingStmt;
struct AlterTableSpaceOptionsStmt;
struct AlterTableMoveAllStmt;
struct SecLabelStmt;
struct CreateForeignTableStmt;
struct ImportForeignSchemaStmt;
struct CreateExtensionStmt;
struct AlterExtensionStmt;
struct AlterExtensionContentsStmt;
struct CreateEventTrigStmt;
struct AlterEventTrigStmt;
struct RefreshMatViewStmt;
struct ReplicaIdentityStmt;
struct AlterSystemStmt;
struct CreatePolicyStmt;
struct AlterPolicyStmt;
struct CreateTransformStmt;
struct CreateAmStmt;
struct CreatePublicationStmt;
struct AlterPublicationStmt;
struct CreateSubscriptionStmt;
struct AlterSubscriptionStmt;
struct DropSubscriptionStmt;
struct CreateStatsStmt;
struct AlterCollationStmt;
struct CallStmt;
struct AlterStatsStmt;
struct A_Expr;
struct ColumnRef;
struct ParamRef;
struct A_Const;
struct FuncCall;
struct A_Star;
struct A_Indices;
struct A_Indirection;
struct A_ArrayExpr;
struct ResTarget;
struct MultiAssignRef;
struct TypeCast;
struct CollateClause;
struct SortBy;
struct WindowDef;
struct RangeSubselect;
struct RangeFunction;
struct RangeTableSample;
struct RangeTableFunc;
struct RangeTableFuncCol;
struct TypeName;
struct ColumnDef;
struct IndexElem;
struct Constraint;
struct DefElem;
struct RangeTblEntry;
struct RangeTblFunction;
struct TableSampleClause;
struct WithCheckOption;
struct SortGroupClause;
struct GroupingSet;
struct WindowClause;
struct ObjectWithArgs;
struct AccessPriv;
struct CreateOpClassItem;
struct TableLikeClause;
struct FunctionParameter;
struct LockingClause;
struct RowMarkClause;
struct XmlSerialize;
struct WithClause;
struct InferClause;
struct OnConflictClause;
struct CommonTableExpr;
struct RoleSpec;
struct TriggerTransition;
struct PartitionElem;
struct PartitionSpec;
struct PartitionBoundSpec;
struct PartitionRangeDatum;
struct PartitionCmd;
struct VacuumRelation;
struct InlineCodeBlock;
struct CallContext;
struct ScanToken;
struct ParseResult;
struct ScanResult;

using Node = std::variant<::pg_query::Alias*, ::pg_query::RangeVar*, ::pg_query::TableFunc*, ::pg_query::Expr*, ::pg_query::Var*, ::pg_query::Param*, ::pg_query::Aggref*, ::pg_query::GroupingFunc*, ::pg_query::WindowFunc*, ::pg_query::SubscriptingRef*, ::pg_query::FuncExpr*, ::pg_query::NamedArgExpr*, ::pg_query::OpExpr*, ::pg_query::DistinctExpr*, ::pg_query::NullIfExpr*, ::pg_query::ScalarArrayOpExpr*, ::pg_query::BoolExpr*, ::pg_query::SubLink*, ::pg_query::SubPlan*, ::pg_query::AlternativeSubPlan*, ::pg_query::FieldSelect*, ::pg_query::FieldStore*, ::pg_query::RelabelType*, ::pg_query::CoerceViaIO*, ::pg_query::ArrayCoerceExpr*, ::pg_query::ConvertRowtypeExpr*, ::pg_query::CollateExpr*, ::pg_query::CaseExpr*, ::pg_query::CaseWhen*, ::pg_query::CaseTestExpr*, ::pg_query::ArrayExpr*, ::pg_query::RowExpr*, ::pg_query::RowCompareExpr*, ::pg_query::CoalesceExpr*, ::pg_query::MinMaxExpr*, ::pg_query::SQLValueFunction*, ::pg_query::XmlExpr*, ::pg_query::NullTest*, ::pg_query::BooleanTest*, ::pg_query::CoerceToDomain*, ::pg_query::CoerceToDomainValue*, ::pg_query::SetToDefault*, ::pg_query::CurrentOfExpr*, ::pg_query::NextValueExpr*, ::pg_query::InferenceElem*, ::pg_query::TargetEntry*, ::pg_query::RangeTblRef*, ::pg_query::JoinExpr*, ::pg_query::FromExpr*, ::pg_query::OnConflictExpr*, ::pg_query::IntoClause*, ::pg_query::RawStmt*, ::pg_query::Query*, ::pg_query::InsertStmt*, ::pg_query::DeleteStmt*, ::pg_query::UpdateStmt*, ::pg_query::SelectStmt*, ::pg_query::AlterTableStmt*, ::pg_query::AlterTableCmd*, ::pg_query::AlterDomainStmt*, ::pg_query::SetOperationStmt*, ::pg_query::GrantStmt*, ::pg_query::GrantRoleStmt*, ::pg_query::AlterDefaultPrivilegesStmt*, ::pg_query::ClosePortalStmt*, ::pg_query::ClusterStmt*, ::pg_query::CopyStmt*, ::pg_query::CreateStmt*, ::pg_query::DefineStmt*, ::pg_query::DropStmt*, ::pg_query::TruncateStmt*, ::pg_query::CommentStmt*, ::pg_query::FetchStmt*, ::pg_query::IndexStmt*, ::pg_query::CreateFunctionStmt*, ::pg_query::AlterFunctionStmt*, ::pg_query::DoStmt*, ::pg_query::RenameStmt*, ::pg_query::RuleStmt*, ::pg_query::NotifyStmt*, ::pg_query::ListenStmt*, ::pg_query::UnlistenStmt*, ::pg_query::TransactionStmt*, ::pg_query::ViewStmt*, ::pg_query::LoadStmt*, ::pg_query::CreateDomainStmt*, ::pg_query::CreatedbStmt*, ::pg_query::DropdbStmt*, ::pg_query::VacuumStmt*, ::pg_query::ExplainStmt*, ::pg_query::CreateTableAsStmt*, ::pg_query::CreateSeqStmt*, ::pg_query::AlterSeqStmt*, ::pg_query::VariableSetStmt*, ::pg_query::VariableShowStmt*, ::pg_query::DiscardStmt*, ::pg_query::CreateTrigStmt*, ::pg_query::CreatePLangStmt*, ::pg_query::CreateRoleStmt*, ::pg_query::AlterRoleStmt*, ::pg_query::DropRoleStmt*, ::pg_query::LockStmt*, ::pg_query::ConstraintsSetStmt*, ::pg_query::ReindexStmt*, ::pg_query::CheckPointStmt*, ::pg_query::CreateSchemaStmt*, ::pg_query::AlterDatabaseStmt*, ::pg_query::AlterDatabaseSetStmt*, ::pg_query::AlterRoleSetStmt*, ::pg_query::CreateConversionStmt*, ::pg_query::CreateCastStmt*, ::pg_query::CreateOpClassStmt*, ::pg_query::CreateOpFamilyStmt*, ::pg_query::AlterOpFamilyStmt*, ::pg_query::PrepareStmt*, ::pg_query::ExecuteStmt*, ::pg_query::DeallocateStmt*, ::pg_query::DeclareCursorStmt*, ::pg_query::CreateTableSpaceStmt*, ::pg_query::DropTableSpaceStmt*, ::pg_query::AlterObjectDependsStmt*, ::pg_query::AlterObjectSchemaStmt*, ::pg_query::AlterOwnerStmt*, ::pg_query::AlterOperatorStmt*, ::pg_query::AlterTypeStmt*, ::pg_query::DropOwnedStmt*, ::pg_query::ReassignOwnedStmt*, ::pg_query::CompositeTypeStmt*, ::pg_query::CreateEnumStmt*, ::pg_query::CreateRangeStmt*, ::pg_query::AlterEnumStmt*, ::pg_query::AlterTSDictionaryStmt*, ::pg_query::AlterTSConfigurationStmt*, ::pg_query::CreateFdwStmt*, ::pg_query::AlterFdwStmt*, ::pg_query::CreateForeignServerStmt*, ::pg_query::AlterForeignServerStmt*, ::pg_query::CreateUserMappingStmt*, ::pg_query::AlterUserMappingStmt*, ::pg_query::DropUserMappingStmt*, ::pg_query::AlterTableSpaceOptionsStmt*, ::pg_query::AlterTableMoveAllStmt*, ::pg_query::SecLabelStmt*, ::pg_query::CreateForeignTableStmt*, ::pg_query::ImportForeignSchemaStmt*, ::pg_query::CreateExtensionStmt*, ::pg_query::AlterExtensionStmt*, ::pg_query::AlterExtensionContentsStmt*, ::pg_query::CreateEventTrigStmt*, ::pg_query::AlterEventTrigStmt*, ::pg_query::RefreshMatViewStmt*, ::pg_query::ReplicaIdentityStmt*, ::pg_query::AlterSystemStmt*, ::pg_query::CreatePolicyStmt*, ::pg_query::AlterPolicyStmt*, ::pg_query::CreateTransformStmt*, ::pg_query::CreateAmStmt*, ::pg_query::CreatePublicationStmt*, ::pg_query::AlterPublicationStmt*, ::pg_query::CreateSubscriptionStmt*, ::pg_query::AlterSubscriptionStmt*, ::pg_query::DropSubscriptionStmt*, ::pg_query::CreateStatsStmt*, ::pg_query::AlterCollationStmt*, ::pg_query::CallStmt*, ::pg_query::AlterStatsStmt*, ::pg_query::A_Expr*, ::pg_query::ColumnRef*, ::pg_query::ParamRef*, ::pg_query::A_Const*, ::pg_query::FuncCall*, ::pg_query::A_Star*, ::pg_query::A_Indices*, ::pg_query::A_Indirection*, ::pg_query::A_ArrayExpr*, ::pg_query::ResTarget*, ::pg_query::MultiAssignRef*, ::pg_query::TypeCast*, ::pg_query::CollateClause*, ::pg_query::SortBy*, ::pg_query::WindowDef*, ::pg_query::RangeSubselect*, ::pg_query::RangeFunction*, ::pg_query::RangeTableSample*, ::pg_query::RangeTableFunc*, ::pg_query::RangeTableFuncCol*, ::pg_query::TypeName*, ::pg_query::ColumnDef*, ::pg_query::IndexElem*, ::pg_query::Constraint*, ::pg_query::DefElem*, ::pg_query::RangeTblEntry*, ::pg_query::RangeTblFunction*, ::pg_query::TableSampleClause*, ::pg_query::WithCheckOption*, ::pg_query::SortGroupClause*, ::pg_query::GroupingSet*, ::pg_query::WindowClause*, ::pg_query::ObjectWithArgs*, ::pg_query::AccessPriv*, ::pg_query::CreateOpClassItem*, ::pg_query::TableLikeClause*, ::pg_query::FunctionParameter*, ::pg_query::LockingClause*, ::pg_query::RowMarkClause*, ::pg_query::XmlSerialize*, ::pg_query::WithClause*, ::pg_query::InferClause*, ::pg_query::OnConflictClause*, ::pg_query::CommonTableExpr*, ::pg_query::RoleSpec*, ::pg_query::TriggerTransition*, ::pg_query::PartitionElem*, ::pg_query::PartitionSpec*, ::pg_query::PartitionBoundSpec*, ::pg_query::PartitionRangeDatum*, ::pg_query::PartitionCmd*, ::pg_query::VacuumRelation*, ::pg_query::InlineCodeBlock*, ::pg_query::CallContext*, ::pg_query::Integer*, ::pg_query::Float*, ::pg_query::String*, ::pg_query::BitString*, ::pg_query::Null*, ::pg_query::List*, ::pg_query::IntList*, ::pg_query::OidList*>;
std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Node& value);

struct Integer : FBE::Base
{
    int32_t ival;

    size_t fbe_type() const noexcept { return 1; }

    Integer();
    explicit Integer(int32_t arg_ival);
    Integer(const Integer& other) = delete;
    Integer(Integer&& other) noexcept;
    ~Integer() override;

    Integer& operator=(const Integer& other) = delete;
    Integer& operator=(Integer&& other) noexcept;

    bool operator==(const Integer& other) const noexcept;
    bool operator!=(const Integer& other) const noexcept { return !operator==(other); }
    bool operator<(const Integer& other) const noexcept;
    bool operator<=(const Integer& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Integer& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Integer& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Integer& value);

    void swap(Integer& other) noexcept;
    friend void swap(Integer& value1, Integer& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Integer>
{
    typedef pg_query::Integer argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Float : FBE::Base
{
    std::string str;

    size_t fbe_type() const noexcept { return 2; }

    Float();
    explicit Float(const std::string& arg_str);
    Float(const Float& other) = delete;
    Float(Float&& other) noexcept;
    ~Float() override;

    Float& operator=(const Float& other) = delete;
    Float& operator=(Float&& other) noexcept;

    bool operator==(const Float& other) const noexcept;
    bool operator!=(const Float& other) const noexcept { return !operator==(other); }
    bool operator<(const Float& other) const noexcept;
    bool operator<=(const Float& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Float& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Float& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Float& value);

    void swap(Float& other) noexcept;
    friend void swap(Float& value1, Float& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Float>
{
    typedef pg_query::Float argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct String : FBE::Base
{
    std::string str;

    size_t fbe_type() const noexcept { return 3; }

    String();
    explicit String(const std::string& arg_str);
    String(const String& other) = delete;
    String(String&& other) noexcept;
    ~String() override;

    String& operator=(const String& other) = delete;
    String& operator=(String&& other) noexcept;

    bool operator==(const String& other) const noexcept;
    bool operator!=(const String& other) const noexcept { return !operator==(other); }
    bool operator<(const String& other) const noexcept;
    bool operator<=(const String& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const String& other) const noexcept { return !operator<=(other); }
    bool operator>=(const String& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const String& value);

    void swap(String& other) noexcept;
    friend void swap(String& value1, String& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::String>
{
    typedef pg_query::String argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct BitString : FBE::Base
{
    std::string str;

    size_t fbe_type() const noexcept { return 4; }

    BitString();
    explicit BitString(const std::string& arg_str);
    BitString(const BitString& other) = delete;
    BitString(BitString&& other) noexcept;
    ~BitString() override;

    BitString& operator=(const BitString& other) = delete;
    BitString& operator=(BitString&& other) noexcept;

    bool operator==(const BitString& other) const noexcept;
    bool operator!=(const BitString& other) const noexcept { return !operator==(other); }
    bool operator<(const BitString& other) const noexcept;
    bool operator<=(const BitString& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const BitString& other) const noexcept { return !operator<=(other); }
    bool operator>=(const BitString& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const BitString& value);

    void swap(BitString& other) noexcept;
    friend void swap(BitString& value1, BitString& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::BitString>
{
    typedef pg_query::BitString argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Null : FBE::Base
{
    size_t fbe_type() const noexcept { return 5; }

    Null();
    Null(const Null& other) = delete;
    Null(Null&& other) noexcept;
    ~Null() override;

    Null& operator=(const Null& other) = delete;
    Null& operator=(Null&& other) noexcept;

    bool operator==(const Null& other) const noexcept;
    bool operator!=(const Null& other) const noexcept { return !operator==(other); }
    bool operator<(const Null& other) const noexcept;
    bool operator<=(const Null& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Null& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Null& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Null& value);

    void swap(Null& other) noexcept;
    friend void swap(Null& value1, Null& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Null>
{
    typedef pg_query::Null argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct List : FBE::Base
{
    std::vector<::pg_query::Node> items;

    size_t fbe_type() const noexcept { return 6; }

    List();
    explicit List(std::vector<::pg_query::Node> arg_items);
    List(const List& other) = delete;
    List(List&& other) noexcept;
    ~List() override;

    List& operator=(const List& other) = delete;
    List& operator=(List&& other) noexcept;

    bool operator==(const List& other) const noexcept;
    bool operator!=(const List& other) const noexcept { return !operator==(other); }
    bool operator<(const List& other) const noexcept;
    bool operator<=(const List& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const List& other) const noexcept { return !operator<=(other); }
    bool operator>=(const List& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const List& value);

    void swap(List& other) noexcept;
    friend void swap(List& value1, List& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::List>
{
    typedef pg_query::List argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct OidList : FBE::Base
{
    std::vector<::pg_query::Node> items;

    size_t fbe_type() const noexcept { return 7; }

    OidList();
    explicit OidList(std::vector<::pg_query::Node> arg_items);
    OidList(const OidList& other) = delete;
    OidList(OidList&& other) noexcept;
    ~OidList() override;

    OidList& operator=(const OidList& other) = delete;
    OidList& operator=(OidList&& other) noexcept;

    bool operator==(const OidList& other) const noexcept;
    bool operator!=(const OidList& other) const noexcept { return !operator==(other); }
    bool operator<(const OidList& other) const noexcept;
    bool operator<=(const OidList& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const OidList& other) const noexcept { return !operator<=(other); }
    bool operator>=(const OidList& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const OidList& value);

    void swap(OidList& other) noexcept;
    friend void swap(OidList& value1, OidList& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::OidList>
{
    typedef pg_query::OidList argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct IntList : FBE::Base
{
    std::vector<::pg_query::Node> items;

    size_t fbe_type() const noexcept { return 8; }

    IntList();
    explicit IntList(std::vector<::pg_query::Node> arg_items);
    IntList(const IntList& other) = delete;
    IntList(IntList&& other) noexcept;
    ~IntList() override;

    IntList& operator=(const IntList& other) = delete;
    IntList& operator=(IntList&& other) noexcept;

    bool operator==(const IntList& other) const noexcept;
    bool operator!=(const IntList& other) const noexcept { return !operator==(other); }
    bool operator<(const IntList& other) const noexcept;
    bool operator<=(const IntList& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const IntList& other) const noexcept { return !operator<=(other); }
    bool operator>=(const IntList& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const IntList& value);

    void swap(IntList& other) noexcept;
    friend void swap(IntList& value1, IntList& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::IntList>
{
    typedef pg_query::IntList argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Alias : FBE::Base
{
    std::string aliasname;
    std::vector<::pg_query::Node> colnames;

    size_t fbe_type() const noexcept { return 9; }

    Alias();
    Alias(const std::string& arg_aliasname, std::vector<::pg_query::Node> arg_colnames);
    Alias(const Alias& other) = delete;
    Alias(Alias&& other) noexcept;
    ~Alias() override;

    Alias& operator=(const Alias& other) = delete;
    Alias& operator=(Alias&& other) noexcept;

    bool operator==(const Alias& other) const noexcept;
    bool operator!=(const Alias& other) const noexcept { return !operator==(other); }
    bool operator<(const Alias& other) const noexcept;
    bool operator<=(const Alias& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Alias& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Alias& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Alias& value);

    void swap(Alias& other) noexcept;
    friend void swap(Alias& value1, Alias& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Alias>
{
    typedef pg_query::Alias argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Alias;

struct RangeVar : FBE::Base
{
    std::string catalogname;
    std::string schemaname;
    std::string relname;
    bool inh;
    std::string relpersistence;
    ::pg_query::Alias* alias;
    int32_t location;

    size_t fbe_type() const noexcept { return 10; }

    RangeVar();
    RangeVar(const std::string& arg_catalogname, const std::string& arg_schemaname, const std::string& arg_relname, bool arg_inh, const std::string& arg_relpersistence, std::unique_ptr<::pg_query::Alias> arg_alias, int32_t arg_location);
    RangeVar(const RangeVar& other) = delete;
    RangeVar(RangeVar&& other) noexcept;
    ~RangeVar() override;

    RangeVar& operator=(const RangeVar& other) = delete;
    RangeVar& operator=(RangeVar&& other) noexcept;

    bool operator==(const RangeVar& other) const noexcept;
    bool operator!=(const RangeVar& other) const noexcept { return !operator==(other); }
    bool operator<(const RangeVar& other) const noexcept;
    bool operator<=(const RangeVar& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RangeVar& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RangeVar& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RangeVar& value);

    void swap(RangeVar& other) noexcept;
    friend void swap(RangeVar& value1, RangeVar& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RangeVar>
{
    typedef pg_query::RangeVar argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TableFunc : FBE::Base
{
    std::vector<::pg_query::Node> ns_uris;
    std::vector<::pg_query::Node> ns_names;
    ::pg_query::Node docexpr;
    ::pg_query::Node rowexpr;
    std::vector<::pg_query::Node> colnames;
    std::vector<::pg_query::Node> coltypes;
    std::vector<::pg_query::Node> coltypmods;
    std::vector<::pg_query::Node> colcollations;
    std::vector<::pg_query::Node> colexprs;
    std::vector<::pg_query::Node> coldefexprs;
    std::vector<uint64_t> notnulls;
    int32_t ordinalitycol;
    int32_t location;

    size_t fbe_type() const noexcept { return 11; }

    TableFunc();
    TableFunc(std::vector<::pg_query::Node> arg_ns_uris, std::vector<::pg_query::Node> arg_ns_names, ::pg_query::Node&& arg_docexpr, ::pg_query::Node&& arg_rowexpr, std::vector<::pg_query::Node> arg_colnames, std::vector<::pg_query::Node> arg_coltypes, std::vector<::pg_query::Node> arg_coltypmods, std::vector<::pg_query::Node> arg_colcollations, std::vector<::pg_query::Node> arg_colexprs, std::vector<::pg_query::Node> arg_coldefexprs, std::vector<uint64_t> arg_notnulls, int32_t arg_ordinalitycol, int32_t arg_location);
    TableFunc(const TableFunc& other) = delete;
    TableFunc(TableFunc&& other) noexcept;
    ~TableFunc() override;

    TableFunc& operator=(const TableFunc& other) = delete;
    TableFunc& operator=(TableFunc&& other) noexcept;

    bool operator==(const TableFunc& other) const noexcept;
    bool operator!=(const TableFunc& other) const noexcept { return !operator==(other); }
    bool operator<(const TableFunc& other) const noexcept;
    bool operator<=(const TableFunc& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const TableFunc& other) const noexcept { return !operator<=(other); }
    bool operator>=(const TableFunc& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const TableFunc& value);

    void swap(TableFunc& other) noexcept;
    friend void swap(TableFunc& value1, TableFunc& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::TableFunc>
{
    typedef pg_query::TableFunc argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Expr : FBE::Base
{
    size_t fbe_type() const noexcept { return 12; }

    Expr();
    Expr(const Expr& other) = delete;
    Expr(Expr&& other) noexcept;
    ~Expr() override;

    Expr& operator=(const Expr& other) = delete;
    Expr& operator=(Expr&& other) noexcept;

    bool operator==(const Expr& other) const noexcept;
    bool operator!=(const Expr& other) const noexcept { return !operator==(other); }
    bool operator<(const Expr& other) const noexcept;
    bool operator<=(const Expr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Expr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Expr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Expr& value);

    void swap(Expr& other) noexcept;
    friend void swap(Expr& value1, Expr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Expr>
{
    typedef pg_query::Expr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Var : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t varno;
    int32_t varattno;
    uint32_t vartype;
    int32_t vartypmod;
    uint32_t varcollid;
    uint32_t varlevelsup;
    uint32_t varnosyn;
    int32_t varattnosyn;
    int32_t location;

    size_t fbe_type() const noexcept { return 13; }

    Var();
    Var(::pg_query::Node&& arg_xpr, uint32_t arg_varno, int32_t arg_varattno, uint32_t arg_vartype, int32_t arg_vartypmod, uint32_t arg_varcollid, uint32_t arg_varlevelsup, uint32_t arg_varnosyn, int32_t arg_varattnosyn, int32_t arg_location);
    Var(const Var& other) = delete;
    Var(Var&& other) noexcept;
    ~Var() override;

    Var& operator=(const Var& other) = delete;
    Var& operator=(Var&& other) noexcept;

    bool operator==(const Var& other) const noexcept;
    bool operator!=(const Var& other) const noexcept { return !operator==(other); }
    bool operator<(const Var& other) const noexcept;
    bool operator<=(const Var& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Var& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Var& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Var& value);

    void swap(Var& other) noexcept;
    friend void swap(Var& value1, Var& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Var>
{
    typedef pg_query::Var argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Param : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::ParamKind paramkind;
    int32_t paramid;
    uint32_t paramtype;
    int32_t paramtypmod;
    uint32_t paramcollid;
    int32_t location;

    size_t fbe_type() const noexcept { return 14; }

    Param();
    Param(::pg_query::Node&& arg_xpr, ::pg_query::ParamKind&& arg_paramkind, int32_t arg_paramid, uint32_t arg_paramtype, int32_t arg_paramtypmod, uint32_t arg_paramcollid, int32_t arg_location);
    Param(const Param& other) = delete;
    Param(Param&& other) noexcept;
    ~Param() override;

    Param& operator=(const Param& other) = delete;
    Param& operator=(Param&& other) noexcept;

    bool operator==(const Param& other) const noexcept;
    bool operator!=(const Param& other) const noexcept { return !operator==(other); }
    bool operator<(const Param& other) const noexcept;
    bool operator<=(const Param& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Param& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Param& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Param& value);

    void swap(Param& other) noexcept;
    friend void swap(Param& value1, Param& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Param>
{
    typedef pg_query::Param argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Aggref : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t aggfnoid;
    uint32_t aggtype;
    uint32_t aggcollid;
    uint32_t inputcollid;
    uint32_t aggtranstype;
    std::vector<::pg_query::Node> aggargtypes;
    std::vector<::pg_query::Node> aggdirectargs;
    std::vector<::pg_query::Node> args;
    std::vector<::pg_query::Node> aggorder;
    std::vector<::pg_query::Node> aggdistinct;
    ::pg_query::Node aggfilter;
    bool aggstar;
    bool aggvariadic;
    std::string aggkind;
    uint32_t agglevelsup;
    ::pg_query::AggSplit aggsplit;
    int32_t location;

    size_t fbe_type() const noexcept { return 15; }

    Aggref();
    Aggref(::pg_query::Node&& arg_xpr, uint32_t arg_aggfnoid, uint32_t arg_aggtype, uint32_t arg_aggcollid, uint32_t arg_inputcollid, uint32_t arg_aggtranstype, std::vector<::pg_query::Node> arg_aggargtypes, std::vector<::pg_query::Node> arg_aggdirectargs, std::vector<::pg_query::Node> arg_args, std::vector<::pg_query::Node> arg_aggorder, std::vector<::pg_query::Node> arg_aggdistinct, ::pg_query::Node&& arg_aggfilter, bool arg_aggstar, bool arg_aggvariadic, const std::string& arg_aggkind, uint32_t arg_agglevelsup, ::pg_query::AggSplit&& arg_aggsplit, int32_t arg_location);
    Aggref(const Aggref& other) = delete;
    Aggref(Aggref&& other) noexcept;
    ~Aggref() override;

    Aggref& operator=(const Aggref& other) = delete;
    Aggref& operator=(Aggref&& other) noexcept;

    bool operator==(const Aggref& other) const noexcept;
    bool operator!=(const Aggref& other) const noexcept { return !operator==(other); }
    bool operator<(const Aggref& other) const noexcept;
    bool operator<=(const Aggref& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Aggref& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Aggref& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Aggref& value);

    void swap(Aggref& other) noexcept;
    friend void swap(Aggref& value1, Aggref& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Aggref>
{
    typedef pg_query::Aggref argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct GroupingFunc : FBE::Base
{
    ::pg_query::Node xpr;
    std::vector<::pg_query::Node> args;
    std::vector<::pg_query::Node> refs;
    std::vector<::pg_query::Node> cols;
    uint32_t agglevelsup;
    int32_t location;

    size_t fbe_type() const noexcept { return 16; }

    GroupingFunc();
    GroupingFunc(::pg_query::Node&& arg_xpr, std::vector<::pg_query::Node> arg_args, std::vector<::pg_query::Node> arg_refs, std::vector<::pg_query::Node> arg_cols, uint32_t arg_agglevelsup, int32_t arg_location);
    GroupingFunc(const GroupingFunc& other) = delete;
    GroupingFunc(GroupingFunc&& other) noexcept;
    ~GroupingFunc() override;

    GroupingFunc& operator=(const GroupingFunc& other) = delete;
    GroupingFunc& operator=(GroupingFunc&& other) noexcept;

    bool operator==(const GroupingFunc& other) const noexcept;
    bool operator!=(const GroupingFunc& other) const noexcept { return !operator==(other); }
    bool operator<(const GroupingFunc& other) const noexcept;
    bool operator<=(const GroupingFunc& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const GroupingFunc& other) const noexcept { return !operator<=(other); }
    bool operator>=(const GroupingFunc& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const GroupingFunc& value);

    void swap(GroupingFunc& other) noexcept;
    friend void swap(GroupingFunc& value1, GroupingFunc& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::GroupingFunc>
{
    typedef pg_query::GroupingFunc argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct WindowFunc : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t winfnoid;
    uint32_t wintype;
    uint32_t wincollid;
    uint32_t inputcollid;
    std::vector<::pg_query::Node> args;
    ::pg_query::Node aggfilter;
    uint32_t winref;
    bool winstar;
    bool winagg;
    int32_t location;

    size_t fbe_type() const noexcept { return 17; }

    WindowFunc();
    WindowFunc(::pg_query::Node&& arg_xpr, uint32_t arg_winfnoid, uint32_t arg_wintype, uint32_t arg_wincollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, ::pg_query::Node&& arg_aggfilter, uint32_t arg_winref, bool arg_winstar, bool arg_winagg, int32_t arg_location);
    WindowFunc(const WindowFunc& other) = delete;
    WindowFunc(WindowFunc&& other) noexcept;
    ~WindowFunc() override;

    WindowFunc& operator=(const WindowFunc& other) = delete;
    WindowFunc& operator=(WindowFunc&& other) noexcept;

    bool operator==(const WindowFunc& other) const noexcept;
    bool operator!=(const WindowFunc& other) const noexcept { return !operator==(other); }
    bool operator<(const WindowFunc& other) const noexcept;
    bool operator<=(const WindowFunc& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const WindowFunc& other) const noexcept { return !operator<=(other); }
    bool operator>=(const WindowFunc& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const WindowFunc& value);

    void swap(WindowFunc& other) noexcept;
    friend void swap(WindowFunc& value1, WindowFunc& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::WindowFunc>
{
    typedef pg_query::WindowFunc argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct SubscriptingRef : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t refcontainertype;
    uint32_t refelemtype;
    int32_t reftypmod;
    uint32_t refcollid;
    std::vector<::pg_query::Node> refupperindexpr;
    std::vector<::pg_query::Node> reflowerindexpr;
    ::pg_query::Node refexpr;
    ::pg_query::Node refassgnexpr;

    size_t fbe_type() const noexcept { return 18; }

    SubscriptingRef();
    SubscriptingRef(::pg_query::Node&& arg_xpr, uint32_t arg_refcontainertype, uint32_t arg_refelemtype, int32_t arg_reftypmod, uint32_t arg_refcollid, std::vector<::pg_query::Node> arg_refupperindexpr, std::vector<::pg_query::Node> arg_reflowerindexpr, ::pg_query::Node&& arg_refexpr, ::pg_query::Node&& arg_refassgnexpr);
    SubscriptingRef(const SubscriptingRef& other) = delete;
    SubscriptingRef(SubscriptingRef&& other) noexcept;
    ~SubscriptingRef() override;

    SubscriptingRef& operator=(const SubscriptingRef& other) = delete;
    SubscriptingRef& operator=(SubscriptingRef&& other) noexcept;

    bool operator==(const SubscriptingRef& other) const noexcept;
    bool operator!=(const SubscriptingRef& other) const noexcept { return !operator==(other); }
    bool operator<(const SubscriptingRef& other) const noexcept;
    bool operator<=(const SubscriptingRef& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SubscriptingRef& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SubscriptingRef& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SubscriptingRef& value);

    void swap(SubscriptingRef& other) noexcept;
    friend void swap(SubscriptingRef& value1, SubscriptingRef& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SubscriptingRef>
{
    typedef pg_query::SubscriptingRef argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct FuncExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t funcid;
    uint32_t funcresulttype;
    bool funcretset;
    bool funcvariadic;
    ::pg_query::CoercionForm funcformat;
    uint32_t funccollid;
    uint32_t inputcollid;
    std::vector<::pg_query::Node> args;
    int32_t location;

    size_t fbe_type() const noexcept { return 19; }

    FuncExpr();
    FuncExpr(::pg_query::Node&& arg_xpr, uint32_t arg_funcid, uint32_t arg_funcresulttype, bool arg_funcretset, bool arg_funcvariadic, ::pg_query::CoercionForm&& arg_funcformat, uint32_t arg_funccollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location);
    FuncExpr(const FuncExpr& other) = delete;
    FuncExpr(FuncExpr&& other) noexcept;
    ~FuncExpr() override;

    FuncExpr& operator=(const FuncExpr& other) = delete;
    FuncExpr& operator=(FuncExpr&& other) noexcept;

    bool operator==(const FuncExpr& other) const noexcept;
    bool operator!=(const FuncExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const FuncExpr& other) const noexcept;
    bool operator<=(const FuncExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const FuncExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const FuncExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const FuncExpr& value);

    void swap(FuncExpr& other) noexcept;
    friend void swap(FuncExpr& value1, FuncExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::FuncExpr>
{
    typedef pg_query::FuncExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct NamedArgExpr : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    std::string name;
    int32_t argnumber;
    int32_t location;

    size_t fbe_type() const noexcept { return 20; }

    NamedArgExpr();
    NamedArgExpr(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, const std::string& arg_name, int32_t arg_argnumber, int32_t arg_location);
    NamedArgExpr(const NamedArgExpr& other) = delete;
    NamedArgExpr(NamedArgExpr&& other) noexcept;
    ~NamedArgExpr() override;

    NamedArgExpr& operator=(const NamedArgExpr& other) = delete;
    NamedArgExpr& operator=(NamedArgExpr&& other) noexcept;

    bool operator==(const NamedArgExpr& other) const noexcept;
    bool operator!=(const NamedArgExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const NamedArgExpr& other) const noexcept;
    bool operator<=(const NamedArgExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const NamedArgExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const NamedArgExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const NamedArgExpr& value);

    void swap(NamedArgExpr& other) noexcept;
    friend void swap(NamedArgExpr& value1, NamedArgExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::NamedArgExpr>
{
    typedef pg_query::NamedArgExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct OpExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t opno;
    uint32_t opfuncid;
    uint32_t opresulttype;
    bool opretset;
    uint32_t opcollid;
    uint32_t inputcollid;
    std::vector<::pg_query::Node> args;
    int32_t location;

    size_t fbe_type() const noexcept { return 21; }

    OpExpr();
    OpExpr(::pg_query::Node&& arg_xpr, uint32_t arg_opno, uint32_t arg_opfuncid, uint32_t arg_opresulttype, bool arg_opretset, uint32_t arg_opcollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location);
    OpExpr(const OpExpr& other) = delete;
    OpExpr(OpExpr&& other) noexcept;
    ~OpExpr() override;

    OpExpr& operator=(const OpExpr& other) = delete;
    OpExpr& operator=(OpExpr&& other) noexcept;

    bool operator==(const OpExpr& other) const noexcept;
    bool operator!=(const OpExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const OpExpr& other) const noexcept;
    bool operator<=(const OpExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const OpExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const OpExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const OpExpr& value);

    void swap(OpExpr& other) noexcept;
    friend void swap(OpExpr& value1, OpExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::OpExpr>
{
    typedef pg_query::OpExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DistinctExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t opno;
    uint32_t opfuncid;
    uint32_t opresulttype;
    bool opretset;
    uint32_t opcollid;
    uint32_t inputcollid;
    std::vector<::pg_query::Node> args;
    int32_t location;

    size_t fbe_type() const noexcept { return 22; }

    DistinctExpr();
    DistinctExpr(::pg_query::Node&& arg_xpr, uint32_t arg_opno, uint32_t arg_opfuncid, uint32_t arg_opresulttype, bool arg_opretset, uint32_t arg_opcollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location);
    DistinctExpr(const DistinctExpr& other) = delete;
    DistinctExpr(DistinctExpr&& other) noexcept;
    ~DistinctExpr() override;

    DistinctExpr& operator=(const DistinctExpr& other) = delete;
    DistinctExpr& operator=(DistinctExpr&& other) noexcept;

    bool operator==(const DistinctExpr& other) const noexcept;
    bool operator!=(const DistinctExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const DistinctExpr& other) const noexcept;
    bool operator<=(const DistinctExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DistinctExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DistinctExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DistinctExpr& value);

    void swap(DistinctExpr& other) noexcept;
    friend void swap(DistinctExpr& value1, DistinctExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DistinctExpr>
{
    typedef pg_query::DistinctExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct NullIfExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t opno;
    uint32_t opfuncid;
    uint32_t opresulttype;
    bool opretset;
    uint32_t opcollid;
    uint32_t inputcollid;
    std::vector<::pg_query::Node> args;
    int32_t location;

    size_t fbe_type() const noexcept { return 23; }

    NullIfExpr();
    NullIfExpr(::pg_query::Node&& arg_xpr, uint32_t arg_opno, uint32_t arg_opfuncid, uint32_t arg_opresulttype, bool arg_opretset, uint32_t arg_opcollid, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location);
    NullIfExpr(const NullIfExpr& other) = delete;
    NullIfExpr(NullIfExpr&& other) noexcept;
    ~NullIfExpr() override;

    NullIfExpr& operator=(const NullIfExpr& other) = delete;
    NullIfExpr& operator=(NullIfExpr&& other) noexcept;

    bool operator==(const NullIfExpr& other) const noexcept;
    bool operator!=(const NullIfExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const NullIfExpr& other) const noexcept;
    bool operator<=(const NullIfExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const NullIfExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const NullIfExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const NullIfExpr& value);

    void swap(NullIfExpr& other) noexcept;
    friend void swap(NullIfExpr& value1, NullIfExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::NullIfExpr>
{
    typedef pg_query::NullIfExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ScalarArrayOpExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t opno;
    uint32_t opfuncid;
    bool use_or;
    uint32_t inputcollid;
    std::vector<::pg_query::Node> args;
    int32_t location;

    size_t fbe_type() const noexcept { return 24; }

    ScalarArrayOpExpr();
    ScalarArrayOpExpr(::pg_query::Node&& arg_xpr, uint32_t arg_opno, uint32_t arg_opfuncid, bool arg_use_or, uint32_t arg_inputcollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location);
    ScalarArrayOpExpr(const ScalarArrayOpExpr& other) = delete;
    ScalarArrayOpExpr(ScalarArrayOpExpr&& other) noexcept;
    ~ScalarArrayOpExpr() override;

    ScalarArrayOpExpr& operator=(const ScalarArrayOpExpr& other) = delete;
    ScalarArrayOpExpr& operator=(ScalarArrayOpExpr&& other) noexcept;

    bool operator==(const ScalarArrayOpExpr& other) const noexcept;
    bool operator!=(const ScalarArrayOpExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const ScalarArrayOpExpr& other) const noexcept;
    bool operator<=(const ScalarArrayOpExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ScalarArrayOpExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ScalarArrayOpExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ScalarArrayOpExpr& value);

    void swap(ScalarArrayOpExpr& other) noexcept;
    friend void swap(ScalarArrayOpExpr& value1, ScalarArrayOpExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ScalarArrayOpExpr>
{
    typedef pg_query::ScalarArrayOpExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct BoolExpr : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::BoolExprType boolop;
    std::vector<::pg_query::Node> args;
    int32_t location;

    size_t fbe_type() const noexcept { return 25; }

    BoolExpr();
    BoolExpr(::pg_query::Node&& arg_xpr, ::pg_query::BoolExprType&& arg_boolop, std::vector<::pg_query::Node> arg_args, int32_t arg_location);
    BoolExpr(const BoolExpr& other) = delete;
    BoolExpr(BoolExpr&& other) noexcept;
    ~BoolExpr() override;

    BoolExpr& operator=(const BoolExpr& other) = delete;
    BoolExpr& operator=(BoolExpr&& other) noexcept;

    bool operator==(const BoolExpr& other) const noexcept;
    bool operator!=(const BoolExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const BoolExpr& other) const noexcept;
    bool operator<=(const BoolExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const BoolExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const BoolExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const BoolExpr& value);

    void swap(BoolExpr& other) noexcept;
    friend void swap(BoolExpr& value1, BoolExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::BoolExpr>
{
    typedef pg_query::BoolExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct SubLink : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::SubLinkType sub_link_type;
    int32_t sub_link_id;
    ::pg_query::Node testexpr;
    std::vector<::pg_query::Node> oper_name;
    ::pg_query::Node subselect;
    int32_t location;

    size_t fbe_type() const noexcept { return 26; }

    SubLink();
    SubLink(::pg_query::Node&& arg_xpr, ::pg_query::SubLinkType&& arg_sub_link_type, int32_t arg_sub_link_id, ::pg_query::Node&& arg_testexpr, std::vector<::pg_query::Node> arg_oper_name, ::pg_query::Node&& arg_subselect, int32_t arg_location);
    SubLink(const SubLink& other) = delete;
    SubLink(SubLink&& other) noexcept;
    ~SubLink() override;

    SubLink& operator=(const SubLink& other) = delete;
    SubLink& operator=(SubLink&& other) noexcept;

    bool operator==(const SubLink& other) const noexcept;
    bool operator!=(const SubLink& other) const noexcept { return !operator==(other); }
    bool operator<(const SubLink& other) const noexcept;
    bool operator<=(const SubLink& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SubLink& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SubLink& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SubLink& value);

    void swap(SubLink& other) noexcept;
    friend void swap(SubLink& value1, SubLink& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SubLink>
{
    typedef pg_query::SubLink argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct SubPlan : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::SubLinkType sub_link_type;
    ::pg_query::Node testexpr;
    std::vector<::pg_query::Node> param_ids;
    int32_t plan_id;
    std::string plan_name;
    uint32_t first_col_type;
    int32_t first_col_typmod;
    uint32_t first_col_collation;
    bool use_hash_table;
    bool unknown_eq_false;
    bool parallel_safe;
    std::vector<::pg_query::Node> set_param;
    std::vector<::pg_query::Node> par_param;
    std::vector<::pg_query::Node> args;
    double startup_cost;
    double per_call_cost;

    size_t fbe_type() const noexcept { return 27; }

    SubPlan();
    SubPlan(::pg_query::Node&& arg_xpr, ::pg_query::SubLinkType&& arg_sub_link_type, ::pg_query::Node&& arg_testexpr, std::vector<::pg_query::Node> arg_param_ids, int32_t arg_plan_id, const std::string& arg_plan_name, uint32_t arg_first_col_type, int32_t arg_first_col_typmod, uint32_t arg_first_col_collation, bool arg_use_hash_table, bool arg_unknown_eq_false, bool arg_parallel_safe, std::vector<::pg_query::Node> arg_set_param, std::vector<::pg_query::Node> arg_par_param, std::vector<::pg_query::Node> arg_args, double arg_startup_cost, double arg_per_call_cost);
    SubPlan(const SubPlan& other) = delete;
    SubPlan(SubPlan&& other) noexcept;
    ~SubPlan() override;

    SubPlan& operator=(const SubPlan& other) = delete;
    SubPlan& operator=(SubPlan&& other) noexcept;

    bool operator==(const SubPlan& other) const noexcept;
    bool operator!=(const SubPlan& other) const noexcept { return !operator==(other); }
    bool operator<(const SubPlan& other) const noexcept;
    bool operator<=(const SubPlan& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SubPlan& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SubPlan& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SubPlan& value);

    void swap(SubPlan& other) noexcept;
    friend void swap(SubPlan& value1, SubPlan& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SubPlan>
{
    typedef pg_query::SubPlan argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlternativeSubPlan : FBE::Base
{
    ::pg_query::Node xpr;
    std::vector<::pg_query::Node> subplans;

    size_t fbe_type() const noexcept { return 28; }

    AlternativeSubPlan();
    AlternativeSubPlan(::pg_query::Node&& arg_xpr, std::vector<::pg_query::Node> arg_subplans);
    AlternativeSubPlan(const AlternativeSubPlan& other) = delete;
    AlternativeSubPlan(AlternativeSubPlan&& other) noexcept;
    ~AlternativeSubPlan() override;

    AlternativeSubPlan& operator=(const AlternativeSubPlan& other) = delete;
    AlternativeSubPlan& operator=(AlternativeSubPlan&& other) noexcept;

    bool operator==(const AlternativeSubPlan& other) const noexcept;
    bool operator!=(const AlternativeSubPlan& other) const noexcept { return !operator==(other); }
    bool operator<(const AlternativeSubPlan& other) const noexcept;
    bool operator<=(const AlternativeSubPlan& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlternativeSubPlan& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlternativeSubPlan& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlternativeSubPlan& value);

    void swap(AlternativeSubPlan& other) noexcept;
    friend void swap(AlternativeSubPlan& value1, AlternativeSubPlan& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlternativeSubPlan>
{
    typedef pg_query::AlternativeSubPlan argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct FieldSelect : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    int32_t fieldnum;
    uint32_t resulttype;
    int32_t resulttypmod;
    uint32_t resultcollid;

    size_t fbe_type() const noexcept { return 29; }

    FieldSelect();
    FieldSelect(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, int32_t arg_fieldnum, uint32_t arg_resulttype, int32_t arg_resulttypmod, uint32_t arg_resultcollid);
    FieldSelect(const FieldSelect& other) = delete;
    FieldSelect(FieldSelect&& other) noexcept;
    ~FieldSelect() override;

    FieldSelect& operator=(const FieldSelect& other) = delete;
    FieldSelect& operator=(FieldSelect&& other) noexcept;

    bool operator==(const FieldSelect& other) const noexcept;
    bool operator!=(const FieldSelect& other) const noexcept { return !operator==(other); }
    bool operator<(const FieldSelect& other) const noexcept;
    bool operator<=(const FieldSelect& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const FieldSelect& other) const noexcept { return !operator<=(other); }
    bool operator>=(const FieldSelect& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const FieldSelect& value);

    void swap(FieldSelect& other) noexcept;
    friend void swap(FieldSelect& value1, FieldSelect& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::FieldSelect>
{
    typedef pg_query::FieldSelect argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct FieldStore : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    std::vector<::pg_query::Node> newvals;
    std::vector<::pg_query::Node> fieldnums;
    uint32_t resulttype;

    size_t fbe_type() const noexcept { return 30; }

    FieldStore();
    FieldStore(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, std::vector<::pg_query::Node> arg_newvals, std::vector<::pg_query::Node> arg_fieldnums, uint32_t arg_resulttype);
    FieldStore(const FieldStore& other) = delete;
    FieldStore(FieldStore&& other) noexcept;
    ~FieldStore() override;

    FieldStore& operator=(const FieldStore& other) = delete;
    FieldStore& operator=(FieldStore&& other) noexcept;

    bool operator==(const FieldStore& other) const noexcept;
    bool operator!=(const FieldStore& other) const noexcept { return !operator==(other); }
    bool operator<(const FieldStore& other) const noexcept;
    bool operator<=(const FieldStore& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const FieldStore& other) const noexcept { return !operator<=(other); }
    bool operator>=(const FieldStore& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const FieldStore& value);

    void swap(FieldStore& other) noexcept;
    friend void swap(FieldStore& value1, FieldStore& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::FieldStore>
{
    typedef pg_query::FieldStore argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RelabelType : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    uint32_t resulttype;
    int32_t resulttypmod;
    uint32_t resultcollid;
    ::pg_query::CoercionForm relabelformat;
    int32_t location;

    size_t fbe_type() const noexcept { return 31; }

    RelabelType();
    RelabelType(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_resulttype, int32_t arg_resulttypmod, uint32_t arg_resultcollid, ::pg_query::CoercionForm&& arg_relabelformat, int32_t arg_location);
    RelabelType(const RelabelType& other) = delete;
    RelabelType(RelabelType&& other) noexcept;
    ~RelabelType() override;

    RelabelType& operator=(const RelabelType& other) = delete;
    RelabelType& operator=(RelabelType&& other) noexcept;

    bool operator==(const RelabelType& other) const noexcept;
    bool operator!=(const RelabelType& other) const noexcept { return !operator==(other); }
    bool operator<(const RelabelType& other) const noexcept;
    bool operator<=(const RelabelType& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RelabelType& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RelabelType& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RelabelType& value);

    void swap(RelabelType& other) noexcept;
    friend void swap(RelabelType& value1, RelabelType& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RelabelType>
{
    typedef pg_query::RelabelType argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CoerceViaIO : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    uint32_t resulttype;
    uint32_t resultcollid;
    ::pg_query::CoercionForm coerceformat;
    int32_t location;

    size_t fbe_type() const noexcept { return 32; }

    CoerceViaIO();
    CoerceViaIO(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_resulttype, uint32_t arg_resultcollid, ::pg_query::CoercionForm&& arg_coerceformat, int32_t arg_location);
    CoerceViaIO(const CoerceViaIO& other) = delete;
    CoerceViaIO(CoerceViaIO&& other) noexcept;
    ~CoerceViaIO() override;

    CoerceViaIO& operator=(const CoerceViaIO& other) = delete;
    CoerceViaIO& operator=(CoerceViaIO&& other) noexcept;

    bool operator==(const CoerceViaIO& other) const noexcept;
    bool operator!=(const CoerceViaIO& other) const noexcept { return !operator==(other); }
    bool operator<(const CoerceViaIO& other) const noexcept;
    bool operator<=(const CoerceViaIO& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CoerceViaIO& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CoerceViaIO& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CoerceViaIO& value);

    void swap(CoerceViaIO& other) noexcept;
    friend void swap(CoerceViaIO& value1, CoerceViaIO& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CoerceViaIO>
{
    typedef pg_query::CoerceViaIO argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ArrayCoerceExpr : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    ::pg_query::Node elemexpr;
    uint32_t resulttype;
    int32_t resulttypmod;
    uint32_t resultcollid;
    ::pg_query::CoercionForm coerceformat;
    int32_t location;

    size_t fbe_type() const noexcept { return 33; }

    ArrayCoerceExpr();
    ArrayCoerceExpr(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, ::pg_query::Node&& arg_elemexpr, uint32_t arg_resulttype, int32_t arg_resulttypmod, uint32_t arg_resultcollid, ::pg_query::CoercionForm&& arg_coerceformat, int32_t arg_location);
    ArrayCoerceExpr(const ArrayCoerceExpr& other) = delete;
    ArrayCoerceExpr(ArrayCoerceExpr&& other) noexcept;
    ~ArrayCoerceExpr() override;

    ArrayCoerceExpr& operator=(const ArrayCoerceExpr& other) = delete;
    ArrayCoerceExpr& operator=(ArrayCoerceExpr&& other) noexcept;

    bool operator==(const ArrayCoerceExpr& other) const noexcept;
    bool operator!=(const ArrayCoerceExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const ArrayCoerceExpr& other) const noexcept;
    bool operator<=(const ArrayCoerceExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ArrayCoerceExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ArrayCoerceExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ArrayCoerceExpr& value);

    void swap(ArrayCoerceExpr& other) noexcept;
    friend void swap(ArrayCoerceExpr& value1, ArrayCoerceExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ArrayCoerceExpr>
{
    typedef pg_query::ArrayCoerceExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ConvertRowtypeExpr : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    uint32_t resulttype;
    ::pg_query::CoercionForm convertformat;
    int32_t location;

    size_t fbe_type() const noexcept { return 34; }

    ConvertRowtypeExpr();
    ConvertRowtypeExpr(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_resulttype, ::pg_query::CoercionForm&& arg_convertformat, int32_t arg_location);
    ConvertRowtypeExpr(const ConvertRowtypeExpr& other) = delete;
    ConvertRowtypeExpr(ConvertRowtypeExpr&& other) noexcept;
    ~ConvertRowtypeExpr() override;

    ConvertRowtypeExpr& operator=(const ConvertRowtypeExpr& other) = delete;
    ConvertRowtypeExpr& operator=(ConvertRowtypeExpr&& other) noexcept;

    bool operator==(const ConvertRowtypeExpr& other) const noexcept;
    bool operator!=(const ConvertRowtypeExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const ConvertRowtypeExpr& other) const noexcept;
    bool operator<=(const ConvertRowtypeExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ConvertRowtypeExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ConvertRowtypeExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ConvertRowtypeExpr& value);

    void swap(ConvertRowtypeExpr& other) noexcept;
    friend void swap(ConvertRowtypeExpr& value1, ConvertRowtypeExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ConvertRowtypeExpr>
{
    typedef pg_query::ConvertRowtypeExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CollateExpr : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    uint32_t coll_oid;
    int32_t location;

    size_t fbe_type() const noexcept { return 35; }

    CollateExpr();
    CollateExpr(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_coll_oid, int32_t arg_location);
    CollateExpr(const CollateExpr& other) = delete;
    CollateExpr(CollateExpr&& other) noexcept;
    ~CollateExpr() override;

    CollateExpr& operator=(const CollateExpr& other) = delete;
    CollateExpr& operator=(CollateExpr&& other) noexcept;

    bool operator==(const CollateExpr& other) const noexcept;
    bool operator!=(const CollateExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const CollateExpr& other) const noexcept;
    bool operator<=(const CollateExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CollateExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CollateExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CollateExpr& value);

    void swap(CollateExpr& other) noexcept;
    friend void swap(CollateExpr& value1, CollateExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CollateExpr>
{
    typedef pg_query::CollateExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CaseExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t casetype;
    uint32_t casecollid;
    ::pg_query::Node arg;
    std::vector<::pg_query::Node> args;
    ::pg_query::Node defresult;
    int32_t location;

    size_t fbe_type() const noexcept { return 36; }

    CaseExpr();
    CaseExpr(::pg_query::Node&& arg_xpr, uint32_t arg_casetype, uint32_t arg_casecollid, ::pg_query::Node&& arg_arg, std::vector<::pg_query::Node> arg_args, ::pg_query::Node&& arg_defresult, int32_t arg_location);
    CaseExpr(const CaseExpr& other) = delete;
    CaseExpr(CaseExpr&& other) noexcept;
    ~CaseExpr() override;

    CaseExpr& operator=(const CaseExpr& other) = delete;
    CaseExpr& operator=(CaseExpr&& other) noexcept;

    bool operator==(const CaseExpr& other) const noexcept;
    bool operator!=(const CaseExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const CaseExpr& other) const noexcept;
    bool operator<=(const CaseExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CaseExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CaseExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CaseExpr& value);

    void swap(CaseExpr& other) noexcept;
    friend void swap(CaseExpr& value1, CaseExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CaseExpr>
{
    typedef pg_query::CaseExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CaseWhen : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node expr;
    ::pg_query::Node result;
    int32_t location;

    size_t fbe_type() const noexcept { return 37; }

    CaseWhen();
    CaseWhen(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_expr, ::pg_query::Node&& arg_result, int32_t arg_location);
    CaseWhen(const CaseWhen& other) = delete;
    CaseWhen(CaseWhen&& other) noexcept;
    ~CaseWhen() override;

    CaseWhen& operator=(const CaseWhen& other) = delete;
    CaseWhen& operator=(CaseWhen&& other) noexcept;

    bool operator==(const CaseWhen& other) const noexcept;
    bool operator!=(const CaseWhen& other) const noexcept { return !operator==(other); }
    bool operator<(const CaseWhen& other) const noexcept;
    bool operator<=(const CaseWhen& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CaseWhen& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CaseWhen& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CaseWhen& value);

    void swap(CaseWhen& other) noexcept;
    friend void swap(CaseWhen& value1, CaseWhen& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CaseWhen>
{
    typedef pg_query::CaseWhen argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CaseTestExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t type_id;
    int32_t type_mod;
    uint32_t collation;

    size_t fbe_type() const noexcept { return 38; }

    CaseTestExpr();
    CaseTestExpr(::pg_query::Node&& arg_xpr, uint32_t arg_type_id, int32_t arg_type_mod, uint32_t arg_collation);
    CaseTestExpr(const CaseTestExpr& other) = delete;
    CaseTestExpr(CaseTestExpr&& other) noexcept;
    ~CaseTestExpr() override;

    CaseTestExpr& operator=(const CaseTestExpr& other) = delete;
    CaseTestExpr& operator=(CaseTestExpr&& other) noexcept;

    bool operator==(const CaseTestExpr& other) const noexcept;
    bool operator!=(const CaseTestExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const CaseTestExpr& other) const noexcept;
    bool operator<=(const CaseTestExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CaseTestExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CaseTestExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CaseTestExpr& value);

    void swap(CaseTestExpr& other) noexcept;
    friend void swap(CaseTestExpr& value1, CaseTestExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CaseTestExpr>
{
    typedef pg_query::CaseTestExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ArrayExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t array_typeid;
    uint32_t array_collid;
    uint32_t element_typeid;
    std::vector<::pg_query::Node> elements;
    bool multidims;
    int32_t location;

    size_t fbe_type() const noexcept { return 39; }

    ArrayExpr();
    ArrayExpr(::pg_query::Node&& arg_xpr, uint32_t arg_array_typeid, uint32_t arg_array_collid, uint32_t arg_element_typeid, std::vector<::pg_query::Node> arg_elements, bool arg_multidims, int32_t arg_location);
    ArrayExpr(const ArrayExpr& other) = delete;
    ArrayExpr(ArrayExpr&& other) noexcept;
    ~ArrayExpr() override;

    ArrayExpr& operator=(const ArrayExpr& other) = delete;
    ArrayExpr& operator=(ArrayExpr&& other) noexcept;

    bool operator==(const ArrayExpr& other) const noexcept;
    bool operator!=(const ArrayExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const ArrayExpr& other) const noexcept;
    bool operator<=(const ArrayExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ArrayExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ArrayExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ArrayExpr& value);

    void swap(ArrayExpr& other) noexcept;
    friend void swap(ArrayExpr& value1, ArrayExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ArrayExpr>
{
    typedef pg_query::ArrayExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RowExpr : FBE::Base
{
    ::pg_query::Node xpr;
    std::vector<::pg_query::Node> args;
    uint32_t row_typeid;
    ::pg_query::CoercionForm row_format;
    std::vector<::pg_query::Node> colnames;
    int32_t location;

    size_t fbe_type() const noexcept { return 40; }

    RowExpr();
    RowExpr(::pg_query::Node&& arg_xpr, std::vector<::pg_query::Node> arg_args, uint32_t arg_row_typeid, ::pg_query::CoercionForm&& arg_row_format, std::vector<::pg_query::Node> arg_colnames, int32_t arg_location);
    RowExpr(const RowExpr& other) = delete;
    RowExpr(RowExpr&& other) noexcept;
    ~RowExpr() override;

    RowExpr& operator=(const RowExpr& other) = delete;
    RowExpr& operator=(RowExpr&& other) noexcept;

    bool operator==(const RowExpr& other) const noexcept;
    bool operator!=(const RowExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const RowExpr& other) const noexcept;
    bool operator<=(const RowExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RowExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RowExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RowExpr& value);

    void swap(RowExpr& other) noexcept;
    friend void swap(RowExpr& value1, RowExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RowExpr>
{
    typedef pg_query::RowExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RowCompareExpr : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::RowCompareType rctype;
    std::vector<::pg_query::Node> opnos;
    std::vector<::pg_query::Node> opfamilies;
    std::vector<::pg_query::Node> inputcollids;
    std::vector<::pg_query::Node> largs;
    std::vector<::pg_query::Node> rargs;

    size_t fbe_type() const noexcept { return 41; }

    RowCompareExpr();
    RowCompareExpr(::pg_query::Node&& arg_xpr, ::pg_query::RowCompareType&& arg_rctype, std::vector<::pg_query::Node> arg_opnos, std::vector<::pg_query::Node> arg_opfamilies, std::vector<::pg_query::Node> arg_inputcollids, std::vector<::pg_query::Node> arg_largs, std::vector<::pg_query::Node> arg_rargs);
    RowCompareExpr(const RowCompareExpr& other) = delete;
    RowCompareExpr(RowCompareExpr&& other) noexcept;
    ~RowCompareExpr() override;

    RowCompareExpr& operator=(const RowCompareExpr& other) = delete;
    RowCompareExpr& operator=(RowCompareExpr&& other) noexcept;

    bool operator==(const RowCompareExpr& other) const noexcept;
    bool operator!=(const RowCompareExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const RowCompareExpr& other) const noexcept;
    bool operator<=(const RowCompareExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RowCompareExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RowCompareExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RowCompareExpr& value);

    void swap(RowCompareExpr& other) noexcept;
    friend void swap(RowCompareExpr& value1, RowCompareExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RowCompareExpr>
{
    typedef pg_query::RowCompareExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CoalesceExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t coalescetype;
    uint32_t coalescecollid;
    std::vector<::pg_query::Node> args;
    int32_t location;

    size_t fbe_type() const noexcept { return 42; }

    CoalesceExpr();
    CoalesceExpr(::pg_query::Node&& arg_xpr, uint32_t arg_coalescetype, uint32_t arg_coalescecollid, std::vector<::pg_query::Node> arg_args, int32_t arg_location);
    CoalesceExpr(const CoalesceExpr& other) = delete;
    CoalesceExpr(CoalesceExpr&& other) noexcept;
    ~CoalesceExpr() override;

    CoalesceExpr& operator=(const CoalesceExpr& other) = delete;
    CoalesceExpr& operator=(CoalesceExpr&& other) noexcept;

    bool operator==(const CoalesceExpr& other) const noexcept;
    bool operator!=(const CoalesceExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const CoalesceExpr& other) const noexcept;
    bool operator<=(const CoalesceExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CoalesceExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CoalesceExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CoalesceExpr& value);

    void swap(CoalesceExpr& other) noexcept;
    friend void swap(CoalesceExpr& value1, CoalesceExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CoalesceExpr>
{
    typedef pg_query::CoalesceExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct MinMaxExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t minmaxtype;
    uint32_t minmaxcollid;
    uint32_t inputcollid;
    ::pg_query::MinMaxOp op;
    std::vector<::pg_query::Node> args;
    int32_t location;

    size_t fbe_type() const noexcept { return 43; }

    MinMaxExpr();
    MinMaxExpr(::pg_query::Node&& arg_xpr, uint32_t arg_minmaxtype, uint32_t arg_minmaxcollid, uint32_t arg_inputcollid, ::pg_query::MinMaxOp&& arg_op, std::vector<::pg_query::Node> arg_args, int32_t arg_location);
    MinMaxExpr(const MinMaxExpr& other) = delete;
    MinMaxExpr(MinMaxExpr&& other) noexcept;
    ~MinMaxExpr() override;

    MinMaxExpr& operator=(const MinMaxExpr& other) = delete;
    MinMaxExpr& operator=(MinMaxExpr&& other) noexcept;

    bool operator==(const MinMaxExpr& other) const noexcept;
    bool operator!=(const MinMaxExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const MinMaxExpr& other) const noexcept;
    bool operator<=(const MinMaxExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MinMaxExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MinMaxExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const MinMaxExpr& value);

    void swap(MinMaxExpr& other) noexcept;
    friend void swap(MinMaxExpr& value1, MinMaxExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::MinMaxExpr>
{
    typedef pg_query::MinMaxExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct SQLValueFunction : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::SQLValueFunctionOp op;
    uint32_t type;
    int32_t typmod;
    int32_t location;

    size_t fbe_type() const noexcept { return 44; }

    SQLValueFunction();
    SQLValueFunction(::pg_query::Node&& arg_xpr, ::pg_query::SQLValueFunctionOp&& arg_op, uint32_t arg_type, int32_t arg_typmod, int32_t arg_location);
    SQLValueFunction(const SQLValueFunction& other) = delete;
    SQLValueFunction(SQLValueFunction&& other) noexcept;
    ~SQLValueFunction() override;

    SQLValueFunction& operator=(const SQLValueFunction& other) = delete;
    SQLValueFunction& operator=(SQLValueFunction&& other) noexcept;

    bool operator==(const SQLValueFunction& other) const noexcept;
    bool operator!=(const SQLValueFunction& other) const noexcept { return !operator==(other); }
    bool operator<(const SQLValueFunction& other) const noexcept;
    bool operator<=(const SQLValueFunction& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SQLValueFunction& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SQLValueFunction& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SQLValueFunction& value);

    void swap(SQLValueFunction& other) noexcept;
    friend void swap(SQLValueFunction& value1, SQLValueFunction& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SQLValueFunction>
{
    typedef pg_query::SQLValueFunction argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct XmlExpr : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::XmlExprOp op;
    std::string name;
    std::vector<::pg_query::Node> named_args;
    std::vector<::pg_query::Node> arg_names;
    std::vector<::pg_query::Node> args;
    ::pg_query::XmlOptionType xmloption;
    uint32_t type;
    int32_t typmod;
    int32_t location;

    size_t fbe_type() const noexcept { return 45; }

    XmlExpr();
    XmlExpr(::pg_query::Node&& arg_xpr, ::pg_query::XmlExprOp&& arg_op, const std::string& arg_name, std::vector<::pg_query::Node> arg_named_args, std::vector<::pg_query::Node> arg_arg_names, std::vector<::pg_query::Node> arg_args, ::pg_query::XmlOptionType&& arg_xmloption, uint32_t arg_type, int32_t arg_typmod, int32_t arg_location);
    XmlExpr(const XmlExpr& other) = delete;
    XmlExpr(XmlExpr&& other) noexcept;
    ~XmlExpr() override;

    XmlExpr& operator=(const XmlExpr& other) = delete;
    XmlExpr& operator=(XmlExpr&& other) noexcept;

    bool operator==(const XmlExpr& other) const noexcept;
    bool operator!=(const XmlExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const XmlExpr& other) const noexcept;
    bool operator<=(const XmlExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const XmlExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const XmlExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const XmlExpr& value);

    void swap(XmlExpr& other) noexcept;
    friend void swap(XmlExpr& value1, XmlExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::XmlExpr>
{
    typedef pg_query::XmlExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct NullTest : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    ::pg_query::NullTestType nulltesttype;
    bool argisrow;
    int32_t location;

    size_t fbe_type() const noexcept { return 46; }

    NullTest();
    NullTest(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, ::pg_query::NullTestType&& arg_nulltesttype, bool arg_argisrow, int32_t arg_location);
    NullTest(const NullTest& other) = delete;
    NullTest(NullTest&& other) noexcept;
    ~NullTest() override;

    NullTest& operator=(const NullTest& other) = delete;
    NullTest& operator=(NullTest&& other) noexcept;

    bool operator==(const NullTest& other) const noexcept;
    bool operator!=(const NullTest& other) const noexcept { return !operator==(other); }
    bool operator<(const NullTest& other) const noexcept;
    bool operator<=(const NullTest& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const NullTest& other) const noexcept { return !operator<=(other); }
    bool operator>=(const NullTest& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const NullTest& value);

    void swap(NullTest& other) noexcept;
    friend void swap(NullTest& value1, NullTest& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::NullTest>
{
    typedef pg_query::NullTest argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct BooleanTest : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    ::pg_query::BoolTestType booltesttype;
    int32_t location;

    size_t fbe_type() const noexcept { return 47; }

    BooleanTest();
    BooleanTest(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, ::pg_query::BoolTestType&& arg_booltesttype, int32_t arg_location);
    BooleanTest(const BooleanTest& other) = delete;
    BooleanTest(BooleanTest&& other) noexcept;
    ~BooleanTest() override;

    BooleanTest& operator=(const BooleanTest& other) = delete;
    BooleanTest& operator=(BooleanTest&& other) noexcept;

    bool operator==(const BooleanTest& other) const noexcept;
    bool operator!=(const BooleanTest& other) const noexcept { return !operator==(other); }
    bool operator<(const BooleanTest& other) const noexcept;
    bool operator<=(const BooleanTest& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const BooleanTest& other) const noexcept { return !operator<=(other); }
    bool operator>=(const BooleanTest& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const BooleanTest& value);

    void swap(BooleanTest& other) noexcept;
    friend void swap(BooleanTest& value1, BooleanTest& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::BooleanTest>
{
    typedef pg_query::BooleanTest argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CoerceToDomain : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node arg;
    uint32_t resulttype;
    int32_t resulttypmod;
    uint32_t resultcollid;
    ::pg_query::CoercionForm coercionformat;
    int32_t location;

    size_t fbe_type() const noexcept { return 48; }

    CoerceToDomain();
    CoerceToDomain(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_arg, uint32_t arg_resulttype, int32_t arg_resulttypmod, uint32_t arg_resultcollid, ::pg_query::CoercionForm&& arg_coercionformat, int32_t arg_location);
    CoerceToDomain(const CoerceToDomain& other) = delete;
    CoerceToDomain(CoerceToDomain&& other) noexcept;
    ~CoerceToDomain() override;

    CoerceToDomain& operator=(const CoerceToDomain& other) = delete;
    CoerceToDomain& operator=(CoerceToDomain&& other) noexcept;

    bool operator==(const CoerceToDomain& other) const noexcept;
    bool operator!=(const CoerceToDomain& other) const noexcept { return !operator==(other); }
    bool operator<(const CoerceToDomain& other) const noexcept;
    bool operator<=(const CoerceToDomain& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CoerceToDomain& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CoerceToDomain& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CoerceToDomain& value);

    void swap(CoerceToDomain& other) noexcept;
    friend void swap(CoerceToDomain& value1, CoerceToDomain& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CoerceToDomain>
{
    typedef pg_query::CoerceToDomain argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CoerceToDomainValue : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t type_id;
    int32_t type_mod;
    uint32_t collation;
    int32_t location;

    size_t fbe_type() const noexcept { return 49; }

    CoerceToDomainValue();
    CoerceToDomainValue(::pg_query::Node&& arg_xpr, uint32_t arg_type_id, int32_t arg_type_mod, uint32_t arg_collation, int32_t arg_location);
    CoerceToDomainValue(const CoerceToDomainValue& other) = delete;
    CoerceToDomainValue(CoerceToDomainValue&& other) noexcept;
    ~CoerceToDomainValue() override;

    CoerceToDomainValue& operator=(const CoerceToDomainValue& other) = delete;
    CoerceToDomainValue& operator=(CoerceToDomainValue&& other) noexcept;

    bool operator==(const CoerceToDomainValue& other) const noexcept;
    bool operator!=(const CoerceToDomainValue& other) const noexcept { return !operator==(other); }
    bool operator<(const CoerceToDomainValue& other) const noexcept;
    bool operator<=(const CoerceToDomainValue& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CoerceToDomainValue& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CoerceToDomainValue& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CoerceToDomainValue& value);

    void swap(CoerceToDomainValue& other) noexcept;
    friend void swap(CoerceToDomainValue& value1, CoerceToDomainValue& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CoerceToDomainValue>
{
    typedef pg_query::CoerceToDomainValue argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct SetToDefault : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t type_id;
    int32_t type_mod;
    uint32_t collation;
    int32_t location;

    size_t fbe_type() const noexcept { return 50; }

    SetToDefault();
    SetToDefault(::pg_query::Node&& arg_xpr, uint32_t arg_type_id, int32_t arg_type_mod, uint32_t arg_collation, int32_t arg_location);
    SetToDefault(const SetToDefault& other) = delete;
    SetToDefault(SetToDefault&& other) noexcept;
    ~SetToDefault() override;

    SetToDefault& operator=(const SetToDefault& other) = delete;
    SetToDefault& operator=(SetToDefault&& other) noexcept;

    bool operator==(const SetToDefault& other) const noexcept;
    bool operator!=(const SetToDefault& other) const noexcept { return !operator==(other); }
    bool operator<(const SetToDefault& other) const noexcept;
    bool operator<=(const SetToDefault& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SetToDefault& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SetToDefault& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SetToDefault& value);

    void swap(SetToDefault& other) noexcept;
    friend void swap(SetToDefault& value1, SetToDefault& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SetToDefault>
{
    typedef pg_query::SetToDefault argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CurrentOfExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t cvarno;
    std::string cursor_name;
    int32_t cursor_param;

    size_t fbe_type() const noexcept { return 51; }

    CurrentOfExpr();
    CurrentOfExpr(::pg_query::Node&& arg_xpr, uint32_t arg_cvarno, const std::string& arg_cursor_name, int32_t arg_cursor_param);
    CurrentOfExpr(const CurrentOfExpr& other) = delete;
    CurrentOfExpr(CurrentOfExpr&& other) noexcept;
    ~CurrentOfExpr() override;

    CurrentOfExpr& operator=(const CurrentOfExpr& other) = delete;
    CurrentOfExpr& operator=(CurrentOfExpr&& other) noexcept;

    bool operator==(const CurrentOfExpr& other) const noexcept;
    bool operator!=(const CurrentOfExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const CurrentOfExpr& other) const noexcept;
    bool operator<=(const CurrentOfExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CurrentOfExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CurrentOfExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CurrentOfExpr& value);

    void swap(CurrentOfExpr& other) noexcept;
    friend void swap(CurrentOfExpr& value1, CurrentOfExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CurrentOfExpr>
{
    typedef pg_query::CurrentOfExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct NextValueExpr : FBE::Base
{
    ::pg_query::Node xpr;
    uint32_t seqid;
    uint32_t type_id;

    size_t fbe_type() const noexcept { return 52; }

    NextValueExpr();
    NextValueExpr(::pg_query::Node&& arg_xpr, uint32_t arg_seqid, uint32_t arg_type_id);
    NextValueExpr(const NextValueExpr& other) = delete;
    NextValueExpr(NextValueExpr&& other) noexcept;
    ~NextValueExpr() override;

    NextValueExpr& operator=(const NextValueExpr& other) = delete;
    NextValueExpr& operator=(NextValueExpr&& other) noexcept;

    bool operator==(const NextValueExpr& other) const noexcept;
    bool operator!=(const NextValueExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const NextValueExpr& other) const noexcept;
    bool operator<=(const NextValueExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const NextValueExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const NextValueExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const NextValueExpr& value);

    void swap(NextValueExpr& other) noexcept;
    friend void swap(NextValueExpr& value1, NextValueExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::NextValueExpr>
{
    typedef pg_query::NextValueExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct InferenceElem : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node expr;
    uint32_t infercollid;
    uint32_t inferopclass;

    size_t fbe_type() const noexcept { return 53; }

    InferenceElem();
    InferenceElem(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_expr, uint32_t arg_infercollid, uint32_t arg_inferopclass);
    InferenceElem(const InferenceElem& other) = delete;
    InferenceElem(InferenceElem&& other) noexcept;
    ~InferenceElem() override;

    InferenceElem& operator=(const InferenceElem& other) = delete;
    InferenceElem& operator=(InferenceElem&& other) noexcept;

    bool operator==(const InferenceElem& other) const noexcept;
    bool operator!=(const InferenceElem& other) const noexcept { return !operator==(other); }
    bool operator<(const InferenceElem& other) const noexcept;
    bool operator<=(const InferenceElem& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const InferenceElem& other) const noexcept { return !operator<=(other); }
    bool operator>=(const InferenceElem& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const InferenceElem& value);

    void swap(InferenceElem& other) noexcept;
    friend void swap(InferenceElem& value1, InferenceElem& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::InferenceElem>
{
    typedef pg_query::InferenceElem argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TargetEntry : FBE::Base
{
    ::pg_query::Node xpr;
    ::pg_query::Node expr;
    int32_t resno;
    std::string resname;
    uint32_t ressortgroupref;
    uint32_t resorigtbl;
    int32_t resorigcol;
    bool resjunk;

    size_t fbe_type() const noexcept { return 54; }

    TargetEntry();
    TargetEntry(::pg_query::Node&& arg_xpr, ::pg_query::Node&& arg_expr, int32_t arg_resno, const std::string& arg_resname, uint32_t arg_ressortgroupref, uint32_t arg_resorigtbl, int32_t arg_resorigcol, bool arg_resjunk);
    TargetEntry(const TargetEntry& other) = delete;
    TargetEntry(TargetEntry&& other) noexcept;
    ~TargetEntry() override;

    TargetEntry& operator=(const TargetEntry& other) = delete;
    TargetEntry& operator=(TargetEntry&& other) noexcept;

    bool operator==(const TargetEntry& other) const noexcept;
    bool operator!=(const TargetEntry& other) const noexcept { return !operator==(other); }
    bool operator<(const TargetEntry& other) const noexcept;
    bool operator<=(const TargetEntry& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const TargetEntry& other) const noexcept { return !operator<=(other); }
    bool operator>=(const TargetEntry& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const TargetEntry& value);

    void swap(TargetEntry& other) noexcept;
    friend void swap(TargetEntry& value1, TargetEntry& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::TargetEntry>
{
    typedef pg_query::TargetEntry argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeTblRef : FBE::Base
{
    int32_t rtindex;

    size_t fbe_type() const noexcept { return 55; }

    RangeTblRef();
    explicit RangeTblRef(int32_t arg_rtindex);
    RangeTblRef(const RangeTblRef& other) = delete;
    RangeTblRef(RangeTblRef&& other) noexcept;
    ~RangeTblRef() override;

    RangeTblRef& operator=(const RangeTblRef& other) = delete;
    RangeTblRef& operator=(RangeTblRef&& other) noexcept;

    bool operator==(const RangeTblRef& other) const noexcept;
    bool operator!=(const RangeTblRef& other) const noexcept { return !operator==(other); }
    bool operator<(const RangeTblRef& other) const noexcept;
    bool operator<=(const RangeTblRef& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RangeTblRef& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RangeTblRef& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RangeTblRef& value);

    void swap(RangeTblRef& other) noexcept;
    friend void swap(RangeTblRef& value1, RangeTblRef& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RangeTblRef>
{
    typedef pg_query::RangeTblRef argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Alias;

struct JoinExpr : FBE::Base
{
    ::pg_query::JoinType jointype;
    bool is_natural;
    ::pg_query::Node larg;
    ::pg_query::Node rarg;
    std::vector<::pg_query::Node> using_clause;
    ::pg_query::Node quals;
    ::pg_query::Alias* alias;
    int32_t rtindex;

    size_t fbe_type() const noexcept { return 56; }

    JoinExpr();
    JoinExpr(::pg_query::JoinType&& arg_jointype, bool arg_is_natural, ::pg_query::Node&& arg_larg, ::pg_query::Node&& arg_rarg, std::vector<::pg_query::Node> arg_using_clause, ::pg_query::Node&& arg_quals, std::unique_ptr<::pg_query::Alias> arg_alias, int32_t arg_rtindex);
    JoinExpr(const JoinExpr& other) = delete;
    JoinExpr(JoinExpr&& other) noexcept;
    ~JoinExpr() override;

    JoinExpr& operator=(const JoinExpr& other) = delete;
    JoinExpr& operator=(JoinExpr&& other) noexcept;

    bool operator==(const JoinExpr& other) const noexcept;
    bool operator!=(const JoinExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const JoinExpr& other) const noexcept;
    bool operator<=(const JoinExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const JoinExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const JoinExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const JoinExpr& value);

    void swap(JoinExpr& other) noexcept;
    friend void swap(JoinExpr& value1, JoinExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::JoinExpr>
{
    typedef pg_query::JoinExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct FromExpr : FBE::Base
{
    std::vector<::pg_query::Node> fromlist;
    ::pg_query::Node quals;

    size_t fbe_type() const noexcept { return 57; }

    FromExpr();
    FromExpr(std::vector<::pg_query::Node> arg_fromlist, ::pg_query::Node&& arg_quals);
    FromExpr(const FromExpr& other) = delete;
    FromExpr(FromExpr&& other) noexcept;
    ~FromExpr() override;

    FromExpr& operator=(const FromExpr& other) = delete;
    FromExpr& operator=(FromExpr&& other) noexcept;

    bool operator==(const FromExpr& other) const noexcept;
    bool operator!=(const FromExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const FromExpr& other) const noexcept;
    bool operator<=(const FromExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const FromExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const FromExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const FromExpr& value);

    void swap(FromExpr& other) noexcept;
    friend void swap(FromExpr& value1, FromExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::FromExpr>
{
    typedef pg_query::FromExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct OnConflictExpr : FBE::Base
{
    ::pg_query::OnConflictAction action;
    std::vector<::pg_query::Node> arbiter_elems;
    ::pg_query::Node arbiter_where;
    uint32_t constraint;
    std::vector<::pg_query::Node> on_conflict_set;
    ::pg_query::Node on_conflict_where;
    int32_t excl_rel_index;
    std::vector<::pg_query::Node> excl_rel_tlist;

    size_t fbe_type() const noexcept { return 58; }

    OnConflictExpr();
    OnConflictExpr(::pg_query::OnConflictAction&& arg_action, std::vector<::pg_query::Node> arg_arbiter_elems, ::pg_query::Node&& arg_arbiter_where, uint32_t arg_constraint, std::vector<::pg_query::Node> arg_on_conflict_set, ::pg_query::Node&& arg_on_conflict_where, int32_t arg_excl_rel_index, std::vector<::pg_query::Node> arg_excl_rel_tlist);
    OnConflictExpr(const OnConflictExpr& other) = delete;
    OnConflictExpr(OnConflictExpr&& other) noexcept;
    ~OnConflictExpr() override;

    OnConflictExpr& operator=(const OnConflictExpr& other) = delete;
    OnConflictExpr& operator=(OnConflictExpr&& other) noexcept;

    bool operator==(const OnConflictExpr& other) const noexcept;
    bool operator!=(const OnConflictExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const OnConflictExpr& other) const noexcept;
    bool operator<=(const OnConflictExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const OnConflictExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const OnConflictExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const OnConflictExpr& value);

    void swap(OnConflictExpr& other) noexcept;
    friend void swap(OnConflictExpr& value1, OnConflictExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::OnConflictExpr>
{
    typedef pg_query::OnConflictExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct IntoClause : FBE::Base
{
    ::pg_query::RangeVar* rel;
    std::vector<::pg_query::Node> col_names;
    std::string access_method;
    std::vector<::pg_query::Node> options;
    ::pg_query::OnCommitAction on_commit;
    std::string table_space_name;
    ::pg_query::Node view_query;
    bool skip_data;

    size_t fbe_type() const noexcept { return 59; }

    IntoClause();
    IntoClause(std::unique_ptr<::pg_query::RangeVar> arg_rel, std::vector<::pg_query::Node> arg_col_names, const std::string& arg_access_method, std::vector<::pg_query::Node> arg_options, ::pg_query::OnCommitAction&& arg_on_commit, const std::string& arg_table_space_name, ::pg_query::Node&& arg_view_query, bool arg_skip_data);
    IntoClause(const IntoClause& other) = delete;
    IntoClause(IntoClause&& other) noexcept;
    ~IntoClause() override;

    IntoClause& operator=(const IntoClause& other) = delete;
    IntoClause& operator=(IntoClause&& other) noexcept;

    bool operator==(const IntoClause& other) const noexcept;
    bool operator!=(const IntoClause& other) const noexcept { return !operator==(other); }
    bool operator<(const IntoClause& other) const noexcept;
    bool operator<=(const IntoClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const IntoClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const IntoClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const IntoClause& value);

    void swap(IntoClause& other) noexcept;
    friend void swap(IntoClause& value1, IntoClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::IntoClause>
{
    typedef pg_query::IntoClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RawStmt : FBE::Base
{
    ::pg_query::Node stmt;
    int32_t stmt_location;
    int32_t stmt_len;

    size_t fbe_type() const noexcept { return 60; }

    RawStmt();
    RawStmt(::pg_query::Node&& arg_stmt, int32_t arg_stmt_location, int32_t arg_stmt_len);
    RawStmt(const RawStmt& other) = delete;
    RawStmt(RawStmt&& other) noexcept;
    ~RawStmt() override;

    RawStmt& operator=(const RawStmt& other) = delete;
    RawStmt& operator=(RawStmt&& other) noexcept;

    bool operator==(const RawStmt& other) const noexcept;
    bool operator!=(const RawStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const RawStmt& other) const noexcept;
    bool operator<=(const RawStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RawStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RawStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RawStmt& value);

    void swap(RawStmt& other) noexcept;
    friend void swap(RawStmt& value1, RawStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RawStmt>
{
    typedef pg_query::RawStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct FromExpr;

struct OnConflictExpr;

struct Query : FBE::Base
{
    ::pg_query::CmdType command_type;
    ::pg_query::QuerySource query_source;
    bool can_set_tag;
    ::pg_query::Node utility_stmt;
    int32_t result_relation;
    bool has_aggs;
    bool has_window_funcs;
    bool has_target_srfs;
    bool has_sub_links;
    bool has_distinct_on;
    bool has_recursive;
    bool has_modifying_cte;
    bool has_for_update;
    bool has_row_security;
    std::vector<::pg_query::Node> cte_list;
    std::vector<::pg_query::Node> rtable;
    ::pg_query::FromExpr* jointree;
    std::vector<::pg_query::Node> target_list;
    ::pg_query::OverridingKind override;
    ::pg_query::OnConflictExpr* on_conflict;
    std::vector<::pg_query::Node> returning_list;
    std::vector<::pg_query::Node> group_clause;
    std::vector<::pg_query::Node> grouping_sets;
    ::pg_query::Node having_qual;
    std::vector<::pg_query::Node> window_clause;
    std::vector<::pg_query::Node> distinct_clause;
    std::vector<::pg_query::Node> sort_clause;
    ::pg_query::Node limit_offset;
    ::pg_query::Node limit_count;
    ::pg_query::LimitOption limit_option;
    std::vector<::pg_query::Node> row_marks;
    ::pg_query::Node set_operations;
    std::vector<::pg_query::Node> constraint_deps;
    std::vector<::pg_query::Node> with_check_options;
    int32_t stmt_location;
    int32_t stmt_len;

    size_t fbe_type() const noexcept { return 61; }

    Query();
    Query(::pg_query::CmdType&& arg_command_type, ::pg_query::QuerySource&& arg_query_source, bool arg_can_set_tag, ::pg_query::Node&& arg_utility_stmt, int32_t arg_result_relation, bool arg_has_aggs, bool arg_has_window_funcs, bool arg_has_target_srfs, bool arg_has_sub_links, bool arg_has_distinct_on, bool arg_has_recursive, bool arg_has_modifying_cte, bool arg_has_for_update, bool arg_has_row_security, std::vector<::pg_query::Node> arg_cte_list, std::vector<::pg_query::Node> arg_rtable, std::unique_ptr<::pg_query::FromExpr> arg_jointree, std::vector<::pg_query::Node> arg_target_list, ::pg_query::OverridingKind&& arg_override, std::unique_ptr<::pg_query::OnConflictExpr> arg_on_conflict, std::vector<::pg_query::Node> arg_returning_list, std::vector<::pg_query::Node> arg_group_clause, std::vector<::pg_query::Node> arg_grouping_sets, ::pg_query::Node&& arg_having_qual, std::vector<::pg_query::Node> arg_window_clause, std::vector<::pg_query::Node> arg_distinct_clause, std::vector<::pg_query::Node> arg_sort_clause, ::pg_query::Node&& arg_limit_offset, ::pg_query::Node&& arg_limit_count, ::pg_query::LimitOption&& arg_limit_option, std::vector<::pg_query::Node> arg_row_marks, ::pg_query::Node&& arg_set_operations, std::vector<::pg_query::Node> arg_constraint_deps, std::vector<::pg_query::Node> arg_with_check_options, int32_t arg_stmt_location, int32_t arg_stmt_len);
    Query(const Query& other) = delete;
    Query(Query&& other) noexcept;
    ~Query() override;

    Query& operator=(const Query& other) = delete;
    Query& operator=(Query&& other) noexcept;

    bool operator==(const Query& other) const noexcept;
    bool operator!=(const Query& other) const noexcept { return !operator==(other); }
    bool operator<(const Query& other) const noexcept;
    bool operator<=(const Query& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Query& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Query& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Query& value);

    void swap(Query& other) noexcept;
    friend void swap(Query& value1, Query& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Query>
{
    typedef pg_query::Query argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct OnConflictClause;

struct WithClause;

struct InsertStmt : FBE::Base
{
    ::pg_query::RangeVar* relation;
    std::vector<::pg_query::Node> cols;
    ::pg_query::Node select_stmt;
    ::pg_query::OnConflictClause* on_conflict_clause;
    std::vector<::pg_query::Node> returning_list;
    ::pg_query::WithClause* with_clause;
    ::pg_query::OverridingKind override;

    size_t fbe_type() const noexcept { return 62; }

    InsertStmt();
    InsertStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_cols, ::pg_query::Node&& arg_select_stmt, std::unique_ptr<::pg_query::OnConflictClause> arg_on_conflict_clause, std::vector<::pg_query::Node> arg_returning_list, std::unique_ptr<::pg_query::WithClause> arg_with_clause, ::pg_query::OverridingKind&& arg_override);
    InsertStmt(const InsertStmt& other) = delete;
    InsertStmt(InsertStmt&& other) noexcept;
    ~InsertStmt() override;

    InsertStmt& operator=(const InsertStmt& other) = delete;
    InsertStmt& operator=(InsertStmt&& other) noexcept;

    bool operator==(const InsertStmt& other) const noexcept;
    bool operator!=(const InsertStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const InsertStmt& other) const noexcept;
    bool operator<=(const InsertStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const InsertStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const InsertStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const InsertStmt& value);

    void swap(InsertStmt& other) noexcept;
    friend void swap(InsertStmt& value1, InsertStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::InsertStmt>
{
    typedef pg_query::InsertStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct WithClause;

struct DeleteStmt : FBE::Base
{
    ::pg_query::RangeVar* relation;
    std::vector<::pg_query::Node> using_clause;
    ::pg_query::Node where_clause;
    std::vector<::pg_query::Node> returning_list;
    ::pg_query::WithClause* with_clause;

    size_t fbe_type() const noexcept { return 63; }

    DeleteStmt();
    DeleteStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_using_clause, ::pg_query::Node&& arg_where_clause, std::vector<::pg_query::Node> arg_returning_list, std::unique_ptr<::pg_query::WithClause> arg_with_clause);
    DeleteStmt(const DeleteStmt& other) = delete;
    DeleteStmt(DeleteStmt&& other) noexcept;
    ~DeleteStmt() override;

    DeleteStmt& operator=(const DeleteStmt& other) = delete;
    DeleteStmt& operator=(DeleteStmt&& other) noexcept;

    bool operator==(const DeleteStmt& other) const noexcept;
    bool operator!=(const DeleteStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DeleteStmt& other) const noexcept;
    bool operator<=(const DeleteStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DeleteStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DeleteStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DeleteStmt& value);

    void swap(DeleteStmt& other) noexcept;
    friend void swap(DeleteStmt& value1, DeleteStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DeleteStmt>
{
    typedef pg_query::DeleteStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct WithClause;

struct UpdateStmt : FBE::Base
{
    ::pg_query::RangeVar* relation;
    std::vector<::pg_query::Node> target_list;
    ::pg_query::Node where_clause;
    std::vector<::pg_query::Node> from_clause;
    std::vector<::pg_query::Node> returning_list;
    ::pg_query::WithClause* with_clause;

    size_t fbe_type() const noexcept { return 64; }

    UpdateStmt();
    UpdateStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_target_list, ::pg_query::Node&& arg_where_clause, std::vector<::pg_query::Node> arg_from_clause, std::vector<::pg_query::Node> arg_returning_list, std::unique_ptr<::pg_query::WithClause> arg_with_clause);
    UpdateStmt(const UpdateStmt& other) = delete;
    UpdateStmt(UpdateStmt&& other) noexcept;
    ~UpdateStmt() override;

    UpdateStmt& operator=(const UpdateStmt& other) = delete;
    UpdateStmt& operator=(UpdateStmt&& other) noexcept;

    bool operator==(const UpdateStmt& other) const noexcept;
    bool operator!=(const UpdateStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const UpdateStmt& other) const noexcept;
    bool operator<=(const UpdateStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const UpdateStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const UpdateStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const UpdateStmt& value);

    void swap(UpdateStmt& other) noexcept;
    friend void swap(UpdateStmt& value1, UpdateStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::UpdateStmt>
{
    typedef pg_query::UpdateStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct IntoClause;

struct WithClause;

struct SelectStmt : FBE::Base
{
    std::vector<::pg_query::Node> distinct_clause;
    ::pg_query::IntoClause* into_clause;
    std::vector<::pg_query::Node> target_list;
    std::vector<::pg_query::Node> from_clause;
    ::pg_query::Node where_clause;
    std::vector<::pg_query::Node> group_clause;
    ::pg_query::Node having_clause;
    std::vector<::pg_query::Node> window_clause;
    std::vector<::pg_query::Node> values_lists;
    std::vector<::pg_query::Node> sort_clause;
    ::pg_query::Node limit_offset;
    ::pg_query::Node limit_count;
    ::pg_query::LimitOption limit_option;
    std::vector<::pg_query::Node> locking_clause;
    ::pg_query::WithClause* with_clause;
    ::pg_query::SetOperation op;
    bool all;
    ::pg_query::SelectStmt* larg;
    ::pg_query::SelectStmt* rarg;

    size_t fbe_type() const noexcept { return 65; }

    SelectStmt();
    SelectStmt(std::vector<::pg_query::Node> arg_distinct_clause, std::unique_ptr<::pg_query::IntoClause> arg_into_clause, std::vector<::pg_query::Node> arg_target_list, std::vector<::pg_query::Node> arg_from_clause, ::pg_query::Node&& arg_where_clause, std::vector<::pg_query::Node> arg_group_clause, ::pg_query::Node&& arg_having_clause, std::vector<::pg_query::Node> arg_window_clause, std::vector<::pg_query::Node> arg_values_lists, std::vector<::pg_query::Node> arg_sort_clause, ::pg_query::Node&& arg_limit_offset, ::pg_query::Node&& arg_limit_count, ::pg_query::LimitOption&& arg_limit_option, std::vector<::pg_query::Node> arg_locking_clause, std::unique_ptr<::pg_query::WithClause> arg_with_clause, ::pg_query::SetOperation&& arg_op, bool arg_all, std::unique_ptr<::pg_query::SelectStmt> arg_larg, std::unique_ptr<::pg_query::SelectStmt> arg_rarg);
    SelectStmt(const SelectStmt& other) = delete;
    SelectStmt(SelectStmt&& other) noexcept;
    ~SelectStmt() override;

    SelectStmt& operator=(const SelectStmt& other) = delete;
    SelectStmt& operator=(SelectStmt&& other) noexcept;

    bool operator==(const SelectStmt& other) const noexcept;
    bool operator!=(const SelectStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const SelectStmt& other) const noexcept;
    bool operator<=(const SelectStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SelectStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SelectStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SelectStmt& value);

    void swap(SelectStmt& other) noexcept;
    friend void swap(SelectStmt& value1, SelectStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SelectStmt>
{
    typedef pg_query::SelectStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct AlterTableStmt : FBE::Base
{
    ::pg_query::RangeVar* relation;
    std::vector<::pg_query::Node> cmds;
    ::pg_query::ObjectType relkind;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 66; }

    AlterTableStmt();
    AlterTableStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_cmds, ::pg_query::ObjectType&& arg_relkind, bool arg_missing_ok);
    AlterTableStmt(const AlterTableStmt& other) = delete;
    AlterTableStmt(AlterTableStmt&& other) noexcept;
    ~AlterTableStmt() override;

    AlterTableStmt& operator=(const AlterTableStmt& other) = delete;
    AlterTableStmt& operator=(AlterTableStmt&& other) noexcept;

    bool operator==(const AlterTableStmt& other) const noexcept;
    bool operator!=(const AlterTableStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterTableStmt& other) const noexcept;
    bool operator<=(const AlterTableStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterTableStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterTableStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterTableStmt& value);

    void swap(AlterTableStmt& other) noexcept;
    friend void swap(AlterTableStmt& value1, AlterTableStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterTableStmt>
{
    typedef pg_query::AlterTableStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct AlterTableCmd : FBE::Base
{
    ::pg_query::AlterTableType subtype;
    std::string name;
    int32_t num;
    ::pg_query::RoleSpec* newowner;
    ::pg_query::Node def;
    ::pg_query::DropBehavior behavior;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 67; }

    AlterTableCmd();
    AlterTableCmd(::pg_query::AlterTableType&& arg_subtype, const std::string& arg_name, int32_t arg_num, std::unique_ptr<::pg_query::RoleSpec> arg_newowner, ::pg_query::Node&& arg_def, ::pg_query::DropBehavior&& arg_behavior, bool arg_missing_ok);
    AlterTableCmd(const AlterTableCmd& other) = delete;
    AlterTableCmd(AlterTableCmd&& other) noexcept;
    ~AlterTableCmd() override;

    AlterTableCmd& operator=(const AlterTableCmd& other) = delete;
    AlterTableCmd& operator=(AlterTableCmd&& other) noexcept;

    bool operator==(const AlterTableCmd& other) const noexcept;
    bool operator!=(const AlterTableCmd& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterTableCmd& other) const noexcept;
    bool operator<=(const AlterTableCmd& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterTableCmd& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterTableCmd& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterTableCmd& value);

    void swap(AlterTableCmd& other) noexcept;
    friend void swap(AlterTableCmd& value1, AlterTableCmd& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterTableCmd>
{
    typedef pg_query::AlterTableCmd argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterDomainStmt : FBE::Base
{
    std::string subtype;
    std::vector<::pg_query::Node> type_name;
    std::string name;
    ::pg_query::Node def;
    ::pg_query::DropBehavior behavior;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 68; }

    AlterDomainStmt();
    AlterDomainStmt(const std::string& arg_subtype, std::vector<::pg_query::Node> arg_type_name, const std::string& arg_name, ::pg_query::Node&& arg_def, ::pg_query::DropBehavior&& arg_behavior, bool arg_missing_ok);
    AlterDomainStmt(const AlterDomainStmt& other) = delete;
    AlterDomainStmt(AlterDomainStmt&& other) noexcept;
    ~AlterDomainStmt() override;

    AlterDomainStmt& operator=(const AlterDomainStmt& other) = delete;
    AlterDomainStmt& operator=(AlterDomainStmt&& other) noexcept;

    bool operator==(const AlterDomainStmt& other) const noexcept;
    bool operator!=(const AlterDomainStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterDomainStmt& other) const noexcept;
    bool operator<=(const AlterDomainStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterDomainStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterDomainStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterDomainStmt& value);

    void swap(AlterDomainStmt& other) noexcept;
    friend void swap(AlterDomainStmt& value1, AlterDomainStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterDomainStmt>
{
    typedef pg_query::AlterDomainStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct SetOperationStmt : FBE::Base
{
    ::pg_query::SetOperation op;
    bool all;
    ::pg_query::Node larg;
    ::pg_query::Node rarg;
    std::vector<::pg_query::Node> col_types;
    std::vector<::pg_query::Node> col_typmods;
    std::vector<::pg_query::Node> col_collations;
    std::vector<::pg_query::Node> group_clauses;

    size_t fbe_type() const noexcept { return 69; }

    SetOperationStmt();
    SetOperationStmt(::pg_query::SetOperation&& arg_op, bool arg_all, ::pg_query::Node&& arg_larg, ::pg_query::Node&& arg_rarg, std::vector<::pg_query::Node> arg_col_types, std::vector<::pg_query::Node> arg_col_typmods, std::vector<::pg_query::Node> arg_col_collations, std::vector<::pg_query::Node> arg_group_clauses);
    SetOperationStmt(const SetOperationStmt& other) = delete;
    SetOperationStmt(SetOperationStmt&& other) noexcept;
    ~SetOperationStmt() override;

    SetOperationStmt& operator=(const SetOperationStmt& other) = delete;
    SetOperationStmt& operator=(SetOperationStmt&& other) noexcept;

    bool operator==(const SetOperationStmt& other) const noexcept;
    bool operator!=(const SetOperationStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const SetOperationStmt& other) const noexcept;
    bool operator<=(const SetOperationStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SetOperationStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SetOperationStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SetOperationStmt& value);

    void swap(SetOperationStmt& other) noexcept;
    friend void swap(SetOperationStmt& value1, SetOperationStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SetOperationStmt>
{
    typedef pg_query::SetOperationStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct GrantStmt : FBE::Base
{
    bool is_grant;
    ::pg_query::GrantTargetType targtype;
    ::pg_query::ObjectType objtype;
    std::vector<::pg_query::Node> objects;
    std::vector<::pg_query::Node> privileges;
    std::vector<::pg_query::Node> grantees;
    bool grant_option;
    ::pg_query::DropBehavior behavior;

    size_t fbe_type() const noexcept { return 70; }

    GrantStmt();
    GrantStmt(bool arg_is_grant, ::pg_query::GrantTargetType&& arg_targtype, ::pg_query::ObjectType&& arg_objtype, std::vector<::pg_query::Node> arg_objects, std::vector<::pg_query::Node> arg_privileges, std::vector<::pg_query::Node> arg_grantees, bool arg_grant_option, ::pg_query::DropBehavior&& arg_behavior);
    GrantStmt(const GrantStmt& other) = delete;
    GrantStmt(GrantStmt&& other) noexcept;
    ~GrantStmt() override;

    GrantStmt& operator=(const GrantStmt& other) = delete;
    GrantStmt& operator=(GrantStmt&& other) noexcept;

    bool operator==(const GrantStmt& other) const noexcept;
    bool operator!=(const GrantStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const GrantStmt& other) const noexcept;
    bool operator<=(const GrantStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const GrantStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const GrantStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const GrantStmt& value);

    void swap(GrantStmt& other) noexcept;
    friend void swap(GrantStmt& value1, GrantStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::GrantStmt>
{
    typedef pg_query::GrantStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct GrantRoleStmt : FBE::Base
{
    std::vector<::pg_query::Node> granted_roles;
    std::vector<::pg_query::Node> grantee_roles;
    bool is_grant;
    bool admin_opt;
    ::pg_query::RoleSpec* grantor;
    ::pg_query::DropBehavior behavior;

    size_t fbe_type() const noexcept { return 71; }

    GrantRoleStmt();
    GrantRoleStmt(std::vector<::pg_query::Node> arg_granted_roles, std::vector<::pg_query::Node> arg_grantee_roles, bool arg_is_grant, bool arg_admin_opt, std::unique_ptr<::pg_query::RoleSpec> arg_grantor, ::pg_query::DropBehavior&& arg_behavior);
    GrantRoleStmt(const GrantRoleStmt& other) = delete;
    GrantRoleStmt(GrantRoleStmt&& other) noexcept;
    ~GrantRoleStmt() override;

    GrantRoleStmt& operator=(const GrantRoleStmt& other) = delete;
    GrantRoleStmt& operator=(GrantRoleStmt&& other) noexcept;

    bool operator==(const GrantRoleStmt& other) const noexcept;
    bool operator!=(const GrantRoleStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const GrantRoleStmt& other) const noexcept;
    bool operator<=(const GrantRoleStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const GrantRoleStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const GrantRoleStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const GrantRoleStmt& value);

    void swap(GrantRoleStmt& other) noexcept;
    friend void swap(GrantRoleStmt& value1, GrantRoleStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::GrantRoleStmt>
{
    typedef pg_query::GrantRoleStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct GrantStmt;

struct AlterDefaultPrivilegesStmt : FBE::Base
{
    std::vector<::pg_query::Node> options;
    ::pg_query::GrantStmt* action;

    size_t fbe_type() const noexcept { return 72; }

    AlterDefaultPrivilegesStmt();
    AlterDefaultPrivilegesStmt(std::vector<::pg_query::Node> arg_options, std::unique_ptr<::pg_query::GrantStmt> arg_action);
    AlterDefaultPrivilegesStmt(const AlterDefaultPrivilegesStmt& other) = delete;
    AlterDefaultPrivilegesStmt(AlterDefaultPrivilegesStmt&& other) noexcept;
    ~AlterDefaultPrivilegesStmt() override;

    AlterDefaultPrivilegesStmt& operator=(const AlterDefaultPrivilegesStmt& other) = delete;
    AlterDefaultPrivilegesStmt& operator=(AlterDefaultPrivilegesStmt&& other) noexcept;

    bool operator==(const AlterDefaultPrivilegesStmt& other) const noexcept;
    bool operator!=(const AlterDefaultPrivilegesStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterDefaultPrivilegesStmt& other) const noexcept;
    bool operator<=(const AlterDefaultPrivilegesStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterDefaultPrivilegesStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterDefaultPrivilegesStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterDefaultPrivilegesStmt& value);

    void swap(AlterDefaultPrivilegesStmt& other) noexcept;
    friend void swap(AlterDefaultPrivilegesStmt& value1, AlterDefaultPrivilegesStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterDefaultPrivilegesStmt>
{
    typedef pg_query::AlterDefaultPrivilegesStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ClosePortalStmt : FBE::Base
{
    std::string portalname;

    size_t fbe_type() const noexcept { return 73; }

    ClosePortalStmt();
    explicit ClosePortalStmt(const std::string& arg_portalname);
    ClosePortalStmt(const ClosePortalStmt& other) = delete;
    ClosePortalStmt(ClosePortalStmt&& other) noexcept;
    ~ClosePortalStmt() override;

    ClosePortalStmt& operator=(const ClosePortalStmt& other) = delete;
    ClosePortalStmt& operator=(ClosePortalStmt&& other) noexcept;

    bool operator==(const ClosePortalStmt& other) const noexcept;
    bool operator!=(const ClosePortalStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ClosePortalStmt& other) const noexcept;
    bool operator<=(const ClosePortalStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ClosePortalStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ClosePortalStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ClosePortalStmt& value);

    void swap(ClosePortalStmt& other) noexcept;
    friend void swap(ClosePortalStmt& value1, ClosePortalStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ClosePortalStmt>
{
    typedef pg_query::ClosePortalStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct ClusterStmt : FBE::Base
{
    ::pg_query::RangeVar* relation;
    std::string indexname;
    int32_t options;

    size_t fbe_type() const noexcept { return 74; }

    ClusterStmt();
    ClusterStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, const std::string& arg_indexname, int32_t arg_options);
    ClusterStmt(const ClusterStmt& other) = delete;
    ClusterStmt(ClusterStmt&& other) noexcept;
    ~ClusterStmt() override;

    ClusterStmt& operator=(const ClusterStmt& other) = delete;
    ClusterStmt& operator=(ClusterStmt&& other) noexcept;

    bool operator==(const ClusterStmt& other) const noexcept;
    bool operator!=(const ClusterStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ClusterStmt& other) const noexcept;
    bool operator<=(const ClusterStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ClusterStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ClusterStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ClusterStmt& value);

    void swap(ClusterStmt& other) noexcept;
    friend void swap(ClusterStmt& value1, ClusterStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ClusterStmt>
{
    typedef pg_query::ClusterStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct CopyStmt : FBE::Base
{
    ::pg_query::RangeVar* relation;
    ::pg_query::Node query;
    std::vector<::pg_query::Node> attlist;
    bool is_from;
    bool is_program;
    std::string filename;
    std::vector<::pg_query::Node> options;
    ::pg_query::Node where_clause;

    size_t fbe_type() const noexcept { return 75; }

    CopyStmt();
    CopyStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_query, std::vector<::pg_query::Node> arg_attlist, bool arg_is_from, bool arg_is_program, const std::string& arg_filename, std::vector<::pg_query::Node> arg_options, ::pg_query::Node&& arg_where_clause);
    CopyStmt(const CopyStmt& other) = delete;
    CopyStmt(CopyStmt&& other) noexcept;
    ~CopyStmt() override;

    CopyStmt& operator=(const CopyStmt& other) = delete;
    CopyStmt& operator=(CopyStmt&& other) noexcept;

    bool operator==(const CopyStmt& other) const noexcept;
    bool operator!=(const CopyStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CopyStmt& other) const noexcept;
    bool operator<=(const CopyStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CopyStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CopyStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CopyStmt& value);

    void swap(CopyStmt& other) noexcept;
    friend void swap(CopyStmt& value1, CopyStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CopyStmt>
{
    typedef pg_query::CopyStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct PartitionBoundSpec;

struct PartitionSpec;

struct TypeName;

struct CreateStmt : FBE::Base
{
    ::pg_query::RangeVar* relation;
    std::vector<::pg_query::Node> table_elts;
    std::vector<::pg_query::Node> inh_relations;
    ::pg_query::PartitionBoundSpec* partbound;
    ::pg_query::PartitionSpec* partspec;
    ::pg_query::TypeName* of_typename;
    std::vector<::pg_query::Node> constraints;
    std::vector<::pg_query::Node> options;
    ::pg_query::OnCommitAction oncommit;
    std::string tablespacename;
    std::string access_method;
    bool if_not_exists;

    size_t fbe_type() const noexcept { return 76; }

    CreateStmt();
    CreateStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_table_elts, std::vector<::pg_query::Node> arg_inh_relations, std::unique_ptr<::pg_query::PartitionBoundSpec> arg_partbound, std::unique_ptr<::pg_query::PartitionSpec> arg_partspec, std::unique_ptr<::pg_query::TypeName> arg_of_typename, std::vector<::pg_query::Node> arg_constraints, std::vector<::pg_query::Node> arg_options, ::pg_query::OnCommitAction&& arg_oncommit, const std::string& arg_tablespacename, const std::string& arg_access_method, bool arg_if_not_exists);
    CreateStmt(const CreateStmt& other) = delete;
    CreateStmt(CreateStmt&& other) noexcept;
    ~CreateStmt() override;

    CreateStmt& operator=(const CreateStmt& other) = delete;
    CreateStmt& operator=(CreateStmt&& other) noexcept;

    bool operator==(const CreateStmt& other) const noexcept;
    bool operator!=(const CreateStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateStmt& other) const noexcept;
    bool operator<=(const CreateStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateStmt& value);

    void swap(CreateStmt& other) noexcept;
    friend void swap(CreateStmt& value1, CreateStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateStmt>
{
    typedef pg_query::CreateStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DefineStmt : FBE::Base
{
    ::pg_query::ObjectType kind;
    bool oldstyle;
    std::vector<::pg_query::Node> defnames;
    std::vector<::pg_query::Node> args;
    std::vector<::pg_query::Node> definition;
    bool if_not_exists;
    bool replace;

    size_t fbe_type() const noexcept { return 77; }

    DefineStmt();
    DefineStmt(::pg_query::ObjectType&& arg_kind, bool arg_oldstyle, std::vector<::pg_query::Node> arg_defnames, std::vector<::pg_query::Node> arg_args, std::vector<::pg_query::Node> arg_definition, bool arg_if_not_exists, bool arg_replace);
    DefineStmt(const DefineStmt& other) = delete;
    DefineStmt(DefineStmt&& other) noexcept;
    ~DefineStmt() override;

    DefineStmt& operator=(const DefineStmt& other) = delete;
    DefineStmt& operator=(DefineStmt&& other) noexcept;

    bool operator==(const DefineStmt& other) const noexcept;
    bool operator!=(const DefineStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DefineStmt& other) const noexcept;
    bool operator<=(const DefineStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DefineStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DefineStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DefineStmt& value);

    void swap(DefineStmt& other) noexcept;
    friend void swap(DefineStmt& value1, DefineStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DefineStmt>
{
    typedef pg_query::DefineStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DropStmt : FBE::Base
{
    std::vector<::pg_query::Node> objects;
    ::pg_query::ObjectType remove_type;
    ::pg_query::DropBehavior behavior;
    bool missing_ok;
    bool concurrent;

    size_t fbe_type() const noexcept { return 78; }

    DropStmt();
    DropStmt(std::vector<::pg_query::Node> arg_objects, ::pg_query::ObjectType&& arg_remove_type, ::pg_query::DropBehavior&& arg_behavior, bool arg_missing_ok, bool arg_concurrent);
    DropStmt(const DropStmt& other) = delete;
    DropStmt(DropStmt&& other) noexcept;
    ~DropStmt() override;

    DropStmt& operator=(const DropStmt& other) = delete;
    DropStmt& operator=(DropStmt&& other) noexcept;

    bool operator==(const DropStmt& other) const noexcept;
    bool operator!=(const DropStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DropStmt& other) const noexcept;
    bool operator<=(const DropStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DropStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DropStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DropStmt& value);

    void swap(DropStmt& other) noexcept;
    friend void swap(DropStmt& value1, DropStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DropStmt>
{
    typedef pg_query::DropStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TruncateStmt : FBE::Base
{
    std::vector<::pg_query::Node> relations;
    bool restart_seqs;
    ::pg_query::DropBehavior behavior;

    size_t fbe_type() const noexcept { return 79; }

    TruncateStmt();
    TruncateStmt(std::vector<::pg_query::Node> arg_relations, bool arg_restart_seqs, ::pg_query::DropBehavior&& arg_behavior);
    TruncateStmt(const TruncateStmt& other) = delete;
    TruncateStmt(TruncateStmt&& other) noexcept;
    ~TruncateStmt() override;

    TruncateStmt& operator=(const TruncateStmt& other) = delete;
    TruncateStmt& operator=(TruncateStmt&& other) noexcept;

    bool operator==(const TruncateStmt& other) const noexcept;
    bool operator!=(const TruncateStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const TruncateStmt& other) const noexcept;
    bool operator<=(const TruncateStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const TruncateStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const TruncateStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const TruncateStmt& value);

    void swap(TruncateStmt& other) noexcept;
    friend void swap(TruncateStmt& value1, TruncateStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::TruncateStmt>
{
    typedef pg_query::TruncateStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CommentStmt : FBE::Base
{
    ::pg_query::ObjectType objtype;
    ::pg_query::Node object;
    std::string comment;

    size_t fbe_type() const noexcept { return 80; }

    CommentStmt();
    CommentStmt(::pg_query::ObjectType&& arg_objtype, ::pg_query::Node&& arg_object, const std::string& arg_comment);
    CommentStmt(const CommentStmt& other) = delete;
    CommentStmt(CommentStmt&& other) noexcept;
    ~CommentStmt() override;

    CommentStmt& operator=(const CommentStmt& other) = delete;
    CommentStmt& operator=(CommentStmt&& other) noexcept;

    bool operator==(const CommentStmt& other) const noexcept;
    bool operator!=(const CommentStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CommentStmt& other) const noexcept;
    bool operator<=(const CommentStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CommentStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CommentStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CommentStmt& value);

    void swap(CommentStmt& other) noexcept;
    friend void swap(CommentStmt& value1, CommentStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CommentStmt>
{
    typedef pg_query::CommentStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct FetchStmt : FBE::Base
{
    ::pg_query::FetchDirection direction;
    int64_t how_many;
    std::string portalname;
    bool ismove;

    size_t fbe_type() const noexcept { return 81; }

    FetchStmt();
    FetchStmt(::pg_query::FetchDirection&& arg_direction, int64_t arg_how_many, const std::string& arg_portalname, bool arg_ismove);
    FetchStmt(const FetchStmt& other) = delete;
    FetchStmt(FetchStmt&& other) noexcept;
    ~FetchStmt() override;

    FetchStmt& operator=(const FetchStmt& other) = delete;
    FetchStmt& operator=(FetchStmt&& other) noexcept;

    bool operator==(const FetchStmt& other) const noexcept;
    bool operator!=(const FetchStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const FetchStmt& other) const noexcept;
    bool operator<=(const FetchStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const FetchStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const FetchStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const FetchStmt& value);

    void swap(FetchStmt& other) noexcept;
    friend void swap(FetchStmt& value1, FetchStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::FetchStmt>
{
    typedef pg_query::FetchStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct IndexStmt : FBE::Base
{
    std::string idxname;
    ::pg_query::RangeVar* relation;
    std::string access_method;
    std::string table_space;
    std::vector<::pg_query::Node> index_params;
    std::vector<::pg_query::Node> index_including_params;
    std::vector<::pg_query::Node> options;
    ::pg_query::Node where_clause;
    std::vector<::pg_query::Node> exclude_op_names;
    std::string idxcomment;
    uint32_t index_oid;
    uint32_t old_node;
    uint32_t old_create_subid;
    uint32_t old_first_relfilenode_subid;
    bool unique;
    bool primary;
    bool isconstraint;
    bool deferrable;
    bool initdeferred;
    bool transformed;
    bool concurrent;
    bool if_not_exists;
    bool reset_default_tblspc;

    size_t fbe_type() const noexcept { return 82; }

    IndexStmt();
    IndexStmt(const std::string& arg_idxname, std::unique_ptr<::pg_query::RangeVar> arg_relation, const std::string& arg_access_method, const std::string& arg_table_space, std::vector<::pg_query::Node> arg_index_params, std::vector<::pg_query::Node> arg_index_including_params, std::vector<::pg_query::Node> arg_options, ::pg_query::Node&& arg_where_clause, std::vector<::pg_query::Node> arg_exclude_op_names, const std::string& arg_idxcomment, uint32_t arg_index_oid, uint32_t arg_old_node, uint32_t arg_old_create_subid, uint32_t arg_old_first_relfilenode_subid, bool arg_unique, bool arg_primary, bool arg_isconstraint, bool arg_deferrable, bool arg_initdeferred, bool arg_transformed, bool arg_concurrent, bool arg_if_not_exists, bool arg_reset_default_tblspc);
    IndexStmt(const IndexStmt& other) = delete;
    IndexStmt(IndexStmt&& other) noexcept;
    ~IndexStmt() override;

    IndexStmt& operator=(const IndexStmt& other) = delete;
    IndexStmt& operator=(IndexStmt&& other) noexcept;

    bool operator==(const IndexStmt& other) const noexcept;
    bool operator!=(const IndexStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const IndexStmt& other) const noexcept;
    bool operator<=(const IndexStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const IndexStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const IndexStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const IndexStmt& value);

    void swap(IndexStmt& other) noexcept;
    friend void swap(IndexStmt& value1, IndexStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::IndexStmt>
{
    typedef pg_query::IndexStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct CreateFunctionStmt : FBE::Base
{
    bool is_procedure;
    bool replace;
    std::vector<::pg_query::Node> funcname;
    std::vector<::pg_query::Node> parameters;
    ::pg_query::TypeName* return_type;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 83; }

    CreateFunctionStmt();
    CreateFunctionStmt(bool arg_is_procedure, bool arg_replace, std::vector<::pg_query::Node> arg_funcname, std::vector<::pg_query::Node> arg_parameters, std::unique_ptr<::pg_query::TypeName> arg_return_type, std::vector<::pg_query::Node> arg_options);
    CreateFunctionStmt(const CreateFunctionStmt& other) = delete;
    CreateFunctionStmt(CreateFunctionStmt&& other) noexcept;
    ~CreateFunctionStmt() override;

    CreateFunctionStmt& operator=(const CreateFunctionStmt& other) = delete;
    CreateFunctionStmt& operator=(CreateFunctionStmt&& other) noexcept;

    bool operator==(const CreateFunctionStmt& other) const noexcept;
    bool operator!=(const CreateFunctionStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateFunctionStmt& other) const noexcept;
    bool operator<=(const CreateFunctionStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateFunctionStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateFunctionStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateFunctionStmt& value);

    void swap(CreateFunctionStmt& other) noexcept;
    friend void swap(CreateFunctionStmt& value1, CreateFunctionStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateFunctionStmt>
{
    typedef pg_query::CreateFunctionStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ObjectWithArgs;

struct AlterFunctionStmt : FBE::Base
{
    ::pg_query::ObjectType objtype;
    ::pg_query::ObjectWithArgs* func;
    std::vector<::pg_query::Node> actions;

    size_t fbe_type() const noexcept { return 84; }

    AlterFunctionStmt();
    AlterFunctionStmt(::pg_query::ObjectType&& arg_objtype, std::unique_ptr<::pg_query::ObjectWithArgs> arg_func, std::vector<::pg_query::Node> arg_actions);
    AlterFunctionStmt(const AlterFunctionStmt& other) = delete;
    AlterFunctionStmt(AlterFunctionStmt&& other) noexcept;
    ~AlterFunctionStmt() override;

    AlterFunctionStmt& operator=(const AlterFunctionStmt& other) = delete;
    AlterFunctionStmt& operator=(AlterFunctionStmt&& other) noexcept;

    bool operator==(const AlterFunctionStmt& other) const noexcept;
    bool operator!=(const AlterFunctionStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterFunctionStmt& other) const noexcept;
    bool operator<=(const AlterFunctionStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterFunctionStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterFunctionStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterFunctionStmt& value);

    void swap(AlterFunctionStmt& other) noexcept;
    friend void swap(AlterFunctionStmt& value1, AlterFunctionStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterFunctionStmt>
{
    typedef pg_query::AlterFunctionStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DoStmt : FBE::Base
{
    std::vector<::pg_query::Node> args;

    size_t fbe_type() const noexcept { return 85; }

    DoStmt();
    explicit DoStmt(std::vector<::pg_query::Node> arg_args);
    DoStmt(const DoStmt& other) = delete;
    DoStmt(DoStmt&& other) noexcept;
    ~DoStmt() override;

    DoStmt& operator=(const DoStmt& other) = delete;
    DoStmt& operator=(DoStmt&& other) noexcept;

    bool operator==(const DoStmt& other) const noexcept;
    bool operator!=(const DoStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DoStmt& other) const noexcept;
    bool operator<=(const DoStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DoStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DoStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DoStmt& value);

    void swap(DoStmt& other) noexcept;
    friend void swap(DoStmt& value1, DoStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DoStmt>
{
    typedef pg_query::DoStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct RenameStmt : FBE::Base
{
    ::pg_query::ObjectType rename_type;
    ::pg_query::ObjectType relation_type;
    ::pg_query::RangeVar* relation;
    ::pg_query::Node object;
    std::string subname;
    std::string newname;
    ::pg_query::DropBehavior behavior;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 86; }

    RenameStmt();
    RenameStmt(::pg_query::ObjectType&& arg_rename_type, ::pg_query::ObjectType&& arg_relation_type, std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_object, const std::string& arg_subname, const std::string& arg_newname, ::pg_query::DropBehavior&& arg_behavior, bool arg_missing_ok);
    RenameStmt(const RenameStmt& other) = delete;
    RenameStmt(RenameStmt&& other) noexcept;
    ~RenameStmt() override;

    RenameStmt& operator=(const RenameStmt& other) = delete;
    RenameStmt& operator=(RenameStmt&& other) noexcept;

    bool operator==(const RenameStmt& other) const noexcept;
    bool operator!=(const RenameStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const RenameStmt& other) const noexcept;
    bool operator<=(const RenameStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RenameStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RenameStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RenameStmt& value);

    void swap(RenameStmt& other) noexcept;
    friend void swap(RenameStmt& value1, RenameStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RenameStmt>
{
    typedef pg_query::RenameStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct RuleStmt : FBE::Base
{
    ::pg_query::RangeVar* relation;
    std::string rulename;
    ::pg_query::Node where_clause;
    ::pg_query::CmdType event;
    bool instead;
    std::vector<::pg_query::Node> actions;
    bool replace;

    size_t fbe_type() const noexcept { return 87; }

    RuleStmt();
    RuleStmt(std::unique_ptr<::pg_query::RangeVar> arg_relation, const std::string& arg_rulename, ::pg_query::Node&& arg_where_clause, ::pg_query::CmdType&& arg_event, bool arg_instead, std::vector<::pg_query::Node> arg_actions, bool arg_replace);
    RuleStmt(const RuleStmt& other) = delete;
    RuleStmt(RuleStmt&& other) noexcept;
    ~RuleStmt() override;

    RuleStmt& operator=(const RuleStmt& other) = delete;
    RuleStmt& operator=(RuleStmt&& other) noexcept;

    bool operator==(const RuleStmt& other) const noexcept;
    bool operator!=(const RuleStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const RuleStmt& other) const noexcept;
    bool operator<=(const RuleStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RuleStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RuleStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RuleStmt& value);

    void swap(RuleStmt& other) noexcept;
    friend void swap(RuleStmt& value1, RuleStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RuleStmt>
{
    typedef pg_query::RuleStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct NotifyStmt : FBE::Base
{
    std::string conditionname;
    std::string payload;

    size_t fbe_type() const noexcept { return 88; }

    NotifyStmt();
    NotifyStmt(const std::string& arg_conditionname, const std::string& arg_payload);
    NotifyStmt(const NotifyStmt& other) = delete;
    NotifyStmt(NotifyStmt&& other) noexcept;
    ~NotifyStmt() override;

    NotifyStmt& operator=(const NotifyStmt& other) = delete;
    NotifyStmt& operator=(NotifyStmt&& other) noexcept;

    bool operator==(const NotifyStmt& other) const noexcept;
    bool operator!=(const NotifyStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const NotifyStmt& other) const noexcept;
    bool operator<=(const NotifyStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const NotifyStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const NotifyStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const NotifyStmt& value);

    void swap(NotifyStmt& other) noexcept;
    friend void swap(NotifyStmt& value1, NotifyStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::NotifyStmt>
{
    typedef pg_query::NotifyStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ListenStmt : FBE::Base
{
    std::string conditionname;

    size_t fbe_type() const noexcept { return 89; }

    ListenStmt();
    explicit ListenStmt(const std::string& arg_conditionname);
    ListenStmt(const ListenStmt& other) = delete;
    ListenStmt(ListenStmt&& other) noexcept;
    ~ListenStmt() override;

    ListenStmt& operator=(const ListenStmt& other) = delete;
    ListenStmt& operator=(ListenStmt&& other) noexcept;

    bool operator==(const ListenStmt& other) const noexcept;
    bool operator!=(const ListenStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ListenStmt& other) const noexcept;
    bool operator<=(const ListenStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ListenStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ListenStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ListenStmt& value);

    void swap(ListenStmt& other) noexcept;
    friend void swap(ListenStmt& value1, ListenStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ListenStmt>
{
    typedef pg_query::ListenStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct UnlistenStmt : FBE::Base
{
    std::string conditionname;

    size_t fbe_type() const noexcept { return 90; }

    UnlistenStmt();
    explicit UnlistenStmt(const std::string& arg_conditionname);
    UnlistenStmt(const UnlistenStmt& other) = delete;
    UnlistenStmt(UnlistenStmt&& other) noexcept;
    ~UnlistenStmt() override;

    UnlistenStmt& operator=(const UnlistenStmt& other) = delete;
    UnlistenStmt& operator=(UnlistenStmt&& other) noexcept;

    bool operator==(const UnlistenStmt& other) const noexcept;
    bool operator!=(const UnlistenStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const UnlistenStmt& other) const noexcept;
    bool operator<=(const UnlistenStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const UnlistenStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const UnlistenStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const UnlistenStmt& value);

    void swap(UnlistenStmt& other) noexcept;
    friend void swap(UnlistenStmt& value1, UnlistenStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::UnlistenStmt>
{
    typedef pg_query::UnlistenStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TransactionStmt : FBE::Base
{
    ::pg_query::TransactionStmtKind kind;
    std::vector<::pg_query::Node> options;
    std::string savepoint_name;
    std::string gid;
    bool chain;

    size_t fbe_type() const noexcept { return 91; }

    TransactionStmt();
    TransactionStmt(::pg_query::TransactionStmtKind&& arg_kind, std::vector<::pg_query::Node> arg_options, const std::string& arg_savepoint_name, const std::string& arg_gid, bool arg_chain);
    TransactionStmt(const TransactionStmt& other) = delete;
    TransactionStmt(TransactionStmt&& other) noexcept;
    ~TransactionStmt() override;

    TransactionStmt& operator=(const TransactionStmt& other) = delete;
    TransactionStmt& operator=(TransactionStmt&& other) noexcept;

    bool operator==(const TransactionStmt& other) const noexcept;
    bool operator!=(const TransactionStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const TransactionStmt& other) const noexcept;
    bool operator<=(const TransactionStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const TransactionStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const TransactionStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const TransactionStmt& value);

    void swap(TransactionStmt& other) noexcept;
    friend void swap(TransactionStmt& value1, TransactionStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::TransactionStmt>
{
    typedef pg_query::TransactionStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct ViewStmt : FBE::Base
{
    ::pg_query::RangeVar* view;
    std::vector<::pg_query::Node> aliases;
    ::pg_query::Node query;
    bool replace;
    std::vector<::pg_query::Node> options;
    ::pg_query::ViewCheckOption with_check_option;

    size_t fbe_type() const noexcept { return 92; }

    ViewStmt();
    ViewStmt(std::unique_ptr<::pg_query::RangeVar> arg_view, std::vector<::pg_query::Node> arg_aliases, ::pg_query::Node&& arg_query, bool arg_replace, std::vector<::pg_query::Node> arg_options, ::pg_query::ViewCheckOption&& arg_with_check_option);
    ViewStmt(const ViewStmt& other) = delete;
    ViewStmt(ViewStmt&& other) noexcept;
    ~ViewStmt() override;

    ViewStmt& operator=(const ViewStmt& other) = delete;
    ViewStmt& operator=(ViewStmt&& other) noexcept;

    bool operator==(const ViewStmt& other) const noexcept;
    bool operator!=(const ViewStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ViewStmt& other) const noexcept;
    bool operator<=(const ViewStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ViewStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ViewStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ViewStmt& value);

    void swap(ViewStmt& other) noexcept;
    friend void swap(ViewStmt& value1, ViewStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ViewStmt>
{
    typedef pg_query::ViewStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct LoadStmt : FBE::Base
{
    std::string filename;

    size_t fbe_type() const noexcept { return 93; }

    LoadStmt();
    explicit LoadStmt(const std::string& arg_filename);
    LoadStmt(const LoadStmt& other) = delete;
    LoadStmt(LoadStmt&& other) noexcept;
    ~LoadStmt() override;

    LoadStmt& operator=(const LoadStmt& other) = delete;
    LoadStmt& operator=(LoadStmt&& other) noexcept;

    bool operator==(const LoadStmt& other) const noexcept;
    bool operator!=(const LoadStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const LoadStmt& other) const noexcept;
    bool operator<=(const LoadStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const LoadStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const LoadStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const LoadStmt& value);

    void swap(LoadStmt& other) noexcept;
    friend void swap(LoadStmt& value1, LoadStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::LoadStmt>
{
    typedef pg_query::LoadStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct CollateClause;

struct CreateDomainStmt : FBE::Base
{
    std::vector<::pg_query::Node> domainname;
    ::pg_query::TypeName* type_name;
    ::pg_query::CollateClause* coll_clause;
    std::vector<::pg_query::Node> constraints;

    size_t fbe_type() const noexcept { return 94; }

    CreateDomainStmt();
    CreateDomainStmt(std::vector<::pg_query::Node> arg_domainname, std::unique_ptr<::pg_query::TypeName> arg_type_name, std::unique_ptr<::pg_query::CollateClause> arg_coll_clause, std::vector<::pg_query::Node> arg_constraints);
    CreateDomainStmt(const CreateDomainStmt& other) = delete;
    CreateDomainStmt(CreateDomainStmt&& other) noexcept;
    ~CreateDomainStmt() override;

    CreateDomainStmt& operator=(const CreateDomainStmt& other) = delete;
    CreateDomainStmt& operator=(CreateDomainStmt&& other) noexcept;

    bool operator==(const CreateDomainStmt& other) const noexcept;
    bool operator!=(const CreateDomainStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateDomainStmt& other) const noexcept;
    bool operator<=(const CreateDomainStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateDomainStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateDomainStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateDomainStmt& value);

    void swap(CreateDomainStmt& other) noexcept;
    friend void swap(CreateDomainStmt& value1, CreateDomainStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateDomainStmt>
{
    typedef pg_query::CreateDomainStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreatedbStmt : FBE::Base
{
    std::string dbname;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 95; }

    CreatedbStmt();
    CreatedbStmt(const std::string& arg_dbname, std::vector<::pg_query::Node> arg_options);
    CreatedbStmt(const CreatedbStmt& other) = delete;
    CreatedbStmt(CreatedbStmt&& other) noexcept;
    ~CreatedbStmt() override;

    CreatedbStmt& operator=(const CreatedbStmt& other) = delete;
    CreatedbStmt& operator=(CreatedbStmt&& other) noexcept;

    bool operator==(const CreatedbStmt& other) const noexcept;
    bool operator!=(const CreatedbStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreatedbStmt& other) const noexcept;
    bool operator<=(const CreatedbStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreatedbStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreatedbStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreatedbStmt& value);

    void swap(CreatedbStmt& other) noexcept;
    friend void swap(CreatedbStmt& value1, CreatedbStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreatedbStmt>
{
    typedef pg_query::CreatedbStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DropdbStmt : FBE::Base
{
    std::string dbname;
    bool missing_ok;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 96; }

    DropdbStmt();
    DropdbStmt(const std::string& arg_dbname, bool arg_missing_ok, std::vector<::pg_query::Node> arg_options);
    DropdbStmt(const DropdbStmt& other) = delete;
    DropdbStmt(DropdbStmt&& other) noexcept;
    ~DropdbStmt() override;

    DropdbStmt& operator=(const DropdbStmt& other) = delete;
    DropdbStmt& operator=(DropdbStmt&& other) noexcept;

    bool operator==(const DropdbStmt& other) const noexcept;
    bool operator!=(const DropdbStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DropdbStmt& other) const noexcept;
    bool operator<=(const DropdbStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DropdbStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DropdbStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DropdbStmt& value);

    void swap(DropdbStmt& other) noexcept;
    friend void swap(DropdbStmt& value1, DropdbStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DropdbStmt>
{
    typedef pg_query::DropdbStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct VacuumStmt : FBE::Base
{
    std::vector<::pg_query::Node> options;
    std::vector<::pg_query::Node> rels;
    bool is_vacuumcmd;

    size_t fbe_type() const noexcept { return 97; }

    VacuumStmt();
    VacuumStmt(std::vector<::pg_query::Node> arg_options, std::vector<::pg_query::Node> arg_rels, bool arg_is_vacuumcmd);
    VacuumStmt(const VacuumStmt& other) = delete;
    VacuumStmt(VacuumStmt&& other) noexcept;
    ~VacuumStmt() override;

    VacuumStmt& operator=(const VacuumStmt& other) = delete;
    VacuumStmt& operator=(VacuumStmt&& other) noexcept;

    bool operator==(const VacuumStmt& other) const noexcept;
    bool operator!=(const VacuumStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const VacuumStmt& other) const noexcept;
    bool operator<=(const VacuumStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const VacuumStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const VacuumStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const VacuumStmt& value);

    void swap(VacuumStmt& other) noexcept;
    friend void swap(VacuumStmt& value1, VacuumStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::VacuumStmt>
{
    typedef pg_query::VacuumStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ExplainStmt : FBE::Base
{
    ::pg_query::Node query;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 98; }

    ExplainStmt();
    ExplainStmt(::pg_query::Node&& arg_query, std::vector<::pg_query::Node> arg_options);
    ExplainStmt(const ExplainStmt& other) = delete;
    ExplainStmt(ExplainStmt&& other) noexcept;
    ~ExplainStmt() override;

    ExplainStmt& operator=(const ExplainStmt& other) = delete;
    ExplainStmt& operator=(ExplainStmt&& other) noexcept;

    bool operator==(const ExplainStmt& other) const noexcept;
    bool operator!=(const ExplainStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ExplainStmt& other) const noexcept;
    bool operator<=(const ExplainStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ExplainStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ExplainStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ExplainStmt& value);

    void swap(ExplainStmt& other) noexcept;
    friend void swap(ExplainStmt& value1, ExplainStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ExplainStmt>
{
    typedef pg_query::ExplainStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct IntoClause;

struct CreateTableAsStmt : FBE::Base
{
    ::pg_query::Node query;
    ::pg_query::IntoClause* into;
    ::pg_query::ObjectType relkind;
    bool is_select_into;
    bool if_not_exists;

    size_t fbe_type() const noexcept { return 99; }

    CreateTableAsStmt();
    CreateTableAsStmt(::pg_query::Node&& arg_query, std::unique_ptr<::pg_query::IntoClause> arg_into, ::pg_query::ObjectType&& arg_relkind, bool arg_is_select_into, bool arg_if_not_exists);
    CreateTableAsStmt(const CreateTableAsStmt& other) = delete;
    CreateTableAsStmt(CreateTableAsStmt&& other) noexcept;
    ~CreateTableAsStmt() override;

    CreateTableAsStmt& operator=(const CreateTableAsStmt& other) = delete;
    CreateTableAsStmt& operator=(CreateTableAsStmt&& other) noexcept;

    bool operator==(const CreateTableAsStmt& other) const noexcept;
    bool operator!=(const CreateTableAsStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateTableAsStmt& other) const noexcept;
    bool operator<=(const CreateTableAsStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateTableAsStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateTableAsStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateTableAsStmt& value);

    void swap(CreateTableAsStmt& other) noexcept;
    friend void swap(CreateTableAsStmt& value1, CreateTableAsStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateTableAsStmt>
{
    typedef pg_query::CreateTableAsStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct CreateSeqStmt : FBE::Base
{
    ::pg_query::RangeVar* sequence;
    std::vector<::pg_query::Node> options;
    uint32_t owner_id;
    bool for_identity;
    bool if_not_exists;

    size_t fbe_type() const noexcept { return 100; }

    CreateSeqStmt();
    CreateSeqStmt(std::unique_ptr<::pg_query::RangeVar> arg_sequence, std::vector<::pg_query::Node> arg_options, uint32_t arg_owner_id, bool arg_for_identity, bool arg_if_not_exists);
    CreateSeqStmt(const CreateSeqStmt& other) = delete;
    CreateSeqStmt(CreateSeqStmt&& other) noexcept;
    ~CreateSeqStmt() override;

    CreateSeqStmt& operator=(const CreateSeqStmt& other) = delete;
    CreateSeqStmt& operator=(CreateSeqStmt&& other) noexcept;

    bool operator==(const CreateSeqStmt& other) const noexcept;
    bool operator!=(const CreateSeqStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateSeqStmt& other) const noexcept;
    bool operator<=(const CreateSeqStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateSeqStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateSeqStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateSeqStmt& value);

    void swap(CreateSeqStmt& other) noexcept;
    friend void swap(CreateSeqStmt& value1, CreateSeqStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateSeqStmt>
{
    typedef pg_query::CreateSeqStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct AlterSeqStmt : FBE::Base
{
    ::pg_query::RangeVar* sequence;
    std::vector<::pg_query::Node> options;
    bool for_identity;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 101; }

    AlterSeqStmt();
    AlterSeqStmt(std::unique_ptr<::pg_query::RangeVar> arg_sequence, std::vector<::pg_query::Node> arg_options, bool arg_for_identity, bool arg_missing_ok);
    AlterSeqStmt(const AlterSeqStmt& other) = delete;
    AlterSeqStmt(AlterSeqStmt&& other) noexcept;
    ~AlterSeqStmt() override;

    AlterSeqStmt& operator=(const AlterSeqStmt& other) = delete;
    AlterSeqStmt& operator=(AlterSeqStmt&& other) noexcept;

    bool operator==(const AlterSeqStmt& other) const noexcept;
    bool operator!=(const AlterSeqStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterSeqStmt& other) const noexcept;
    bool operator<=(const AlterSeqStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterSeqStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterSeqStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterSeqStmt& value);

    void swap(AlterSeqStmt& other) noexcept;
    friend void swap(AlterSeqStmt& value1, AlterSeqStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterSeqStmt>
{
    typedef pg_query::AlterSeqStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct VariableSetStmt : FBE::Base
{
    ::pg_query::VariableSetKind kind;
    std::string name;
    std::vector<::pg_query::Node> args;
    bool is_local;

    size_t fbe_type() const noexcept { return 102; }

    VariableSetStmt();
    VariableSetStmt(::pg_query::VariableSetKind&& arg_kind, const std::string& arg_name, std::vector<::pg_query::Node> arg_args, bool arg_is_local);
    VariableSetStmt(const VariableSetStmt& other) = delete;
    VariableSetStmt(VariableSetStmt&& other) noexcept;
    ~VariableSetStmt() override;

    VariableSetStmt& operator=(const VariableSetStmt& other) = delete;
    VariableSetStmt& operator=(VariableSetStmt&& other) noexcept;

    bool operator==(const VariableSetStmt& other) const noexcept;
    bool operator!=(const VariableSetStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const VariableSetStmt& other) const noexcept;
    bool operator<=(const VariableSetStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const VariableSetStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const VariableSetStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const VariableSetStmt& value);

    void swap(VariableSetStmt& other) noexcept;
    friend void swap(VariableSetStmt& value1, VariableSetStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::VariableSetStmt>
{
    typedef pg_query::VariableSetStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct VariableShowStmt : FBE::Base
{
    std::string name;

    size_t fbe_type() const noexcept { return 103; }

    VariableShowStmt();
    explicit VariableShowStmt(const std::string& arg_name);
    VariableShowStmt(const VariableShowStmt& other) = delete;
    VariableShowStmt(VariableShowStmt&& other) noexcept;
    ~VariableShowStmt() override;

    VariableShowStmt& operator=(const VariableShowStmt& other) = delete;
    VariableShowStmt& operator=(VariableShowStmt&& other) noexcept;

    bool operator==(const VariableShowStmt& other) const noexcept;
    bool operator!=(const VariableShowStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const VariableShowStmt& other) const noexcept;
    bool operator<=(const VariableShowStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const VariableShowStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const VariableShowStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const VariableShowStmt& value);

    void swap(VariableShowStmt& other) noexcept;
    friend void swap(VariableShowStmt& value1, VariableShowStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::VariableShowStmt>
{
    typedef pg_query::VariableShowStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DiscardStmt : FBE::Base
{
    ::pg_query::DiscardMode target;

    size_t fbe_type() const noexcept { return 104; }

    DiscardStmt();
    explicit DiscardStmt(::pg_query::DiscardMode&& arg_target);
    DiscardStmt(const DiscardStmt& other) = delete;
    DiscardStmt(DiscardStmt&& other) noexcept;
    ~DiscardStmt() override;

    DiscardStmt& operator=(const DiscardStmt& other) = delete;
    DiscardStmt& operator=(DiscardStmt&& other) noexcept;

    bool operator==(const DiscardStmt& other) const noexcept;
    bool operator!=(const DiscardStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DiscardStmt& other) const noexcept;
    bool operator<=(const DiscardStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DiscardStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DiscardStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DiscardStmt& value);

    void swap(DiscardStmt& other) noexcept;
    friend void swap(DiscardStmt& value1, DiscardStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DiscardStmt>
{
    typedef pg_query::DiscardStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct CreateTrigStmt : FBE::Base
{
    std::string trigname;
    ::pg_query::RangeVar* relation;
    std::vector<::pg_query::Node> funcname;
    std::vector<::pg_query::Node> args;
    bool row;
    int32_t timing;
    int32_t events;
    std::vector<::pg_query::Node> columns;
    ::pg_query::Node when_clause;
    bool isconstraint;
    std::vector<::pg_query::Node> transition_rels;
    bool deferrable;
    bool initdeferred;
    ::pg_query::RangeVar* constrrel;

    size_t fbe_type() const noexcept { return 105; }

    CreateTrigStmt();
    CreateTrigStmt(const std::string& arg_trigname, std::unique_ptr<::pg_query::RangeVar> arg_relation, std::vector<::pg_query::Node> arg_funcname, std::vector<::pg_query::Node> arg_args, bool arg_row, int32_t arg_timing, int32_t arg_events, std::vector<::pg_query::Node> arg_columns, ::pg_query::Node&& arg_when_clause, bool arg_isconstraint, std::vector<::pg_query::Node> arg_transition_rels, bool arg_deferrable, bool arg_initdeferred, std::unique_ptr<::pg_query::RangeVar> arg_constrrel);
    CreateTrigStmt(const CreateTrigStmt& other) = delete;
    CreateTrigStmt(CreateTrigStmt&& other) noexcept;
    ~CreateTrigStmt() override;

    CreateTrigStmt& operator=(const CreateTrigStmt& other) = delete;
    CreateTrigStmt& operator=(CreateTrigStmt&& other) noexcept;

    bool operator==(const CreateTrigStmt& other) const noexcept;
    bool operator!=(const CreateTrigStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateTrigStmt& other) const noexcept;
    bool operator<=(const CreateTrigStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateTrigStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateTrigStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateTrigStmt& value);

    void swap(CreateTrigStmt& other) noexcept;
    friend void swap(CreateTrigStmt& value1, CreateTrigStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateTrigStmt>
{
    typedef pg_query::CreateTrigStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreatePLangStmt : FBE::Base
{
    bool replace;
    std::string plname;
    std::vector<::pg_query::Node> plhandler;
    std::vector<::pg_query::Node> plinline;
    std::vector<::pg_query::Node> plvalidator;
    bool pltrusted;

    size_t fbe_type() const noexcept { return 106; }

    CreatePLangStmt();
    CreatePLangStmt(bool arg_replace, const std::string& arg_plname, std::vector<::pg_query::Node> arg_plhandler, std::vector<::pg_query::Node> arg_plinline, std::vector<::pg_query::Node> arg_plvalidator, bool arg_pltrusted);
    CreatePLangStmt(const CreatePLangStmt& other) = delete;
    CreatePLangStmt(CreatePLangStmt&& other) noexcept;
    ~CreatePLangStmt() override;

    CreatePLangStmt& operator=(const CreatePLangStmt& other) = delete;
    CreatePLangStmt& operator=(CreatePLangStmt&& other) noexcept;

    bool operator==(const CreatePLangStmt& other) const noexcept;
    bool operator!=(const CreatePLangStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreatePLangStmt& other) const noexcept;
    bool operator<=(const CreatePLangStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreatePLangStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreatePLangStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreatePLangStmt& value);

    void swap(CreatePLangStmt& other) noexcept;
    friend void swap(CreatePLangStmt& value1, CreatePLangStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreatePLangStmt>
{
    typedef pg_query::CreatePLangStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateRoleStmt : FBE::Base
{
    ::pg_query::RoleStmtType stmt_type;
    std::string role;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 107; }

    CreateRoleStmt();
    CreateRoleStmt(::pg_query::RoleStmtType&& arg_stmt_type, const std::string& arg_role, std::vector<::pg_query::Node> arg_options);
    CreateRoleStmt(const CreateRoleStmt& other) = delete;
    CreateRoleStmt(CreateRoleStmt&& other) noexcept;
    ~CreateRoleStmt() override;

    CreateRoleStmt& operator=(const CreateRoleStmt& other) = delete;
    CreateRoleStmt& operator=(CreateRoleStmt&& other) noexcept;

    bool operator==(const CreateRoleStmt& other) const noexcept;
    bool operator!=(const CreateRoleStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateRoleStmt& other) const noexcept;
    bool operator<=(const CreateRoleStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateRoleStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateRoleStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateRoleStmt& value);

    void swap(CreateRoleStmt& other) noexcept;
    friend void swap(CreateRoleStmt& value1, CreateRoleStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateRoleStmt>
{
    typedef pg_query::CreateRoleStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct AlterRoleStmt : FBE::Base
{
    ::pg_query::RoleSpec* role;
    std::vector<::pg_query::Node> options;
    int32_t action;

    size_t fbe_type() const noexcept { return 108; }

    AlterRoleStmt();
    AlterRoleStmt(std::unique_ptr<::pg_query::RoleSpec> arg_role, std::vector<::pg_query::Node> arg_options, int32_t arg_action);
    AlterRoleStmt(const AlterRoleStmt& other) = delete;
    AlterRoleStmt(AlterRoleStmt&& other) noexcept;
    ~AlterRoleStmt() override;

    AlterRoleStmt& operator=(const AlterRoleStmt& other) = delete;
    AlterRoleStmt& operator=(AlterRoleStmt&& other) noexcept;

    bool operator==(const AlterRoleStmt& other) const noexcept;
    bool operator!=(const AlterRoleStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterRoleStmt& other) const noexcept;
    bool operator<=(const AlterRoleStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterRoleStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterRoleStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterRoleStmt& value);

    void swap(AlterRoleStmt& other) noexcept;
    friend void swap(AlterRoleStmt& value1, AlterRoleStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterRoleStmt>
{
    typedef pg_query::AlterRoleStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DropRoleStmt : FBE::Base
{
    std::vector<::pg_query::Node> roles;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 109; }

    DropRoleStmt();
    DropRoleStmt(std::vector<::pg_query::Node> arg_roles, bool arg_missing_ok);
    DropRoleStmt(const DropRoleStmt& other) = delete;
    DropRoleStmt(DropRoleStmt&& other) noexcept;
    ~DropRoleStmt() override;

    DropRoleStmt& operator=(const DropRoleStmt& other) = delete;
    DropRoleStmt& operator=(DropRoleStmt&& other) noexcept;

    bool operator==(const DropRoleStmt& other) const noexcept;
    bool operator!=(const DropRoleStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DropRoleStmt& other) const noexcept;
    bool operator<=(const DropRoleStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DropRoleStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DropRoleStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DropRoleStmt& value);

    void swap(DropRoleStmt& other) noexcept;
    friend void swap(DropRoleStmt& value1, DropRoleStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DropRoleStmt>
{
    typedef pg_query::DropRoleStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct LockStmt : FBE::Base
{
    std::vector<::pg_query::Node> relations;
    int32_t mode;
    bool nowait;

    size_t fbe_type() const noexcept { return 110; }

    LockStmt();
    LockStmt(std::vector<::pg_query::Node> arg_relations, int32_t arg_mode, bool arg_nowait);
    LockStmt(const LockStmt& other) = delete;
    LockStmt(LockStmt&& other) noexcept;
    ~LockStmt() override;

    LockStmt& operator=(const LockStmt& other) = delete;
    LockStmt& operator=(LockStmt&& other) noexcept;

    bool operator==(const LockStmt& other) const noexcept;
    bool operator!=(const LockStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const LockStmt& other) const noexcept;
    bool operator<=(const LockStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const LockStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const LockStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const LockStmt& value);

    void swap(LockStmt& other) noexcept;
    friend void swap(LockStmt& value1, LockStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::LockStmt>
{
    typedef pg_query::LockStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ConstraintsSetStmt : FBE::Base
{
    std::vector<::pg_query::Node> constraints;
    bool deferred;

    size_t fbe_type() const noexcept { return 111; }

    ConstraintsSetStmt();
    ConstraintsSetStmt(std::vector<::pg_query::Node> arg_constraints, bool arg_deferred);
    ConstraintsSetStmt(const ConstraintsSetStmt& other) = delete;
    ConstraintsSetStmt(ConstraintsSetStmt&& other) noexcept;
    ~ConstraintsSetStmt() override;

    ConstraintsSetStmt& operator=(const ConstraintsSetStmt& other) = delete;
    ConstraintsSetStmt& operator=(ConstraintsSetStmt&& other) noexcept;

    bool operator==(const ConstraintsSetStmt& other) const noexcept;
    bool operator!=(const ConstraintsSetStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ConstraintsSetStmt& other) const noexcept;
    bool operator<=(const ConstraintsSetStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ConstraintsSetStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ConstraintsSetStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ConstraintsSetStmt& value);

    void swap(ConstraintsSetStmt& other) noexcept;
    friend void swap(ConstraintsSetStmt& value1, ConstraintsSetStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ConstraintsSetStmt>
{
    typedef pg_query::ConstraintsSetStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct ReindexStmt : FBE::Base
{
    ::pg_query::ReindexObjectType kind;
    ::pg_query::RangeVar* relation;
    std::string name;
    int32_t options;
    bool concurrent;

    size_t fbe_type() const noexcept { return 112; }

    ReindexStmt();
    ReindexStmt(::pg_query::ReindexObjectType&& arg_kind, std::unique_ptr<::pg_query::RangeVar> arg_relation, const std::string& arg_name, int32_t arg_options, bool arg_concurrent);
    ReindexStmt(const ReindexStmt& other) = delete;
    ReindexStmt(ReindexStmt&& other) noexcept;
    ~ReindexStmt() override;

    ReindexStmt& operator=(const ReindexStmt& other) = delete;
    ReindexStmt& operator=(ReindexStmt&& other) noexcept;

    bool operator==(const ReindexStmt& other) const noexcept;
    bool operator!=(const ReindexStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ReindexStmt& other) const noexcept;
    bool operator<=(const ReindexStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ReindexStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ReindexStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ReindexStmt& value);

    void swap(ReindexStmt& other) noexcept;
    friend void swap(ReindexStmt& value1, ReindexStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ReindexStmt>
{
    typedef pg_query::ReindexStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CheckPointStmt : FBE::Base
{
    size_t fbe_type() const noexcept { return 113; }

    CheckPointStmt();
    CheckPointStmt(const CheckPointStmt& other) = delete;
    CheckPointStmt(CheckPointStmt&& other) noexcept;
    ~CheckPointStmt() override;

    CheckPointStmt& operator=(const CheckPointStmt& other) = delete;
    CheckPointStmt& operator=(CheckPointStmt&& other) noexcept;

    bool operator==(const CheckPointStmt& other) const noexcept;
    bool operator!=(const CheckPointStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CheckPointStmt& other) const noexcept;
    bool operator<=(const CheckPointStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CheckPointStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CheckPointStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CheckPointStmt& value);

    void swap(CheckPointStmt& other) noexcept;
    friend void swap(CheckPointStmt& value1, CheckPointStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CheckPointStmt>
{
    typedef pg_query::CheckPointStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct CreateSchemaStmt : FBE::Base
{
    std::string schemaname;
    ::pg_query::RoleSpec* authrole;
    std::vector<::pg_query::Node> schema_elts;
    bool if_not_exists;

    size_t fbe_type() const noexcept { return 114; }

    CreateSchemaStmt();
    CreateSchemaStmt(const std::string& arg_schemaname, std::unique_ptr<::pg_query::RoleSpec> arg_authrole, std::vector<::pg_query::Node> arg_schema_elts, bool arg_if_not_exists);
    CreateSchemaStmt(const CreateSchemaStmt& other) = delete;
    CreateSchemaStmt(CreateSchemaStmt&& other) noexcept;
    ~CreateSchemaStmt() override;

    CreateSchemaStmt& operator=(const CreateSchemaStmt& other) = delete;
    CreateSchemaStmt& operator=(CreateSchemaStmt&& other) noexcept;

    bool operator==(const CreateSchemaStmt& other) const noexcept;
    bool operator!=(const CreateSchemaStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateSchemaStmt& other) const noexcept;
    bool operator<=(const CreateSchemaStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateSchemaStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateSchemaStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateSchemaStmt& value);

    void swap(CreateSchemaStmt& other) noexcept;
    friend void swap(CreateSchemaStmt& value1, CreateSchemaStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateSchemaStmt>
{
    typedef pg_query::CreateSchemaStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterDatabaseStmt : FBE::Base
{
    std::string dbname;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 115; }

    AlterDatabaseStmt();
    AlterDatabaseStmt(const std::string& arg_dbname, std::vector<::pg_query::Node> arg_options);
    AlterDatabaseStmt(const AlterDatabaseStmt& other) = delete;
    AlterDatabaseStmt(AlterDatabaseStmt&& other) noexcept;
    ~AlterDatabaseStmt() override;

    AlterDatabaseStmt& operator=(const AlterDatabaseStmt& other) = delete;
    AlterDatabaseStmt& operator=(AlterDatabaseStmt&& other) noexcept;

    bool operator==(const AlterDatabaseStmt& other) const noexcept;
    bool operator!=(const AlterDatabaseStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterDatabaseStmt& other) const noexcept;
    bool operator<=(const AlterDatabaseStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterDatabaseStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterDatabaseStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterDatabaseStmt& value);

    void swap(AlterDatabaseStmt& other) noexcept;
    friend void swap(AlterDatabaseStmt& value1, AlterDatabaseStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterDatabaseStmt>
{
    typedef pg_query::AlterDatabaseStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct VariableSetStmt;

struct AlterDatabaseSetStmt : FBE::Base
{
    std::string dbname;
    ::pg_query::VariableSetStmt* setstmt;

    size_t fbe_type() const noexcept { return 116; }

    AlterDatabaseSetStmt();
    AlterDatabaseSetStmt(const std::string& arg_dbname, std::unique_ptr<::pg_query::VariableSetStmt> arg_setstmt);
    AlterDatabaseSetStmt(const AlterDatabaseSetStmt& other) = delete;
    AlterDatabaseSetStmt(AlterDatabaseSetStmt&& other) noexcept;
    ~AlterDatabaseSetStmt() override;

    AlterDatabaseSetStmt& operator=(const AlterDatabaseSetStmt& other) = delete;
    AlterDatabaseSetStmt& operator=(AlterDatabaseSetStmt&& other) noexcept;

    bool operator==(const AlterDatabaseSetStmt& other) const noexcept;
    bool operator!=(const AlterDatabaseSetStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterDatabaseSetStmt& other) const noexcept;
    bool operator<=(const AlterDatabaseSetStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterDatabaseSetStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterDatabaseSetStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterDatabaseSetStmt& value);

    void swap(AlterDatabaseSetStmt& other) noexcept;
    friend void swap(AlterDatabaseSetStmt& value1, AlterDatabaseSetStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterDatabaseSetStmt>
{
    typedef pg_query::AlterDatabaseSetStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct VariableSetStmt;

struct AlterRoleSetStmt : FBE::Base
{
    ::pg_query::RoleSpec* role;
    std::string database;
    ::pg_query::VariableSetStmt* setstmt;

    size_t fbe_type() const noexcept { return 117; }

    AlterRoleSetStmt();
    AlterRoleSetStmt(std::unique_ptr<::pg_query::RoleSpec> arg_role, const std::string& arg_database, std::unique_ptr<::pg_query::VariableSetStmt> arg_setstmt);
    AlterRoleSetStmt(const AlterRoleSetStmt& other) = delete;
    AlterRoleSetStmt(AlterRoleSetStmt&& other) noexcept;
    ~AlterRoleSetStmt() override;

    AlterRoleSetStmt& operator=(const AlterRoleSetStmt& other) = delete;
    AlterRoleSetStmt& operator=(AlterRoleSetStmt&& other) noexcept;

    bool operator==(const AlterRoleSetStmt& other) const noexcept;
    bool operator!=(const AlterRoleSetStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterRoleSetStmt& other) const noexcept;
    bool operator<=(const AlterRoleSetStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterRoleSetStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterRoleSetStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterRoleSetStmt& value);

    void swap(AlterRoleSetStmt& other) noexcept;
    friend void swap(AlterRoleSetStmt& value1, AlterRoleSetStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterRoleSetStmt>
{
    typedef pg_query::AlterRoleSetStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateConversionStmt : FBE::Base
{
    std::vector<::pg_query::Node> conversion_name;
    std::string for_encoding_name;
    std::string to_encoding_name;
    std::vector<::pg_query::Node> func_name;
    bool def;

    size_t fbe_type() const noexcept { return 118; }

    CreateConversionStmt();
    CreateConversionStmt(std::vector<::pg_query::Node> arg_conversion_name, const std::string& arg_for_encoding_name, const std::string& arg_to_encoding_name, std::vector<::pg_query::Node> arg_func_name, bool arg_def);
    CreateConversionStmt(const CreateConversionStmt& other) = delete;
    CreateConversionStmt(CreateConversionStmt&& other) noexcept;
    ~CreateConversionStmt() override;

    CreateConversionStmt& operator=(const CreateConversionStmt& other) = delete;
    CreateConversionStmt& operator=(CreateConversionStmt&& other) noexcept;

    bool operator==(const CreateConversionStmt& other) const noexcept;
    bool operator!=(const CreateConversionStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateConversionStmt& other) const noexcept;
    bool operator<=(const CreateConversionStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateConversionStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateConversionStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateConversionStmt& value);

    void swap(CreateConversionStmt& other) noexcept;
    friend void swap(CreateConversionStmt& value1, CreateConversionStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateConversionStmt>
{
    typedef pg_query::CreateConversionStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct ObjectWithArgs;

struct CreateCastStmt : FBE::Base
{
    ::pg_query::TypeName* sourcetype;
    ::pg_query::TypeName* targettype;
    ::pg_query::ObjectWithArgs* func;
    ::pg_query::CoercionContext context;
    bool inout;

    size_t fbe_type() const noexcept { return 119; }

    CreateCastStmt();
    CreateCastStmt(std::unique_ptr<::pg_query::TypeName> arg_sourcetype, std::unique_ptr<::pg_query::TypeName> arg_targettype, std::unique_ptr<::pg_query::ObjectWithArgs> arg_func, ::pg_query::CoercionContext&& arg_context, bool arg_inout);
    CreateCastStmt(const CreateCastStmt& other) = delete;
    CreateCastStmt(CreateCastStmt&& other) noexcept;
    ~CreateCastStmt() override;

    CreateCastStmt& operator=(const CreateCastStmt& other) = delete;
    CreateCastStmt& operator=(CreateCastStmt&& other) noexcept;

    bool operator==(const CreateCastStmt& other) const noexcept;
    bool operator!=(const CreateCastStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateCastStmt& other) const noexcept;
    bool operator<=(const CreateCastStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateCastStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateCastStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateCastStmt& value);

    void swap(CreateCastStmt& other) noexcept;
    friend void swap(CreateCastStmt& value1, CreateCastStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateCastStmt>
{
    typedef pg_query::CreateCastStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct CreateOpClassStmt : FBE::Base
{
    std::vector<::pg_query::Node> opclassname;
    std::vector<::pg_query::Node> opfamilyname;
    std::string amname;
    ::pg_query::TypeName* datatype;
    std::vector<::pg_query::Node> items;
    bool is_default;

    size_t fbe_type() const noexcept { return 120; }

    CreateOpClassStmt();
    CreateOpClassStmt(std::vector<::pg_query::Node> arg_opclassname, std::vector<::pg_query::Node> arg_opfamilyname, const std::string& arg_amname, std::unique_ptr<::pg_query::TypeName> arg_datatype, std::vector<::pg_query::Node> arg_items, bool arg_is_default);
    CreateOpClassStmt(const CreateOpClassStmt& other) = delete;
    CreateOpClassStmt(CreateOpClassStmt&& other) noexcept;
    ~CreateOpClassStmt() override;

    CreateOpClassStmt& operator=(const CreateOpClassStmt& other) = delete;
    CreateOpClassStmt& operator=(CreateOpClassStmt&& other) noexcept;

    bool operator==(const CreateOpClassStmt& other) const noexcept;
    bool operator!=(const CreateOpClassStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateOpClassStmt& other) const noexcept;
    bool operator<=(const CreateOpClassStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateOpClassStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateOpClassStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateOpClassStmt& value);

    void swap(CreateOpClassStmt& other) noexcept;
    friend void swap(CreateOpClassStmt& value1, CreateOpClassStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateOpClassStmt>
{
    typedef pg_query::CreateOpClassStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateOpFamilyStmt : FBE::Base
{
    std::vector<::pg_query::Node> opfamilyname;
    std::string amname;

    size_t fbe_type() const noexcept { return 121; }

    CreateOpFamilyStmt();
    CreateOpFamilyStmt(std::vector<::pg_query::Node> arg_opfamilyname, const std::string& arg_amname);
    CreateOpFamilyStmt(const CreateOpFamilyStmt& other) = delete;
    CreateOpFamilyStmt(CreateOpFamilyStmt&& other) noexcept;
    ~CreateOpFamilyStmt() override;

    CreateOpFamilyStmt& operator=(const CreateOpFamilyStmt& other) = delete;
    CreateOpFamilyStmt& operator=(CreateOpFamilyStmt&& other) noexcept;

    bool operator==(const CreateOpFamilyStmt& other) const noexcept;
    bool operator!=(const CreateOpFamilyStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateOpFamilyStmt& other) const noexcept;
    bool operator<=(const CreateOpFamilyStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateOpFamilyStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateOpFamilyStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateOpFamilyStmt& value);

    void swap(CreateOpFamilyStmt& other) noexcept;
    friend void swap(CreateOpFamilyStmt& value1, CreateOpFamilyStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateOpFamilyStmt>
{
    typedef pg_query::CreateOpFamilyStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterOpFamilyStmt : FBE::Base
{
    std::vector<::pg_query::Node> opfamilyname;
    std::string amname;
    bool is_drop;
    std::vector<::pg_query::Node> items;

    size_t fbe_type() const noexcept { return 122; }

    AlterOpFamilyStmt();
    AlterOpFamilyStmt(std::vector<::pg_query::Node> arg_opfamilyname, const std::string& arg_amname, bool arg_is_drop, std::vector<::pg_query::Node> arg_items);
    AlterOpFamilyStmt(const AlterOpFamilyStmt& other) = delete;
    AlterOpFamilyStmt(AlterOpFamilyStmt&& other) noexcept;
    ~AlterOpFamilyStmt() override;

    AlterOpFamilyStmt& operator=(const AlterOpFamilyStmt& other) = delete;
    AlterOpFamilyStmt& operator=(AlterOpFamilyStmt&& other) noexcept;

    bool operator==(const AlterOpFamilyStmt& other) const noexcept;
    bool operator!=(const AlterOpFamilyStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterOpFamilyStmt& other) const noexcept;
    bool operator<=(const AlterOpFamilyStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterOpFamilyStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterOpFamilyStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterOpFamilyStmt& value);

    void swap(AlterOpFamilyStmt& other) noexcept;
    friend void swap(AlterOpFamilyStmt& value1, AlterOpFamilyStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterOpFamilyStmt>
{
    typedef pg_query::AlterOpFamilyStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct PrepareStmt : FBE::Base
{
    std::string name;
    std::vector<::pg_query::Node> argtypes;
    ::pg_query::Node query;

    size_t fbe_type() const noexcept { return 123; }

    PrepareStmt();
    PrepareStmt(const std::string& arg_name, std::vector<::pg_query::Node> arg_argtypes, ::pg_query::Node&& arg_query);
    PrepareStmt(const PrepareStmt& other) = delete;
    PrepareStmt(PrepareStmt&& other) noexcept;
    ~PrepareStmt() override;

    PrepareStmt& operator=(const PrepareStmt& other) = delete;
    PrepareStmt& operator=(PrepareStmt&& other) noexcept;

    bool operator==(const PrepareStmt& other) const noexcept;
    bool operator!=(const PrepareStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const PrepareStmt& other) const noexcept;
    bool operator<=(const PrepareStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const PrepareStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const PrepareStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const PrepareStmt& value);

    void swap(PrepareStmt& other) noexcept;
    friend void swap(PrepareStmt& value1, PrepareStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::PrepareStmt>
{
    typedef pg_query::PrepareStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ExecuteStmt : FBE::Base
{
    std::string name;
    std::vector<::pg_query::Node> params;

    size_t fbe_type() const noexcept { return 124; }

    ExecuteStmt();
    ExecuteStmt(const std::string& arg_name, std::vector<::pg_query::Node> arg_params);
    ExecuteStmt(const ExecuteStmt& other) = delete;
    ExecuteStmt(ExecuteStmt&& other) noexcept;
    ~ExecuteStmt() override;

    ExecuteStmt& operator=(const ExecuteStmt& other) = delete;
    ExecuteStmt& operator=(ExecuteStmt&& other) noexcept;

    bool operator==(const ExecuteStmt& other) const noexcept;
    bool operator!=(const ExecuteStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ExecuteStmt& other) const noexcept;
    bool operator<=(const ExecuteStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ExecuteStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ExecuteStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ExecuteStmt& value);

    void swap(ExecuteStmt& other) noexcept;
    friend void swap(ExecuteStmt& value1, ExecuteStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ExecuteStmt>
{
    typedef pg_query::ExecuteStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DeallocateStmt : FBE::Base
{
    std::string name;

    size_t fbe_type() const noexcept { return 125; }

    DeallocateStmt();
    explicit DeallocateStmt(const std::string& arg_name);
    DeallocateStmt(const DeallocateStmt& other) = delete;
    DeallocateStmt(DeallocateStmt&& other) noexcept;
    ~DeallocateStmt() override;

    DeallocateStmt& operator=(const DeallocateStmt& other) = delete;
    DeallocateStmt& operator=(DeallocateStmt&& other) noexcept;

    bool operator==(const DeallocateStmt& other) const noexcept;
    bool operator!=(const DeallocateStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DeallocateStmt& other) const noexcept;
    bool operator<=(const DeallocateStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DeallocateStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DeallocateStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DeallocateStmt& value);

    void swap(DeallocateStmt& other) noexcept;
    friend void swap(DeallocateStmt& value1, DeallocateStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DeallocateStmt>
{
    typedef pg_query::DeallocateStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DeclareCursorStmt : FBE::Base
{
    std::string portalname;
    int32_t options;
    ::pg_query::Node query;

    size_t fbe_type() const noexcept { return 126; }

    DeclareCursorStmt();
    DeclareCursorStmt(const std::string& arg_portalname, int32_t arg_options, ::pg_query::Node&& arg_query);
    DeclareCursorStmt(const DeclareCursorStmt& other) = delete;
    DeclareCursorStmt(DeclareCursorStmt&& other) noexcept;
    ~DeclareCursorStmt() override;

    DeclareCursorStmt& operator=(const DeclareCursorStmt& other) = delete;
    DeclareCursorStmt& operator=(DeclareCursorStmt&& other) noexcept;

    bool operator==(const DeclareCursorStmt& other) const noexcept;
    bool operator!=(const DeclareCursorStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DeclareCursorStmt& other) const noexcept;
    bool operator<=(const DeclareCursorStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DeclareCursorStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DeclareCursorStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DeclareCursorStmt& value);

    void swap(DeclareCursorStmt& other) noexcept;
    friend void swap(DeclareCursorStmt& value1, DeclareCursorStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DeclareCursorStmt>
{
    typedef pg_query::DeclareCursorStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct CreateTableSpaceStmt : FBE::Base
{
    std::string tablespacename;
    ::pg_query::RoleSpec* owner;
    std::string location;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 127; }

    CreateTableSpaceStmt();
    CreateTableSpaceStmt(const std::string& arg_tablespacename, std::unique_ptr<::pg_query::RoleSpec> arg_owner, const std::string& arg_location, std::vector<::pg_query::Node> arg_options);
    CreateTableSpaceStmt(const CreateTableSpaceStmt& other) = delete;
    CreateTableSpaceStmt(CreateTableSpaceStmt&& other) noexcept;
    ~CreateTableSpaceStmt() override;

    CreateTableSpaceStmt& operator=(const CreateTableSpaceStmt& other) = delete;
    CreateTableSpaceStmt& operator=(CreateTableSpaceStmt&& other) noexcept;

    bool operator==(const CreateTableSpaceStmt& other) const noexcept;
    bool operator!=(const CreateTableSpaceStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateTableSpaceStmt& other) const noexcept;
    bool operator<=(const CreateTableSpaceStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateTableSpaceStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateTableSpaceStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateTableSpaceStmt& value);

    void swap(CreateTableSpaceStmt& other) noexcept;
    friend void swap(CreateTableSpaceStmt& value1, CreateTableSpaceStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateTableSpaceStmt>
{
    typedef pg_query::CreateTableSpaceStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DropTableSpaceStmt : FBE::Base
{
    std::string tablespacename;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 128; }

    DropTableSpaceStmt();
    DropTableSpaceStmt(const std::string& arg_tablespacename, bool arg_missing_ok);
    DropTableSpaceStmt(const DropTableSpaceStmt& other) = delete;
    DropTableSpaceStmt(DropTableSpaceStmt&& other) noexcept;
    ~DropTableSpaceStmt() override;

    DropTableSpaceStmt& operator=(const DropTableSpaceStmt& other) = delete;
    DropTableSpaceStmt& operator=(DropTableSpaceStmt&& other) noexcept;

    bool operator==(const DropTableSpaceStmt& other) const noexcept;
    bool operator!=(const DropTableSpaceStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DropTableSpaceStmt& other) const noexcept;
    bool operator<=(const DropTableSpaceStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DropTableSpaceStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DropTableSpaceStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DropTableSpaceStmt& value);

    void swap(DropTableSpaceStmt& other) noexcept;
    friend void swap(DropTableSpaceStmt& value1, DropTableSpaceStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DropTableSpaceStmt>
{
    typedef pg_query::DropTableSpaceStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct AlterObjectDependsStmt : FBE::Base
{
    ::pg_query::ObjectType object_type;
    ::pg_query::RangeVar* relation;
    ::pg_query::Node object;
    ::pg_query::Node extname;
    bool remove;

    size_t fbe_type() const noexcept { return 129; }

    AlterObjectDependsStmt();
    AlterObjectDependsStmt(::pg_query::ObjectType&& arg_object_type, std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_object, ::pg_query::Node&& arg_extname, bool arg_remove);
    AlterObjectDependsStmt(const AlterObjectDependsStmt& other) = delete;
    AlterObjectDependsStmt(AlterObjectDependsStmt&& other) noexcept;
    ~AlterObjectDependsStmt() override;

    AlterObjectDependsStmt& operator=(const AlterObjectDependsStmt& other) = delete;
    AlterObjectDependsStmt& operator=(AlterObjectDependsStmt&& other) noexcept;

    bool operator==(const AlterObjectDependsStmt& other) const noexcept;
    bool operator!=(const AlterObjectDependsStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterObjectDependsStmt& other) const noexcept;
    bool operator<=(const AlterObjectDependsStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterObjectDependsStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterObjectDependsStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterObjectDependsStmt& value);

    void swap(AlterObjectDependsStmt& other) noexcept;
    friend void swap(AlterObjectDependsStmt& value1, AlterObjectDependsStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterObjectDependsStmt>
{
    typedef pg_query::AlterObjectDependsStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct AlterObjectSchemaStmt : FBE::Base
{
    ::pg_query::ObjectType object_type;
    ::pg_query::RangeVar* relation;
    ::pg_query::Node object;
    std::string newschema;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 130; }

    AlterObjectSchemaStmt();
    AlterObjectSchemaStmt(::pg_query::ObjectType&& arg_object_type, std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_object, const std::string& arg_newschema, bool arg_missing_ok);
    AlterObjectSchemaStmt(const AlterObjectSchemaStmt& other) = delete;
    AlterObjectSchemaStmt(AlterObjectSchemaStmt&& other) noexcept;
    ~AlterObjectSchemaStmt() override;

    AlterObjectSchemaStmt& operator=(const AlterObjectSchemaStmt& other) = delete;
    AlterObjectSchemaStmt& operator=(AlterObjectSchemaStmt&& other) noexcept;

    bool operator==(const AlterObjectSchemaStmt& other) const noexcept;
    bool operator!=(const AlterObjectSchemaStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterObjectSchemaStmt& other) const noexcept;
    bool operator<=(const AlterObjectSchemaStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterObjectSchemaStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterObjectSchemaStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterObjectSchemaStmt& value);

    void swap(AlterObjectSchemaStmt& other) noexcept;
    friend void swap(AlterObjectSchemaStmt& value1, AlterObjectSchemaStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterObjectSchemaStmt>
{
    typedef pg_query::AlterObjectSchemaStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct RoleSpec;

struct AlterOwnerStmt : FBE::Base
{
    ::pg_query::ObjectType object_type;
    ::pg_query::RangeVar* relation;
    ::pg_query::Node object;
    ::pg_query::RoleSpec* newowner;

    size_t fbe_type() const noexcept { return 131; }

    AlterOwnerStmt();
    AlterOwnerStmt(::pg_query::ObjectType&& arg_object_type, std::unique_ptr<::pg_query::RangeVar> arg_relation, ::pg_query::Node&& arg_object, std::unique_ptr<::pg_query::RoleSpec> arg_newowner);
    AlterOwnerStmt(const AlterOwnerStmt& other) = delete;
    AlterOwnerStmt(AlterOwnerStmt&& other) noexcept;
    ~AlterOwnerStmt() override;

    AlterOwnerStmt& operator=(const AlterOwnerStmt& other) = delete;
    AlterOwnerStmt& operator=(AlterOwnerStmt&& other) noexcept;

    bool operator==(const AlterOwnerStmt& other) const noexcept;
    bool operator!=(const AlterOwnerStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterOwnerStmt& other) const noexcept;
    bool operator<=(const AlterOwnerStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterOwnerStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterOwnerStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterOwnerStmt& value);

    void swap(AlterOwnerStmt& other) noexcept;
    friend void swap(AlterOwnerStmt& value1, AlterOwnerStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterOwnerStmt>
{
    typedef pg_query::AlterOwnerStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ObjectWithArgs;

struct AlterOperatorStmt : FBE::Base
{
    ::pg_query::ObjectWithArgs* opername;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 132; }

    AlterOperatorStmt();
    AlterOperatorStmt(std::unique_ptr<::pg_query::ObjectWithArgs> arg_opername, std::vector<::pg_query::Node> arg_options);
    AlterOperatorStmt(const AlterOperatorStmt& other) = delete;
    AlterOperatorStmt(AlterOperatorStmt&& other) noexcept;
    ~AlterOperatorStmt() override;

    AlterOperatorStmt& operator=(const AlterOperatorStmt& other) = delete;
    AlterOperatorStmt& operator=(AlterOperatorStmt&& other) noexcept;

    bool operator==(const AlterOperatorStmt& other) const noexcept;
    bool operator!=(const AlterOperatorStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterOperatorStmt& other) const noexcept;
    bool operator<=(const AlterOperatorStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterOperatorStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterOperatorStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterOperatorStmt& value);

    void swap(AlterOperatorStmt& other) noexcept;
    friend void swap(AlterOperatorStmt& value1, AlterOperatorStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterOperatorStmt>
{
    typedef pg_query::AlterOperatorStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterTypeStmt : FBE::Base
{
    std::vector<::pg_query::Node> type_name;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 133; }

    AlterTypeStmt();
    AlterTypeStmt(std::vector<::pg_query::Node> arg_type_name, std::vector<::pg_query::Node> arg_options);
    AlterTypeStmt(const AlterTypeStmt& other) = delete;
    AlterTypeStmt(AlterTypeStmt&& other) noexcept;
    ~AlterTypeStmt() override;

    AlterTypeStmt& operator=(const AlterTypeStmt& other) = delete;
    AlterTypeStmt& operator=(AlterTypeStmt&& other) noexcept;

    bool operator==(const AlterTypeStmt& other) const noexcept;
    bool operator!=(const AlterTypeStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterTypeStmt& other) const noexcept;
    bool operator<=(const AlterTypeStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterTypeStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterTypeStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterTypeStmt& value);

    void swap(AlterTypeStmt& other) noexcept;
    friend void swap(AlterTypeStmt& value1, AlterTypeStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterTypeStmt>
{
    typedef pg_query::AlterTypeStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DropOwnedStmt : FBE::Base
{
    std::vector<::pg_query::Node> roles;
    ::pg_query::DropBehavior behavior;

    size_t fbe_type() const noexcept { return 134; }

    DropOwnedStmt();
    DropOwnedStmt(std::vector<::pg_query::Node> arg_roles, ::pg_query::DropBehavior&& arg_behavior);
    DropOwnedStmt(const DropOwnedStmt& other) = delete;
    DropOwnedStmt(DropOwnedStmt&& other) noexcept;
    ~DropOwnedStmt() override;

    DropOwnedStmt& operator=(const DropOwnedStmt& other) = delete;
    DropOwnedStmt& operator=(DropOwnedStmt&& other) noexcept;

    bool operator==(const DropOwnedStmt& other) const noexcept;
    bool operator!=(const DropOwnedStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DropOwnedStmt& other) const noexcept;
    bool operator<=(const DropOwnedStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DropOwnedStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DropOwnedStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DropOwnedStmt& value);

    void swap(DropOwnedStmt& other) noexcept;
    friend void swap(DropOwnedStmt& value1, DropOwnedStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DropOwnedStmt>
{
    typedef pg_query::DropOwnedStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct ReassignOwnedStmt : FBE::Base
{
    std::vector<::pg_query::Node> roles;
    ::pg_query::RoleSpec* newrole;

    size_t fbe_type() const noexcept { return 135; }

    ReassignOwnedStmt();
    ReassignOwnedStmt(std::vector<::pg_query::Node> arg_roles, std::unique_ptr<::pg_query::RoleSpec> arg_newrole);
    ReassignOwnedStmt(const ReassignOwnedStmt& other) = delete;
    ReassignOwnedStmt(ReassignOwnedStmt&& other) noexcept;
    ~ReassignOwnedStmt() override;

    ReassignOwnedStmt& operator=(const ReassignOwnedStmt& other) = delete;
    ReassignOwnedStmt& operator=(ReassignOwnedStmt&& other) noexcept;

    bool operator==(const ReassignOwnedStmt& other) const noexcept;
    bool operator!=(const ReassignOwnedStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ReassignOwnedStmt& other) const noexcept;
    bool operator<=(const ReassignOwnedStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ReassignOwnedStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ReassignOwnedStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ReassignOwnedStmt& value);

    void swap(ReassignOwnedStmt& other) noexcept;
    friend void swap(ReassignOwnedStmt& value1, ReassignOwnedStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ReassignOwnedStmt>
{
    typedef pg_query::ReassignOwnedStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct CompositeTypeStmt : FBE::Base
{
    ::pg_query::RangeVar* typevar;
    std::vector<::pg_query::Node> coldeflist;

    size_t fbe_type() const noexcept { return 136; }

    CompositeTypeStmt();
    CompositeTypeStmt(std::unique_ptr<::pg_query::RangeVar> arg_typevar, std::vector<::pg_query::Node> arg_coldeflist);
    CompositeTypeStmt(const CompositeTypeStmt& other) = delete;
    CompositeTypeStmt(CompositeTypeStmt&& other) noexcept;
    ~CompositeTypeStmt() override;

    CompositeTypeStmt& operator=(const CompositeTypeStmt& other) = delete;
    CompositeTypeStmt& operator=(CompositeTypeStmt&& other) noexcept;

    bool operator==(const CompositeTypeStmt& other) const noexcept;
    bool operator!=(const CompositeTypeStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CompositeTypeStmt& other) const noexcept;
    bool operator<=(const CompositeTypeStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CompositeTypeStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CompositeTypeStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CompositeTypeStmt& value);

    void swap(CompositeTypeStmt& other) noexcept;
    friend void swap(CompositeTypeStmt& value1, CompositeTypeStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CompositeTypeStmt>
{
    typedef pg_query::CompositeTypeStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateEnumStmt : FBE::Base
{
    std::vector<::pg_query::Node> type_name;
    std::vector<::pg_query::Node> vals;

    size_t fbe_type() const noexcept { return 137; }

    CreateEnumStmt();
    CreateEnumStmt(std::vector<::pg_query::Node> arg_type_name, std::vector<::pg_query::Node> arg_vals);
    CreateEnumStmt(const CreateEnumStmt& other) = delete;
    CreateEnumStmt(CreateEnumStmt&& other) noexcept;
    ~CreateEnumStmt() override;

    CreateEnumStmt& operator=(const CreateEnumStmt& other) = delete;
    CreateEnumStmt& operator=(CreateEnumStmt&& other) noexcept;

    bool operator==(const CreateEnumStmt& other) const noexcept;
    bool operator!=(const CreateEnumStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateEnumStmt& other) const noexcept;
    bool operator<=(const CreateEnumStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateEnumStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateEnumStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateEnumStmt& value);

    void swap(CreateEnumStmt& other) noexcept;
    friend void swap(CreateEnumStmt& value1, CreateEnumStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateEnumStmt>
{
    typedef pg_query::CreateEnumStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateRangeStmt : FBE::Base
{
    std::vector<::pg_query::Node> type_name;
    std::vector<::pg_query::Node> params;

    size_t fbe_type() const noexcept { return 138; }

    CreateRangeStmt();
    CreateRangeStmt(std::vector<::pg_query::Node> arg_type_name, std::vector<::pg_query::Node> arg_params);
    CreateRangeStmt(const CreateRangeStmt& other) = delete;
    CreateRangeStmt(CreateRangeStmt&& other) noexcept;
    ~CreateRangeStmt() override;

    CreateRangeStmt& operator=(const CreateRangeStmt& other) = delete;
    CreateRangeStmt& operator=(CreateRangeStmt&& other) noexcept;

    bool operator==(const CreateRangeStmt& other) const noexcept;
    bool operator!=(const CreateRangeStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateRangeStmt& other) const noexcept;
    bool operator<=(const CreateRangeStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateRangeStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateRangeStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateRangeStmt& value);

    void swap(CreateRangeStmt& other) noexcept;
    friend void swap(CreateRangeStmt& value1, CreateRangeStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateRangeStmt>
{
    typedef pg_query::CreateRangeStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterEnumStmt : FBE::Base
{
    std::vector<::pg_query::Node> type_name;
    std::string old_val;
    std::string new_val;
    std::string new_val_neighbor;
    bool new_val_is_after;
    bool skip_if_new_val_exists;

    size_t fbe_type() const noexcept { return 139; }

    AlterEnumStmt();
    AlterEnumStmt(std::vector<::pg_query::Node> arg_type_name, const std::string& arg_old_val, const std::string& arg_new_val, const std::string& arg_new_val_neighbor, bool arg_new_val_is_after, bool arg_skip_if_new_val_exists);
    AlterEnumStmt(const AlterEnumStmt& other) = delete;
    AlterEnumStmt(AlterEnumStmt&& other) noexcept;
    ~AlterEnumStmt() override;

    AlterEnumStmt& operator=(const AlterEnumStmt& other) = delete;
    AlterEnumStmt& operator=(AlterEnumStmt&& other) noexcept;

    bool operator==(const AlterEnumStmt& other) const noexcept;
    bool operator!=(const AlterEnumStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterEnumStmt& other) const noexcept;
    bool operator<=(const AlterEnumStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterEnumStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterEnumStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterEnumStmt& value);

    void swap(AlterEnumStmt& other) noexcept;
    friend void swap(AlterEnumStmt& value1, AlterEnumStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterEnumStmt>
{
    typedef pg_query::AlterEnumStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterTSDictionaryStmt : FBE::Base
{
    std::vector<::pg_query::Node> dictname;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 140; }

    AlterTSDictionaryStmt();
    AlterTSDictionaryStmt(std::vector<::pg_query::Node> arg_dictname, std::vector<::pg_query::Node> arg_options);
    AlterTSDictionaryStmt(const AlterTSDictionaryStmt& other) = delete;
    AlterTSDictionaryStmt(AlterTSDictionaryStmt&& other) noexcept;
    ~AlterTSDictionaryStmt() override;

    AlterTSDictionaryStmt& operator=(const AlterTSDictionaryStmt& other) = delete;
    AlterTSDictionaryStmt& operator=(AlterTSDictionaryStmt&& other) noexcept;

    bool operator==(const AlterTSDictionaryStmt& other) const noexcept;
    bool operator!=(const AlterTSDictionaryStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterTSDictionaryStmt& other) const noexcept;
    bool operator<=(const AlterTSDictionaryStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterTSDictionaryStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterTSDictionaryStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterTSDictionaryStmt& value);

    void swap(AlterTSDictionaryStmt& other) noexcept;
    friend void swap(AlterTSDictionaryStmt& value1, AlterTSDictionaryStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterTSDictionaryStmt>
{
    typedef pg_query::AlterTSDictionaryStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterTSConfigurationStmt : FBE::Base
{
    ::pg_query::AlterTSConfigType kind;
    std::vector<::pg_query::Node> cfgname;
    std::vector<::pg_query::Node> tokentype;
    std::vector<::pg_query::Node> dicts;
    bool override;
    bool replace;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 141; }

    AlterTSConfigurationStmt();
    AlterTSConfigurationStmt(::pg_query::AlterTSConfigType&& arg_kind, std::vector<::pg_query::Node> arg_cfgname, std::vector<::pg_query::Node> arg_tokentype, std::vector<::pg_query::Node> arg_dicts, bool arg_override, bool arg_replace, bool arg_missing_ok);
    AlterTSConfigurationStmt(const AlterTSConfigurationStmt& other) = delete;
    AlterTSConfigurationStmt(AlterTSConfigurationStmt&& other) noexcept;
    ~AlterTSConfigurationStmt() override;

    AlterTSConfigurationStmt& operator=(const AlterTSConfigurationStmt& other) = delete;
    AlterTSConfigurationStmt& operator=(AlterTSConfigurationStmt&& other) noexcept;

    bool operator==(const AlterTSConfigurationStmt& other) const noexcept;
    bool operator!=(const AlterTSConfigurationStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterTSConfigurationStmt& other) const noexcept;
    bool operator<=(const AlterTSConfigurationStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterTSConfigurationStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterTSConfigurationStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterTSConfigurationStmt& value);

    void swap(AlterTSConfigurationStmt& other) noexcept;
    friend void swap(AlterTSConfigurationStmt& value1, AlterTSConfigurationStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterTSConfigurationStmt>
{
    typedef pg_query::AlterTSConfigurationStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateFdwStmt : FBE::Base
{
    std::string fdwname;
    std::vector<::pg_query::Node> func_options;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 142; }

    CreateFdwStmt();
    CreateFdwStmt(const std::string& arg_fdwname, std::vector<::pg_query::Node> arg_func_options, std::vector<::pg_query::Node> arg_options);
    CreateFdwStmt(const CreateFdwStmt& other) = delete;
    CreateFdwStmt(CreateFdwStmt&& other) noexcept;
    ~CreateFdwStmt() override;

    CreateFdwStmt& operator=(const CreateFdwStmt& other) = delete;
    CreateFdwStmt& operator=(CreateFdwStmt&& other) noexcept;

    bool operator==(const CreateFdwStmt& other) const noexcept;
    bool operator!=(const CreateFdwStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateFdwStmt& other) const noexcept;
    bool operator<=(const CreateFdwStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateFdwStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateFdwStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateFdwStmt& value);

    void swap(CreateFdwStmt& other) noexcept;
    friend void swap(CreateFdwStmt& value1, CreateFdwStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateFdwStmt>
{
    typedef pg_query::CreateFdwStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterFdwStmt : FBE::Base
{
    std::string fdwname;
    std::vector<::pg_query::Node> func_options;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 143; }

    AlterFdwStmt();
    AlterFdwStmt(const std::string& arg_fdwname, std::vector<::pg_query::Node> arg_func_options, std::vector<::pg_query::Node> arg_options);
    AlterFdwStmt(const AlterFdwStmt& other) = delete;
    AlterFdwStmt(AlterFdwStmt&& other) noexcept;
    ~AlterFdwStmt() override;

    AlterFdwStmt& operator=(const AlterFdwStmt& other) = delete;
    AlterFdwStmt& operator=(AlterFdwStmt&& other) noexcept;

    bool operator==(const AlterFdwStmt& other) const noexcept;
    bool operator!=(const AlterFdwStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterFdwStmt& other) const noexcept;
    bool operator<=(const AlterFdwStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterFdwStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterFdwStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterFdwStmt& value);

    void swap(AlterFdwStmt& other) noexcept;
    friend void swap(AlterFdwStmt& value1, AlterFdwStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterFdwStmt>
{
    typedef pg_query::AlterFdwStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateForeignServerStmt : FBE::Base
{
    std::string servername;
    std::string servertype;
    std::string version;
    std::string fdwname;
    bool if_not_exists;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 144; }

    CreateForeignServerStmt();
    CreateForeignServerStmt(const std::string& arg_servername, const std::string& arg_servertype, const std::string& arg_version, const std::string& arg_fdwname, bool arg_if_not_exists, std::vector<::pg_query::Node> arg_options);
    CreateForeignServerStmt(const CreateForeignServerStmt& other) = delete;
    CreateForeignServerStmt(CreateForeignServerStmt&& other) noexcept;
    ~CreateForeignServerStmt() override;

    CreateForeignServerStmt& operator=(const CreateForeignServerStmt& other) = delete;
    CreateForeignServerStmt& operator=(CreateForeignServerStmt&& other) noexcept;

    bool operator==(const CreateForeignServerStmt& other) const noexcept;
    bool operator!=(const CreateForeignServerStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateForeignServerStmt& other) const noexcept;
    bool operator<=(const CreateForeignServerStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateForeignServerStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateForeignServerStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateForeignServerStmt& value);

    void swap(CreateForeignServerStmt& other) noexcept;
    friend void swap(CreateForeignServerStmt& value1, CreateForeignServerStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateForeignServerStmt>
{
    typedef pg_query::CreateForeignServerStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterForeignServerStmt : FBE::Base
{
    std::string servername;
    std::string version;
    std::vector<::pg_query::Node> options;
    bool has_version;

    size_t fbe_type() const noexcept { return 145; }

    AlterForeignServerStmt();
    AlterForeignServerStmt(const std::string& arg_servername, const std::string& arg_version, std::vector<::pg_query::Node> arg_options, bool arg_has_version);
    AlterForeignServerStmt(const AlterForeignServerStmt& other) = delete;
    AlterForeignServerStmt(AlterForeignServerStmt&& other) noexcept;
    ~AlterForeignServerStmt() override;

    AlterForeignServerStmt& operator=(const AlterForeignServerStmt& other) = delete;
    AlterForeignServerStmt& operator=(AlterForeignServerStmt&& other) noexcept;

    bool operator==(const AlterForeignServerStmt& other) const noexcept;
    bool operator!=(const AlterForeignServerStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterForeignServerStmt& other) const noexcept;
    bool operator<=(const AlterForeignServerStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterForeignServerStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterForeignServerStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterForeignServerStmt& value);

    void swap(AlterForeignServerStmt& other) noexcept;
    friend void swap(AlterForeignServerStmt& value1, AlterForeignServerStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterForeignServerStmt>
{
    typedef pg_query::AlterForeignServerStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct CreateUserMappingStmt : FBE::Base
{
    ::pg_query::RoleSpec* user;
    std::string servername;
    bool if_not_exists;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 146; }

    CreateUserMappingStmt();
    CreateUserMappingStmt(std::unique_ptr<::pg_query::RoleSpec> arg_user, const std::string& arg_servername, bool arg_if_not_exists, std::vector<::pg_query::Node> arg_options);
    CreateUserMappingStmt(const CreateUserMappingStmt& other) = delete;
    CreateUserMappingStmt(CreateUserMappingStmt&& other) noexcept;
    ~CreateUserMappingStmt() override;

    CreateUserMappingStmt& operator=(const CreateUserMappingStmt& other) = delete;
    CreateUserMappingStmt& operator=(CreateUserMappingStmt&& other) noexcept;

    bool operator==(const CreateUserMappingStmt& other) const noexcept;
    bool operator!=(const CreateUserMappingStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateUserMappingStmt& other) const noexcept;
    bool operator<=(const CreateUserMappingStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateUserMappingStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateUserMappingStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateUserMappingStmt& value);

    void swap(CreateUserMappingStmt& other) noexcept;
    friend void swap(CreateUserMappingStmt& value1, CreateUserMappingStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateUserMappingStmt>
{
    typedef pg_query::CreateUserMappingStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct AlterUserMappingStmt : FBE::Base
{
    ::pg_query::RoleSpec* user;
    std::string servername;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 147; }

    AlterUserMappingStmt();
    AlterUserMappingStmt(std::unique_ptr<::pg_query::RoleSpec> arg_user, const std::string& arg_servername, std::vector<::pg_query::Node> arg_options);
    AlterUserMappingStmt(const AlterUserMappingStmt& other) = delete;
    AlterUserMappingStmt(AlterUserMappingStmt&& other) noexcept;
    ~AlterUserMappingStmt() override;

    AlterUserMappingStmt& operator=(const AlterUserMappingStmt& other) = delete;
    AlterUserMappingStmt& operator=(AlterUserMappingStmt&& other) noexcept;

    bool operator==(const AlterUserMappingStmt& other) const noexcept;
    bool operator!=(const AlterUserMappingStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterUserMappingStmt& other) const noexcept;
    bool operator<=(const AlterUserMappingStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterUserMappingStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterUserMappingStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterUserMappingStmt& value);

    void swap(AlterUserMappingStmt& other) noexcept;
    friend void swap(AlterUserMappingStmt& value1, AlterUserMappingStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterUserMappingStmt>
{
    typedef pg_query::AlterUserMappingStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec;

struct DropUserMappingStmt : FBE::Base
{
    ::pg_query::RoleSpec* user;
    std::string servername;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 148; }

    DropUserMappingStmt();
    DropUserMappingStmt(std::unique_ptr<::pg_query::RoleSpec> arg_user, const std::string& arg_servername, bool arg_missing_ok);
    DropUserMappingStmt(const DropUserMappingStmt& other) = delete;
    DropUserMappingStmt(DropUserMappingStmt&& other) noexcept;
    ~DropUserMappingStmt() override;

    DropUserMappingStmt& operator=(const DropUserMappingStmt& other) = delete;
    DropUserMappingStmt& operator=(DropUserMappingStmt&& other) noexcept;

    bool operator==(const DropUserMappingStmt& other) const noexcept;
    bool operator!=(const DropUserMappingStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DropUserMappingStmt& other) const noexcept;
    bool operator<=(const DropUserMappingStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DropUserMappingStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DropUserMappingStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DropUserMappingStmt& value);

    void swap(DropUserMappingStmt& other) noexcept;
    friend void swap(DropUserMappingStmt& value1, DropUserMappingStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DropUserMappingStmt>
{
    typedef pg_query::DropUserMappingStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterTableSpaceOptionsStmt : FBE::Base
{
    std::string tablespacename;
    std::vector<::pg_query::Node> options;
    bool is_reset;

    size_t fbe_type() const noexcept { return 149; }

    AlterTableSpaceOptionsStmt();
    AlterTableSpaceOptionsStmt(const std::string& arg_tablespacename, std::vector<::pg_query::Node> arg_options, bool arg_is_reset);
    AlterTableSpaceOptionsStmt(const AlterTableSpaceOptionsStmt& other) = delete;
    AlterTableSpaceOptionsStmt(AlterTableSpaceOptionsStmt&& other) noexcept;
    ~AlterTableSpaceOptionsStmt() override;

    AlterTableSpaceOptionsStmt& operator=(const AlterTableSpaceOptionsStmt& other) = delete;
    AlterTableSpaceOptionsStmt& operator=(AlterTableSpaceOptionsStmt&& other) noexcept;

    bool operator==(const AlterTableSpaceOptionsStmt& other) const noexcept;
    bool operator!=(const AlterTableSpaceOptionsStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterTableSpaceOptionsStmt& other) const noexcept;
    bool operator<=(const AlterTableSpaceOptionsStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterTableSpaceOptionsStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterTableSpaceOptionsStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterTableSpaceOptionsStmt& value);

    void swap(AlterTableSpaceOptionsStmt& other) noexcept;
    friend void swap(AlterTableSpaceOptionsStmt& value1, AlterTableSpaceOptionsStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterTableSpaceOptionsStmt>
{
    typedef pg_query::AlterTableSpaceOptionsStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterTableMoveAllStmt : FBE::Base
{
    std::string orig_tablespacename;
    ::pg_query::ObjectType objtype;
    std::vector<::pg_query::Node> roles;
    std::string new_tablespacename;
    bool nowait;

    size_t fbe_type() const noexcept { return 150; }

    AlterTableMoveAllStmt();
    AlterTableMoveAllStmt(const std::string& arg_orig_tablespacename, ::pg_query::ObjectType&& arg_objtype, std::vector<::pg_query::Node> arg_roles, const std::string& arg_new_tablespacename, bool arg_nowait);
    AlterTableMoveAllStmt(const AlterTableMoveAllStmt& other) = delete;
    AlterTableMoveAllStmt(AlterTableMoveAllStmt&& other) noexcept;
    ~AlterTableMoveAllStmt() override;

    AlterTableMoveAllStmt& operator=(const AlterTableMoveAllStmt& other) = delete;
    AlterTableMoveAllStmt& operator=(AlterTableMoveAllStmt&& other) noexcept;

    bool operator==(const AlterTableMoveAllStmt& other) const noexcept;
    bool operator!=(const AlterTableMoveAllStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterTableMoveAllStmt& other) const noexcept;
    bool operator<=(const AlterTableMoveAllStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterTableMoveAllStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterTableMoveAllStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterTableMoveAllStmt& value);

    void swap(AlterTableMoveAllStmt& other) noexcept;
    friend void swap(AlterTableMoveAllStmt& value1, AlterTableMoveAllStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterTableMoveAllStmt>
{
    typedef pg_query::AlterTableMoveAllStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct SecLabelStmt : FBE::Base
{
    ::pg_query::ObjectType objtype;
    ::pg_query::Node object;
    std::string provider;
    std::string label;

    size_t fbe_type() const noexcept { return 151; }

    SecLabelStmt();
    SecLabelStmt(::pg_query::ObjectType&& arg_objtype, ::pg_query::Node&& arg_object, const std::string& arg_provider, const std::string& arg_label);
    SecLabelStmt(const SecLabelStmt& other) = delete;
    SecLabelStmt(SecLabelStmt&& other) noexcept;
    ~SecLabelStmt() override;

    SecLabelStmt& operator=(const SecLabelStmt& other) = delete;
    SecLabelStmt& operator=(SecLabelStmt&& other) noexcept;

    bool operator==(const SecLabelStmt& other) const noexcept;
    bool operator!=(const SecLabelStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const SecLabelStmt& other) const noexcept;
    bool operator<=(const SecLabelStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SecLabelStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SecLabelStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SecLabelStmt& value);

    void swap(SecLabelStmt& other) noexcept;
    friend void swap(SecLabelStmt& value1, SecLabelStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SecLabelStmt>
{
    typedef pg_query::SecLabelStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateForeignTableStmt : FBE::Base
{
    ::pg_query::CreateStmt base_stmt;
    std::string servername;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 152; }

    CreateForeignTableStmt();
    CreateForeignTableStmt(::pg_query::CreateStmt&& arg_base_stmt, const std::string& arg_servername, std::vector<::pg_query::Node> arg_options);
    CreateForeignTableStmt(const CreateForeignTableStmt& other) = delete;
    CreateForeignTableStmt(CreateForeignTableStmt&& other) noexcept;
    ~CreateForeignTableStmt() override;

    CreateForeignTableStmt& operator=(const CreateForeignTableStmt& other) = delete;
    CreateForeignTableStmt& operator=(CreateForeignTableStmt&& other) noexcept;

    bool operator==(const CreateForeignTableStmt& other) const noexcept;
    bool operator!=(const CreateForeignTableStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateForeignTableStmt& other) const noexcept;
    bool operator<=(const CreateForeignTableStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateForeignTableStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateForeignTableStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateForeignTableStmt& value);

    void swap(CreateForeignTableStmt& other) noexcept;
    friend void swap(CreateForeignTableStmt& value1, CreateForeignTableStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateForeignTableStmt>
{
    typedef pg_query::CreateForeignTableStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ImportForeignSchemaStmt : FBE::Base
{
    std::string server_name;
    std::string remote_schema;
    std::string local_schema;
    ::pg_query::ImportForeignSchemaType list_type;
    std::vector<::pg_query::Node> table_list;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 153; }

    ImportForeignSchemaStmt();
    ImportForeignSchemaStmt(const std::string& arg_server_name, const std::string& arg_remote_schema, const std::string& arg_local_schema, ::pg_query::ImportForeignSchemaType&& arg_list_type, std::vector<::pg_query::Node> arg_table_list, std::vector<::pg_query::Node> arg_options);
    ImportForeignSchemaStmt(const ImportForeignSchemaStmt& other) = delete;
    ImportForeignSchemaStmt(ImportForeignSchemaStmt&& other) noexcept;
    ~ImportForeignSchemaStmt() override;

    ImportForeignSchemaStmt& operator=(const ImportForeignSchemaStmt& other) = delete;
    ImportForeignSchemaStmt& operator=(ImportForeignSchemaStmt&& other) noexcept;

    bool operator==(const ImportForeignSchemaStmt& other) const noexcept;
    bool operator!=(const ImportForeignSchemaStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ImportForeignSchemaStmt& other) const noexcept;
    bool operator<=(const ImportForeignSchemaStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ImportForeignSchemaStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ImportForeignSchemaStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ImportForeignSchemaStmt& value);

    void swap(ImportForeignSchemaStmt& other) noexcept;
    friend void swap(ImportForeignSchemaStmt& value1, ImportForeignSchemaStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ImportForeignSchemaStmt>
{
    typedef pg_query::ImportForeignSchemaStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateExtensionStmt : FBE::Base
{
    std::string extname;
    bool if_not_exists;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 154; }

    CreateExtensionStmt();
    CreateExtensionStmt(const std::string& arg_extname, bool arg_if_not_exists, std::vector<::pg_query::Node> arg_options);
    CreateExtensionStmt(const CreateExtensionStmt& other) = delete;
    CreateExtensionStmt(CreateExtensionStmt&& other) noexcept;
    ~CreateExtensionStmt() override;

    CreateExtensionStmt& operator=(const CreateExtensionStmt& other) = delete;
    CreateExtensionStmt& operator=(CreateExtensionStmt&& other) noexcept;

    bool operator==(const CreateExtensionStmt& other) const noexcept;
    bool operator!=(const CreateExtensionStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateExtensionStmt& other) const noexcept;
    bool operator<=(const CreateExtensionStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateExtensionStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateExtensionStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateExtensionStmt& value);

    void swap(CreateExtensionStmt& other) noexcept;
    friend void swap(CreateExtensionStmt& value1, CreateExtensionStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateExtensionStmt>
{
    typedef pg_query::CreateExtensionStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterExtensionStmt : FBE::Base
{
    std::string extname;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 155; }

    AlterExtensionStmt();
    AlterExtensionStmt(const std::string& arg_extname, std::vector<::pg_query::Node> arg_options);
    AlterExtensionStmt(const AlterExtensionStmt& other) = delete;
    AlterExtensionStmt(AlterExtensionStmt&& other) noexcept;
    ~AlterExtensionStmt() override;

    AlterExtensionStmt& operator=(const AlterExtensionStmt& other) = delete;
    AlterExtensionStmt& operator=(AlterExtensionStmt&& other) noexcept;

    bool operator==(const AlterExtensionStmt& other) const noexcept;
    bool operator!=(const AlterExtensionStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterExtensionStmt& other) const noexcept;
    bool operator<=(const AlterExtensionStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterExtensionStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterExtensionStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterExtensionStmt& value);

    void swap(AlterExtensionStmt& other) noexcept;
    friend void swap(AlterExtensionStmt& value1, AlterExtensionStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterExtensionStmt>
{
    typedef pg_query::AlterExtensionStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterExtensionContentsStmt : FBE::Base
{
    std::string extname;
    int32_t action;
    ::pg_query::ObjectType objtype;
    ::pg_query::Node object;

    size_t fbe_type() const noexcept { return 156; }

    AlterExtensionContentsStmt();
    AlterExtensionContentsStmt(const std::string& arg_extname, int32_t arg_action, ::pg_query::ObjectType&& arg_objtype, ::pg_query::Node&& arg_object);
    AlterExtensionContentsStmt(const AlterExtensionContentsStmt& other) = delete;
    AlterExtensionContentsStmt(AlterExtensionContentsStmt&& other) noexcept;
    ~AlterExtensionContentsStmt() override;

    AlterExtensionContentsStmt& operator=(const AlterExtensionContentsStmt& other) = delete;
    AlterExtensionContentsStmt& operator=(AlterExtensionContentsStmt&& other) noexcept;

    bool operator==(const AlterExtensionContentsStmt& other) const noexcept;
    bool operator!=(const AlterExtensionContentsStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterExtensionContentsStmt& other) const noexcept;
    bool operator<=(const AlterExtensionContentsStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterExtensionContentsStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterExtensionContentsStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterExtensionContentsStmt& value);

    void swap(AlterExtensionContentsStmt& other) noexcept;
    friend void swap(AlterExtensionContentsStmt& value1, AlterExtensionContentsStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterExtensionContentsStmt>
{
    typedef pg_query::AlterExtensionContentsStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateEventTrigStmt : FBE::Base
{
    std::string trigname;
    std::string eventname;
    std::vector<::pg_query::Node> whenclause;
    std::vector<::pg_query::Node> funcname;

    size_t fbe_type() const noexcept { return 157; }

    CreateEventTrigStmt();
    CreateEventTrigStmt(const std::string& arg_trigname, const std::string& arg_eventname, std::vector<::pg_query::Node> arg_whenclause, std::vector<::pg_query::Node> arg_funcname);
    CreateEventTrigStmt(const CreateEventTrigStmt& other) = delete;
    CreateEventTrigStmt(CreateEventTrigStmt&& other) noexcept;
    ~CreateEventTrigStmt() override;

    CreateEventTrigStmt& operator=(const CreateEventTrigStmt& other) = delete;
    CreateEventTrigStmt& operator=(CreateEventTrigStmt&& other) noexcept;

    bool operator==(const CreateEventTrigStmt& other) const noexcept;
    bool operator!=(const CreateEventTrigStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateEventTrigStmt& other) const noexcept;
    bool operator<=(const CreateEventTrigStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateEventTrigStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateEventTrigStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateEventTrigStmt& value);

    void swap(CreateEventTrigStmt& other) noexcept;
    friend void swap(CreateEventTrigStmt& value1, CreateEventTrigStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateEventTrigStmt>
{
    typedef pg_query::CreateEventTrigStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterEventTrigStmt : FBE::Base
{
    std::string trigname;
    std::string tgenabled;

    size_t fbe_type() const noexcept { return 158; }

    AlterEventTrigStmt();
    AlterEventTrigStmt(const std::string& arg_trigname, const std::string& arg_tgenabled);
    AlterEventTrigStmt(const AlterEventTrigStmt& other) = delete;
    AlterEventTrigStmt(AlterEventTrigStmt&& other) noexcept;
    ~AlterEventTrigStmt() override;

    AlterEventTrigStmt& operator=(const AlterEventTrigStmt& other) = delete;
    AlterEventTrigStmt& operator=(AlterEventTrigStmt&& other) noexcept;

    bool operator==(const AlterEventTrigStmt& other) const noexcept;
    bool operator!=(const AlterEventTrigStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterEventTrigStmt& other) const noexcept;
    bool operator<=(const AlterEventTrigStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterEventTrigStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterEventTrigStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterEventTrigStmt& value);

    void swap(AlterEventTrigStmt& other) noexcept;
    friend void swap(AlterEventTrigStmt& value1, AlterEventTrigStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterEventTrigStmt>
{
    typedef pg_query::AlterEventTrigStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct RefreshMatViewStmt : FBE::Base
{
    bool concurrent;
    bool skip_data;
    ::pg_query::RangeVar* relation;

    size_t fbe_type() const noexcept { return 159; }

    RefreshMatViewStmt();
    RefreshMatViewStmt(bool arg_concurrent, bool arg_skip_data, std::unique_ptr<::pg_query::RangeVar> arg_relation);
    RefreshMatViewStmt(const RefreshMatViewStmt& other) = delete;
    RefreshMatViewStmt(RefreshMatViewStmt&& other) noexcept;
    ~RefreshMatViewStmt() override;

    RefreshMatViewStmt& operator=(const RefreshMatViewStmt& other) = delete;
    RefreshMatViewStmt& operator=(RefreshMatViewStmt&& other) noexcept;

    bool operator==(const RefreshMatViewStmt& other) const noexcept;
    bool operator!=(const RefreshMatViewStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const RefreshMatViewStmt& other) const noexcept;
    bool operator<=(const RefreshMatViewStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RefreshMatViewStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RefreshMatViewStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RefreshMatViewStmt& value);

    void swap(RefreshMatViewStmt& other) noexcept;
    friend void swap(RefreshMatViewStmt& value1, RefreshMatViewStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RefreshMatViewStmt>
{
    typedef pg_query::RefreshMatViewStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ReplicaIdentityStmt : FBE::Base
{
    std::string identity_type;
    std::string name;

    size_t fbe_type() const noexcept { return 160; }

    ReplicaIdentityStmt();
    ReplicaIdentityStmt(const std::string& arg_identity_type, const std::string& arg_name);
    ReplicaIdentityStmt(const ReplicaIdentityStmt& other) = delete;
    ReplicaIdentityStmt(ReplicaIdentityStmt&& other) noexcept;
    ~ReplicaIdentityStmt() override;

    ReplicaIdentityStmt& operator=(const ReplicaIdentityStmt& other) = delete;
    ReplicaIdentityStmt& operator=(ReplicaIdentityStmt&& other) noexcept;

    bool operator==(const ReplicaIdentityStmt& other) const noexcept;
    bool operator!=(const ReplicaIdentityStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const ReplicaIdentityStmt& other) const noexcept;
    bool operator<=(const ReplicaIdentityStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ReplicaIdentityStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ReplicaIdentityStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ReplicaIdentityStmt& value);

    void swap(ReplicaIdentityStmt& other) noexcept;
    friend void swap(ReplicaIdentityStmt& value1, ReplicaIdentityStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ReplicaIdentityStmt>
{
    typedef pg_query::ReplicaIdentityStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct VariableSetStmt;

struct AlterSystemStmt : FBE::Base
{
    ::pg_query::VariableSetStmt* setstmt;

    size_t fbe_type() const noexcept { return 161; }

    AlterSystemStmt();
    explicit AlterSystemStmt(std::unique_ptr<::pg_query::VariableSetStmt> arg_setstmt);
    AlterSystemStmt(const AlterSystemStmt& other) = delete;
    AlterSystemStmt(AlterSystemStmt&& other) noexcept;
    ~AlterSystemStmt() override;

    AlterSystemStmt& operator=(const AlterSystemStmt& other) = delete;
    AlterSystemStmt& operator=(AlterSystemStmt&& other) noexcept;

    bool operator==(const AlterSystemStmt& other) const noexcept;
    bool operator!=(const AlterSystemStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterSystemStmt& other) const noexcept;
    bool operator<=(const AlterSystemStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterSystemStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterSystemStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterSystemStmt& value);

    void swap(AlterSystemStmt& other) noexcept;
    friend void swap(AlterSystemStmt& value1, AlterSystemStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterSystemStmt>
{
    typedef pg_query::AlterSystemStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct CreatePolicyStmt : FBE::Base
{
    std::string policy_name;
    ::pg_query::RangeVar* table;
    std::string cmd_name;
    bool permissive;
    std::vector<::pg_query::Node> roles;
    ::pg_query::Node qual;
    ::pg_query::Node with_check;

    size_t fbe_type() const noexcept { return 162; }

    CreatePolicyStmt();
    CreatePolicyStmt(const std::string& arg_policy_name, std::unique_ptr<::pg_query::RangeVar> arg_table, const std::string& arg_cmd_name, bool arg_permissive, std::vector<::pg_query::Node> arg_roles, ::pg_query::Node&& arg_qual, ::pg_query::Node&& arg_with_check);
    CreatePolicyStmt(const CreatePolicyStmt& other) = delete;
    CreatePolicyStmt(CreatePolicyStmt&& other) noexcept;
    ~CreatePolicyStmt() override;

    CreatePolicyStmt& operator=(const CreatePolicyStmt& other) = delete;
    CreatePolicyStmt& operator=(CreatePolicyStmt&& other) noexcept;

    bool operator==(const CreatePolicyStmt& other) const noexcept;
    bool operator!=(const CreatePolicyStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreatePolicyStmt& other) const noexcept;
    bool operator<=(const CreatePolicyStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreatePolicyStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreatePolicyStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreatePolicyStmt& value);

    void swap(CreatePolicyStmt& other) noexcept;
    friend void swap(CreatePolicyStmt& value1, CreatePolicyStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreatePolicyStmt>
{
    typedef pg_query::CreatePolicyStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct AlterPolicyStmt : FBE::Base
{
    std::string policy_name;
    ::pg_query::RangeVar* table;
    std::vector<::pg_query::Node> roles;
    ::pg_query::Node qual;
    ::pg_query::Node with_check;

    size_t fbe_type() const noexcept { return 163; }

    AlterPolicyStmt();
    AlterPolicyStmt(const std::string& arg_policy_name, std::unique_ptr<::pg_query::RangeVar> arg_table, std::vector<::pg_query::Node> arg_roles, ::pg_query::Node&& arg_qual, ::pg_query::Node&& arg_with_check);
    AlterPolicyStmt(const AlterPolicyStmt& other) = delete;
    AlterPolicyStmt(AlterPolicyStmt&& other) noexcept;
    ~AlterPolicyStmt() override;

    AlterPolicyStmt& operator=(const AlterPolicyStmt& other) = delete;
    AlterPolicyStmt& operator=(AlterPolicyStmt&& other) noexcept;

    bool operator==(const AlterPolicyStmt& other) const noexcept;
    bool operator!=(const AlterPolicyStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterPolicyStmt& other) const noexcept;
    bool operator<=(const AlterPolicyStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterPolicyStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterPolicyStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterPolicyStmt& value);

    void swap(AlterPolicyStmt& other) noexcept;
    friend void swap(AlterPolicyStmt& value1, AlterPolicyStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterPolicyStmt>
{
    typedef pg_query::AlterPolicyStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct ObjectWithArgs;

struct CreateTransformStmt : FBE::Base
{
    bool replace;
    ::pg_query::TypeName* type_name;
    std::string lang;
    ::pg_query::ObjectWithArgs* fromsql;
    ::pg_query::ObjectWithArgs* tosql;

    size_t fbe_type() const noexcept { return 164; }

    CreateTransformStmt();
    CreateTransformStmt(bool arg_replace, std::unique_ptr<::pg_query::TypeName> arg_type_name, const std::string& arg_lang, std::unique_ptr<::pg_query::ObjectWithArgs> arg_fromsql, std::unique_ptr<::pg_query::ObjectWithArgs> arg_tosql);
    CreateTransformStmt(const CreateTransformStmt& other) = delete;
    CreateTransformStmt(CreateTransformStmt&& other) noexcept;
    ~CreateTransformStmt() override;

    CreateTransformStmt& operator=(const CreateTransformStmt& other) = delete;
    CreateTransformStmt& operator=(CreateTransformStmt&& other) noexcept;

    bool operator==(const CreateTransformStmt& other) const noexcept;
    bool operator!=(const CreateTransformStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateTransformStmt& other) const noexcept;
    bool operator<=(const CreateTransformStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateTransformStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateTransformStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateTransformStmt& value);

    void swap(CreateTransformStmt& other) noexcept;
    friend void swap(CreateTransformStmt& value1, CreateTransformStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateTransformStmt>
{
    typedef pg_query::CreateTransformStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateAmStmt : FBE::Base
{
    std::string amname;
    std::vector<::pg_query::Node> handler_name;
    std::string amtype;

    size_t fbe_type() const noexcept { return 165; }

    CreateAmStmt();
    CreateAmStmt(const std::string& arg_amname, std::vector<::pg_query::Node> arg_handler_name, const std::string& arg_amtype);
    CreateAmStmt(const CreateAmStmt& other) = delete;
    CreateAmStmt(CreateAmStmt&& other) noexcept;
    ~CreateAmStmt() override;

    CreateAmStmt& operator=(const CreateAmStmt& other) = delete;
    CreateAmStmt& operator=(CreateAmStmt&& other) noexcept;

    bool operator==(const CreateAmStmt& other) const noexcept;
    bool operator!=(const CreateAmStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateAmStmt& other) const noexcept;
    bool operator<=(const CreateAmStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateAmStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateAmStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateAmStmt& value);

    void swap(CreateAmStmt& other) noexcept;
    friend void swap(CreateAmStmt& value1, CreateAmStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateAmStmt>
{
    typedef pg_query::CreateAmStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreatePublicationStmt : FBE::Base
{
    std::string pubname;
    std::vector<::pg_query::Node> options;
    std::vector<::pg_query::Node> tables;
    bool for_all_tables;

    size_t fbe_type() const noexcept { return 166; }

    CreatePublicationStmt();
    CreatePublicationStmt(const std::string& arg_pubname, std::vector<::pg_query::Node> arg_options, std::vector<::pg_query::Node> arg_tables, bool arg_for_all_tables);
    CreatePublicationStmt(const CreatePublicationStmt& other) = delete;
    CreatePublicationStmt(CreatePublicationStmt&& other) noexcept;
    ~CreatePublicationStmt() override;

    CreatePublicationStmt& operator=(const CreatePublicationStmt& other) = delete;
    CreatePublicationStmt& operator=(CreatePublicationStmt&& other) noexcept;

    bool operator==(const CreatePublicationStmt& other) const noexcept;
    bool operator!=(const CreatePublicationStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreatePublicationStmt& other) const noexcept;
    bool operator<=(const CreatePublicationStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreatePublicationStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreatePublicationStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreatePublicationStmt& value);

    void swap(CreatePublicationStmt& other) noexcept;
    friend void swap(CreatePublicationStmt& value1, CreatePublicationStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreatePublicationStmt>
{
    typedef pg_query::CreatePublicationStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterPublicationStmt : FBE::Base
{
    std::string pubname;
    std::vector<::pg_query::Node> options;
    std::vector<::pg_query::Node> tables;
    bool for_all_tables;
    ::pg_query::DefElemAction table_action;

    size_t fbe_type() const noexcept { return 167; }

    AlterPublicationStmt();
    AlterPublicationStmt(const std::string& arg_pubname, std::vector<::pg_query::Node> arg_options, std::vector<::pg_query::Node> arg_tables, bool arg_for_all_tables, ::pg_query::DefElemAction&& arg_table_action);
    AlterPublicationStmt(const AlterPublicationStmt& other) = delete;
    AlterPublicationStmt(AlterPublicationStmt&& other) noexcept;
    ~AlterPublicationStmt() override;

    AlterPublicationStmt& operator=(const AlterPublicationStmt& other) = delete;
    AlterPublicationStmt& operator=(AlterPublicationStmt&& other) noexcept;

    bool operator==(const AlterPublicationStmt& other) const noexcept;
    bool operator!=(const AlterPublicationStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterPublicationStmt& other) const noexcept;
    bool operator<=(const AlterPublicationStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterPublicationStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterPublicationStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterPublicationStmt& value);

    void swap(AlterPublicationStmt& other) noexcept;
    friend void swap(AlterPublicationStmt& value1, AlterPublicationStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterPublicationStmt>
{
    typedef pg_query::AlterPublicationStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateSubscriptionStmt : FBE::Base
{
    std::string subname;
    std::string conninfo;
    std::vector<::pg_query::Node> publication;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 168; }

    CreateSubscriptionStmt();
    CreateSubscriptionStmt(const std::string& arg_subname, const std::string& arg_conninfo, std::vector<::pg_query::Node> arg_publication, std::vector<::pg_query::Node> arg_options);
    CreateSubscriptionStmt(const CreateSubscriptionStmt& other) = delete;
    CreateSubscriptionStmt(CreateSubscriptionStmt&& other) noexcept;
    ~CreateSubscriptionStmt() override;

    CreateSubscriptionStmt& operator=(const CreateSubscriptionStmt& other) = delete;
    CreateSubscriptionStmt& operator=(CreateSubscriptionStmt&& other) noexcept;

    bool operator==(const CreateSubscriptionStmt& other) const noexcept;
    bool operator!=(const CreateSubscriptionStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateSubscriptionStmt& other) const noexcept;
    bool operator<=(const CreateSubscriptionStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateSubscriptionStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateSubscriptionStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateSubscriptionStmt& value);

    void swap(CreateSubscriptionStmt& other) noexcept;
    friend void swap(CreateSubscriptionStmt& value1, CreateSubscriptionStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateSubscriptionStmt>
{
    typedef pg_query::CreateSubscriptionStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterSubscriptionStmt : FBE::Base
{
    ::pg_query::AlterSubscriptionType kind;
    std::string subname;
    std::string conninfo;
    std::vector<::pg_query::Node> publication;
    std::vector<::pg_query::Node> options;

    size_t fbe_type() const noexcept { return 169; }

    AlterSubscriptionStmt();
    AlterSubscriptionStmt(::pg_query::AlterSubscriptionType&& arg_kind, const std::string& arg_subname, const std::string& arg_conninfo, std::vector<::pg_query::Node> arg_publication, std::vector<::pg_query::Node> arg_options);
    AlterSubscriptionStmt(const AlterSubscriptionStmt& other) = delete;
    AlterSubscriptionStmt(AlterSubscriptionStmt&& other) noexcept;
    ~AlterSubscriptionStmt() override;

    AlterSubscriptionStmt& operator=(const AlterSubscriptionStmt& other) = delete;
    AlterSubscriptionStmt& operator=(AlterSubscriptionStmt&& other) noexcept;

    bool operator==(const AlterSubscriptionStmt& other) const noexcept;
    bool operator!=(const AlterSubscriptionStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterSubscriptionStmt& other) const noexcept;
    bool operator<=(const AlterSubscriptionStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterSubscriptionStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterSubscriptionStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterSubscriptionStmt& value);

    void swap(AlterSubscriptionStmt& other) noexcept;
    friend void swap(AlterSubscriptionStmt& value1, AlterSubscriptionStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterSubscriptionStmt>
{
    typedef pg_query::AlterSubscriptionStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DropSubscriptionStmt : FBE::Base
{
    std::string subname;
    bool missing_ok;
    ::pg_query::DropBehavior behavior;

    size_t fbe_type() const noexcept { return 170; }

    DropSubscriptionStmt();
    DropSubscriptionStmt(const std::string& arg_subname, bool arg_missing_ok, ::pg_query::DropBehavior&& arg_behavior);
    DropSubscriptionStmt(const DropSubscriptionStmt& other) = delete;
    DropSubscriptionStmt(DropSubscriptionStmt&& other) noexcept;
    ~DropSubscriptionStmt() override;

    DropSubscriptionStmt& operator=(const DropSubscriptionStmt& other) = delete;
    DropSubscriptionStmt& operator=(DropSubscriptionStmt&& other) noexcept;

    bool operator==(const DropSubscriptionStmt& other) const noexcept;
    bool operator!=(const DropSubscriptionStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const DropSubscriptionStmt& other) const noexcept;
    bool operator<=(const DropSubscriptionStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DropSubscriptionStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DropSubscriptionStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DropSubscriptionStmt& value);

    void swap(DropSubscriptionStmt& other) noexcept;
    friend void swap(DropSubscriptionStmt& value1, DropSubscriptionStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DropSubscriptionStmt>
{
    typedef pg_query::DropSubscriptionStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CreateStatsStmt : FBE::Base
{
    std::vector<::pg_query::Node> defnames;
    std::vector<::pg_query::Node> stat_types;
    std::vector<::pg_query::Node> exprs;
    std::vector<::pg_query::Node> relations;
    std::string stxcomment;
    bool if_not_exists;

    size_t fbe_type() const noexcept { return 171; }

    CreateStatsStmt();
    CreateStatsStmt(std::vector<::pg_query::Node> arg_defnames, std::vector<::pg_query::Node> arg_stat_types, std::vector<::pg_query::Node> arg_exprs, std::vector<::pg_query::Node> arg_relations, const std::string& arg_stxcomment, bool arg_if_not_exists);
    CreateStatsStmt(const CreateStatsStmt& other) = delete;
    CreateStatsStmt(CreateStatsStmt&& other) noexcept;
    ~CreateStatsStmt() override;

    CreateStatsStmt& operator=(const CreateStatsStmt& other) = delete;
    CreateStatsStmt& operator=(CreateStatsStmt&& other) noexcept;

    bool operator==(const CreateStatsStmt& other) const noexcept;
    bool operator!=(const CreateStatsStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateStatsStmt& other) const noexcept;
    bool operator<=(const CreateStatsStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateStatsStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateStatsStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateStatsStmt& value);

    void swap(CreateStatsStmt& other) noexcept;
    friend void swap(CreateStatsStmt& value1, CreateStatsStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateStatsStmt>
{
    typedef pg_query::CreateStatsStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterCollationStmt : FBE::Base
{
    std::vector<::pg_query::Node> collname;

    size_t fbe_type() const noexcept { return 172; }

    AlterCollationStmt();
    explicit AlterCollationStmt(std::vector<::pg_query::Node> arg_collname);
    AlterCollationStmt(const AlterCollationStmt& other) = delete;
    AlterCollationStmt(AlterCollationStmt&& other) noexcept;
    ~AlterCollationStmt() override;

    AlterCollationStmt& operator=(const AlterCollationStmt& other) = delete;
    AlterCollationStmt& operator=(AlterCollationStmt&& other) noexcept;

    bool operator==(const AlterCollationStmt& other) const noexcept;
    bool operator!=(const AlterCollationStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterCollationStmt& other) const noexcept;
    bool operator<=(const AlterCollationStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterCollationStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterCollationStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterCollationStmt& value);

    void swap(AlterCollationStmt& other) noexcept;
    friend void swap(AlterCollationStmt& value1, AlterCollationStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterCollationStmt>
{
    typedef pg_query::AlterCollationStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct FuncCall;

struct FuncExpr;

struct CallStmt : FBE::Base
{
    ::pg_query::FuncCall* funccall;
    ::pg_query::FuncExpr* funcexpr;

    size_t fbe_type() const noexcept { return 173; }

    CallStmt();
    CallStmt(std::unique_ptr<::pg_query::FuncCall> arg_funccall, std::unique_ptr<::pg_query::FuncExpr> arg_funcexpr);
    CallStmt(const CallStmt& other) = delete;
    CallStmt(CallStmt&& other) noexcept;
    ~CallStmt() override;

    CallStmt& operator=(const CallStmt& other) = delete;
    CallStmt& operator=(CallStmt&& other) noexcept;

    bool operator==(const CallStmt& other) const noexcept;
    bool operator!=(const CallStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const CallStmt& other) const noexcept;
    bool operator<=(const CallStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CallStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CallStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CallStmt& value);

    void swap(CallStmt& other) noexcept;
    friend void swap(CallStmt& value1, CallStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CallStmt>
{
    typedef pg_query::CallStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AlterStatsStmt : FBE::Base
{
    std::vector<::pg_query::Node> defnames;
    int32_t stxstattarget;
    bool missing_ok;

    size_t fbe_type() const noexcept { return 174; }

    AlterStatsStmt();
    AlterStatsStmt(std::vector<::pg_query::Node> arg_defnames, int32_t arg_stxstattarget, bool arg_missing_ok);
    AlterStatsStmt(const AlterStatsStmt& other) = delete;
    AlterStatsStmt(AlterStatsStmt&& other) noexcept;
    ~AlterStatsStmt() override;

    AlterStatsStmt& operator=(const AlterStatsStmt& other) = delete;
    AlterStatsStmt& operator=(AlterStatsStmt&& other) noexcept;

    bool operator==(const AlterStatsStmt& other) const noexcept;
    bool operator!=(const AlterStatsStmt& other) const noexcept { return !operator==(other); }
    bool operator<(const AlterStatsStmt& other) const noexcept;
    bool operator<=(const AlterStatsStmt& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AlterStatsStmt& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AlterStatsStmt& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AlterStatsStmt& value);

    void swap(AlterStatsStmt& other) noexcept;
    friend void swap(AlterStatsStmt& value1, AlterStatsStmt& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AlterStatsStmt>
{
    typedef pg_query::AlterStatsStmt argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct A_Expr : FBE::Base
{
    ::pg_query::A_Expr_Kind kind;
    std::vector<::pg_query::Node> name;
    ::pg_query::Node lexpr;
    ::pg_query::Node rexpr;
    int32_t location;

    size_t fbe_type() const noexcept { return 175; }

    A_Expr();
    A_Expr(::pg_query::A_Expr_Kind&& arg_kind, std::vector<::pg_query::Node> arg_name, ::pg_query::Node&& arg_lexpr, ::pg_query::Node&& arg_rexpr, int32_t arg_location);
    A_Expr(const A_Expr& other) = delete;
    A_Expr(A_Expr&& other) noexcept;
    ~A_Expr() override;

    A_Expr& operator=(const A_Expr& other) = delete;
    A_Expr& operator=(A_Expr&& other) noexcept;

    bool operator==(const A_Expr& other) const noexcept;
    bool operator!=(const A_Expr& other) const noexcept { return !operator==(other); }
    bool operator<(const A_Expr& other) const noexcept;
    bool operator<=(const A_Expr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const A_Expr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const A_Expr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const A_Expr& value);

    void swap(A_Expr& other) noexcept;
    friend void swap(A_Expr& value1, A_Expr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::A_Expr>
{
    typedef pg_query::A_Expr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ColumnRef : FBE::Base
{
    std::vector<::pg_query::Node> fields;
    int32_t location;

    size_t fbe_type() const noexcept { return 176; }

    ColumnRef();
    ColumnRef(std::vector<::pg_query::Node> arg_fields, int32_t arg_location);
    ColumnRef(const ColumnRef& other) = delete;
    ColumnRef(ColumnRef&& other) noexcept;
    ~ColumnRef() override;

    ColumnRef& operator=(const ColumnRef& other) = delete;
    ColumnRef& operator=(ColumnRef&& other) noexcept;

    bool operator==(const ColumnRef& other) const noexcept;
    bool operator!=(const ColumnRef& other) const noexcept { return !operator==(other); }
    bool operator<(const ColumnRef& other) const noexcept;
    bool operator<=(const ColumnRef& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ColumnRef& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ColumnRef& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ColumnRef& value);

    void swap(ColumnRef& other) noexcept;
    friend void swap(ColumnRef& value1, ColumnRef& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ColumnRef>
{
    typedef pg_query::ColumnRef argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ParamRef : FBE::Base
{
    int32_t number;
    int32_t location;

    size_t fbe_type() const noexcept { return 177; }

    ParamRef();
    ParamRef(int32_t arg_number, int32_t arg_location);
    ParamRef(const ParamRef& other) = delete;
    ParamRef(ParamRef&& other) noexcept;
    ~ParamRef() override;

    ParamRef& operator=(const ParamRef& other) = delete;
    ParamRef& operator=(ParamRef&& other) noexcept;

    bool operator==(const ParamRef& other) const noexcept;
    bool operator!=(const ParamRef& other) const noexcept { return !operator==(other); }
    bool operator<(const ParamRef& other) const noexcept;
    bool operator<=(const ParamRef& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ParamRef& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ParamRef& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ParamRef& value);

    void swap(ParamRef& other) noexcept;
    friend void swap(ParamRef& value1, ParamRef& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ParamRef>
{
    typedef pg_query::ParamRef argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct A_Const : FBE::Base
{
    ::pg_query::Node val;
    int32_t location;

    size_t fbe_type() const noexcept { return 178; }

    A_Const();
    A_Const(::pg_query::Node&& arg_val, int32_t arg_location);
    A_Const(const A_Const& other) = delete;
    A_Const(A_Const&& other) noexcept;
    ~A_Const() override;

    A_Const& operator=(const A_Const& other) = delete;
    A_Const& operator=(A_Const&& other) noexcept;

    bool operator==(const A_Const& other) const noexcept;
    bool operator!=(const A_Const& other) const noexcept { return !operator==(other); }
    bool operator<(const A_Const& other) const noexcept;
    bool operator<=(const A_Const& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const A_Const& other) const noexcept { return !operator<=(other); }
    bool operator>=(const A_Const& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const A_Const& value);

    void swap(A_Const& other) noexcept;
    friend void swap(A_Const& value1, A_Const& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::A_Const>
{
    typedef pg_query::A_Const argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct WindowDef;

struct FuncCall : FBE::Base
{
    std::vector<::pg_query::Node> funcname;
    std::vector<::pg_query::Node> args;
    std::vector<::pg_query::Node> agg_order;
    ::pg_query::Node agg_filter;
    bool agg_within_group;
    bool agg_star;
    bool agg_distinct;
    bool func_variadic;
    ::pg_query::WindowDef* over;
    int32_t location;

    size_t fbe_type() const noexcept { return 179; }

    FuncCall();
    FuncCall(std::vector<::pg_query::Node> arg_funcname, std::vector<::pg_query::Node> arg_args, std::vector<::pg_query::Node> arg_agg_order, ::pg_query::Node&& arg_agg_filter, bool arg_agg_within_group, bool arg_agg_star, bool arg_agg_distinct, bool arg_func_variadic, std::unique_ptr<::pg_query::WindowDef> arg_over, int32_t arg_location);
    FuncCall(const FuncCall& other) = delete;
    FuncCall(FuncCall&& other) noexcept;
    ~FuncCall() override;

    FuncCall& operator=(const FuncCall& other) = delete;
    FuncCall& operator=(FuncCall&& other) noexcept;

    bool operator==(const FuncCall& other) const noexcept;
    bool operator!=(const FuncCall& other) const noexcept { return !operator==(other); }
    bool operator<(const FuncCall& other) const noexcept;
    bool operator<=(const FuncCall& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const FuncCall& other) const noexcept { return !operator<=(other); }
    bool operator>=(const FuncCall& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const FuncCall& value);

    void swap(FuncCall& other) noexcept;
    friend void swap(FuncCall& value1, FuncCall& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::FuncCall>
{
    typedef pg_query::FuncCall argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct A_Star : FBE::Base
{
    size_t fbe_type() const noexcept { return 180; }

    A_Star();
    A_Star(const A_Star& other) = delete;
    A_Star(A_Star&& other) noexcept;
    ~A_Star() override;

    A_Star& operator=(const A_Star& other) = delete;
    A_Star& operator=(A_Star&& other) noexcept;

    bool operator==(const A_Star& other) const noexcept;
    bool operator!=(const A_Star& other) const noexcept { return !operator==(other); }
    bool operator<(const A_Star& other) const noexcept;
    bool operator<=(const A_Star& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const A_Star& other) const noexcept { return !operator<=(other); }
    bool operator>=(const A_Star& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const A_Star& value);

    void swap(A_Star& other) noexcept;
    friend void swap(A_Star& value1, A_Star& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::A_Star>
{
    typedef pg_query::A_Star argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct A_Indices : FBE::Base
{
    bool is_slice;
    ::pg_query::Node lidx;
    ::pg_query::Node uidx;

    size_t fbe_type() const noexcept { return 181; }

    A_Indices();
    A_Indices(bool arg_is_slice, ::pg_query::Node&& arg_lidx, ::pg_query::Node&& arg_uidx);
    A_Indices(const A_Indices& other) = delete;
    A_Indices(A_Indices&& other) noexcept;
    ~A_Indices() override;

    A_Indices& operator=(const A_Indices& other) = delete;
    A_Indices& operator=(A_Indices&& other) noexcept;

    bool operator==(const A_Indices& other) const noexcept;
    bool operator!=(const A_Indices& other) const noexcept { return !operator==(other); }
    bool operator<(const A_Indices& other) const noexcept;
    bool operator<=(const A_Indices& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const A_Indices& other) const noexcept { return !operator<=(other); }
    bool operator>=(const A_Indices& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const A_Indices& value);

    void swap(A_Indices& other) noexcept;
    friend void swap(A_Indices& value1, A_Indices& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::A_Indices>
{
    typedef pg_query::A_Indices argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct A_Indirection : FBE::Base
{
    ::pg_query::Node arg;
    std::vector<::pg_query::Node> indirection;

    size_t fbe_type() const noexcept { return 182; }

    A_Indirection();
    A_Indirection(::pg_query::Node&& arg_arg, std::vector<::pg_query::Node> arg_indirection);
    A_Indirection(const A_Indirection& other) = delete;
    A_Indirection(A_Indirection&& other) noexcept;
    ~A_Indirection() override;

    A_Indirection& operator=(const A_Indirection& other) = delete;
    A_Indirection& operator=(A_Indirection&& other) noexcept;

    bool operator==(const A_Indirection& other) const noexcept;
    bool operator!=(const A_Indirection& other) const noexcept { return !operator==(other); }
    bool operator<(const A_Indirection& other) const noexcept;
    bool operator<=(const A_Indirection& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const A_Indirection& other) const noexcept { return !operator<=(other); }
    bool operator>=(const A_Indirection& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const A_Indirection& value);

    void swap(A_Indirection& other) noexcept;
    friend void swap(A_Indirection& value1, A_Indirection& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::A_Indirection>
{
    typedef pg_query::A_Indirection argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct A_ArrayExpr : FBE::Base
{
    std::vector<::pg_query::Node> elements;
    int32_t location;

    size_t fbe_type() const noexcept { return 183; }

    A_ArrayExpr();
    A_ArrayExpr(std::vector<::pg_query::Node> arg_elements, int32_t arg_location);
    A_ArrayExpr(const A_ArrayExpr& other) = delete;
    A_ArrayExpr(A_ArrayExpr&& other) noexcept;
    ~A_ArrayExpr() override;

    A_ArrayExpr& operator=(const A_ArrayExpr& other) = delete;
    A_ArrayExpr& operator=(A_ArrayExpr&& other) noexcept;

    bool operator==(const A_ArrayExpr& other) const noexcept;
    bool operator!=(const A_ArrayExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const A_ArrayExpr& other) const noexcept;
    bool operator<=(const A_ArrayExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const A_ArrayExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const A_ArrayExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const A_ArrayExpr& value);

    void swap(A_ArrayExpr& other) noexcept;
    friend void swap(A_ArrayExpr& value1, A_ArrayExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::A_ArrayExpr>
{
    typedef pg_query::A_ArrayExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ResTarget : FBE::Base
{
    std::string name;
    std::vector<::pg_query::Node> indirection;
    ::pg_query::Node val;
    int32_t location;

    size_t fbe_type() const noexcept { return 184; }

    ResTarget();
    ResTarget(const std::string& arg_name, std::vector<::pg_query::Node> arg_indirection, ::pg_query::Node&& arg_val, int32_t arg_location);
    ResTarget(const ResTarget& other) = delete;
    ResTarget(ResTarget&& other) noexcept;
    ~ResTarget() override;

    ResTarget& operator=(const ResTarget& other) = delete;
    ResTarget& operator=(ResTarget&& other) noexcept;

    bool operator==(const ResTarget& other) const noexcept;
    bool operator!=(const ResTarget& other) const noexcept { return !operator==(other); }
    bool operator<(const ResTarget& other) const noexcept;
    bool operator<=(const ResTarget& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ResTarget& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ResTarget& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ResTarget& value);

    void swap(ResTarget& other) noexcept;
    friend void swap(ResTarget& value1, ResTarget& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ResTarget>
{
    typedef pg_query::ResTarget argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct MultiAssignRef : FBE::Base
{
    ::pg_query::Node source;
    int32_t colno;
    int32_t ncolumns;

    size_t fbe_type() const noexcept { return 185; }

    MultiAssignRef();
    MultiAssignRef(::pg_query::Node&& arg_source, int32_t arg_colno, int32_t arg_ncolumns);
    MultiAssignRef(const MultiAssignRef& other) = delete;
    MultiAssignRef(MultiAssignRef&& other) noexcept;
    ~MultiAssignRef() override;

    MultiAssignRef& operator=(const MultiAssignRef& other) = delete;
    MultiAssignRef& operator=(MultiAssignRef&& other) noexcept;

    bool operator==(const MultiAssignRef& other) const noexcept;
    bool operator!=(const MultiAssignRef& other) const noexcept { return !operator==(other); }
    bool operator<(const MultiAssignRef& other) const noexcept;
    bool operator<=(const MultiAssignRef& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const MultiAssignRef& other) const noexcept { return !operator<=(other); }
    bool operator>=(const MultiAssignRef& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const MultiAssignRef& value);

    void swap(MultiAssignRef& other) noexcept;
    friend void swap(MultiAssignRef& value1, MultiAssignRef& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::MultiAssignRef>
{
    typedef pg_query::MultiAssignRef argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct TypeCast : FBE::Base
{
    ::pg_query::Node arg;
    ::pg_query::TypeName* type_name;
    int32_t location;

    size_t fbe_type() const noexcept { return 186; }

    TypeCast();
    TypeCast(::pg_query::Node&& arg_arg, std::unique_ptr<::pg_query::TypeName> arg_type_name, int32_t arg_location);
    TypeCast(const TypeCast& other) = delete;
    TypeCast(TypeCast&& other) noexcept;
    ~TypeCast() override;

    TypeCast& operator=(const TypeCast& other) = delete;
    TypeCast& operator=(TypeCast&& other) noexcept;

    bool operator==(const TypeCast& other) const noexcept;
    bool operator!=(const TypeCast& other) const noexcept { return !operator==(other); }
    bool operator<(const TypeCast& other) const noexcept;
    bool operator<=(const TypeCast& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const TypeCast& other) const noexcept { return !operator<=(other); }
    bool operator>=(const TypeCast& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const TypeCast& value);

    void swap(TypeCast& other) noexcept;
    friend void swap(TypeCast& value1, TypeCast& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::TypeCast>
{
    typedef pg_query::TypeCast argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CollateClause : FBE::Base
{
    ::pg_query::Node arg;
    std::vector<::pg_query::Node> collname;
    int32_t location;

    size_t fbe_type() const noexcept { return 187; }

    CollateClause();
    CollateClause(::pg_query::Node&& arg_arg, std::vector<::pg_query::Node> arg_collname, int32_t arg_location);
    CollateClause(const CollateClause& other) = delete;
    CollateClause(CollateClause&& other) noexcept;
    ~CollateClause() override;

    CollateClause& operator=(const CollateClause& other) = delete;
    CollateClause& operator=(CollateClause&& other) noexcept;

    bool operator==(const CollateClause& other) const noexcept;
    bool operator!=(const CollateClause& other) const noexcept { return !operator==(other); }
    bool operator<(const CollateClause& other) const noexcept;
    bool operator<=(const CollateClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CollateClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CollateClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CollateClause& value);

    void swap(CollateClause& other) noexcept;
    friend void swap(CollateClause& value1, CollateClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CollateClause>
{
    typedef pg_query::CollateClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct SortBy : FBE::Base
{
    ::pg_query::Node node;
    ::pg_query::SortByDir sortby_dir;
    ::pg_query::SortByNulls sortby_nulls;
    std::vector<::pg_query::Node> use_op;
    int32_t location;

    size_t fbe_type() const noexcept { return 188; }

    SortBy();
    SortBy(::pg_query::Node&& arg_node, ::pg_query::SortByDir&& arg_sortby_dir, ::pg_query::SortByNulls&& arg_sortby_nulls, std::vector<::pg_query::Node> arg_use_op, int32_t arg_location);
    SortBy(const SortBy& other) = delete;
    SortBy(SortBy&& other) noexcept;
    ~SortBy() override;

    SortBy& operator=(const SortBy& other) = delete;
    SortBy& operator=(SortBy&& other) noexcept;

    bool operator==(const SortBy& other) const noexcept;
    bool operator!=(const SortBy& other) const noexcept { return !operator==(other); }
    bool operator<(const SortBy& other) const noexcept;
    bool operator<=(const SortBy& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SortBy& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SortBy& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SortBy& value);

    void swap(SortBy& other) noexcept;
    friend void swap(SortBy& value1, SortBy& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SortBy>
{
    typedef pg_query::SortBy argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct WindowDef : FBE::Base
{
    std::string name;
    std::string refname;
    std::vector<::pg_query::Node> partition_clause;
    std::vector<::pg_query::Node> order_clause;
    int32_t frame_options;
    ::pg_query::Node start_offset;
    ::pg_query::Node end_offset;
    int32_t location;

    size_t fbe_type() const noexcept { return 189; }

    WindowDef();
    WindowDef(const std::string& arg_name, const std::string& arg_refname, std::vector<::pg_query::Node> arg_partition_clause, std::vector<::pg_query::Node> arg_order_clause, int32_t arg_frame_options, ::pg_query::Node&& arg_start_offset, ::pg_query::Node&& arg_end_offset, int32_t arg_location);
    WindowDef(const WindowDef& other) = delete;
    WindowDef(WindowDef&& other) noexcept;
    ~WindowDef() override;

    WindowDef& operator=(const WindowDef& other) = delete;
    WindowDef& operator=(WindowDef&& other) noexcept;

    bool operator==(const WindowDef& other) const noexcept;
    bool operator!=(const WindowDef& other) const noexcept { return !operator==(other); }
    bool operator<(const WindowDef& other) const noexcept;
    bool operator<=(const WindowDef& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const WindowDef& other) const noexcept { return !operator<=(other); }
    bool operator>=(const WindowDef& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const WindowDef& value);

    void swap(WindowDef& other) noexcept;
    friend void swap(WindowDef& value1, WindowDef& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::WindowDef>
{
    typedef pg_query::WindowDef argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Alias;

struct RangeSubselect : FBE::Base
{
    bool lateral;
    ::pg_query::Node subquery;
    ::pg_query::Alias* alias;

    size_t fbe_type() const noexcept { return 190; }

    RangeSubselect();
    RangeSubselect(bool arg_lateral, ::pg_query::Node&& arg_subquery, std::unique_ptr<::pg_query::Alias> arg_alias);
    RangeSubselect(const RangeSubselect& other) = delete;
    RangeSubselect(RangeSubselect&& other) noexcept;
    ~RangeSubselect() override;

    RangeSubselect& operator=(const RangeSubselect& other) = delete;
    RangeSubselect& operator=(RangeSubselect&& other) noexcept;

    bool operator==(const RangeSubselect& other) const noexcept;
    bool operator!=(const RangeSubselect& other) const noexcept { return !operator==(other); }
    bool operator<(const RangeSubselect& other) const noexcept;
    bool operator<=(const RangeSubselect& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RangeSubselect& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RangeSubselect& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RangeSubselect& value);

    void swap(RangeSubselect& other) noexcept;
    friend void swap(RangeSubselect& value1, RangeSubselect& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RangeSubselect>
{
    typedef pg_query::RangeSubselect argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Alias;

struct RangeFunction : FBE::Base
{
    bool lateral;
    bool ordinality;
    bool is_rowsfrom;
    std::vector<::pg_query::Node> functions;
    ::pg_query::Alias* alias;
    std::vector<::pg_query::Node> coldeflist;

    size_t fbe_type() const noexcept { return 191; }

    RangeFunction();
    RangeFunction(bool arg_lateral, bool arg_ordinality, bool arg_is_rowsfrom, std::vector<::pg_query::Node> arg_functions, std::unique_ptr<::pg_query::Alias> arg_alias, std::vector<::pg_query::Node> arg_coldeflist);
    RangeFunction(const RangeFunction& other) = delete;
    RangeFunction(RangeFunction&& other) noexcept;
    ~RangeFunction() override;

    RangeFunction& operator=(const RangeFunction& other) = delete;
    RangeFunction& operator=(RangeFunction&& other) noexcept;

    bool operator==(const RangeFunction& other) const noexcept;
    bool operator!=(const RangeFunction& other) const noexcept { return !operator==(other); }
    bool operator<(const RangeFunction& other) const noexcept;
    bool operator<=(const RangeFunction& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RangeFunction& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RangeFunction& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RangeFunction& value);

    void swap(RangeFunction& other) noexcept;
    friend void swap(RangeFunction& value1, RangeFunction& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RangeFunction>
{
    typedef pg_query::RangeFunction argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeTableSample : FBE::Base
{
    ::pg_query::Node relation;
    std::vector<::pg_query::Node> method;
    std::vector<::pg_query::Node> args;
    ::pg_query::Node repeatable;
    int32_t location;

    size_t fbe_type() const noexcept { return 192; }

    RangeTableSample();
    RangeTableSample(::pg_query::Node&& arg_relation, std::vector<::pg_query::Node> arg_method, std::vector<::pg_query::Node> arg_args, ::pg_query::Node&& arg_repeatable, int32_t arg_location);
    RangeTableSample(const RangeTableSample& other) = delete;
    RangeTableSample(RangeTableSample&& other) noexcept;
    ~RangeTableSample() override;

    RangeTableSample& operator=(const RangeTableSample& other) = delete;
    RangeTableSample& operator=(RangeTableSample&& other) noexcept;

    bool operator==(const RangeTableSample& other) const noexcept;
    bool operator!=(const RangeTableSample& other) const noexcept { return !operator==(other); }
    bool operator<(const RangeTableSample& other) const noexcept;
    bool operator<=(const RangeTableSample& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RangeTableSample& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RangeTableSample& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RangeTableSample& value);

    void swap(RangeTableSample& other) noexcept;
    friend void swap(RangeTableSample& value1, RangeTableSample& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RangeTableSample>
{
    typedef pg_query::RangeTableSample argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct Alias;

struct RangeTableFunc : FBE::Base
{
    bool lateral;
    ::pg_query::Node docexpr;
    ::pg_query::Node rowexpr;
    std::vector<::pg_query::Node> namespaces;
    std::vector<::pg_query::Node> columns;
    ::pg_query::Alias* alias;
    int32_t location;

    size_t fbe_type() const noexcept { return 193; }

    RangeTableFunc();
    RangeTableFunc(bool arg_lateral, ::pg_query::Node&& arg_docexpr, ::pg_query::Node&& arg_rowexpr, std::vector<::pg_query::Node> arg_namespaces, std::vector<::pg_query::Node> arg_columns, std::unique_ptr<::pg_query::Alias> arg_alias, int32_t arg_location);
    RangeTableFunc(const RangeTableFunc& other) = delete;
    RangeTableFunc(RangeTableFunc&& other) noexcept;
    ~RangeTableFunc() override;

    RangeTableFunc& operator=(const RangeTableFunc& other) = delete;
    RangeTableFunc& operator=(RangeTableFunc&& other) noexcept;

    bool operator==(const RangeTableFunc& other) const noexcept;
    bool operator!=(const RangeTableFunc& other) const noexcept { return !operator==(other); }
    bool operator<(const RangeTableFunc& other) const noexcept;
    bool operator<=(const RangeTableFunc& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RangeTableFunc& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RangeTableFunc& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RangeTableFunc& value);

    void swap(RangeTableFunc& other) noexcept;
    friend void swap(RangeTableFunc& value1, RangeTableFunc& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RangeTableFunc>
{
    typedef pg_query::RangeTableFunc argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct RangeTableFuncCol : FBE::Base
{
    std::string colname;
    ::pg_query::TypeName* type_name;
    bool for_ordinality;
    bool is_not_null;
    ::pg_query::Node colexpr;
    ::pg_query::Node coldefexpr;
    int32_t location;

    size_t fbe_type() const noexcept { return 194; }

    RangeTableFuncCol();
    RangeTableFuncCol(const std::string& arg_colname, std::unique_ptr<::pg_query::TypeName> arg_type_name, bool arg_for_ordinality, bool arg_is_not_null, ::pg_query::Node&& arg_colexpr, ::pg_query::Node&& arg_coldefexpr, int32_t arg_location);
    RangeTableFuncCol(const RangeTableFuncCol& other) = delete;
    RangeTableFuncCol(RangeTableFuncCol&& other) noexcept;
    ~RangeTableFuncCol() override;

    RangeTableFuncCol& operator=(const RangeTableFuncCol& other) = delete;
    RangeTableFuncCol& operator=(RangeTableFuncCol&& other) noexcept;

    bool operator==(const RangeTableFuncCol& other) const noexcept;
    bool operator!=(const RangeTableFuncCol& other) const noexcept { return !operator==(other); }
    bool operator<(const RangeTableFuncCol& other) const noexcept;
    bool operator<=(const RangeTableFuncCol& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RangeTableFuncCol& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RangeTableFuncCol& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RangeTableFuncCol& value);

    void swap(RangeTableFuncCol& other) noexcept;
    friend void swap(RangeTableFuncCol& value1, RangeTableFuncCol& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RangeTableFuncCol>
{
    typedef pg_query::RangeTableFuncCol argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName : FBE::Base
{
    std::vector<::pg_query::Node> names;
    uint32_t type_oid;
    bool setof;
    bool pct_type;
    std::vector<::pg_query::Node> typmods;
    int32_t typemod;
    std::vector<::pg_query::Node> array_bounds;
    int32_t location;

    size_t fbe_type() const noexcept { return 195; }

    TypeName();
    TypeName(std::vector<::pg_query::Node> arg_names, uint32_t arg_type_oid, bool arg_setof, bool arg_pct_type, std::vector<::pg_query::Node> arg_typmods, int32_t arg_typemod, std::vector<::pg_query::Node> arg_array_bounds, int32_t arg_location);
    TypeName(const TypeName& other) = delete;
    TypeName(TypeName&& other) noexcept;
    ~TypeName() override;

    TypeName& operator=(const TypeName& other) = delete;
    TypeName& operator=(TypeName&& other) noexcept;

    bool operator==(const TypeName& other) const noexcept;
    bool operator!=(const TypeName& other) const noexcept { return !operator==(other); }
    bool operator<(const TypeName& other) const noexcept;
    bool operator<=(const TypeName& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const TypeName& other) const noexcept { return !operator<=(other); }
    bool operator>=(const TypeName& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const TypeName& value);

    void swap(TypeName& other) noexcept;
    friend void swap(TypeName& value1, TypeName& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::TypeName>
{
    typedef pg_query::TypeName argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct RangeVar;

struct CollateClause;

struct ColumnDef : FBE::Base
{
    std::string colname;
    ::pg_query::TypeName* type_name;
    int32_t inhcount;
    bool is_local;
    bool is_not_null;
    bool is_from_type;
    std::string storage;
    ::pg_query::Node raw_default;
    ::pg_query::Node cooked_default;
    std::string identity;
    ::pg_query::RangeVar* identity_sequence;
    std::string generated;
    ::pg_query::CollateClause* coll_clause;
    uint32_t coll_oid;
    std::vector<::pg_query::Node> constraints;
    std::vector<::pg_query::Node> fdwoptions;
    int32_t location;

    size_t fbe_type() const noexcept { return 196; }

    ColumnDef();
    ColumnDef(const std::string& arg_colname, std::unique_ptr<::pg_query::TypeName> arg_type_name, int32_t arg_inhcount, bool arg_is_local, bool arg_is_not_null, bool arg_is_from_type, const std::string& arg_storage, ::pg_query::Node&& arg_raw_default, ::pg_query::Node&& arg_cooked_default, const std::string& arg_identity, std::unique_ptr<::pg_query::RangeVar> arg_identity_sequence, const std::string& arg_generated, std::unique_ptr<::pg_query::CollateClause> arg_coll_clause, uint32_t arg_coll_oid, std::vector<::pg_query::Node> arg_constraints, std::vector<::pg_query::Node> arg_fdwoptions, int32_t arg_location);
    ColumnDef(const ColumnDef& other) = delete;
    ColumnDef(ColumnDef&& other) noexcept;
    ~ColumnDef() override;

    ColumnDef& operator=(const ColumnDef& other) = delete;
    ColumnDef& operator=(ColumnDef&& other) noexcept;

    bool operator==(const ColumnDef& other) const noexcept;
    bool operator!=(const ColumnDef& other) const noexcept { return !operator==(other); }
    bool operator<(const ColumnDef& other) const noexcept;
    bool operator<=(const ColumnDef& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ColumnDef& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ColumnDef& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ColumnDef& value);

    void swap(ColumnDef& other) noexcept;
    friend void swap(ColumnDef& value1, ColumnDef& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ColumnDef>
{
    typedef pg_query::ColumnDef argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct IndexElem : FBE::Base
{
    std::string name;
    ::pg_query::Node expr;
    std::string indexcolname;
    std::vector<::pg_query::Node> collation;
    std::vector<::pg_query::Node> opclass;
    std::vector<::pg_query::Node> opclassopts;
    ::pg_query::SortByDir ordering;
    ::pg_query::SortByNulls nulls_ordering;

    size_t fbe_type() const noexcept { return 197; }

    IndexElem();
    IndexElem(const std::string& arg_name, ::pg_query::Node&& arg_expr, const std::string& arg_indexcolname, std::vector<::pg_query::Node> arg_collation, std::vector<::pg_query::Node> arg_opclass, std::vector<::pg_query::Node> arg_opclassopts, ::pg_query::SortByDir&& arg_ordering, ::pg_query::SortByNulls&& arg_nulls_ordering);
    IndexElem(const IndexElem& other) = delete;
    IndexElem(IndexElem&& other) noexcept;
    ~IndexElem() override;

    IndexElem& operator=(const IndexElem& other) = delete;
    IndexElem& operator=(IndexElem&& other) noexcept;

    bool operator==(const IndexElem& other) const noexcept;
    bool operator!=(const IndexElem& other) const noexcept { return !operator==(other); }
    bool operator<(const IndexElem& other) const noexcept;
    bool operator<=(const IndexElem& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const IndexElem& other) const noexcept { return !operator<=(other); }
    bool operator>=(const IndexElem& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const IndexElem& value);

    void swap(IndexElem& other) noexcept;
    friend void swap(IndexElem& value1, IndexElem& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::IndexElem>
{
    typedef pg_query::IndexElem argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct Constraint : FBE::Base
{
    ::pg_query::ConstrType contype;
    std::string conname;
    bool deferrable;
    bool initdeferred;
    int32_t location;
    bool is_no_inherit;
    ::pg_query::Node raw_expr;
    std::string cooked_expr;
    std::string generated_when;
    std::vector<::pg_query::Node> keys;
    std::vector<::pg_query::Node> including;
    std::vector<::pg_query::Node> exclusions;
    std::vector<::pg_query::Node> options;
    std::string indexname;
    std::string indexspace;
    bool reset_default_tblspc;
    std::string access_method;
    ::pg_query::Node where_clause;
    ::pg_query::RangeVar* pktable;
    std::vector<::pg_query::Node> fk_attrs;
    std::vector<::pg_query::Node> pk_attrs;
    std::string fk_matchtype;
    std::string fk_upd_action;
    std::string fk_del_action;
    std::vector<::pg_query::Node> old_conpfeqop;
    uint32_t old_pktable_oid;
    bool skip_validation;
    bool initially_valid;

    size_t fbe_type() const noexcept { return 198; }

    Constraint();
    Constraint(::pg_query::ConstrType&& arg_contype, const std::string& arg_conname, bool arg_deferrable, bool arg_initdeferred, int32_t arg_location, bool arg_is_no_inherit, ::pg_query::Node&& arg_raw_expr, const std::string& arg_cooked_expr, const std::string& arg_generated_when, std::vector<::pg_query::Node> arg_keys, std::vector<::pg_query::Node> arg_including, std::vector<::pg_query::Node> arg_exclusions, std::vector<::pg_query::Node> arg_options, const std::string& arg_indexname, const std::string& arg_indexspace, bool arg_reset_default_tblspc, const std::string& arg_access_method, ::pg_query::Node&& arg_where_clause, std::unique_ptr<::pg_query::RangeVar> arg_pktable, std::vector<::pg_query::Node> arg_fk_attrs, std::vector<::pg_query::Node> arg_pk_attrs, const std::string& arg_fk_matchtype, const std::string& arg_fk_upd_action, const std::string& arg_fk_del_action, std::vector<::pg_query::Node> arg_old_conpfeqop, uint32_t arg_old_pktable_oid, bool arg_skip_validation, bool arg_initially_valid);
    Constraint(const Constraint& other) = delete;
    Constraint(Constraint&& other) noexcept;
    ~Constraint() override;

    Constraint& operator=(const Constraint& other) = delete;
    Constraint& operator=(Constraint&& other) noexcept;

    bool operator==(const Constraint& other) const noexcept;
    bool operator!=(const Constraint& other) const noexcept { return !operator==(other); }
    bool operator<(const Constraint& other) const noexcept;
    bool operator<=(const Constraint& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Constraint& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Constraint& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Constraint& value);

    void swap(Constraint& other) noexcept;
    friend void swap(Constraint& value1, Constraint& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::Constraint>
{
    typedef pg_query::Constraint argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct DefElem : FBE::Base
{
    std::string defnamespace;
    std::string defname;
    ::pg_query::Node arg;
    ::pg_query::DefElemAction defaction;
    int32_t location;

    size_t fbe_type() const noexcept { return 199; }

    DefElem();
    DefElem(const std::string& arg_defnamespace, const std::string& arg_defname, ::pg_query::Node&& arg_arg, ::pg_query::DefElemAction&& arg_defaction, int32_t arg_location);
    DefElem(const DefElem& other) = delete;
    DefElem(DefElem&& other) noexcept;
    ~DefElem() override;

    DefElem& operator=(const DefElem& other) = delete;
    DefElem& operator=(DefElem&& other) noexcept;

    bool operator==(const DefElem& other) const noexcept;
    bool operator!=(const DefElem& other) const noexcept { return !operator==(other); }
    bool operator<(const DefElem& other) const noexcept;
    bool operator<=(const DefElem& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DefElem& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DefElem& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const DefElem& value);

    void swap(DefElem& other) noexcept;
    friend void swap(DefElem& value1, DefElem& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::DefElem>
{
    typedef pg_query::DefElem argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TableSampleClause;

struct Query;

struct TableFunc;

struct Alias;

struct RangeTblEntry : FBE::Base
{
    ::pg_query::RTEKind rtekind;
    uint32_t relid;
    std::string relkind;
    int32_t rellockmode;
    ::pg_query::TableSampleClause* tablesample;
    ::pg_query::Query* subquery;
    bool security_barrier;
    ::pg_query::JoinType jointype;
    int32_t joinmergedcols;
    std::vector<::pg_query::Node> joinaliasvars;
    std::vector<::pg_query::Node> joinleftcols;
    std::vector<::pg_query::Node> joinrightcols;
    std::vector<::pg_query::Node> functions;
    bool funcordinality;
    ::pg_query::TableFunc* tablefunc;
    std::vector<::pg_query::Node> values_lists;
    std::string ctename;
    uint32_t ctelevelsup;
    bool self_reference;
    std::vector<::pg_query::Node> coltypes;
    std::vector<::pg_query::Node> coltypmods;
    std::vector<::pg_query::Node> colcollations;
    std::string enrname;
    double enrtuples;
    ::pg_query::Alias* alias;
    ::pg_query::Alias* eref;
    bool lateral;
    bool inh;
    bool in_from_cl;
    uint32_t required_perms;
    uint32_t check_as_user;
    std::vector<uint64_t> selected_cols;
    std::vector<uint64_t> inserted_cols;
    std::vector<uint64_t> updated_cols;
    std::vector<uint64_t> extra_updated_cols;
    std::vector<::pg_query::Node> security_quals;

    size_t fbe_type() const noexcept { return 200; }

    RangeTblEntry();
    RangeTblEntry(::pg_query::RTEKind&& arg_rtekind, uint32_t arg_relid, const std::string& arg_relkind, int32_t arg_rellockmode, std::unique_ptr<::pg_query::TableSampleClause> arg_tablesample, std::unique_ptr<::pg_query::Query> arg_subquery, bool arg_security_barrier, ::pg_query::JoinType&& arg_jointype, int32_t arg_joinmergedcols, std::vector<::pg_query::Node> arg_joinaliasvars, std::vector<::pg_query::Node> arg_joinleftcols, std::vector<::pg_query::Node> arg_joinrightcols, std::vector<::pg_query::Node> arg_functions, bool arg_funcordinality, std::unique_ptr<::pg_query::TableFunc> arg_tablefunc, std::vector<::pg_query::Node> arg_values_lists, const std::string& arg_ctename, uint32_t arg_ctelevelsup, bool arg_self_reference, std::vector<::pg_query::Node> arg_coltypes, std::vector<::pg_query::Node> arg_coltypmods, std::vector<::pg_query::Node> arg_colcollations, const std::string& arg_enrname, double arg_enrtuples, std::unique_ptr<::pg_query::Alias> arg_alias, std::unique_ptr<::pg_query::Alias> arg_eref, bool arg_lateral, bool arg_inh, bool arg_in_from_cl, uint32_t arg_required_perms, uint32_t arg_check_as_user, std::vector<uint64_t> arg_selected_cols, std::vector<uint64_t> arg_inserted_cols, std::vector<uint64_t> arg_updated_cols, std::vector<uint64_t> arg_extra_updated_cols, std::vector<::pg_query::Node> arg_security_quals);
    RangeTblEntry(const RangeTblEntry& other) = delete;
    RangeTblEntry(RangeTblEntry&& other) noexcept;
    ~RangeTblEntry() override;

    RangeTblEntry& operator=(const RangeTblEntry& other) = delete;
    RangeTblEntry& operator=(RangeTblEntry&& other) noexcept;

    bool operator==(const RangeTblEntry& other) const noexcept;
    bool operator!=(const RangeTblEntry& other) const noexcept { return !operator==(other); }
    bool operator<(const RangeTblEntry& other) const noexcept;
    bool operator<=(const RangeTblEntry& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RangeTblEntry& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RangeTblEntry& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RangeTblEntry& value);

    void swap(RangeTblEntry& other) noexcept;
    friend void swap(RangeTblEntry& value1, RangeTblEntry& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RangeTblEntry>
{
    typedef pg_query::RangeTblEntry argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeTblFunction : FBE::Base
{
    ::pg_query::Node funcexpr;
    int32_t funccolcount;
    std::vector<::pg_query::Node> funccolnames;
    std::vector<::pg_query::Node> funccoltypes;
    std::vector<::pg_query::Node> funccoltypmods;
    std::vector<::pg_query::Node> funccolcollations;
    std::vector<uint64_t> funcparams;

    size_t fbe_type() const noexcept { return 201; }

    RangeTblFunction();
    RangeTblFunction(::pg_query::Node&& arg_funcexpr, int32_t arg_funccolcount, std::vector<::pg_query::Node> arg_funccolnames, std::vector<::pg_query::Node> arg_funccoltypes, std::vector<::pg_query::Node> arg_funccoltypmods, std::vector<::pg_query::Node> arg_funccolcollations, std::vector<uint64_t> arg_funcparams);
    RangeTblFunction(const RangeTblFunction& other) = delete;
    RangeTblFunction(RangeTblFunction&& other) noexcept;
    ~RangeTblFunction() override;

    RangeTblFunction& operator=(const RangeTblFunction& other) = delete;
    RangeTblFunction& operator=(RangeTblFunction&& other) noexcept;

    bool operator==(const RangeTblFunction& other) const noexcept;
    bool operator!=(const RangeTblFunction& other) const noexcept { return !operator==(other); }
    bool operator<(const RangeTblFunction& other) const noexcept;
    bool operator<=(const RangeTblFunction& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RangeTblFunction& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RangeTblFunction& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RangeTblFunction& value);

    void swap(RangeTblFunction& other) noexcept;
    friend void swap(RangeTblFunction& value1, RangeTblFunction& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RangeTblFunction>
{
    typedef pg_query::RangeTblFunction argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TableSampleClause : FBE::Base
{
    uint32_t tsmhandler;
    std::vector<::pg_query::Node> args;
    ::pg_query::Node repeatable;

    size_t fbe_type() const noexcept { return 202; }

    TableSampleClause();
    TableSampleClause(uint32_t arg_tsmhandler, std::vector<::pg_query::Node> arg_args, ::pg_query::Node&& arg_repeatable);
    TableSampleClause(const TableSampleClause& other) = delete;
    TableSampleClause(TableSampleClause&& other) noexcept;
    ~TableSampleClause() override;

    TableSampleClause& operator=(const TableSampleClause& other) = delete;
    TableSampleClause& operator=(TableSampleClause&& other) noexcept;

    bool operator==(const TableSampleClause& other) const noexcept;
    bool operator!=(const TableSampleClause& other) const noexcept { return !operator==(other); }
    bool operator<(const TableSampleClause& other) const noexcept;
    bool operator<=(const TableSampleClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const TableSampleClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const TableSampleClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const TableSampleClause& value);

    void swap(TableSampleClause& other) noexcept;
    friend void swap(TableSampleClause& value1, TableSampleClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::TableSampleClause>
{
    typedef pg_query::TableSampleClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct WithCheckOption : FBE::Base
{
    ::pg_query::WCOKind kind;
    std::string relname;
    std::string polname;
    ::pg_query::Node qual;
    bool cascaded;

    size_t fbe_type() const noexcept { return 203; }

    WithCheckOption();
    WithCheckOption(::pg_query::WCOKind&& arg_kind, const std::string& arg_relname, const std::string& arg_polname, ::pg_query::Node&& arg_qual, bool arg_cascaded);
    WithCheckOption(const WithCheckOption& other) = delete;
    WithCheckOption(WithCheckOption&& other) noexcept;
    ~WithCheckOption() override;

    WithCheckOption& operator=(const WithCheckOption& other) = delete;
    WithCheckOption& operator=(WithCheckOption&& other) noexcept;

    bool operator==(const WithCheckOption& other) const noexcept;
    bool operator!=(const WithCheckOption& other) const noexcept { return !operator==(other); }
    bool operator<(const WithCheckOption& other) const noexcept;
    bool operator<=(const WithCheckOption& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const WithCheckOption& other) const noexcept { return !operator<=(other); }
    bool operator>=(const WithCheckOption& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const WithCheckOption& value);

    void swap(WithCheckOption& other) noexcept;
    friend void swap(WithCheckOption& value1, WithCheckOption& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::WithCheckOption>
{
    typedef pg_query::WithCheckOption argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct SortGroupClause : FBE::Base
{
    uint32_t tle_sort_group_ref;
    uint32_t eqop;
    uint32_t sortop;
    bool nulls_first;
    bool hashable;

    size_t fbe_type() const noexcept { return 204; }

    SortGroupClause();
    SortGroupClause(uint32_t arg_tle_sort_group_ref, uint32_t arg_eqop, uint32_t arg_sortop, bool arg_nulls_first, bool arg_hashable);
    SortGroupClause(const SortGroupClause& other) = delete;
    SortGroupClause(SortGroupClause&& other) noexcept;
    ~SortGroupClause() override;

    SortGroupClause& operator=(const SortGroupClause& other) = delete;
    SortGroupClause& operator=(SortGroupClause&& other) noexcept;

    bool operator==(const SortGroupClause& other) const noexcept;
    bool operator!=(const SortGroupClause& other) const noexcept { return !operator==(other); }
    bool operator<(const SortGroupClause& other) const noexcept;
    bool operator<=(const SortGroupClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SortGroupClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SortGroupClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const SortGroupClause& value);

    void swap(SortGroupClause& other) noexcept;
    friend void swap(SortGroupClause& value1, SortGroupClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::SortGroupClause>
{
    typedef pg_query::SortGroupClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct GroupingSet : FBE::Base
{
    ::pg_query::GroupingSetKind kind;
    std::vector<::pg_query::Node> content;
    int32_t location;

    size_t fbe_type() const noexcept { return 205; }

    GroupingSet();
    GroupingSet(::pg_query::GroupingSetKind&& arg_kind, std::vector<::pg_query::Node> arg_content, int32_t arg_location);
    GroupingSet(const GroupingSet& other) = delete;
    GroupingSet(GroupingSet&& other) noexcept;
    ~GroupingSet() override;

    GroupingSet& operator=(const GroupingSet& other) = delete;
    GroupingSet& operator=(GroupingSet&& other) noexcept;

    bool operator==(const GroupingSet& other) const noexcept;
    bool operator!=(const GroupingSet& other) const noexcept { return !operator==(other); }
    bool operator<(const GroupingSet& other) const noexcept;
    bool operator<=(const GroupingSet& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const GroupingSet& other) const noexcept { return !operator<=(other); }
    bool operator>=(const GroupingSet& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const GroupingSet& value);

    void swap(GroupingSet& other) noexcept;
    friend void swap(GroupingSet& value1, GroupingSet& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::GroupingSet>
{
    typedef pg_query::GroupingSet argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct WindowClause : FBE::Base
{
    std::string name;
    std::string refname;
    std::vector<::pg_query::Node> partition_clause;
    std::vector<::pg_query::Node> order_clause;
    int32_t frame_options;
    ::pg_query::Node start_offset;
    ::pg_query::Node end_offset;
    uint32_t start_in_range_func;
    uint32_t end_in_range_func;
    uint32_t in_range_coll;
    bool in_range_asc;
    bool in_range_nulls_first;
    uint32_t winref;
    bool copied_order;

    size_t fbe_type() const noexcept { return 206; }

    WindowClause();
    WindowClause(const std::string& arg_name, const std::string& arg_refname, std::vector<::pg_query::Node> arg_partition_clause, std::vector<::pg_query::Node> arg_order_clause, int32_t arg_frame_options, ::pg_query::Node&& arg_start_offset, ::pg_query::Node&& arg_end_offset, uint32_t arg_start_in_range_func, uint32_t arg_end_in_range_func, uint32_t arg_in_range_coll, bool arg_in_range_asc, bool arg_in_range_nulls_first, uint32_t arg_winref, bool arg_copied_order);
    WindowClause(const WindowClause& other) = delete;
    WindowClause(WindowClause&& other) noexcept;
    ~WindowClause() override;

    WindowClause& operator=(const WindowClause& other) = delete;
    WindowClause& operator=(WindowClause&& other) noexcept;

    bool operator==(const WindowClause& other) const noexcept;
    bool operator!=(const WindowClause& other) const noexcept { return !operator==(other); }
    bool operator<(const WindowClause& other) const noexcept;
    bool operator<=(const WindowClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const WindowClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const WindowClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const WindowClause& value);

    void swap(WindowClause& other) noexcept;
    friend void swap(WindowClause& value1, WindowClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::WindowClause>
{
    typedef pg_query::WindowClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ObjectWithArgs : FBE::Base
{
    std::vector<::pg_query::Node> objname;
    std::vector<::pg_query::Node> objargs;
    bool args_unspecified;

    size_t fbe_type() const noexcept { return 207; }

    ObjectWithArgs();
    ObjectWithArgs(std::vector<::pg_query::Node> arg_objname, std::vector<::pg_query::Node> arg_objargs, bool arg_args_unspecified);
    ObjectWithArgs(const ObjectWithArgs& other) = delete;
    ObjectWithArgs(ObjectWithArgs&& other) noexcept;
    ~ObjectWithArgs() override;

    ObjectWithArgs& operator=(const ObjectWithArgs& other) = delete;
    ObjectWithArgs& operator=(ObjectWithArgs&& other) noexcept;

    bool operator==(const ObjectWithArgs& other) const noexcept;
    bool operator!=(const ObjectWithArgs& other) const noexcept { return !operator==(other); }
    bool operator<(const ObjectWithArgs& other) const noexcept;
    bool operator<=(const ObjectWithArgs& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ObjectWithArgs& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ObjectWithArgs& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ObjectWithArgs& value);

    void swap(ObjectWithArgs& other) noexcept;
    friend void swap(ObjectWithArgs& value1, ObjectWithArgs& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ObjectWithArgs>
{
    typedef pg_query::ObjectWithArgs argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct AccessPriv : FBE::Base
{
    std::string priv_name;
    std::vector<::pg_query::Node> cols;

    size_t fbe_type() const noexcept { return 208; }

    AccessPriv();
    AccessPriv(const std::string& arg_priv_name, std::vector<::pg_query::Node> arg_cols);
    AccessPriv(const AccessPriv& other) = delete;
    AccessPriv(AccessPriv&& other) noexcept;
    ~AccessPriv() override;

    AccessPriv& operator=(const AccessPriv& other) = delete;
    AccessPriv& operator=(AccessPriv&& other) noexcept;

    bool operator==(const AccessPriv& other) const noexcept;
    bool operator!=(const AccessPriv& other) const noexcept { return !operator==(other); }
    bool operator<(const AccessPriv& other) const noexcept;
    bool operator<=(const AccessPriv& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const AccessPriv& other) const noexcept { return !operator<=(other); }
    bool operator>=(const AccessPriv& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const AccessPriv& value);

    void swap(AccessPriv& other) noexcept;
    friend void swap(AccessPriv& value1, AccessPriv& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::AccessPriv>
{
    typedef pg_query::AccessPriv argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ObjectWithArgs;

struct TypeName;

struct CreateOpClassItem : FBE::Base
{
    int32_t itemtype;
    ::pg_query::ObjectWithArgs* name;
    int32_t number;
    std::vector<::pg_query::Node> order_family;
    std::vector<::pg_query::Node> class_args;
    ::pg_query::TypeName* storedtype;

    size_t fbe_type() const noexcept { return 209; }

    CreateOpClassItem();
    CreateOpClassItem(int32_t arg_itemtype, std::unique_ptr<::pg_query::ObjectWithArgs> arg_name, int32_t arg_number, std::vector<::pg_query::Node> arg_order_family, std::vector<::pg_query::Node> arg_class_args, std::unique_ptr<::pg_query::TypeName> arg_storedtype);
    CreateOpClassItem(const CreateOpClassItem& other) = delete;
    CreateOpClassItem(CreateOpClassItem&& other) noexcept;
    ~CreateOpClassItem() override;

    CreateOpClassItem& operator=(const CreateOpClassItem& other) = delete;
    CreateOpClassItem& operator=(CreateOpClassItem&& other) noexcept;

    bool operator==(const CreateOpClassItem& other) const noexcept;
    bool operator!=(const CreateOpClassItem& other) const noexcept { return !operator==(other); }
    bool operator<(const CreateOpClassItem& other) const noexcept;
    bool operator<=(const CreateOpClassItem& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CreateOpClassItem& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CreateOpClassItem& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CreateOpClassItem& value);

    void swap(CreateOpClassItem& other) noexcept;
    friend void swap(CreateOpClassItem& value1, CreateOpClassItem& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CreateOpClassItem>
{
    typedef pg_query::CreateOpClassItem argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct TableLikeClause : FBE::Base
{
    ::pg_query::RangeVar* relation;
    uint32_t options;
    uint32_t relation_oid;

    size_t fbe_type() const noexcept { return 210; }

    TableLikeClause();
    TableLikeClause(std::unique_ptr<::pg_query::RangeVar> arg_relation, uint32_t arg_options, uint32_t arg_relation_oid);
    TableLikeClause(const TableLikeClause& other) = delete;
    TableLikeClause(TableLikeClause&& other) noexcept;
    ~TableLikeClause() override;

    TableLikeClause& operator=(const TableLikeClause& other) = delete;
    TableLikeClause& operator=(TableLikeClause&& other) noexcept;

    bool operator==(const TableLikeClause& other) const noexcept;
    bool operator!=(const TableLikeClause& other) const noexcept { return !operator==(other); }
    bool operator<(const TableLikeClause& other) const noexcept;
    bool operator<=(const TableLikeClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const TableLikeClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const TableLikeClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const TableLikeClause& value);

    void swap(TableLikeClause& other) noexcept;
    friend void swap(TableLikeClause& value1, TableLikeClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::TableLikeClause>
{
    typedef pg_query::TableLikeClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct FunctionParameter : FBE::Base
{
    std::string name;
    ::pg_query::TypeName* arg_type;
    ::pg_query::FunctionParameterMode mode;
    ::pg_query::Node defexpr;

    size_t fbe_type() const noexcept { return 211; }

    FunctionParameter();
    FunctionParameter(const std::string& arg_name, std::unique_ptr<::pg_query::TypeName> arg_arg_type, ::pg_query::FunctionParameterMode&& arg_mode, ::pg_query::Node&& arg_defexpr);
    FunctionParameter(const FunctionParameter& other) = delete;
    FunctionParameter(FunctionParameter&& other) noexcept;
    ~FunctionParameter() override;

    FunctionParameter& operator=(const FunctionParameter& other) = delete;
    FunctionParameter& operator=(FunctionParameter&& other) noexcept;

    bool operator==(const FunctionParameter& other) const noexcept;
    bool operator!=(const FunctionParameter& other) const noexcept { return !operator==(other); }
    bool operator<(const FunctionParameter& other) const noexcept;
    bool operator<=(const FunctionParameter& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const FunctionParameter& other) const noexcept { return !operator<=(other); }
    bool operator>=(const FunctionParameter& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const FunctionParameter& value);

    void swap(FunctionParameter& other) noexcept;
    friend void swap(FunctionParameter& value1, FunctionParameter& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::FunctionParameter>
{
    typedef pg_query::FunctionParameter argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct LockingClause : FBE::Base
{
    std::vector<::pg_query::Node> locked_rels;
    ::pg_query::LockClauseStrength strength;
    ::pg_query::LockWaitPolicy wait_policy;

    size_t fbe_type() const noexcept { return 212; }

    LockingClause();
    LockingClause(std::vector<::pg_query::Node> arg_locked_rels, ::pg_query::LockClauseStrength&& arg_strength, ::pg_query::LockWaitPolicy&& arg_wait_policy);
    LockingClause(const LockingClause& other) = delete;
    LockingClause(LockingClause&& other) noexcept;
    ~LockingClause() override;

    LockingClause& operator=(const LockingClause& other) = delete;
    LockingClause& operator=(LockingClause&& other) noexcept;

    bool operator==(const LockingClause& other) const noexcept;
    bool operator!=(const LockingClause& other) const noexcept { return !operator==(other); }
    bool operator<(const LockingClause& other) const noexcept;
    bool operator<=(const LockingClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const LockingClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const LockingClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const LockingClause& value);

    void swap(LockingClause& other) noexcept;
    friend void swap(LockingClause& value1, LockingClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::LockingClause>
{
    typedef pg_query::LockingClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RowMarkClause : FBE::Base
{
    uint32_t rti;
    ::pg_query::LockClauseStrength strength;
    ::pg_query::LockWaitPolicy wait_policy;
    bool pushed_down;

    size_t fbe_type() const noexcept { return 213; }

    RowMarkClause();
    RowMarkClause(uint32_t arg_rti, ::pg_query::LockClauseStrength&& arg_strength, ::pg_query::LockWaitPolicy&& arg_wait_policy, bool arg_pushed_down);
    RowMarkClause(const RowMarkClause& other) = delete;
    RowMarkClause(RowMarkClause&& other) noexcept;
    ~RowMarkClause() override;

    RowMarkClause& operator=(const RowMarkClause& other) = delete;
    RowMarkClause& operator=(RowMarkClause&& other) noexcept;

    bool operator==(const RowMarkClause& other) const noexcept;
    bool operator!=(const RowMarkClause& other) const noexcept { return !operator==(other); }
    bool operator<(const RowMarkClause& other) const noexcept;
    bool operator<=(const RowMarkClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RowMarkClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RowMarkClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RowMarkClause& value);

    void swap(RowMarkClause& other) noexcept;
    friend void swap(RowMarkClause& value1, RowMarkClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RowMarkClause>
{
    typedef pg_query::RowMarkClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TypeName;

struct XmlSerialize : FBE::Base
{
    ::pg_query::XmlOptionType xmloption;
    ::pg_query::Node expr;
    ::pg_query::TypeName* type_name;
    int32_t location;

    size_t fbe_type() const noexcept { return 214; }

    XmlSerialize();
    XmlSerialize(::pg_query::XmlOptionType&& arg_xmloption, ::pg_query::Node&& arg_expr, std::unique_ptr<::pg_query::TypeName> arg_type_name, int32_t arg_location);
    XmlSerialize(const XmlSerialize& other) = delete;
    XmlSerialize(XmlSerialize&& other) noexcept;
    ~XmlSerialize() override;

    XmlSerialize& operator=(const XmlSerialize& other) = delete;
    XmlSerialize& operator=(XmlSerialize&& other) noexcept;

    bool operator==(const XmlSerialize& other) const noexcept;
    bool operator!=(const XmlSerialize& other) const noexcept { return !operator==(other); }
    bool operator<(const XmlSerialize& other) const noexcept;
    bool operator<=(const XmlSerialize& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const XmlSerialize& other) const noexcept { return !operator<=(other); }
    bool operator>=(const XmlSerialize& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const XmlSerialize& value);

    void swap(XmlSerialize& other) noexcept;
    friend void swap(XmlSerialize& value1, XmlSerialize& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::XmlSerialize>
{
    typedef pg_query::XmlSerialize argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct WithClause : FBE::Base
{
    std::vector<::pg_query::Node> ctes;
    bool recursive;
    int32_t location;

    size_t fbe_type() const noexcept { return 215; }

    WithClause();
    WithClause(std::vector<::pg_query::Node> arg_ctes, bool arg_recursive, int32_t arg_location);
    WithClause(const WithClause& other) = delete;
    WithClause(WithClause&& other) noexcept;
    ~WithClause() override;

    WithClause& operator=(const WithClause& other) = delete;
    WithClause& operator=(WithClause&& other) noexcept;

    bool operator==(const WithClause& other) const noexcept;
    bool operator!=(const WithClause& other) const noexcept { return !operator==(other); }
    bool operator<(const WithClause& other) const noexcept;
    bool operator<=(const WithClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const WithClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const WithClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const WithClause& value);

    void swap(WithClause& other) noexcept;
    friend void swap(WithClause& value1, WithClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::WithClause>
{
    typedef pg_query::WithClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct InferClause : FBE::Base
{
    std::vector<::pg_query::Node> index_elems;
    ::pg_query::Node where_clause;
    std::string conname;
    int32_t location;

    size_t fbe_type() const noexcept { return 216; }

    InferClause();
    InferClause(std::vector<::pg_query::Node> arg_index_elems, ::pg_query::Node&& arg_where_clause, const std::string& arg_conname, int32_t arg_location);
    InferClause(const InferClause& other) = delete;
    InferClause(InferClause&& other) noexcept;
    ~InferClause() override;

    InferClause& operator=(const InferClause& other) = delete;
    InferClause& operator=(InferClause&& other) noexcept;

    bool operator==(const InferClause& other) const noexcept;
    bool operator!=(const InferClause& other) const noexcept { return !operator==(other); }
    bool operator<(const InferClause& other) const noexcept;
    bool operator<=(const InferClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const InferClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const InferClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const InferClause& value);

    void swap(InferClause& other) noexcept;
    friend void swap(InferClause& value1, InferClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::InferClause>
{
    typedef pg_query::InferClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct InferClause;

struct OnConflictClause : FBE::Base
{
    ::pg_query::OnConflictAction action;
    ::pg_query::InferClause* infer;
    std::vector<::pg_query::Node> target_list;
    ::pg_query::Node where_clause;
    int32_t location;

    size_t fbe_type() const noexcept { return 217; }

    OnConflictClause();
    OnConflictClause(::pg_query::OnConflictAction&& arg_action, std::unique_ptr<::pg_query::InferClause> arg_infer, std::vector<::pg_query::Node> arg_target_list, ::pg_query::Node&& arg_where_clause, int32_t arg_location);
    OnConflictClause(const OnConflictClause& other) = delete;
    OnConflictClause(OnConflictClause&& other) noexcept;
    ~OnConflictClause() override;

    OnConflictClause& operator=(const OnConflictClause& other) = delete;
    OnConflictClause& operator=(OnConflictClause&& other) noexcept;

    bool operator==(const OnConflictClause& other) const noexcept;
    bool operator!=(const OnConflictClause& other) const noexcept { return !operator==(other); }
    bool operator<(const OnConflictClause& other) const noexcept;
    bool operator<=(const OnConflictClause& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const OnConflictClause& other) const noexcept { return !operator<=(other); }
    bool operator>=(const OnConflictClause& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const OnConflictClause& value);

    void swap(OnConflictClause& other) noexcept;
    friend void swap(OnConflictClause& value1, OnConflictClause& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::OnConflictClause>
{
    typedef pg_query::OnConflictClause argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CommonTableExpr : FBE::Base
{
    std::string ctename;
    std::vector<::pg_query::Node> aliascolnames;
    ::pg_query::CTEMaterialize ctematerialized;
    ::pg_query::Node ctequery;
    int32_t location;
    bool cterecursive;
    int32_t cterefcount;
    std::vector<::pg_query::Node> ctecolnames;
    std::vector<::pg_query::Node> ctecoltypes;
    std::vector<::pg_query::Node> ctecoltypmods;
    std::vector<::pg_query::Node> ctecolcollations;

    size_t fbe_type() const noexcept { return 218; }

    CommonTableExpr();
    CommonTableExpr(const std::string& arg_ctename, std::vector<::pg_query::Node> arg_aliascolnames, ::pg_query::CTEMaterialize&& arg_ctematerialized, ::pg_query::Node&& arg_ctequery, int32_t arg_location, bool arg_cterecursive, int32_t arg_cterefcount, std::vector<::pg_query::Node> arg_ctecolnames, std::vector<::pg_query::Node> arg_ctecoltypes, std::vector<::pg_query::Node> arg_ctecoltypmods, std::vector<::pg_query::Node> arg_ctecolcollations);
    CommonTableExpr(const CommonTableExpr& other) = delete;
    CommonTableExpr(CommonTableExpr&& other) noexcept;
    ~CommonTableExpr() override;

    CommonTableExpr& operator=(const CommonTableExpr& other) = delete;
    CommonTableExpr& operator=(CommonTableExpr&& other) noexcept;

    bool operator==(const CommonTableExpr& other) const noexcept;
    bool operator!=(const CommonTableExpr& other) const noexcept { return !operator==(other); }
    bool operator<(const CommonTableExpr& other) const noexcept;
    bool operator<=(const CommonTableExpr& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CommonTableExpr& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CommonTableExpr& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CommonTableExpr& value);

    void swap(CommonTableExpr& other) noexcept;
    friend void swap(CommonTableExpr& value1, CommonTableExpr& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CommonTableExpr>
{
    typedef pg_query::CommonTableExpr argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RoleSpec : FBE::Base
{
    ::pg_query::RoleSpecType roletype;
    std::string rolename;
    int32_t location;

    size_t fbe_type() const noexcept { return 219; }

    RoleSpec();
    RoleSpec(::pg_query::RoleSpecType&& arg_roletype, const std::string& arg_rolename, int32_t arg_location);
    RoleSpec(const RoleSpec& other) = delete;
    RoleSpec(RoleSpec&& other) noexcept;
    ~RoleSpec() override;

    RoleSpec& operator=(const RoleSpec& other) = delete;
    RoleSpec& operator=(RoleSpec&& other) noexcept;

    bool operator==(const RoleSpec& other) const noexcept;
    bool operator!=(const RoleSpec& other) const noexcept { return !operator==(other); }
    bool operator<(const RoleSpec& other) const noexcept;
    bool operator<=(const RoleSpec& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const RoleSpec& other) const noexcept { return !operator<=(other); }
    bool operator>=(const RoleSpec& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const RoleSpec& value);

    void swap(RoleSpec& other) noexcept;
    friend void swap(RoleSpec& value1, RoleSpec& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::RoleSpec>
{
    typedef pg_query::RoleSpec argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct TriggerTransition : FBE::Base
{
    std::string name;
    bool is_new;
    bool is_table;

    size_t fbe_type() const noexcept { return 220; }

    TriggerTransition();
    TriggerTransition(const std::string& arg_name, bool arg_is_new, bool arg_is_table);
    TriggerTransition(const TriggerTransition& other) = delete;
    TriggerTransition(TriggerTransition&& other) noexcept;
    ~TriggerTransition() override;

    TriggerTransition& operator=(const TriggerTransition& other) = delete;
    TriggerTransition& operator=(TriggerTransition&& other) noexcept;

    bool operator==(const TriggerTransition& other) const noexcept;
    bool operator!=(const TriggerTransition& other) const noexcept { return !operator==(other); }
    bool operator<(const TriggerTransition& other) const noexcept;
    bool operator<=(const TriggerTransition& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const TriggerTransition& other) const noexcept { return !operator<=(other); }
    bool operator>=(const TriggerTransition& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const TriggerTransition& value);

    void swap(TriggerTransition& other) noexcept;
    friend void swap(TriggerTransition& value1, TriggerTransition& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::TriggerTransition>
{
    typedef pg_query::TriggerTransition argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct PartitionElem : FBE::Base
{
    std::string name;
    ::pg_query::Node expr;
    std::vector<::pg_query::Node> collation;
    std::vector<::pg_query::Node> opclass;
    int32_t location;

    size_t fbe_type() const noexcept { return 221; }

    PartitionElem();
    PartitionElem(const std::string& arg_name, ::pg_query::Node&& arg_expr, std::vector<::pg_query::Node> arg_collation, std::vector<::pg_query::Node> arg_opclass, int32_t arg_location);
    PartitionElem(const PartitionElem& other) = delete;
    PartitionElem(PartitionElem&& other) noexcept;
    ~PartitionElem() override;

    PartitionElem& operator=(const PartitionElem& other) = delete;
    PartitionElem& operator=(PartitionElem&& other) noexcept;

    bool operator==(const PartitionElem& other) const noexcept;
    bool operator!=(const PartitionElem& other) const noexcept { return !operator==(other); }
    bool operator<(const PartitionElem& other) const noexcept;
    bool operator<=(const PartitionElem& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const PartitionElem& other) const noexcept { return !operator<=(other); }
    bool operator>=(const PartitionElem& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const PartitionElem& value);

    void swap(PartitionElem& other) noexcept;
    friend void swap(PartitionElem& value1, PartitionElem& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::PartitionElem>
{
    typedef pg_query::PartitionElem argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct PartitionSpec : FBE::Base
{
    std::string strategy;
    std::vector<::pg_query::Node> part_params;
    int32_t location;

    size_t fbe_type() const noexcept { return 222; }

    PartitionSpec();
    PartitionSpec(const std::string& arg_strategy, std::vector<::pg_query::Node> arg_part_params, int32_t arg_location);
    PartitionSpec(const PartitionSpec& other) = delete;
    PartitionSpec(PartitionSpec&& other) noexcept;
    ~PartitionSpec() override;

    PartitionSpec& operator=(const PartitionSpec& other) = delete;
    PartitionSpec& operator=(PartitionSpec&& other) noexcept;

    bool operator==(const PartitionSpec& other) const noexcept;
    bool operator!=(const PartitionSpec& other) const noexcept { return !operator==(other); }
    bool operator<(const PartitionSpec& other) const noexcept;
    bool operator<=(const PartitionSpec& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const PartitionSpec& other) const noexcept { return !operator<=(other); }
    bool operator>=(const PartitionSpec& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const PartitionSpec& value);

    void swap(PartitionSpec& other) noexcept;
    friend void swap(PartitionSpec& value1, PartitionSpec& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::PartitionSpec>
{
    typedef pg_query::PartitionSpec argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct PartitionBoundSpec : FBE::Base
{
    std::string strategy;
    bool is_default;
    int32_t modulus;
    int32_t remainder;
    std::vector<::pg_query::Node> listdatums;
    std::vector<::pg_query::Node> lowerdatums;
    std::vector<::pg_query::Node> upperdatums;
    int32_t location;

    size_t fbe_type() const noexcept { return 223; }

    PartitionBoundSpec();
    PartitionBoundSpec(const std::string& arg_strategy, bool arg_is_default, int32_t arg_modulus, int32_t arg_remainder, std::vector<::pg_query::Node> arg_listdatums, std::vector<::pg_query::Node> arg_lowerdatums, std::vector<::pg_query::Node> arg_upperdatums, int32_t arg_location);
    PartitionBoundSpec(const PartitionBoundSpec& other) = delete;
    PartitionBoundSpec(PartitionBoundSpec&& other) noexcept;
    ~PartitionBoundSpec() override;

    PartitionBoundSpec& operator=(const PartitionBoundSpec& other) = delete;
    PartitionBoundSpec& operator=(PartitionBoundSpec&& other) noexcept;

    bool operator==(const PartitionBoundSpec& other) const noexcept;
    bool operator!=(const PartitionBoundSpec& other) const noexcept { return !operator==(other); }
    bool operator<(const PartitionBoundSpec& other) const noexcept;
    bool operator<=(const PartitionBoundSpec& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const PartitionBoundSpec& other) const noexcept { return !operator<=(other); }
    bool operator>=(const PartitionBoundSpec& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const PartitionBoundSpec& value);

    void swap(PartitionBoundSpec& other) noexcept;
    friend void swap(PartitionBoundSpec& value1, PartitionBoundSpec& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::PartitionBoundSpec>
{
    typedef pg_query::PartitionBoundSpec argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct PartitionRangeDatum : FBE::Base
{
    ::pg_query::PartitionRangeDatumKind kind;
    ::pg_query::Node value;
    int32_t location;

    size_t fbe_type() const noexcept { return 224; }

    PartitionRangeDatum();
    PartitionRangeDatum(::pg_query::PartitionRangeDatumKind&& arg_kind, ::pg_query::Node&& arg_value, int32_t arg_location);
    PartitionRangeDatum(const PartitionRangeDatum& other) = delete;
    PartitionRangeDatum(PartitionRangeDatum&& other) noexcept;
    ~PartitionRangeDatum() override;

    PartitionRangeDatum& operator=(const PartitionRangeDatum& other) = delete;
    PartitionRangeDatum& operator=(PartitionRangeDatum&& other) noexcept;

    bool operator==(const PartitionRangeDatum& other) const noexcept;
    bool operator!=(const PartitionRangeDatum& other) const noexcept { return !operator==(other); }
    bool operator<(const PartitionRangeDatum& other) const noexcept;
    bool operator<=(const PartitionRangeDatum& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const PartitionRangeDatum& other) const noexcept { return !operator<=(other); }
    bool operator>=(const PartitionRangeDatum& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const PartitionRangeDatum& value);

    void swap(PartitionRangeDatum& other) noexcept;
    friend void swap(PartitionRangeDatum& value1, PartitionRangeDatum& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::PartitionRangeDatum>
{
    typedef pg_query::PartitionRangeDatum argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct PartitionBoundSpec;

struct PartitionCmd : FBE::Base
{
    ::pg_query::RangeVar* name;
    ::pg_query::PartitionBoundSpec* bound;

    size_t fbe_type() const noexcept { return 225; }

    PartitionCmd();
    PartitionCmd(std::unique_ptr<::pg_query::RangeVar> arg_name, std::unique_ptr<::pg_query::PartitionBoundSpec> arg_bound);
    PartitionCmd(const PartitionCmd& other) = delete;
    PartitionCmd(PartitionCmd&& other) noexcept;
    ~PartitionCmd() override;

    PartitionCmd& operator=(const PartitionCmd& other) = delete;
    PartitionCmd& operator=(PartitionCmd&& other) noexcept;

    bool operator==(const PartitionCmd& other) const noexcept;
    bool operator!=(const PartitionCmd& other) const noexcept { return !operator==(other); }
    bool operator<(const PartitionCmd& other) const noexcept;
    bool operator<=(const PartitionCmd& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const PartitionCmd& other) const noexcept { return !operator<=(other); }
    bool operator>=(const PartitionCmd& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const PartitionCmd& value);

    void swap(PartitionCmd& other) noexcept;
    friend void swap(PartitionCmd& value1, PartitionCmd& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::PartitionCmd>
{
    typedef pg_query::PartitionCmd argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct RangeVar;

struct VacuumRelation : FBE::Base
{
    ::pg_query::RangeVar* relation;
    uint32_t oid;
    std::vector<::pg_query::Node> va_cols;

    size_t fbe_type() const noexcept { return 226; }

    VacuumRelation();
    VacuumRelation(std::unique_ptr<::pg_query::RangeVar> arg_relation, uint32_t arg_oid, std::vector<::pg_query::Node> arg_va_cols);
    VacuumRelation(const VacuumRelation& other) = delete;
    VacuumRelation(VacuumRelation&& other) noexcept;
    ~VacuumRelation() override;

    VacuumRelation& operator=(const VacuumRelation& other) = delete;
    VacuumRelation& operator=(VacuumRelation&& other) noexcept;

    bool operator==(const VacuumRelation& other) const noexcept;
    bool operator!=(const VacuumRelation& other) const noexcept { return !operator==(other); }
    bool operator<(const VacuumRelation& other) const noexcept;
    bool operator<=(const VacuumRelation& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const VacuumRelation& other) const noexcept { return !operator<=(other); }
    bool operator>=(const VacuumRelation& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const VacuumRelation& value);

    void swap(VacuumRelation& other) noexcept;
    friend void swap(VacuumRelation& value1, VacuumRelation& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::VacuumRelation>
{
    typedef pg_query::VacuumRelation argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct InlineCodeBlock : FBE::Base
{
    std::string source_text;
    uint32_t lang_oid;
    bool lang_is_trusted;
    bool atomic;

    size_t fbe_type() const noexcept { return 227; }

    InlineCodeBlock();
    InlineCodeBlock(const std::string& arg_source_text, uint32_t arg_lang_oid, bool arg_lang_is_trusted, bool arg_atomic);
    InlineCodeBlock(const InlineCodeBlock& other) = delete;
    InlineCodeBlock(InlineCodeBlock&& other) noexcept;
    ~InlineCodeBlock() override;

    InlineCodeBlock& operator=(const InlineCodeBlock& other) = delete;
    InlineCodeBlock& operator=(InlineCodeBlock&& other) noexcept;

    bool operator==(const InlineCodeBlock& other) const noexcept;
    bool operator!=(const InlineCodeBlock& other) const noexcept { return !operator==(other); }
    bool operator<(const InlineCodeBlock& other) const noexcept;
    bool operator<=(const InlineCodeBlock& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const InlineCodeBlock& other) const noexcept { return !operator<=(other); }
    bool operator>=(const InlineCodeBlock& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const InlineCodeBlock& value);

    void swap(InlineCodeBlock& other) noexcept;
    friend void swap(InlineCodeBlock& value1, InlineCodeBlock& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::InlineCodeBlock>
{
    typedef pg_query::InlineCodeBlock argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct CallContext : FBE::Base
{
    bool atomic;

    size_t fbe_type() const noexcept { return 228; }

    CallContext();
    explicit CallContext(bool arg_atomic);
    CallContext(const CallContext& other) = delete;
    CallContext(CallContext&& other) noexcept;
    ~CallContext() override;

    CallContext& operator=(const CallContext& other) = delete;
    CallContext& operator=(CallContext&& other) noexcept;

    bool operator==(const CallContext& other) const noexcept;
    bool operator!=(const CallContext& other) const noexcept { return !operator==(other); }
    bool operator<(const CallContext& other) const noexcept;
    bool operator<=(const CallContext& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const CallContext& other) const noexcept { return !operator<=(other); }
    bool operator>=(const CallContext& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const CallContext& value);

    void swap(CallContext& other) noexcept;
    friend void swap(CallContext& value1, CallContext& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::CallContext>
{
    typedef pg_query::CallContext argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ScanToken : FBE::Base
{
    int32_t start;
    int32_t end;
    ::pg_query::Token token;
    ::pg_query::KeywordKind keyword_kind;

    size_t fbe_type() const noexcept { return 229; }

    ScanToken();
    ScanToken(int32_t arg_start, int32_t arg_end, ::pg_query::Token&& arg_token, ::pg_query::KeywordKind&& arg_keyword_kind);
    ScanToken(const ScanToken& other) = delete;
    ScanToken(ScanToken&& other) noexcept;
    ~ScanToken() override;

    ScanToken& operator=(const ScanToken& other) = delete;
    ScanToken& operator=(ScanToken&& other) noexcept;

    bool operator==(const ScanToken& other) const noexcept;
    bool operator!=(const ScanToken& other) const noexcept { return !operator==(other); }
    bool operator<(const ScanToken& other) const noexcept;
    bool operator<=(const ScanToken& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ScanToken& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ScanToken& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ScanToken& value);

    void swap(ScanToken& other) noexcept;
    friend void swap(ScanToken& value1, ScanToken& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ScanToken>
{
    typedef pg_query::ScanToken argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ParseResult : FBE::Base
{
    int32_t version;
    std::vector<::pg_query::RawStmt> stmts;

    size_t fbe_type() const noexcept { return 230; }

    ParseResult();
    ParseResult(int32_t arg_version, std::vector<::pg_query::RawStmt> arg_stmts);
    ParseResult(const ParseResult& other) = delete;
    ParseResult(ParseResult&& other) noexcept;
    ~ParseResult() override;

    ParseResult& operator=(const ParseResult& other) = delete;
    ParseResult& operator=(ParseResult&& other) noexcept;

    bool operator==(const ParseResult& other) const noexcept;
    bool operator!=(const ParseResult& other) const noexcept { return !operator==(other); }
    bool operator<(const ParseResult& other) const noexcept;
    bool operator<=(const ParseResult& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ParseResult& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ParseResult& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ParseResult& value);

    void swap(ParseResult& other) noexcept;
    friend void swap(ParseResult& value1, ParseResult& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ParseResult>
{
    typedef pg_query::ParseResult argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

struct ScanResult : FBE::Base
{
    int32_t version;
    std::vector<::pg_query::ScanToken> tokens;

    size_t fbe_type() const noexcept { return 231; }

    ScanResult();
    ScanResult(int32_t arg_version, std::vector<::pg_query::ScanToken> arg_tokens);
    ScanResult(const ScanResult& other) = delete;
    ScanResult(ScanResult&& other) noexcept;
    ~ScanResult() override;

    ScanResult& operator=(const ScanResult& other) = delete;
    ScanResult& operator=(ScanResult&& other) noexcept;

    bool operator==(const ScanResult& other) const noexcept;
    bool operator!=(const ScanResult& other) const noexcept { return !operator==(other); }
    bool operator<(const ScanResult& other) const noexcept;
    bool operator<=(const ScanResult& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ScanResult& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ScanResult& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ScanResult& value);

    void swap(ScanResult& other) noexcept;
    friend void swap(ScanResult& value1, ScanResult& value2) noexcept { value1.swap(value2); }
};

} // namespace pg_query

namespace std {

template<>
struct hash<pg_query::ScanResult>
{
    typedef pg_query::ScanResult argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace pg_query {

} // namespace pg_query
