// This file is autogenerated by ./scripts/generate_protobuf_and_funcs.rb

package pg_query

variant Node {
    Alias*;
    RangeVar*;
    TableFunc*;
    Var*;
    Param*;
    Aggref*;
    GroupingFunc*;
    WindowFunc*;
    SubscriptingRef*;
    FuncExpr*;
    NamedArgExpr*;
    OpExpr*;
    DistinctExpr*;
    NullIfExpr*;
    ScalarArrayOpExpr*;
    BoolExpr*;
    SubLink*;
    SubPlan*;
    AlternativeSubPlan*;
    FieldSelect*;
    FieldStore*;
    RelabelType*;
    CoerceViaIO*;
    ArrayCoerceExpr*;
    ConvertRowtypeExpr*;
    CollateExpr*;
    CaseExpr*;
    CaseWhen*;
    CaseTestExpr*;
    ArrayExpr*;
    RowExpr*;
    RowCompareExpr*;
    CoalesceExpr*;
    MinMaxExpr*;
    SQLValueFunction*;
    XmlExpr*;
    NullTest*;
    BooleanTest*;
    CoerceToDomain*;
    CoerceToDomainValue*;
    SetToDefault*;
    CurrentOfExpr*;
    NextValueExpr*;
    InferenceElem*;
    TargetEntry*;
    RangeTblRef*;
    JoinExpr*;
    FromExpr*;
    OnConflictExpr*;
    IntoClause*;
    MergeAction*;
    RawStmt*;
    Query*;
    InsertStmt*;
    DeleteStmt*;
    UpdateStmt*;
    MergeStmt*;
    SelectStmt*;
    ReturnStmt*;
    PLAssignStmt*;
    AlterTableStmt*;
    AlterTableCmd*;
    AlterDomainStmt*;
    SetOperationStmt*;
    GrantStmt*;
    GrantRoleStmt*;
    AlterDefaultPrivilegesStmt*;
    ClosePortalStmt*;
    ClusterStmt*;
    CopyStmt*;
    CreateStmt*;
    DefineStmt*;
    DropStmt*;
    TruncateStmt*;
    CommentStmt*;
    FetchStmt*;
    IndexStmt*;
    CreateFunctionStmt*;
    AlterFunctionStmt*;
    DoStmt*;
    RenameStmt*;
    RuleStmt*;
    NotifyStmt*;
    ListenStmt*;
    UnlistenStmt*;
    TransactionStmt*;
    ViewStmt*;
    LoadStmt*;
    CreateDomainStmt*;
    CreatedbStmt*;
    DropdbStmt*;
    VacuumStmt*;
    ExplainStmt*;
    CreateTableAsStmt*;
    CreateSeqStmt*;
    AlterSeqStmt*;
    VariableSetStmt*;
    VariableShowStmt*;
    DiscardStmt*;
    CreateTrigStmt*;
    CreatePLangStmt*;
    CreateRoleStmt*;
    AlterRoleStmt*;
    DropRoleStmt*;
    LockStmt*;
    ConstraintsSetStmt*;
    ReindexStmt*;
    CheckPointStmt*;
    CreateSchemaStmt*;
    AlterDatabaseStmt*;
    AlterDatabaseRefreshCollStmt*;
    AlterDatabaseSetStmt*;
    AlterRoleSetStmt*;
    CreateConversionStmt*;
    CreateCastStmt*;
    CreateOpClassStmt*;
    CreateOpFamilyStmt*;
    AlterOpFamilyStmt*;
    PrepareStmt*;
    ExecuteStmt*;
    DeallocateStmt*;
    DeclareCursorStmt*;
    CreateTableSpaceStmt*;
    DropTableSpaceStmt*;
    AlterObjectDependsStmt*;
    AlterObjectSchemaStmt*;
    AlterOwnerStmt*;
    AlterOperatorStmt*;
    AlterTypeStmt*;
    DropOwnedStmt*;
    ReassignOwnedStmt*;
    CompositeTypeStmt*;
    CreateEnumStmt*;
    CreateRangeStmt*;
    AlterEnumStmt*;
    AlterTSDictionaryStmt*;
    AlterTSConfigurationStmt*;
    CreateFdwStmt*;
    AlterFdwStmt*;
    CreateForeignServerStmt*;
    AlterForeignServerStmt*;
    CreateUserMappingStmt*;
    AlterUserMappingStmt*;
    DropUserMappingStmt*;
    AlterTableSpaceOptionsStmt*;
    AlterTableMoveAllStmt*;
    SecLabelStmt*;
    CreateForeignTableStmt*;
    ImportForeignSchemaStmt*;
    CreateExtensionStmt*;
    AlterExtensionStmt*;
    AlterExtensionContentsStmt*;
    CreateEventTrigStmt*;
    AlterEventTrigStmt*;
    RefreshMatViewStmt*;
    ReplicaIdentityStmt*;
    AlterSystemStmt*;
    CreatePolicyStmt*;
    AlterPolicyStmt*;
    CreateTransformStmt*;
    CreateAmStmt*;
    CreatePublicationStmt*;
    AlterPublicationStmt*;
    CreateSubscriptionStmt*;
    AlterSubscriptionStmt*;
    DropSubscriptionStmt*;
    CreateStatsStmt*;
    AlterCollationStmt*;
    CallStmt*;
    AlterStatsStmt*;
    A_Expr*;
    ColumnRef*;
    ParamRef*;
    FuncCall*;
    A_Star*;
    A_Indices*;
    A_Indirection*;
    A_ArrayExpr*;
    ResTarget*;
    MultiAssignRef*;
    TypeCast*;
    CollateClause*;
    SortBy*;
    WindowDef*;
    RangeSubselect*;
    RangeFunction*;
    RangeTableSample*;
    RangeTableFunc*;
    RangeTableFuncCol*;
    TypeName*;
    ColumnDef*;
    IndexElem*;
    StatsElem*;
    Constraint*;
    DefElem*;
    RangeTblEntry*;
    RangeTblFunction*;
    TableSampleClause*;
    WithCheckOption*;
    SortGroupClause*;
    GroupingSet*;
    WindowClause*;
    ObjectWithArgs*;
    AccessPriv*;
    CreateOpClassItem*;
    TableLikeClause*;
    FunctionParameter*;
    LockingClause*;
    RowMarkClause*;
    XmlSerialize*;
    WithClause*;
    InferClause*;
    OnConflictClause*;
    CTESearchClause*;
    CTECycleClause*;
    CommonTableExpr*;
    MergeWhenClause*;
    RoleSpec*;
    TriggerTransition*;
    PartitionElem*;
    PartitionSpec*;
    PartitionBoundSpec*;
    PartitionRangeDatum*;
    PartitionCmd*;
    VacuumRelation*;
    PublicationObjSpec*;
    PublicationTable*;
    InlineCodeBlock*;
    CallContext*;
    Integer*;
    Float*;
    Boolean*;
    String*;
    BitString*;
    List*;
    IntList*;
    OidList*;
    A_Const*;
}

struct Integer
{
  int32 ival; /* machine integer */
}

struct Float
{
  string fval; /* string */
}

struct Boolean
{
  bool boolval = 1;
}

struct String
{
  string sval; /* string */
}

struct BitString
{
  string bsval; /* string */
}

struct List
{
  Node[] items;
}

struct OidList
{
  Node[] items;
}

struct IntList
{
  Node[] items;
}

variant A_Const_Value {
  Integer*;
  Float*;
  Boolean*;
  String*;
  BitString*;
}
struct A_Const
{
  A_Const_Value val;
  bool isnull = 10;
  int32 location = 11;
}


struct Alias
{
  string aliasname;
  Node[] colnames;
}

struct RangeVar
{
  string catalogname;
  string schemaname;
  string relname;
  bool inh;
  string relpersistence;
  Alias* alias;
  int32 location;
}

struct TableFunc
{
  Node[] ns_uris;
  Node[] ns_names;
  Node docexpr;
  Node rowexpr;
  Node[] colnames;
  Node[] coltypes;
  Node[] coltypmods;
  Node[] colcollations;
  Node[] colexprs;
  Node[] coldefexprs;
  uint64[] notnulls;
  int32 ordinalitycol;
  int32 location;
}

struct Var
{
  Node xpr;
  int32 varno;
  int32 varattno;
  uint32 vartype;
  int32 vartypmod;
  uint32 varcollid;
  uint32 varlevelsup;
  uint32 varnosyn;
  int32 varattnosyn;
  int32 location;
}

struct Param
{
  Node xpr;
  ParamKind paramkind;
  int32 paramid;
  uint32 paramtype;
  int32 paramtypmod;
  uint32 paramcollid;
  int32 location;
}

struct Aggref
{
  Node xpr;
  uint32 aggfnoid;
  uint32 aggtype;
  uint32 aggcollid;
  uint32 inputcollid;
  uint32 aggtranstype;
  Node[] aggargtypes;
  Node[] aggdirectargs;
  Node[] args;
  Node[] aggorder;
  Node[] aggdistinct;
  Node aggfilter;
  bool aggstar;
  bool aggvariadic;
  string aggkind;
  uint32 agglevelsup;
  AggSplit aggsplit;
  int32 aggno;
  int32 aggtransno;
  int32 location;
}

struct GroupingFunc
{
  Node xpr;
  Node[] args;
  Node[] refs;
  Node[] cols;
  uint32 agglevelsup;
  int32 location;
}

struct WindowFunc
{
  Node xpr;
  uint32 winfnoid;
  uint32 wintype;
  uint32 wincollid;
  uint32 inputcollid;
  Node[] args;
  Node aggfilter;
  uint32 winref;
  bool winstar;
  bool winagg;
  int32 location;
}

struct SubscriptingRef
{
  Node xpr;
  uint32 refcontainertype;
  uint32 refelemtype;
  uint32 refrestype;
  int32 reftypmod;
  uint32 refcollid;
  Node[] refupperindexpr;
  Node[] reflowerindexpr;
  Node refexpr;
  Node refassgnexpr;
}

struct FuncExpr
{
  Node xpr;
  uint32 funcid;
  uint32 funcresulttype;
  bool funcretset;
  bool funcvariadic;
  CoercionForm funcformat;
  uint32 funccollid;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct NamedArgExpr
{
  Node xpr;
  Node arg;
  string name;
  int32 argnumber;
  int32 location;
}

struct OpExpr
{
  Node xpr;
  uint32 opno;
  uint32 opfuncid;
  uint32 opresulttype;
  bool opretset;
  uint32 opcollid;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct DistinctExpr
{
  Node xpr;
  uint32 opno;
  uint32 opfuncid;
  uint32 opresulttype;
  bool opretset;
  uint32 opcollid;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct NullIfExpr
{
  Node xpr;
  uint32 opno;
  uint32 opfuncid;
  uint32 opresulttype;
  bool opretset;
  uint32 opcollid;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct ScalarArrayOpExpr
{
  Node xpr;
  uint32 opno;
  uint32 opfuncid;
  uint32 hashfuncid;
  uint32 negfuncid;
  bool use_or;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct BoolExpr
{
  Node xpr;
  BoolExprType boolop;
  Node[] args;
  int32 location;
}

struct SubLink
{
  Node xpr;
  SubLinkType sub_link_type;
  int32 sub_link_id;
  Node testexpr;
  Node[] oper_name;
  Node subselect;
  int32 location;
}

struct SubPlan
{
  Node xpr;
  SubLinkType sub_link_type;
  Node testexpr;
  Node[] param_ids;
  int32 plan_id;
  string plan_name;
  uint32 first_col_type;
  int32 first_col_typmod;
  uint32 first_col_collation;
  bool use_hash_table;
  bool unknown_eq_false;
  bool parallel_safe;
  Node[] set_param;
  Node[] par_param;
  Node[] args;
  double startup_cost;
  double per_call_cost;
}

struct AlternativeSubPlan
{
  Node xpr;
  Node[] subplans;
}

struct FieldSelect
{
  Node xpr;
  Node arg;
  int32 fieldnum;
  uint32 resulttype;
  int32 resulttypmod;
  uint32 resultcollid;
}

struct FieldStore
{
  Node xpr;
  Node arg;
  Node[] newvals;
  Node[] fieldnums;
  uint32 resulttype;
}

struct RelabelType
{
  Node xpr;
  Node arg;
  uint32 resulttype;
  int32 resulttypmod;
  uint32 resultcollid;
  CoercionForm relabelformat;
  int32 location;
}

struct CoerceViaIO
{
  Node xpr;
  Node arg;
  uint32 resulttype;
  uint32 resultcollid;
  CoercionForm coerceformat;
  int32 location;
}

struct ArrayCoerceExpr
{
  Node xpr;
  Node arg;
  Node elemexpr;
  uint32 resulttype;
  int32 resulttypmod;
  uint32 resultcollid;
  CoercionForm coerceformat;
  int32 location;
}

struct ConvertRowtypeExpr
{
  Node xpr;
  Node arg;
  uint32 resulttype;
  CoercionForm convertformat;
  int32 location;
}

struct CollateExpr
{
  Node xpr;
  Node arg;
  uint32 coll_oid;
  int32 location;
}

struct CaseExpr
{
  Node xpr;
  uint32 casetype;
  uint32 casecollid;
  Node arg;
  Node[] args;
  Node defresult;
  int32 location;
}

struct CaseWhen
{
  Node xpr;
  Node expr;
  Node result;
  int32 location;
}

struct CaseTestExpr
{
  Node xpr;
  uint32 type_id;
  int32 type_mod;
  uint32 collation;
}

struct ArrayExpr
{
  Node xpr;
  uint32 array_typeid;
  uint32 array_collid;
  uint32 element_typeid;
  Node[] elements;
  bool multidims;
  int32 location;
}

struct RowExpr
{
  Node xpr;
  Node[] args;
  uint32 row_typeid;
  CoercionForm row_format;
  Node[] colnames;
  int32 location;
}

struct RowCompareExpr
{
  Node xpr;
  RowCompareType rctype;
  Node[] opnos;
  Node[] opfamilies;
  Node[] inputcollids;
  Node[] largs;
  Node[] rargs;
}

struct CoalesceExpr
{
  Node xpr;
  uint32 coalescetype;
  uint32 coalescecollid;
  Node[] args;
  int32 location;
}

struct MinMaxExpr
{
  Node xpr;
  uint32 minmaxtype;
  uint32 minmaxcollid;
  uint32 inputcollid;
  MinMaxOp op;
  Node[] args;
  int32 location;
}

struct SQLValueFunction
{
  Node xpr;
  SQLValueFunctionOp op;
  uint32 type;
  int32 typmod;
  int32 location;
}

struct XmlExpr
{
  Node xpr;
  XmlExprOp op;
  string name;
  Node[] named_args;
  Node[] arg_names;
  Node[] args;
  XmlOptionType xmloption;
  uint32 type;
  int32 typmod;
  int32 location;
}

struct NullTest
{
  Node xpr;
  Node arg;
  NullTestType nulltesttype;
  bool argisrow;
  int32 location;
}

struct BooleanTest
{
  Node xpr;
  Node arg;
  BoolTestType booltesttype;
  int32 location;
}

struct CoerceToDomain
{
  Node xpr;
  Node arg;
  uint32 resulttype;
  int32 resulttypmod;
  uint32 resultcollid;
  CoercionForm coercionformat;
  int32 location;
}

struct CoerceToDomainValue
{
  Node xpr;
  uint32 type_id;
  int32 type_mod;
  uint32 collation;
  int32 location;
}

struct SetToDefault
{
  Node xpr;
  uint32 type_id;
  int32 type_mod;
  uint32 collation;
  int32 location;
}

struct CurrentOfExpr
{
  Node xpr;
  uint32 cvarno;
  string cursor_name;
  int32 cursor_param;
}

struct NextValueExpr
{
  Node xpr;
  uint32 seqid;
  uint32 type_id;
}

struct InferenceElem
{
  Node xpr;
  Node expr;
  uint32 infercollid;
  uint32 inferopclass;
}

struct TargetEntry
{
  Node xpr;
  Node expr;
  int32 resno;
  string resname;
  uint32 ressortgroupref;
  uint32 resorigtbl;
  int32 resorigcol;
  bool resjunk;
}

struct RangeTblRef
{
  int32 rtindex;
}

struct JoinExpr
{
  JoinType jointype;
  bool is_natural;
  Node larg;
  Node rarg;
  Node[] using_clause;
  Alias* join_using_alias;
  Node quals;
  Alias* alias;
  int32 rtindex;
}

struct FromExpr
{
  Node[] fromlist;
  Node quals;
}

struct OnConflictExpr
{
  OnConflictAction action;
  Node[] arbiter_elems;
  Node arbiter_where;
  uint32 constraint;
  Node[] on_conflict_set;
  Node on_conflict_where;
  int32 excl_rel_index;
  Node[] excl_rel_tlist;
}

struct IntoClause
{
  RangeVar* rel;
  Node[] col_names;
  string access_method;
  Node[] options;
  OnCommitAction on_commit;
  string table_space_name;
  Node view_query;
  bool skip_data;
}

struct MergeAction
{
  bool matched;
  CmdType command_type;
  OverridingKind override;
  Node qual;
  Node[] target_list;
  Node[] update_colnos;
}

struct RawStmt
{
  Node stmt;
  int32 stmt_location;
  int32 stmt_len;
}

struct Query
{
  CmdType command_type;
  QuerySource query_source;
  bool can_set_tag;
  Node utility_stmt;
  int32 result_relation;
  bool has_aggs;
  bool has_window_funcs;
  bool has_target_srfs;
  bool has_sub_links;
  bool has_distinct_on;
  bool has_recursive;
  bool has_modifying_cte;
  bool has_for_update;
  bool has_row_security;
  bool is_return;
  Node[] cte_list;
  Node[] rtable;
  FromExpr* jointree;
  Node[] merge_action_list;
  bool merge_use_outer_join;
  Node[] target_list;
  OverridingKind override;
  OnConflictExpr* on_conflict;
  Node[] returning_list;
  Node[] group_clause;
  bool group_distinct;
  Node[] grouping_sets;
  Node having_qual;
  Node[] window_clause;
  Node[] distinct_clause;
  Node[] sort_clause;
  Node limit_offset;
  Node limit_count;
  LimitOption limit_option;
  Node[] row_marks;
  Node set_operations;
  Node[] constraint_deps;
  Node[] with_check_options;
  int32 stmt_location;
  int32 stmt_len;
}

struct InsertStmt
{
  RangeVar* relation;
  Node[] cols;
  Node select_stmt;
  OnConflictClause* on_conflict_clause;
  Node[] returning_list;
  WithClause* with_clause;
  OverridingKind override;
}

struct DeleteStmt
{
  RangeVar* relation;
  Node[] using_clause;
  Node where_clause;
  Node[] returning_list;
  WithClause* with_clause;
}

struct UpdateStmt
{
  RangeVar* relation;
  Node[] target_list;
  Node where_clause;
  Node[] from_clause;
  Node[] returning_list;
  WithClause* with_clause;
}

struct MergeStmt
{
  RangeVar* relation;
  Node source_relation;
  Node join_condition;
  Node[] merge_when_clauses;
  WithClause* with_clause;
}

struct SelectStmt
{
  Node[] distinct_clause;
  IntoClause* into_clause;
  Node[] target_list;
  Node[] from_clause;
  Node where_clause;
  Node[] group_clause;
  bool group_distinct;
  Node having_clause;
  Node[] window_clause;
  Node[] values_lists;
  Node[] sort_clause;
  Node limit_offset;
  Node limit_count;
  LimitOption limit_option;
  Node[] locking_clause;
  WithClause* with_clause;
  SetOperation op;
  bool all;
  SelectStmt* larg;
  SelectStmt* rarg;
}

struct ReturnStmt
{
  Node returnval;
}

struct PLAssignStmt
{
  string name;
  Node[] indirection;
  int32 nnames;
  SelectStmt* val;
  int32 location;
}

struct AlterTableStmt
{
  RangeVar* relation;
  Node[] cmds;
  ObjectType objtype;
  bool missing_ok;
}

struct AlterTableCmd
{
  AlterTableType subtype;
  string name;
  int32 num;
  RoleSpec* newowner;
  Node def;
  DropBehavior behavior;
  bool missing_ok;
  bool recurse;
}

struct AlterDomainStmt
{
  string subtype;
  Node[] type_name;
  string name;
  Node def;
  DropBehavior behavior;
  bool missing_ok;
}

struct SetOperationStmt
{
  SetOperation op;
  bool all;
  Node larg;
  Node rarg;
  Node[] col_types;
  Node[] col_typmods;
  Node[] col_collations;
  Node[] group_clauses;
}

struct GrantStmt
{
  bool is_grant;
  GrantTargetType targtype;
  ObjectType objtype;
  Node[] objects;
  Node[] privileges;
  Node[] grantees;
  bool grant_option;
  RoleSpec* grantor;
  DropBehavior behavior;
}

struct GrantRoleStmt
{
  Node[] granted_roles;
  Node[] grantee_roles;
  bool is_grant;
  bool admin_opt;
  RoleSpec* grantor;
  DropBehavior behavior;
}

struct AlterDefaultPrivilegesStmt
{
  Node[] options;
  GrantStmt* action;
}

struct ClosePortalStmt
{
  string portalname;
}

struct ClusterStmt
{
  RangeVar* relation;
  string indexname;
  Node[] params;
}

struct CopyStmt
{
  RangeVar* relation;
  Node query;
  Node[] attlist;
  bool is_from;
  bool is_program;
  string filename;
  Node[] options;
  Node where_clause;
}

struct CreateStmt
{
  RangeVar* relation;
  Node[] table_elts;
  Node[] inh_relations;
  PartitionBoundSpec* partbound;
  PartitionSpec* partspec;
  TypeName* of_typename;
  Node[] constraints;
  Node[] options;
  OnCommitAction oncommit;
  string tablespacename;
  string access_method;
  bool if_not_exists;
}

struct DefineStmt
{
  ObjectType kind;
  bool oldstyle;
  Node[] defnames;
  Node[] args;
  Node[] definition;
  bool if_not_exists;
  bool replace;
}

struct DropStmt
{
  Node[] objects;
  ObjectType remove_type;
  DropBehavior behavior;
  bool missing_ok;
  bool concurrent;
}

struct TruncateStmt
{
  Node[] relations;
  bool restart_seqs;
  DropBehavior behavior;
}

struct CommentStmt
{
  ObjectType objtype;
  Node object;
  string comment;
}

struct FetchStmt
{
  FetchDirection direction;
  int64 how_many;
  string portalname;
  bool ismove;
}

struct IndexStmt
{
  string idxname;
  RangeVar* relation;
  string access_method;
  string table_space;
  Node[] index_params;
  Node[] index_including_params;
  Node[] options;
  Node where_clause;
  Node[] exclude_op_names;
  string idxcomment;
  uint32 index_oid;
  uint32 old_node;
  uint32 old_create_subid;
  uint32 old_first_relfilenode_subid;
  bool unique;
  bool nulls_not_distinct;
  bool primary;
  bool isconstraint;
  bool deferrable;
  bool initdeferred;
  bool transformed;
  bool concurrent;
  bool if_not_exists;
  bool reset_default_tblspc;
}

struct CreateFunctionStmt
{
  bool is_procedure;
  bool replace;
  Node[] funcname;
  Node[] parameters;
  TypeName* return_type;
  Node[] options;
  Node sql_body;
}

struct AlterFunctionStmt
{
  ObjectType objtype;
  ObjectWithArgs* func;
  Node[] actions;
}

struct DoStmt
{
  Node[] args;
}

struct RenameStmt
{
  ObjectType rename_type;
  ObjectType relation_type;
  RangeVar* relation;
  Node object;
  string subname;
  string newname;
  DropBehavior behavior;
  bool missing_ok;
}

struct RuleStmt
{
  RangeVar* relation;
  string rulename;
  Node where_clause;
  CmdType event;
  bool instead;
  Node[] actions;
  bool replace;
}

struct NotifyStmt
{
  string conditionname;
  string payload;
}

struct ListenStmt
{
  string conditionname;
}

struct UnlistenStmt
{
  string conditionname;
}

struct TransactionStmt
{
  TransactionStmtKind kind;
  Node[] options;
  string savepoint_name;
  string gid;
  bool chain;
}

struct ViewStmt
{
  RangeVar* view;
  Node[] aliases;
  Node query;
  bool replace;
  Node[] options;
  ViewCheckOption with_check_option;
}

struct LoadStmt
{
  string filename;
}

struct CreateDomainStmt
{
  Node[] domainname;
  TypeName* type_name;
  CollateClause* coll_clause;
  Node[] constraints;
}

struct CreatedbStmt
{
  string dbname;
  Node[] options;
}

struct DropdbStmt
{
  string dbname;
  bool missing_ok;
  Node[] options;
}

struct VacuumStmt
{
  Node[] options;
  Node[] rels;
  bool is_vacuumcmd;
}

struct ExplainStmt
{
  Node query;
  Node[] options;
}

struct CreateTableAsStmt
{
  Node query;
  IntoClause* into;
  ObjectType objtype;
  bool is_select_into;
  bool if_not_exists;
}

struct CreateSeqStmt
{
  RangeVar* sequence;
  Node[] options;
  uint32 owner_id;
  bool for_identity;
  bool if_not_exists;
}

struct AlterSeqStmt
{
  RangeVar* sequence;
  Node[] options;
  bool for_identity;
  bool missing_ok;
}

struct VariableSetStmt
{
  VariableSetKind kind;
  string name;
  Node[] args;
  bool is_local;
}

struct VariableShowStmt
{
  string name;
}

struct DiscardStmt
{
  DiscardMode target;
}

struct CreateTrigStmt
{
  bool replace;
  bool isconstraint;
  string trigname;
  RangeVar* relation;
  Node[] funcname;
  Node[] args;
  bool row;
  int32 timing;
  int32 events;
  Node[] columns;
  Node when_clause;
  Node[] transition_rels;
  bool deferrable;
  bool initdeferred;
  RangeVar* constrrel;
}

struct CreatePLangStmt
{
  bool replace;
  string plname;
  Node[] plhandler;
  Node[] plinline;
  Node[] plvalidator;
  bool pltrusted;
}

struct CreateRoleStmt
{
  RoleStmtType stmt_type;
  string role;
  Node[] options;
}

struct AlterRoleStmt
{
  RoleSpec* role;
  Node[] options;
  int32 action;
}

struct DropRoleStmt
{
  Node[] roles;
  bool missing_ok;
}

struct LockStmt
{
  Node[] relations;
  int32 mode;
  bool nowait;
}

struct ConstraintsSetStmt
{
  Node[] constraints;
  bool deferred;
}

struct ReindexStmt
{
  ReindexObjectType kind;
  RangeVar* relation;
  string name;
  Node[] params;
}

struct CheckPointStmt
{
}

struct CreateSchemaStmt
{
  string schemaname;
  RoleSpec* authrole;
  Node[] schema_elts;
  bool if_not_exists;
}

struct AlterDatabaseStmt
{
  string dbname;
  Node[] options;
}

struct AlterDatabaseRefreshCollStmt
{
  string dbname;
}

struct AlterDatabaseSetStmt
{
  string dbname;
  VariableSetStmt* setstmt;
}

struct AlterRoleSetStmt
{
  RoleSpec* role;
  string database;
  VariableSetStmt* setstmt;
}

struct CreateConversionStmt
{
  Node[] conversion_name;
  string for_encoding_name;
  string to_encoding_name;
  Node[] func_name;
  bool def;
}

struct CreateCastStmt
{
  TypeName* sourcetype;
  TypeName* targettype;
  ObjectWithArgs* func;
  CoercionContext context;
  bool inout;
}

struct CreateOpClassStmt
{
  Node[] opclassname;
  Node[] opfamilyname;
  string amname;
  TypeName* datatype;
  Node[] items;
  bool is_default;
}

struct CreateOpFamilyStmt
{
  Node[] opfamilyname;
  string amname;
}

struct AlterOpFamilyStmt
{
  Node[] opfamilyname;
  string amname;
  bool is_drop;
  Node[] items;
}

struct PrepareStmt
{
  string name;
  Node[] argtypes;
  Node query;
}

struct ExecuteStmt
{
  string name;
  Node[] params;
}

struct DeallocateStmt
{
  string name;
}

struct DeclareCursorStmt
{
  string portalname;
  int32 options;
  Node query;
}

struct CreateTableSpaceStmt
{
  string tablespacename;
  RoleSpec* owner;
  string location;
  Node[] options;
}

struct DropTableSpaceStmt
{
  string tablespacename;
  bool missing_ok;
}

struct AlterObjectDependsStmt
{
  ObjectType object_type;
  RangeVar* relation;
  Node object;
  String* extname;
  bool remove;
}

struct AlterObjectSchemaStmt
{
  ObjectType object_type;
  RangeVar* relation;
  Node object;
  string newschema;
  bool missing_ok;
}

struct AlterOwnerStmt
{
  ObjectType object_type;
  RangeVar* relation;
  Node object;
  RoleSpec* newowner;
}

struct AlterOperatorStmt
{
  ObjectWithArgs* opername;
  Node[] options;
}

struct AlterTypeStmt
{
  Node[] type_name;
  Node[] options;
}

struct DropOwnedStmt
{
  Node[] roles;
  DropBehavior behavior;
}

struct ReassignOwnedStmt
{
  Node[] roles;
  RoleSpec* newrole;
}

struct CompositeTypeStmt
{
  RangeVar* typevar;
  Node[] coldeflist;
}

struct CreateEnumStmt
{
  Node[] type_name;
  Node[] vals;
}

struct CreateRangeStmt
{
  Node[] type_name;
  Node[] params;
}

struct AlterEnumStmt
{
  Node[] type_name;
  string old_val;
  string new_val;
  string new_val_neighbor;
  bool new_val_is_after;
  bool skip_if_new_val_exists;
}

struct AlterTSDictionaryStmt
{
  Node[] dictname;
  Node[] options;
}

struct AlterTSConfigurationStmt
{
  AlterTSConfigType kind;
  Node[] cfgname;
  Node[] tokentype;
  Node[] dicts;
  bool override;
  bool replace;
  bool missing_ok;
}

struct CreateFdwStmt
{
  string fdwname;
  Node[] func_options;
  Node[] options;
}

struct AlterFdwStmt
{
  string fdwname;
  Node[] func_options;
  Node[] options;
}

struct CreateForeignServerStmt
{
  string servername;
  string servertype;
  string version;
  string fdwname;
  bool if_not_exists;
  Node[] options;
}

struct AlterForeignServerStmt
{
  string servername;
  string version;
  Node[] options;
  bool has_version;
}

struct CreateUserMappingStmt
{
  RoleSpec* user;
  string servername;
  bool if_not_exists;
  Node[] options;
}

struct AlterUserMappingStmt
{
  RoleSpec* user;
  string servername;
  Node[] options;
}

struct DropUserMappingStmt
{
  RoleSpec* user;
  string servername;
  bool missing_ok;
}

struct AlterTableSpaceOptionsStmt
{
  string tablespacename;
  Node[] options;
  bool is_reset;
}

struct AlterTableMoveAllStmt
{
  string orig_tablespacename;
  ObjectType objtype;
  Node[] roles;
  string new_tablespacename;
  bool nowait;
}

struct SecLabelStmt
{
  ObjectType objtype;
  Node object;
  string provider;
  string label;
}

struct CreateForeignTableStmt
{
  CreateStmt base_stmt;
  string servername;
  Node[] options;
}

struct ImportForeignSchemaStmt
{
  string server_name;
  string remote_schema;
  string local_schema;
  ImportForeignSchemaType list_type;
  Node[] table_list;
  Node[] options;
}

struct CreateExtensionStmt
{
  string extname;
  bool if_not_exists;
  Node[] options;
}

struct AlterExtensionStmt
{
  string extname;
  Node[] options;
}

struct AlterExtensionContentsStmt
{
  string extname;
  int32 action;
  ObjectType objtype;
  Node object;
}

struct CreateEventTrigStmt
{
  string trigname;
  string eventname;
  Node[] whenclause;
  Node[] funcname;
}

struct AlterEventTrigStmt
{
  string trigname;
  string tgenabled;
}

struct RefreshMatViewStmt
{
  bool concurrent;
  bool skip_data;
  RangeVar* relation;
}

struct ReplicaIdentityStmt
{
  string identity_type;
  string name;
}

struct AlterSystemStmt
{
  VariableSetStmt* setstmt;
}

struct CreatePolicyStmt
{
  string policy_name;
  RangeVar* table;
  string cmd_name;
  bool permissive;
  Node[] roles;
  Node qual;
  Node with_check;
}

struct AlterPolicyStmt
{
  string policy_name;
  RangeVar* table;
  Node[] roles;
  Node qual;
  Node with_check;
}

struct CreateTransformStmt
{
  bool replace;
  TypeName* type_name;
  string lang;
  ObjectWithArgs* fromsql;
  ObjectWithArgs* tosql;
}

struct CreateAmStmt
{
  string amname;
  Node[] handler_name;
  string amtype;
}

struct CreatePublicationStmt
{
  string pubname;
  Node[] options;
  Node[] pubobjects;
  bool for_all_tables;
}

struct AlterPublicationStmt
{
  string pubname;
  Node[] options;
  Node[] pubobjects;
  bool for_all_tables;
  AlterPublicationAction action;
}

struct CreateSubscriptionStmt
{
  string subname;
  string conninfo;
  Node[] publication;
  Node[] options;
}

struct AlterSubscriptionStmt
{
  AlterSubscriptionType kind;
  string subname;
  string conninfo;
  Node[] publication;
  Node[] options;
}

struct DropSubscriptionStmt
{
  string subname;
  bool missing_ok;
  DropBehavior behavior;
}

struct CreateStatsStmt
{
  Node[] defnames;
  Node[] stat_types;
  Node[] exprs;
  Node[] relations;
  string stxcomment;
  bool transformed;
  bool if_not_exists;
}

struct AlterCollationStmt
{
  Node[] collname;
}

struct CallStmt
{
  FuncCall* funccall;
  FuncExpr* funcexpr;
  Node[] outargs;
}

struct AlterStatsStmt
{
  Node[] defnames;
  int32 stxstattarget;
  bool missing_ok;
}

struct A_Expr
{
  A_Expr_Kind kind;
  Node[] name;
  Node lexpr;
  Node rexpr;
  int32 location;
}

struct ColumnRef
{
  Node[] fields;
  int32 location;
}

struct ParamRef
{
  int32 number;
  int32 location;
}

struct FuncCall
{
  Node[] funcname;
  Node[] args;
  Node[] agg_order;
  Node agg_filter;
  WindowDef* over;
  bool agg_within_group;
  bool agg_star;
  bool agg_distinct;
  bool func_variadic;
  CoercionForm funcformat;
  int32 location;
}

struct A_Star
{
}

struct A_Indices
{
  bool is_slice;
  Node lidx;
  Node uidx;
}

struct A_Indirection
{
  Node arg;
  Node[] indirection;
}

struct A_ArrayExpr
{
  Node[] elements;
  int32 location;
}

struct ResTarget
{
  string name;
  Node[] indirection;
  Node val;
  int32 location;
}

struct MultiAssignRef
{
  Node source;
  int32 colno;
  int32 ncolumns;
}

struct TypeCast
{
  Node arg;
  TypeName* type_name;
  int32 location;
}

struct CollateClause
{
  Node arg;
  Node[] collname;
  int32 location;
}

struct SortBy
{
  Node node;
  SortByDir sortby_dir;
  SortByNulls sortby_nulls;
  Node[] use_op;
  int32 location;
}

struct WindowDef
{
  string name;
  string refname;
  Node[] partition_clause;
  Node[] order_clause;
  int32 frame_options;
  Node start_offset;
  Node end_offset;
  int32 location;
}

struct RangeSubselect
{
  bool lateral;
  Node subquery;
  Alias* alias;
}

struct RangeFunction
{
  bool lateral;
  bool ordinality;
  bool is_rowsfrom;
  Node[] functions;
  Alias* alias;
  Node[] coldeflist;
}

struct RangeTableSample
{
  Node relation;
  Node[] method;
  Node[] args;
  Node repeatable;
  int32 location;
}

struct RangeTableFunc
{
  bool lateral;
  Node docexpr;
  Node rowexpr;
  Node[] namespaces;
  Node[] columns;
  Alias* alias;
  int32 location;
}

struct RangeTableFuncCol
{
  string colname;
  TypeName* type_name;
  bool for_ordinality;
  bool is_not_null;
  Node colexpr;
  Node coldefexpr;
  int32 location;
}

struct TypeName
{
  Node[] names;
  uint32 type_oid;
  bool setof;
  bool pct_type;
  Node[] typmods;
  int32 typemod;
  Node[] array_bounds;
  int32 location;
}

struct ColumnDef
{
  string colname;
  TypeName* type_name;
  string compression;
  int32 inhcount;
  bool is_local;
  bool is_not_null;
  bool is_from_type;
  string storage;
  Node raw_default;
  Node cooked_default;
  string identity;
  RangeVar* identity_sequence;
  string generated;
  CollateClause* coll_clause;
  uint32 coll_oid;
  Node[] constraints;
  Node[] fdwoptions;
  int32 location;
}

struct IndexElem
{
  string name;
  Node expr;
  string indexcolname;
  Node[] collation;
  Node[] opclass;
  Node[] opclassopts;
  SortByDir ordering;
  SortByNulls nulls_ordering;
}

struct StatsElem
{
  string name;
  Node expr;
}

struct Constraint
{
  ConstrType contype;
  string conname;
  bool deferrable;
  bool initdeferred;
  int32 location;
  bool is_no_inherit;
  Node raw_expr;
  string cooked_expr;
  string generated_when;
  bool nulls_not_distinct;
  Node[] keys;
  Node[] including;
  Node[] exclusions;
  Node[] options;
  string indexname;
  string indexspace;
  bool reset_default_tblspc;
  string access_method;
  Node where_clause;
  RangeVar* pktable;
  Node[] fk_attrs;
  Node[] pk_attrs;
  string fk_matchtype;
  string fk_upd_action;
  string fk_del_action;
  Node[] fk_del_set_cols;
  Node[] old_conpfeqop;
  uint32 old_pktable_oid;
  bool skip_validation;
  bool initially_valid;
}

struct DefElem
{
  string defnamespace;
  string defname;
  Node arg;
  DefElemAction defaction;
  int32 location;
}

struct RangeTblEntry
{
  RTEKind rtekind;
  uint32 relid;
  string relkind;
  int32 rellockmode;
  TableSampleClause* tablesample;
  Query* subquery;
  bool security_barrier;
  JoinType jointype;
  int32 joinmergedcols;
  Node[] joinaliasvars;
  Node[] joinleftcols;
  Node[] joinrightcols;
  Alias* join_using_alias;
  Node[] functions;
  bool funcordinality;
  TableFunc* tablefunc;
  Node[] values_lists;
  string ctename;
  uint32 ctelevelsup;
  bool self_reference;
  Node[] coltypes;
  Node[] coltypmods;
  Node[] colcollations;
  string enrname;
  double enrtuples;
  Alias* alias;
  Alias* eref;
  bool lateral;
  bool inh;
  bool in_from_cl;
  uint32 required_perms;
  uint32 check_as_user;
  uint64[] selected_cols;
  uint64[] inserted_cols;
  uint64[] updated_cols;
  uint64[] extra_updated_cols;
  Node[] security_quals;
}

struct RangeTblFunction
{
  Node funcexpr;
  int32 funccolcount;
  Node[] funccolnames;
  Node[] funccoltypes;
  Node[] funccoltypmods;
  Node[] funccolcollations;
  uint64[] funcparams;
}

struct TableSampleClause
{
  uint32 tsmhandler;
  Node[] args;
  Node repeatable;
}

struct WithCheckOption
{
  WCOKind kind;
  string relname;
  string polname;
  Node qual;
  bool cascaded;
}

struct SortGroupClause
{
  uint32 tle_sort_group_ref;
  uint32 eqop;
  uint32 sortop;
  bool nulls_first;
  bool hashable;
}

struct GroupingSet
{
  GroupingSetKind kind;
  Node[] content;
  int32 location;
}

struct WindowClause
{
  string name;
  string refname;
  Node[] partition_clause;
  Node[] order_clause;
  int32 frame_options;
  Node start_offset;
  Node end_offset;
  Node[] run_condition;
  uint32 start_in_range_func;
  uint32 end_in_range_func;
  uint32 in_range_coll;
  bool in_range_asc;
  bool in_range_nulls_first;
  uint32 winref;
  bool copied_order;
}

struct ObjectWithArgs
{
  Node[] objname;
  Node[] objargs;
  Node[] objfuncargs;
  bool args_unspecified;
}

struct AccessPriv
{
  string priv_name;
  Node[] cols;
}

struct CreateOpClassItem
{
  int32 itemtype;
  ObjectWithArgs* name;
  int32 number;
  Node[] order_family;
  Node[] class_args;
  TypeName* storedtype;
}

struct TableLikeClause
{
  RangeVar* relation;
  uint32 options;
  uint32 relation_oid;
}

struct FunctionParameter
{
  string name;
  TypeName* arg_type;
  FunctionParameterMode mode;
  Node defexpr;
}

struct LockingClause
{
  Node[] locked_rels;
  LockClauseStrength strength;
  LockWaitPolicy wait_policy;
}

struct RowMarkClause
{
  uint32 rti;
  LockClauseStrength strength;
  LockWaitPolicy wait_policy;
  bool pushed_down;
}

struct XmlSerialize
{
  XmlOptionType xmloption;
  Node expr;
  TypeName* type_name;
  int32 location;
}

struct WithClause
{
  Node[] ctes;
  bool recursive;
  int32 location;
}

struct InferClause
{
  Node[] index_elems;
  Node where_clause;
  string conname;
  int32 location;
}

struct OnConflictClause
{
  OnConflictAction action;
  InferClause* infer;
  Node[] target_list;
  Node where_clause;
  int32 location;
}

struct CTESearchClause
{
  Node[] search_col_list;
  bool search_breadth_first;
  string search_seq_column;
  int32 location;
}

struct CTECycleClause
{
  Node[] cycle_col_list;
  string cycle_mark_column;
  Node cycle_mark_value;
  Node cycle_mark_default;
  string cycle_path_column;
  int32 location;
  uint32 cycle_mark_type;
  int32 cycle_mark_typmod;
  uint32 cycle_mark_collation;
  uint32 cycle_mark_neop;
}

struct CommonTableExpr
{
  string ctename;
  Node[] aliascolnames;
  CTEMaterialize ctematerialized;
  Node ctequery;
  CTESearchClause* search_clause;
  CTECycleClause* cycle_clause;
  int32 location;
  bool cterecursive;
  int32 cterefcount;
  Node[] ctecolnames;
  Node[] ctecoltypes;
  Node[] ctecoltypmods;
  Node[] ctecolcollations;
}

struct MergeWhenClause
{
  bool matched;
  CmdType command_type;
  OverridingKind override;
  Node condition;
  Node[] target_list;
  Node[] values;
}

struct RoleSpec
{
  RoleSpecType roletype;
  string rolename;
  int32 location;
}

struct TriggerTransition
{
  string name;
  bool is_new;
  bool is_table;
}

struct PartitionElem
{
  string name;
  Node expr;
  Node[] collation;
  Node[] opclass;
  int32 location;
}

struct PartitionSpec
{
  string strategy;
  Node[] part_params;
  int32 location;
}

struct PartitionBoundSpec
{
  string strategy;
  bool is_default;
  int32 modulus;
  int32 remainder;
  Node[] listdatums;
  Node[] lowerdatums;
  Node[] upperdatums;
  int32 location;
}

struct PartitionRangeDatum
{
  PartitionRangeDatumKind kind;
  Node value;
  int32 location;
}

struct PartitionCmd
{
  RangeVar* name;
  PartitionBoundSpec* bound;
  bool concurrent;
}

struct VacuumRelation
{
  RangeVar* relation;
  uint32 oid;
  Node[] va_cols;
}

struct PublicationObjSpec
{
  PublicationObjSpecType pubobjtype;
  string name;
  PublicationTable* pubtable;
  int32 location;
}

struct PublicationTable
{
  RangeVar* relation;
  Node where_clause;
  Node[] columns;
}

struct InlineCodeBlock
{
  string source_text;
  uint32 lang_oid;
  bool lang_is_trusted;
  bool atomic;
}

struct CallContext
{
  bool atomic;
}

enum OverridingKind
{
  OVERRIDING_KIND_UNDEFINED = 0;
  OVERRIDING_NOT_SET = 1;
  OVERRIDING_USER_VALUE = 2;
  OVERRIDING_SYSTEM_VALUE = 3;
}

enum QuerySource
{
  QUERY_SOURCE_UNDEFINED = 0;
  QSRC_ORIGINAL = 1;
  QSRC_PARSER = 2;
  QSRC_INSTEAD_RULE = 3;
  QSRC_QUAL_INSTEAD_RULE = 4;
  QSRC_NON_INSTEAD_RULE = 5;
}

enum SortByDir
{
  SORT_BY_DIR_UNDEFINED = 0;
  SORTBY_DEFAULT = 1;
  SORTBY_ASC = 2;
  SORTBY_DESC = 3;
  SORTBY_USING = 4;
}

enum SortByNulls
{
  SORT_BY_NULLS_UNDEFINED = 0;
  SORTBY_NULLS_DEFAULT = 1;
  SORTBY_NULLS_FIRST = 2;
  SORTBY_NULLS_LAST = 3;
}

enum SetQuantifier
{
  SET_QUANTIFIER_UNDEFINED = 0;
  SET_QUANTIFIER_DEFAULT = 1;
  SET_QUANTIFIER_ALL = 2;
  SET_QUANTIFIER_DISTINCT = 3;
}

enum A_Expr_Kind
{
  A_EXPR_KIND_UNDEFINED = 0;
  AEXPR_OP = 1;
  AEXPR_OP_ANY = 2;
  AEXPR_OP_ALL = 3;
  AEXPR_DISTINCT = 4;
  AEXPR_NOT_DISTINCT = 5;
  AEXPR_NULLIF = 6;
  AEXPR_IN = 7;
  AEXPR_LIKE = 8;
  AEXPR_ILIKE = 9;
  AEXPR_SIMILAR = 10;
  AEXPR_BETWEEN = 11;
  AEXPR_NOT_BETWEEN = 12;
  AEXPR_BETWEEN_SYM = 13;
  AEXPR_NOT_BETWEEN_SYM = 14;
}

enum RoleSpecType
{
  ROLE_SPEC_TYPE_UNDEFINED = 0;
  ROLESPEC_CSTRING = 1;
  ROLESPEC_CURRENT_ROLE = 2;
  ROLESPEC_CURRENT_USER = 3;
  ROLESPEC_SESSION_USER = 4;
  ROLESPEC_PUBLIC = 5;
}

enum TableLikeOption
{
  TABLE_LIKE_OPTION_UNDEFINED = 0;
  CREATE_TABLE_LIKE_COMMENTS = 1;
  CREATE_TABLE_LIKE_COMPRESSION = 2;
  CREATE_TABLE_LIKE_CONSTRAINTS = 3;
  CREATE_TABLE_LIKE_DEFAULTS = 4;
  CREATE_TABLE_LIKE_GENERATED = 5;
  CREATE_TABLE_LIKE_IDENTITY = 6;
  CREATE_TABLE_LIKE_INDEXES = 7;
  CREATE_TABLE_LIKE_STATISTICS = 8;
  CREATE_TABLE_LIKE_STORAGE = 9;
  CREATE_TABLE_LIKE_ALL = 10;
}

enum DefElemAction
{
  DEF_ELEM_ACTION_UNDEFINED = 0;
  DEFELEM_UNSPEC = 1;
  DEFELEM_SET = 2;
  DEFELEM_ADD = 3;
  DEFELEM_DROP = 4;
}

enum PartitionRangeDatumKind
{
  PARTITION_RANGE_DATUM_KIND_UNDEFINED = 0;
  PARTITION_RANGE_DATUM_MINVALUE = 1;
  PARTITION_RANGE_DATUM_VALUE = 2;
  PARTITION_RANGE_DATUM_MAXVALUE = 3;
}

enum RTEKind
{
  RTEKIND_UNDEFINED = 0;
  RTE_RELATION = 1;
  RTE_SUBQUERY = 2;
  RTE_JOIN = 3;
  RTE_FUNCTION = 4;
  RTE_TABLEFUNC = 5;
  RTE_VALUES = 6;
  RTE_CTE = 7;
  RTE_NAMEDTUPLESTORE = 8;
  RTE_RESULT = 9;
}

enum WCOKind
{
  WCOKIND_UNDEFINED = 0;
  WCO_VIEW_CHECK = 1;
  WCO_RLS_INSERT_CHECK = 2;
  WCO_RLS_UPDATE_CHECK = 3;
  WCO_RLS_CONFLICT_CHECK = 4;
  WCO_RLS_MERGE_UPDATE_CHECK = 5;
  WCO_RLS_MERGE_DELETE_CHECK = 6;
}

enum GroupingSetKind
{
  GROUPING_SET_KIND_UNDEFINED = 0;
  GROUPING_SET_EMPTY = 1;
  GROUPING_SET_SIMPLE = 2;
  GROUPING_SET_ROLLUP = 3;
  GROUPING_SET_CUBE = 4;
  GROUPING_SET_SETS = 5;
}

enum CTEMaterialize
{
  CTEMATERIALIZE_UNDEFINED = 0;
  CTEMaterializeDefault = 1;
  CTEMaterializeAlways = 2;
  CTEMaterializeNever = 3;
}

enum SetOperation
{
  SET_OPERATION_UNDEFINED = 0;
  SETOP_NONE = 1;
  SETOP_UNION = 2;
  SETOP_INTERSECT = 3;
  SETOP_EXCEPT = 4;
}

enum ObjectType
{
  OBJECT_TYPE_UNDEFINED = 0;
  OBJECT_ACCESS_METHOD = 1;
  OBJECT_AGGREGATE = 2;
  OBJECT_AMOP = 3;
  OBJECT_AMPROC = 4;
  OBJECT_ATTRIBUTE = 5;
  OBJECT_CAST = 6;
  OBJECT_COLUMN = 7;
  OBJECT_COLLATION = 8;
  OBJECT_CONVERSION = 9;
  OBJECT_DATABASE = 10;
  OBJECT_DEFAULT = 11;
  OBJECT_DEFACL = 12;
  OBJECT_DOMAIN = 13;
  OBJECT_DOMCONSTRAINT = 14;
  OBJECT_EVENT_TRIGGER = 15;
  OBJECT_EXTENSION = 16;
  OBJECT_FDW = 17;
  OBJECT_FOREIGN_SERVER = 18;
  OBJECT_FOREIGN_TABLE = 19;
  OBJECT_FUNCTION = 20;
  OBJECT_INDEX = 21;
  OBJECT_LANGUAGE = 22;
  OBJECT_LARGEOBJECT = 23;
  OBJECT_MATVIEW = 24;
  OBJECT_OPCLASS = 25;
  OBJECT_OPERATOR = 26;
  OBJECT_OPFAMILY = 27;
  OBJECT_PARAMETER_ACL = 28;
  OBJECT_POLICY = 29;
  OBJECT_PROCEDURE = 30;
  OBJECT_PUBLICATION = 31;
  OBJECT_PUBLICATION_NAMESPACE = 32;
  OBJECT_PUBLICATION_REL = 33;
  OBJECT_ROLE = 34;
  OBJECT_ROUTINE = 35;
  OBJECT_RULE = 36;
  OBJECT_SCHEMA = 37;
  OBJECT_SEQUENCE = 38;
  OBJECT_SUBSCRIPTION = 39;
  OBJECT_STATISTIC_EXT = 40;
  OBJECT_TABCONSTRAINT = 41;
  OBJECT_TABLE = 42;
  OBJECT_TABLESPACE = 43;
  OBJECT_TRANSFORM = 44;
  OBJECT_TRIGGER = 45;
  OBJECT_TSCONFIGURATION = 46;
  OBJECT_TSDICTIONARY = 47;
  OBJECT_TSPARSER = 48;
  OBJECT_TSTEMPLATE = 49;
  OBJECT_TYPE = 50;
  OBJECT_USER_MAPPING = 51;
  OBJECT_VIEW = 52;
}

enum DropBehavior
{
  DROP_BEHAVIOR_UNDEFINED = 0;
  DROP_RESTRICT = 1;
  DROP_CASCADE = 2;
}

enum AlterTableType
{
  ALTER_TABLE_TYPE_UNDEFINED = 0;
  AT_AddColumn = 1;
  AT_AddColumnRecurse = 2;
  AT_AddColumnToView = 3;
  AT_ColumnDefault = 4;
  AT_CookedColumnDefault = 5;
  AT_DropNotNull = 6;
  AT_SetNotNull = 7;
  AT_DropExpression = 8;
  AT_CheckNotNull = 9;
  AT_SetStatistics = 10;
  AT_SetOptions = 11;
  AT_ResetOptions = 12;
  AT_SetStorage = 13;
  AT_SetCompression = 14;
  AT_DropColumn = 15;
  AT_DropColumnRecurse = 16;
  AT_AddIndex = 17;
  AT_ReAddIndex = 18;
  AT_AddConstraint = 19;
  AT_AddConstraintRecurse = 20;
  AT_ReAddConstraint = 21;
  AT_ReAddDomainConstraint = 22;
  AT_AlterConstraint = 23;
  AT_ValidateConstraint = 24;
  AT_ValidateConstraintRecurse = 25;
  AT_AddIndexConstraint = 26;
  AT_DropConstraint = 27;
  AT_DropConstraintRecurse = 28;
  AT_ReAddComment = 29;
  AT_AlterColumnType = 30;
  AT_AlterColumnGenericOptions = 31;
  AT_ChangeOwner = 32;
  AT_ClusterOn = 33;
  AT_DropCluster = 34;
  AT_SetLogged = 35;
  AT_SetUnLogged = 36;
  AT_DropOids = 37;
  AT_SetAccessMethod = 38;
  AT_SetTableSpace = 39;
  AT_SetRelOptions = 40;
  AT_ResetRelOptions = 41;
  AT_ReplaceRelOptions = 42;
  AT_EnableTrig = 43;
  AT_EnableAlwaysTrig = 44;
  AT_EnableReplicaTrig = 45;
  AT_DisableTrig = 46;
  AT_EnableTrigAll = 47;
  AT_DisableTrigAll = 48;
  AT_EnableTrigUser = 49;
  AT_DisableTrigUser = 50;
  AT_EnableRule = 51;
  AT_EnableAlwaysRule = 52;
  AT_EnableReplicaRule = 53;
  AT_DisableRule = 54;
  AT_AddInherit = 55;
  AT_DropInherit = 56;
  AT_AddOf = 57;
  AT_DropOf = 58;
  AT_ReplicaIdentity = 59;
  AT_EnableRowSecurity = 60;
  AT_DisableRowSecurity = 61;
  AT_ForceRowSecurity = 62;
  AT_NoForceRowSecurity = 63;
  AT_GenericOptions = 64;
  AT_AttachPartition = 65;
  AT_DetachPartition = 66;
  AT_DetachPartitionFinalize = 67;
  AT_AddIdentity = 68;
  AT_SetIdentity = 69;
  AT_DropIdentity = 70;
  AT_ReAddStatistics = 71;
}

enum GrantTargetType
{
  GRANT_TARGET_TYPE_UNDEFINED = 0;
  ACL_TARGET_OBJECT = 1;
  ACL_TARGET_ALL_IN_SCHEMA = 2;
  ACL_TARGET_DEFAULTS = 3;
}

enum VariableSetKind
{
  VARIABLE_SET_KIND_UNDEFINED = 0;
  VAR_SET_VALUE = 1;
  VAR_SET_DEFAULT = 2;
  VAR_SET_CURRENT = 3;
  VAR_SET_MULTI = 4;
  VAR_RESET = 5;
  VAR_RESET_ALL = 6;
}

enum ConstrType
{
  CONSTR_TYPE_UNDEFINED = 0;
  CONSTR_NULL = 1;
  CONSTR_NOTNULL = 2;
  CONSTR_DEFAULT = 3;
  CONSTR_IDENTITY = 4;
  CONSTR_GENERATED = 5;
  CONSTR_CHECK = 6;
  CONSTR_PRIMARY = 7;
  CONSTR_UNIQUE = 8;
  CONSTR_EXCLUSION = 9;
  CONSTR_FOREIGN = 10;
  CONSTR_ATTR_DEFERRABLE = 11;
  CONSTR_ATTR_NOT_DEFERRABLE = 12;
  CONSTR_ATTR_DEFERRED = 13;
  CONSTR_ATTR_IMMEDIATE = 14;
}

enum ImportForeignSchemaType
{
  IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED = 0;
  FDW_IMPORT_SCHEMA_ALL = 1;
  FDW_IMPORT_SCHEMA_LIMIT_TO = 2;
  FDW_IMPORT_SCHEMA_EXCEPT = 3;
}

enum RoleStmtType
{
  ROLE_STMT_TYPE_UNDEFINED = 0;
  ROLESTMT_ROLE = 1;
  ROLESTMT_USER = 2;
  ROLESTMT_GROUP = 3;
}

enum FetchDirection
{
  FETCH_DIRECTION_UNDEFINED = 0;
  FETCH_FORWARD = 1;
  FETCH_BACKWARD = 2;
  FETCH_ABSOLUTE = 3;
  FETCH_RELATIVE = 4;
}

enum FunctionParameterMode
{
  FUNCTION_PARAMETER_MODE_UNDEFINED = 0;
  FUNC_PARAM_IN = 1;
  FUNC_PARAM_OUT = 2;
  FUNC_PARAM_INOUT = 3;
  FUNC_PARAM_VARIADIC = 4;
  FUNC_PARAM_TABLE = 5;
  FUNC_PARAM_DEFAULT = 6;
}

enum TransactionStmtKind
{
  TRANSACTION_STMT_KIND_UNDEFINED = 0;
  TRANS_STMT_BEGIN = 1;
  TRANS_STMT_START = 2;
  TRANS_STMT_COMMIT = 3;
  TRANS_STMT_ROLLBACK = 4;
  TRANS_STMT_SAVEPOINT = 5;
  TRANS_STMT_RELEASE = 6;
  TRANS_STMT_ROLLBACK_TO = 7;
  TRANS_STMT_PREPARE = 8;
  TRANS_STMT_COMMIT_PREPARED = 9;
  TRANS_STMT_ROLLBACK_PREPARED = 10;
}

enum ViewCheckOption
{
  VIEW_CHECK_OPTION_UNDEFINED = 0;
  NO_CHECK_OPTION = 1;
  LOCAL_CHECK_OPTION = 2;
  CASCADED_CHECK_OPTION = 3;
}

enum DiscardMode
{
  DISCARD_MODE_UNDEFINED = 0;
  DISCARD_ALL = 1;
  DISCARD_PLANS = 2;
  DISCARD_SEQUENCES = 3;
  DISCARD_TEMP = 4;
}

enum ReindexObjectType
{
  REINDEX_OBJECT_TYPE_UNDEFINED = 0;
  REINDEX_OBJECT_INDEX = 1;
  REINDEX_OBJECT_TABLE = 2;
  REINDEX_OBJECT_SCHEMA = 3;
  REINDEX_OBJECT_SYSTEM = 4;
  REINDEX_OBJECT_DATABASE = 5;
}

enum AlterTSConfigType
{
  ALTER_TSCONFIG_TYPE_UNDEFINED = 0;
  ALTER_TSCONFIG_ADD_MAPPING = 1;
  ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN = 2;
  ALTER_TSCONFIG_REPLACE_DICT = 3;
  ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN = 4;
  ALTER_TSCONFIG_DROP_MAPPING = 5;
}

enum PublicationObjSpecType
{
  PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED = 0;
  PUBLICATIONOBJ_TABLE = 1;
  PUBLICATIONOBJ_TABLES_IN_SCHEMA = 2;
  PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA = 3;
  PUBLICATIONOBJ_CONTINUATION = 4;
}

enum AlterPublicationAction
{
  ALTER_PUBLICATION_ACTION_UNDEFINED = 0;
  AP_AddObjects = 1;
  AP_DropObjects = 2;
  AP_SetObjects = 3;
}

enum AlterSubscriptionType
{
  ALTER_SUBSCRIPTION_TYPE_UNDEFINED = 0;
  ALTER_SUBSCRIPTION_OPTIONS = 1;
  ALTER_SUBSCRIPTION_CONNECTION = 2;
  ALTER_SUBSCRIPTION_SET_PUBLICATION = 3;
  ALTER_SUBSCRIPTION_ADD_PUBLICATION = 4;
  ALTER_SUBSCRIPTION_DROP_PUBLICATION = 5;
  ALTER_SUBSCRIPTION_REFRESH = 6;
  ALTER_SUBSCRIPTION_ENABLED = 7;
  ALTER_SUBSCRIPTION_SKIP = 8;
}

enum OnCommitAction
{
  ON_COMMIT_ACTION_UNDEFINED = 0;
  ONCOMMIT_NOOP = 1;
  ONCOMMIT_PRESERVE_ROWS = 2;
  ONCOMMIT_DELETE_ROWS = 3;
  ONCOMMIT_DROP = 4;
}

enum ParamKind
{
  PARAM_KIND_UNDEFINED = 0;
  PARAM_EXTERN = 1;
  PARAM_EXEC = 2;
  PARAM_SUBLINK = 3;
  PARAM_MULTIEXPR = 4;
}

enum CoercionContext
{
  COERCION_CONTEXT_UNDEFINED = 0;
  COERCION_IMPLICIT = 1;
  COERCION_ASSIGNMENT = 2;
  COERCION_PLPGSQL = 3;
  COERCION_EXPLICIT = 4;
}

enum CoercionForm
{
  COERCION_FORM_UNDEFINED = 0;
  COERCE_EXPLICIT_CALL = 1;
  COERCE_EXPLICIT_CAST = 2;
  COERCE_IMPLICIT_CAST = 3;
  COERCE_SQL_SYNTAX = 4;
}

enum BoolExprType
{
  BOOL_EXPR_TYPE_UNDEFINED = 0;
  AND_EXPR = 1;
  OR_EXPR = 2;
  NOT_EXPR = 3;
}

enum SubLinkType
{
  SUB_LINK_TYPE_UNDEFINED = 0;
  EXISTS_SUBLINK = 1;
  ALL_SUBLINK = 2;
  ANY_SUBLINK = 3;
  ROWCOMPARE_SUBLINK = 4;
  EXPR_SUBLINK = 5;
  MULTIEXPR_SUBLINK = 6;
  ARRAY_SUBLINK = 7;
  CTE_SUBLINK = 8;
}

enum RowCompareType
{
  ROW_COMPARE_TYPE_UNDEFINED = 0;
  ROWCOMPARE_LT = 1;
  ROWCOMPARE_LE = 2;
  ROWCOMPARE_EQ = 3;
  ROWCOMPARE_GE = 4;
  ROWCOMPARE_GT = 5;
  ROWCOMPARE_NE = 6;
}

enum MinMaxOp
{
  MIN_MAX_OP_UNDEFINED = 0;
  IS_GREATEST = 1;
  IS_LEAST = 2;
}

enum SQLValueFunctionOp
{
  SQLVALUE_FUNCTION_OP_UNDEFINED = 0;
  SVFOP_CURRENT_DATE = 1;
  SVFOP_CURRENT_TIME = 2;
  SVFOP_CURRENT_TIME_N = 3;
  SVFOP_CURRENT_TIMESTAMP = 4;
  SVFOP_CURRENT_TIMESTAMP_N = 5;
  SVFOP_LOCALTIME = 6;
  SVFOP_LOCALTIME_N = 7;
  SVFOP_LOCALTIMESTAMP = 8;
  SVFOP_LOCALTIMESTAMP_N = 9;
  SVFOP_CURRENT_ROLE = 10;
  SVFOP_CURRENT_USER = 11;
  SVFOP_USER = 12;
  SVFOP_SESSION_USER = 13;
  SVFOP_CURRENT_CATALOG = 14;
  SVFOP_CURRENT_SCHEMA = 15;
}

enum XmlExprOp
{
  XML_EXPR_OP_UNDEFINED = 0;
  IS_XMLCONCAT = 1;
  IS_XMLELEMENT = 2;
  IS_XMLFOREST = 3;
  IS_XMLPARSE = 4;
  IS_XMLPI = 5;
  IS_XMLROOT = 6;
  IS_XMLSERIALIZE = 7;
  IS_DOCUMENT = 8;
}

enum XmlOptionType
{
  XML_OPTION_TYPE_UNDEFINED = 0;
  XMLOPTION_DOCUMENT = 1;
  XMLOPTION_CONTENT = 2;
}

enum NullTestType
{
  NULL_TEST_TYPE_UNDEFINED = 0;
  IS_NULL = 1;
  IS_NOT_NULL = 2;
}

enum BoolTestType
{
  BOOL_TEST_TYPE_UNDEFINED = 0;
  IS_TRUE = 1;
  IS_NOT_TRUE = 2;
  IS_FALSE = 3;
  IS_NOT_FALSE = 4;
  IS_UNKNOWN = 5;
  IS_NOT_UNKNOWN = 6;
}

enum CmdType
{
  CMD_TYPE_UNDEFINED = 0;
  CMD_UNKNOWN = 1;
  CMD_SELECT = 2;
  CMD_UPDATE = 3;
  CMD_INSERT = 4;
  CMD_DELETE = 5;
  CMD_MERGE = 6;
  CMD_UTILITY = 7;
  CMD_NOTHING = 8;
}

enum JoinType
{
  JOIN_TYPE_UNDEFINED = 0;
  JOIN_INNER = 1;
  JOIN_LEFT = 2;
  JOIN_FULL = 3;
  JOIN_RIGHT = 4;
  JOIN_SEMI = 5;
  JOIN_ANTI = 6;
  JOIN_UNIQUE_OUTER = 7;
  JOIN_UNIQUE_INNER = 8;
}

enum AggStrategy
{
  AGG_STRATEGY_UNDEFINED = 0;
  AGG_PLAIN = 1;
  AGG_SORTED = 2;
  AGG_HASHED = 3;
  AGG_MIXED = 4;
}

enum AggSplit
{
  AGG_SPLIT_UNDEFINED = 0;
  AGGSPLIT_SIMPLE = 1;
  AGGSPLIT_INITIAL_SERIAL = 2;
  AGGSPLIT_FINAL_DESERIAL = 3;
}

enum SetOpCmd
{
  SET_OP_CMD_UNDEFINED = 0;
  SETOPCMD_INTERSECT = 1;
  SETOPCMD_INTERSECT_ALL = 2;
  SETOPCMD_EXCEPT = 3;
  SETOPCMD_EXCEPT_ALL = 4;
}

enum SetOpStrategy
{
  SET_OP_STRATEGY_UNDEFINED = 0;
  SETOP_SORTED = 1;
  SETOP_HASHED = 2;
}

enum OnConflictAction
{
  ON_CONFLICT_ACTION_UNDEFINED = 0;
  ONCONFLICT_NONE = 1;
  ONCONFLICT_NOTHING = 2;
  ONCONFLICT_UPDATE = 3;
}

enum LimitOption
{
  LIMIT_OPTION_UNDEFINED = 0;
  LIMIT_OPTION_DEFAULT = 1;
  LIMIT_OPTION_COUNT = 2;
  LIMIT_OPTION_WITH_TIES = 3;
}

enum LockClauseStrength
{
  LOCK_CLAUSE_STRENGTH_UNDEFINED = 0;
  LCS_NONE = 1;
  LCS_FORKEYSHARE = 2;
  LCS_FORSHARE = 3;
  LCS_FORNOKEYUPDATE = 4;
  LCS_FORUPDATE = 5;
}

enum LockWaitPolicy
{
  LOCK_WAIT_POLICY_UNDEFINED = 0;
  LockWaitBlock = 1;
  LockWaitSkip = 2;
  LockWaitError = 3;
}

enum LockTupleMode
{
  LOCK_TUPLE_MODE_UNDEFINED = 0;
  LockTupleKeyShare = 1;
  LockTupleShare = 2;
  LockTupleNoKeyExclusive = 3;
  LockTupleExclusive = 4;
}

enum KeywordKind {
  NO_KEYWORD = 0;
  UNRESERVED_KEYWORD = 1;
  COL_NAME_KEYWORD = 2;
  TYPE_FUNC_NAME_KEYWORD = 3;
  RESERVED_KEYWORD = 4;
}

enum Token {
  NUL = 0;
  // Single-character tokens that are returned 1:1 (identical with "self" list in scan.l)
  // Either supporting syntax, or single-character operators (some can be both)
  // Also see https://www.postgresql.org/docs/12/sql-syntax-lexical.html#SQL-SYNTAX-SPECIAL-CHARS
  ASCII_37 = 37; // "%"
  ASCII_40 = 40; // "("
  ASCII_41 = 41; // ")"
  ASCII_42 = 42; // "*"
  ASCII_43 = 43; // "+"
  ASCII_44 = 44; // ","
  ASCII_45 = 45; // "-"
  ASCII_46 = 46; // "."
  ASCII_47 = 47; // "/"
  ASCII_58 = 58; // ":"
  ASCII_59 = 59; // ";"
  ASCII_60 = 60; // "<"
  ASCII_61 = 61; // "="
  ASCII_62 = 62; // ">"
  ASCII_63 = 63; // "?"
  ASCII_91 = 91; // "["
  ASCII_92 = 92; // "\"
  ASCII_93 = 93; // "]"
  ASCII_94 = 94; // "^"
  // Named tokens in scan.l
  IDENT = 258;
  UIDENT = 259;
  FCONST = 260;
  SCONST = 261;
  USCONST = 262;
  BCONST = 263;
  XCONST = 264;
  Op = 265;
  ICONST = 266;
  PARAM = 267;
  TYPECAST = 268;
  DOT_DOT = 269;
  COLON_EQUALS = 270;
  EQUALS_GREATER = 271;
  LESS_EQUALS = 272;
  GREATER_EQUALS = 273;
  NOT_EQUALS = 274;
  SQL_COMMENT = 275;
  C_COMMENT = 276;
  ABORT_P = 277;
  ABSOLUTE_P = 278;
  ACCESS = 279;
  ACTION = 280;
  ADD_P = 281;
  ADMIN = 282;
  AFTER = 283;
  AGGREGATE = 284;
  ALL = 285;
  ALSO = 286;
  ALTER = 287;
  ALWAYS = 288;
  ANALYSE = 289;
  ANALYZE = 290;
  AND = 291;
  ANY = 292;
  ARRAY = 293;
  AS = 294;
  ASC = 295;
  ASENSITIVE = 296;
  ASSERTION = 297;
  ASSIGNMENT = 298;
  ASYMMETRIC = 299;
  ATOMIC = 300;
  AT = 301;
  ATTACH = 302;
  ATTRIBUTE = 303;
  AUTHORIZATION = 304;
  BACKWARD = 305;
  BEFORE = 306;
  BEGIN_P = 307;
  BETWEEN = 308;
  BIGINT = 309;
  BINARY = 310;
  BIT = 311;
  BOOLEAN_P = 312;
  BOTH = 313;
  BREADTH = 314;
  BY = 315;
  CACHE = 316;
  CALL = 317;
  CALLED = 318;
  CASCADE = 319;
  CASCADED = 320;
  CASE = 321;
  CAST = 322;
  CATALOG_P = 323;
  CHAIN = 324;
  CHAR_P = 325;
  CHARACTER = 326;
  CHARACTERISTICS = 327;
  CHECK = 328;
  CHECKPOINT = 329;
  CLASS = 330;
  CLOSE = 331;
  CLUSTER = 332;
  COALESCE = 333;
  COLLATE = 334;
  COLLATION = 335;
  COLUMN = 336;
  COLUMNS = 337;
  COMMENT = 338;
  COMMENTS = 339;
  COMMIT = 340;
  COMMITTED = 341;
  COMPRESSION = 342;
  CONCURRENTLY = 343;
  CONFIGURATION = 344;
  CONFLICT = 345;
  CONNECTION = 346;
  CONSTRAINT = 347;
  CONSTRAINTS = 348;
  CONTENT_P = 349;
  CONTINUE_P = 350;
  CONVERSION_P = 351;
  COPY = 352;
  COST = 353;
  CREATE = 354;
  CROSS = 355;
  CSV = 356;
  CUBE = 357;
  CURRENT_P = 358;
  CURRENT_CATALOG = 359;
  CURRENT_DATE = 360;
  CURRENT_ROLE = 361;
  CURRENT_SCHEMA = 362;
  CURRENT_TIME = 363;
  CURRENT_TIMESTAMP = 364;
  CURRENT_USER = 365;
  CURSOR = 366;
  CYCLE = 367;
  DATA_P = 368;
  DATABASE = 369;
  DAY_P = 370;
  DEALLOCATE = 371;
  DEC = 372;
  DECIMAL_P = 373;
  DECLARE = 374;
  DEFAULT = 375;
  DEFAULTS = 376;
  DEFERRABLE = 377;
  DEFERRED = 378;
  DEFINER = 379;
  DELETE_P = 380;
  DELIMITER = 381;
  DELIMITERS = 382;
  DEPENDS = 383;
  DEPTH = 384;
  DESC = 385;
  DETACH = 386;
  DICTIONARY = 387;
  DISABLE_P = 388;
  DISCARD = 389;
  DISTINCT = 390;
  DO = 391;
  DOCUMENT_P = 392;
  DOMAIN_P = 393;
  DOUBLE_P = 394;
  DROP = 395;
  EACH = 396;
  ELSE = 397;
  ENABLE_P = 398;
  ENCODING = 399;
  ENCRYPTED = 400;
  END_P = 401;
  ENUM_P = 402;
  ESCAPE = 403;
  EVENT = 404;
  EXCEPT = 405;
  EXCLUDE = 406;
  EXCLUDING = 407;
  EXCLUSIVE = 408;
  EXECUTE = 409;
  EXISTS = 410;
  EXPLAIN = 411;
  EXPRESSION = 412;
  EXTENSION = 413;
  EXTERNAL = 414;
  EXTRACT = 415;
  FALSE_P = 416;
  FAMILY = 417;
  FETCH = 418;
  FILTER = 419;
  FINALIZE = 420;
  FIRST_P = 421;
  FLOAT_P = 422;
  FOLLOWING = 423;
  FOR = 424;
  FORCE = 425;
  FOREIGN = 426;
  FORWARD = 427;
  FREEZE = 428;
  FROM = 429;
  FULL = 430;
  FUNCTION = 431;
  FUNCTIONS = 432;
  GENERATED = 433;
  GLOBAL = 434;
  GRANT = 435;
  GRANTED = 436;
  GREATEST = 437;
  GROUP_P = 438;
  GROUPING = 439;
  GROUPS = 440;
  HANDLER = 441;
  HAVING = 442;
  HEADER_P = 443;
  HOLD = 444;
  HOUR_P = 445;
  IDENTITY_P = 446;
  IF_P = 447;
  ILIKE = 448;
  IMMEDIATE = 449;
  IMMUTABLE = 450;
  IMPLICIT_P = 451;
  IMPORT_P = 452;
  IN_P = 453;
  INCLUDE = 454;
  INCLUDING = 455;
  INCREMENT = 456;
  INDEX = 457;
  INDEXES = 458;
  INHERIT = 459;
  INHERITS = 460;
  INITIALLY = 461;
  INLINE_P = 462;
  INNER_P = 463;
  INOUT = 464;
  INPUT_P = 465;
  INSENSITIVE = 466;
  INSERT = 467;
  INSTEAD = 468;
  INT_P = 469;
  INTEGER = 470;
  INTERSECT = 471;
  INTERVAL = 472;
  INTO = 473;
  INVOKER = 474;
  IS = 475;
  ISNULL = 476;
  ISOLATION = 477;
  JOIN = 478;
  KEY = 479;
  LABEL = 480;
  LANGUAGE = 481;
  LARGE_P = 482;
  LAST_P = 483;
  LATERAL_P = 484;
  LEADING = 485;
  LEAKPROOF = 486;
  LEAST = 487;
  LEFT = 488;
  LEVEL = 489;
  LIKE = 490;
  LIMIT = 491;
  LISTEN = 492;
  LOAD = 493;
  LOCAL = 494;
  LOCALTIME = 495;
  LOCALTIMESTAMP = 496;
  LOCATION = 497;
  LOCK_P = 498;
  LOCKED = 499;
  LOGGED = 500;
  MAPPING = 501;
  MATCH = 502;
  MATCHED = 503;
  MATERIALIZED = 504;
  MAXVALUE = 505;
  MERGE = 506;
  METHOD = 507;
  MINUTE_P = 508;
  MINVALUE = 509;
  MODE = 510;
  MONTH_P = 511;
  MOVE = 512;
  NAME_P = 513;
  NAMES = 514;
  NATIONAL = 515;
  NATURAL = 516;
  NCHAR = 517;
  NEW = 518;
  NEXT = 519;
  NFC = 520;
  NFD = 521;
  NFKC = 522;
  NFKD = 523;
  NO = 524;
  NONE = 525;
  NORMALIZE = 526;
  NORMALIZED = 527;
  NOT = 528;
  NOTHING = 529;
  NOTIFY = 530;
  NOTNULL = 531;
  NOWAIT = 532;
  NULL_P = 533;
  NULLIF = 534;
  NULLS_P = 535;
  NUMERIC = 536;
  OBJECT_P = 537;
  OF = 538;
  OFF = 539;
  OFFSET = 540;
  OIDS = 541;
  OLD = 542;
  ON = 543;
  ONLY = 544;
  OPERATOR = 545;
  OPTION = 546;
  OPTIONS = 547;
  OR = 548;
  ORDER = 549;
  ORDINALITY = 550;
  OTHERS = 551;
  OUT_P = 552;
  OUTER_P = 553;
  OVER = 554;
  OVERLAPS = 555;
  OVERLAY = 556;
  OVERRIDING = 557;
  OWNED = 558;
  OWNER = 559;
  PARALLEL = 560;
  PARAMETER = 561;
  PARSER = 562;
  PARTIAL = 563;
  PARTITION = 564;
  PASSING = 565;
  PASSWORD = 566;
  PLACING = 567;
  PLANS = 568;
  POLICY = 569;
  POSITION = 570;
  PRECEDING = 571;
  PRECISION = 572;
  PRESERVE = 573;
  PREPARE = 574;
  PREPARED = 575;
  PRIMARY = 576;
  PRIOR = 577;
  PRIVILEGES = 578;
  PROCEDURAL = 579;
  PROCEDURE = 580;
  PROCEDURES = 581;
  PROGRAM = 582;
  PUBLICATION = 583;
  QUOTE = 584;
  RANGE = 585;
  READ = 586;
  REAL = 587;
  REASSIGN = 588;
  RECHECK = 589;
  RECURSIVE = 590;
  REF_P = 591;
  REFERENCES = 592;
  REFERENCING = 593;
  REFRESH = 594;
  REINDEX = 595;
  RELATIVE_P = 596;
  RELEASE = 597;
  RENAME = 598;
  REPEATABLE = 599;
  REPLACE = 600;
  REPLICA = 601;
  RESET = 602;
  RESTART = 603;
  RESTRICT = 604;
  RETURN = 605;
  RETURNING = 606;
  RETURNS = 607;
  REVOKE = 608;
  RIGHT = 609;
  ROLE = 610;
  ROLLBACK = 611;
  ROLLUP = 612;
  ROUTINE = 613;
  ROUTINES = 614;
  ROW = 615;
  ROWS = 616;
  RULE = 617;
  SAVEPOINT = 618;
  SCHEMA = 619;
  SCHEMAS = 620;
  SCROLL = 621;
  SEARCH = 622;
  SECOND_P = 623;
  SECURITY = 624;
  SELECT = 625;
  SEQUENCE = 626;
  SEQUENCES = 627;
  SERIALIZABLE = 628;
  SERVER = 629;
  SESSION = 630;
  SESSION_USER = 631;
  SET = 632;
  SETS = 633;
  SETOF = 634;
  SHARE = 635;
  SHOW = 636;
  SIMILAR = 637;
  SIMPLE = 638;
  SKIP = 639;
  SMALLINT = 640;
  SNAPSHOT = 641;
  SOME = 642;
  SQL_P = 643;
  STABLE = 644;
  STANDALONE_P = 645;
  START = 646;
  STATEMENT = 647;
  STATISTICS = 648;
  STDIN = 649;
  STDOUT = 650;
  STORAGE = 651;
  STORED = 652;
  STRICT_P = 653;
  STRIP_P = 654;
  SUBSCRIPTION = 655;
  SUBSTRING = 656;
  SUPPORT = 657;
  SYMMETRIC = 658;
  SYSID = 659;
  SYSTEM_P = 660;
  TABLE = 661;
  TABLES = 662;
  TABLESAMPLE = 663;
  TABLESPACE = 664;
  TEMP = 665;
  TEMPLATE = 666;
  TEMPORARY = 667;
  TEXT_P = 668;
  THEN = 669;
  TIES = 670;
  TIME = 671;
  TIMESTAMP = 672;
  TO = 673;
  TRAILING = 674;
  TRANSACTION = 675;
  TRANSFORM = 676;
  TREAT = 677;
  TRIGGER = 678;
  TRIM = 679;
  TRUE_P = 680;
  TRUNCATE = 681;
  TRUSTED = 682;
  TYPE_P = 683;
  TYPES_P = 684;
  UESCAPE = 685;
  UNBOUNDED = 686;
  UNCOMMITTED = 687;
  UNENCRYPTED = 688;
  UNION = 689;
  UNIQUE = 690;
  UNKNOWN = 691;
  UNLISTEN = 692;
  UNLOGGED = 693;
  UNTIL = 694;
  UPDATE = 695;
  USER = 696;
  USING = 697;
  VACUUM = 698;
  VALID = 699;
  VALIDATE = 700;
  VALIDATOR = 701;
  VALUE_P = 702;
  VALUES = 703;
  VARCHAR = 704;
  VARIADIC = 705;
  VARYING = 706;
  VERBOSE = 707;
  VERSION_P = 708;
  VIEW = 709;
  VIEWS = 710;
  VOLATILE = 711;
  WHEN = 712;
  WHERE = 713;
  WHITESPACE_P = 714;
  WINDOW = 715;
  WITH = 716;
  WITHIN = 717;
  WITHOUT = 718;
  WORK = 719;
  WRAPPER = 720;
  WRITE = 721;
  XML_P = 722;
  XMLATTRIBUTES = 723;
  XMLCONCAT = 724;
  XMLELEMENT = 725;
  XMLEXISTS = 726;
  XMLFOREST = 727;
  XMLNAMESPACES = 728;
  XMLPARSE = 729;
  XMLPI = 730;
  XMLROOT = 731;
  XMLSERIALIZE = 732;
  XMLTABLE = 733;
  YEAR_P = 734;
  YES_P = 735;
  ZONE = 736;
  NOT_LA = 737;
  NULLS_LA = 738;
  WITH_LA = 739;
  MODE_TYPE_NAME = 740;
  MODE_PLPGSQL_EXPR = 741;
  MODE_PLPGSQL_ASSIGN1 = 742;
  MODE_PLPGSQL_ASSIGN2 = 743;
  MODE_PLPGSQL_ASSIGN3 = 744;
  UMINUS = 745;
}

struct ScanToken {
  int32 start;
  int32 end;
  Token token;
  KeywordKind keyword_kind;
}

struct ParseResult {
  int32 version;
  RawStmt[] stmts;
}

struct ScanResult {
  int32 version;
  ScanToken[] tokens;
}

