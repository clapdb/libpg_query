// This file is autogenerated by ./scripts/generate_protobuf_and_funcs.rb

package pg_query

struct ParseResult {
  int32 version;
  RawStmt[] stmts;
}

struct ScanResult {
  int32 version;
  ScanToken[] tokens;
}

variant Node {
    Alias*;
    RangeVar*;
    TableFunc*;
    Expr*;
    Var*;
    Param*;
    Aggref*;
    GroupingFunc*;
    WindowFunc*;
    SubscriptingRef*;
    FuncExpr*;
    NamedArgExpr*;
    OpExpr*;
    DistinctExpr*;
    NullIfExpr*;
    ScalarArrayOpExpr*;
    BoolExpr*;
    SubLink*;
    SubPlan*;
    AlternativeSubPlan*;
    FieldSelect*;
    FieldStore*;
    RelabelType*;
    CoerceViaIO*;
    ArrayCoerceExpr*;
    ConvertRowtypeExpr*;
    CollateExpr*;
    CaseExpr*;
    CaseWhen*;
    CaseTestExpr*;
    ArrayExpr*;
    RowExpr*;
    RowCompareExpr*;
    CoalesceExpr*;
    MinMaxExpr*;
    SQLValueFunction*;
    XmlExpr*;
    NullTest*;
    BooleanTest*;
    CoerceToDomain*;
    CoerceToDomainValue*;
    SetToDefault*;
    CurrentOfExpr*;
    NextValueExpr*;
    InferenceElem*;
    TargetEntry*;
    RangeTblRef*;
    JoinExpr*;
    FromExpr*;
    OnConflictExpr*;
    IntoClause*;
    RawStmt*;
    Query*;
    InsertStmt*;
    DeleteStmt*;
    UpdateStmt*;
    SelectStmt*;
    AlterTableStmt*;
    AlterTableCmd*;
    AlterDomainStmt*;
    SetOperationStmt*;
    GrantStmt*;
    GrantRoleStmt*;
    AlterDefaultPrivilegesStmt*;
    ClosePortalStmt*;
    ClusterStmt*;
    CopyStmt*;
    CreateStmt*;
    DefineStmt*;
    DropStmt*;
    TruncateStmt*;
    CommentStmt*;
    FetchStmt*;
    IndexStmt*;
    CreateFunctionStmt*;
    AlterFunctionStmt*;
    DoStmt*;
    RenameStmt*;
    RuleStmt*;
    NotifyStmt*;
    ListenStmt*;
    UnlistenStmt*;
    TransactionStmt*;
    ViewStmt*;
    LoadStmt*;
    CreateDomainStmt*;
    CreatedbStmt*;
    DropdbStmt*;
    VacuumStmt*;
    ExplainStmt*;
    CreateTableAsStmt*;
    CreateSeqStmt*;
    AlterSeqStmt*;
    VariableSetStmt*;
    VariableShowStmt*;
    DiscardStmt*;
    CreateTrigStmt*;
    CreatePLangStmt*;
    CreateRoleStmt*;
    AlterRoleStmt*;
    DropRoleStmt*;
    LockStmt*;
    ConstraintsSetStmt*;
    ReindexStmt*;
    CheckPointStmt*;
    CreateSchemaStmt*;
    AlterDatabaseStmt*;
    AlterDatabaseSetStmt*;
    AlterRoleSetStmt*;
    CreateConversionStmt*;
    CreateCastStmt*;
    CreateOpClassStmt*;
    CreateOpFamilyStmt*;
    AlterOpFamilyStmt*;
    PrepareStmt*;
    ExecuteStmt*;
    DeallocateStmt*;
    DeclareCursorStmt*;
    CreateTableSpaceStmt*;
    DropTableSpaceStmt*;
    AlterObjectDependsStmt*;
    AlterObjectSchemaStmt*;
    AlterOwnerStmt*;
    AlterOperatorStmt*;
    AlterTypeStmt*;
    DropOwnedStmt*;
    ReassignOwnedStmt*;
    CompositeTypeStmt*;
    CreateEnumStmt*;
    CreateRangeStmt*;
    AlterEnumStmt*;
    AlterTSDictionaryStmt*;
    AlterTSConfigurationStmt*;
    CreateFdwStmt*;
    AlterFdwStmt*;
    CreateForeignServerStmt*;
    AlterForeignServerStmt*;
    CreateUserMappingStmt*;
    AlterUserMappingStmt*;
    DropUserMappingStmt*;
    AlterTableSpaceOptionsStmt*;
    AlterTableMoveAllStmt*;
    SecLabelStmt*;
    CreateForeignTableStmt*;
    ImportForeignSchemaStmt*;
    CreateExtensionStmt*;
    AlterExtensionStmt*;
    AlterExtensionContentsStmt*;
    CreateEventTrigStmt*;
    AlterEventTrigStmt*;
    RefreshMatViewStmt*;
    ReplicaIdentityStmt*;
    AlterSystemStmt*;
    CreatePolicyStmt*;
    AlterPolicyStmt*;
    CreateTransformStmt*;
    CreateAmStmt*;
    CreatePublicationStmt*;
    AlterPublicationStmt*;
    CreateSubscriptionStmt*;
    AlterSubscriptionStmt*;
    DropSubscriptionStmt*;
    CreateStatsStmt*;
    AlterCollationStmt*;
    CallStmt*;
    AlterStatsStmt*;
    A_Expr*;
    ColumnRef*;
    ParamRef*;
    A_Const*;
    FuncCall*;
    A_Star*;
    A_Indices*;
    A_Indirection*;
    A_ArrayExpr*;
    ResTarget*;
    MultiAssignRef*;
    TypeCast*;
    CollateClause*;
    SortBy*;
    WindowDef*;
    RangeSubselect*;
    RangeFunction*;
    RangeTableSample*;
    RangeTableFunc*;
    RangeTableFuncCol*;
    TypeName*;
    ColumnDef*;
    IndexElem*;
    Constraint*;
    DefElem*;
    RangeTblEntry*;
    RangeTblFunction*;
    TableSampleClause*;
    WithCheckOption*;
    SortGroupClause*;
    GroupingSet*;
    WindowClause*;
    ObjectWithArgs*;
    AccessPriv*;
    CreateOpClassItem*;
    TableLikeClause*;
    FunctionParameter*;
    LockingClause*;
    RowMarkClause*;
    XmlSerialize*;
    WithClause*;
    InferClause*;
    OnConflictClause*;
    CommonTableExpr*;
    RoleSpec*;
    TriggerTransition*;
    PartitionElem*;
    PartitionSpec*;
    PartitionBoundSpec*;
    PartitionRangeDatum*;
    PartitionCmd*;
    VacuumRelation*;
    InlineCodeBlock*;
    CallContext*;
    Integer*;
    Float*;
    String*;
    BitString*;
    Null*;
    List*;
    IntList*;
    OidList*;
}

struct Integer
{
  int32 ival; /* machine integer */
}

struct Float
{
  string str; /* string */
}

struct String
{
  string str; /* string */
}

struct BitString
{
  string str; /* string */
}

struct Null
{
  // intentionally empty
}

struct List
{
  Node[] items;
}

struct OidList
{
  Node[] items;
}

struct IntList
{
  Node[] items;
}

struct Alias
{
  string aliasname;
  Node[] colnames;
}

struct RangeVar
{
  string catalogname;
  string schemaname;
  string relname;
  bool inh;
  string relpersistence;
  Alias alias;
  int32 location;
}

struct TableFunc
{
  Node[] ns_uris;
  Node[] ns_names;
  Node docexpr;
  Node rowexpr;
  Node[] colnames;
  Node[] coltypes;
  Node[] coltypmods;
  Node[] colcollations;
  Node[] colexprs;
  Node[] coldefexprs;
  uint64[] notnulls;
  int32 ordinalitycol;
  int32 location;
}

struct Expr
{
}

struct Var
{
  Node xpr;
  uint32 varno;
  int32 varattno;
  uint32 vartype;
  int32 vartypmod;
  uint32 varcollid;
  uint32 varlevelsup;
  uint32 varnosyn;
  int32 varattnosyn;
  int32 location;
}

struct Param
{
  Node xpr;
  ParamKind paramkind;
  int32 paramid;
  uint32 paramtype;
  int32 paramtypmod;
  uint32 paramcollid;
  int32 location;
}

struct Aggref
{
  Node xpr;
  uint32 aggfnoid;
  uint32 aggtype;
  uint32 aggcollid;
  uint32 inputcollid;
  uint32 aggtranstype;
  Node[] aggargtypes;
  Node[] aggdirectargs;
  Node[] args;
  Node[] aggorder;
  Node[] aggdistinct;
  Node aggfilter;
  bool aggstar;
  bool aggvariadic;
  string aggkind;
  uint32 agglevelsup;
  AggSplit aggsplit;
  int32 location;
}

struct GroupingFunc
{
  Node xpr;
  Node[] args;
  Node[] refs;
  Node[] cols;
  uint32 agglevelsup;
  int32 location;
}

struct WindowFunc
{
  Node xpr;
  uint32 winfnoid;
  uint32 wintype;
  uint32 wincollid;
  uint32 inputcollid;
  Node[] args;
  Node aggfilter;
  uint32 winref;
  bool winstar;
  bool winagg;
  int32 location;
}

struct SubscriptingRef
{
  Node xpr;
  uint32 refcontainertype;
  uint32 refelemtype;
  int32 reftypmod;
  uint32 refcollid;
  Node[] refupperindexpr;
  Node[] reflowerindexpr;
  Node refexpr;
  Node refassgnexpr;
}

struct FuncExpr
{
  Node xpr;
  uint32 funcid;
  uint32 funcresulttype;
  bool funcretset;
  bool funcvariadic;
  CoercionForm funcformat;
  uint32 funccollid;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct NamedArgExpr
{
  Node xpr;
  Node arg;
  string name;
  int32 argnumber;
  int32 location;
}

struct OpExpr
{
  Node xpr;
  uint32 opno;
  uint32 opfuncid;
  uint32 opresulttype;
  bool opretset;
  uint32 opcollid;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct DistinctExpr
{
  Node xpr;
  uint32 opno;
  uint32 opfuncid;
  uint32 opresulttype;
  bool opretset;
  uint32 opcollid;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct NullIfExpr
{
  Node xpr;
  uint32 opno;
  uint32 opfuncid;
  uint32 opresulttype;
  bool opretset;
  uint32 opcollid;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct ScalarArrayOpExpr
{
  Node xpr;
  uint32 opno;
  uint32 opfuncid;
  bool use_or;
  uint32 inputcollid;
  Node[] args;
  int32 location;
}

struct BoolExpr
{
  Node xpr;
  BoolExprType boolop;
  Node[] args;
  int32 location;
}

struct SubLink
{
  Node xpr;
  SubLinkType sub_link_type;
  int32 sub_link_id;
  Node testexpr;
  Node[] oper_name;
  Node subselect;
  int32 location;
}

struct SubPlan
{
  Node xpr;
  SubLinkType sub_link_type;
  Node testexpr;
  Node[] param_ids;
  int32 plan_id;
  string plan_name;
  uint32 first_col_type;
  int32 first_col_typmod;
  uint32 first_col_collation;
  bool use_hash_table;
  bool unknown_eq_false;
  bool parallel_safe;
  Node[] set_param;
  Node[] par_param;
  Node[] args;
  double startup_cost;
  double per_call_cost;
}

struct AlternativeSubPlan
{
  Node xpr;
  Node[] subplans;
}

struct FieldSelect
{
  Node xpr;
  Node arg;
  int32 fieldnum;
  uint32 resulttype;
  int32 resulttypmod;
  uint32 resultcollid;
}

struct FieldStore
{
  Node xpr;
  Node arg;
  Node[] newvals;
  Node[] fieldnums;
  uint32 resulttype;
}

struct RelabelType
{
  Node xpr;
  Node arg;
  uint32 resulttype;
  int32 resulttypmod;
  uint32 resultcollid;
  CoercionForm relabelformat;
  int32 location;
}

struct CoerceViaIO
{
  Node xpr;
  Node arg;
  uint32 resulttype;
  uint32 resultcollid;
  CoercionForm coerceformat;
  int32 location;
}

struct ArrayCoerceExpr
{
  Node xpr;
  Node arg;
  Node elemexpr;
  uint32 resulttype;
  int32 resulttypmod;
  uint32 resultcollid;
  CoercionForm coerceformat;
  int32 location;
}

struct ConvertRowtypeExpr
{
  Node xpr;
  Node arg;
  uint32 resulttype;
  CoercionForm convertformat;
  int32 location;
}

struct CollateExpr
{
  Node xpr;
  Node arg;
  uint32 coll_oid;
  int32 location;
}

struct CaseExpr
{
  Node xpr;
  uint32 casetype;
  uint32 casecollid;
  Node arg;
  Node[] args;
  Node defresult;
  int32 location;
}

struct CaseWhen
{
  Node xpr;
  Node expr;
  Node result;
  int32 location;
}

struct CaseTestExpr
{
  Node xpr;
  uint32 type_id;
  int32 type_mod;
  uint32 collation;
}

struct ArrayExpr
{
  Node xpr;
  uint32 array_typeid;
  uint32 array_collid;
  uint32 element_typeid;
  Node[] elements;
  bool multidims;
  int32 location;
}

struct RowExpr
{
  Node xpr;
  Node[] args;
  uint32 row_typeid;
  CoercionForm row_format;
  Node[] colnames;
  int32 location;
}

struct RowCompareExpr
{
  Node xpr;
  RowCompareType rctype;
  Node[] opnos;
  Node[] opfamilies;
  Node[] inputcollids;
  Node[] largs;
  Node[] rargs;
}

struct CoalesceExpr
{
  Node xpr;
  uint32 coalescetype;
  uint32 coalescecollid;
  Node[] args;
  int32 location;
}

struct MinMaxExpr
{
  Node xpr;
  uint32 minmaxtype;
  uint32 minmaxcollid;
  uint32 inputcollid;
  MinMaxOp op;
  Node[] args;
  int32 location;
}

struct SQLValueFunction
{
  Node xpr;
  SQLValueFunctionOp op;
  uint32 type;
  int32 typmod;
  int32 location;
}

struct XmlExpr
{
  Node xpr;
  XmlExprOp op;
  string name;
  Node[] named_args;
  Node[] arg_names;
  Node[] args;
  XmlOptionType xmloption;
  uint32 type;
  int32 typmod;
  int32 location;
}

struct NullTest
{
  Node xpr;
  Node arg;
  NullTestType nulltesttype;
  bool argisrow;
  int32 location;
}

struct BooleanTest
{
  Node xpr;
  Node arg;
  BoolTestType booltesttype;
  int32 location;
}

struct CoerceToDomain
{
  Node xpr;
  Node arg;
  uint32 resulttype;
  int32 resulttypmod;
  uint32 resultcollid;
  CoercionForm coercionformat;
  int32 location;
}

struct CoerceToDomainValue
{
  Node xpr;
  uint32 type_id;
  int32 type_mod;
  uint32 collation;
  int32 location;
}

struct SetToDefault
{
  Node xpr;
  uint32 type_id;
  int32 type_mod;
  uint32 collation;
  int32 location;
}

struct CurrentOfExpr
{
  Node xpr;
  uint32 cvarno;
  string cursor_name;
  int32 cursor_param;
}

struct NextValueExpr
{
  Node xpr;
  uint32 seqid;
  uint32 type_id;
}

struct InferenceElem
{
  Node xpr;
  Node expr;
  uint32 infercollid;
  uint32 inferopclass;
}

struct TargetEntry
{
  Node xpr;
  Node expr;
  int32 resno;
  string resname;
  uint32 ressortgroupref;
  uint32 resorigtbl;
  int32 resorigcol;
  bool resjunk;
}

struct RangeTblRef
{
  int32 rtindex;
}

struct JoinExpr
{
  JoinType jointype;
  bool is_natural;
  Node larg;
  Node rarg;
  Node[] using_clause;
  Node quals;
  Alias alias;
  int32 rtindex;
}

struct FromExpr
{
  Node[] fromlist;
  Node quals;
}

struct OnConflictExpr
{
  OnConflictAction action;
  Node[] arbiter_elems;
  Node arbiter_where;
  uint32 constraint;
  Node[] on_conflict_set;
  Node on_conflict_where;
  int32 excl_rel_index;
  Node[] excl_rel_tlist;
}

struct IntoClause
{
  RangeVar rel;
  Node[] col_names;
  string access_method;
  Node[] options;
  OnCommitAction on_commit;
  string table_space_name;
  Node view_query;
  bool skip_data;
}

struct RawStmt
{
  Node stmt;
  int32 stmt_location;
  int32 stmt_len;
}

struct Query
{
  CmdType command_type;
  QuerySource query_source;
  bool can_set_tag;
  Node utility_stmt;
  int32 result_relation;
  bool has_aggs;
  bool has_window_funcs;
  bool has_target_srfs;
  bool has_sub_links;
  bool has_distinct_on;
  bool has_recursive;
  bool has_modifying_cte;
  bool has_for_update;
  bool has_row_security;
  Node[] cte_list;
  Node[] rtable;
  FromExpr jointree;
  Node[] target_list;
  OverridingKind override;
  OnConflictExpr on_conflict;
  Node[] returning_list;
  Node[] group_clause;
  Node[] grouping_sets;
  Node having_qual;
  Node[] window_clause;
  Node[] distinct_clause;
  Node[] sort_clause;
  Node limit_offset;
  Node limit_count;
  LimitOption limit_option;
  Node[] row_marks;
  Node set_operations;
  Node[] constraint_deps;
  Node[] with_check_options;
  int32 stmt_location;
  int32 stmt_len;
}

struct InsertStmt
{
  RangeVar relation;
  Node[] cols;
  Node select_stmt;
  OnConflictClause on_conflict_clause;
  Node[] returning_list;
  WithClause with_clause;
  OverridingKind override;
}

struct DeleteStmt
{
  RangeVar relation;
  Node[] using_clause;
  Node where_clause;
  Node[] returning_list;
  WithClause with_clause;
}

struct UpdateStmt
{
  RangeVar relation;
  Node[] target_list;
  Node where_clause;
  Node[] from_clause;
  Node[] returning_list;
  WithClause with_clause;
}

struct SelectStmt
{
  Node[] distinct_clause;
  IntoClause into_clause;
  Node[] target_list;
  Node[] from_clause;
  Node where_clause;
  Node[] group_clause;
  Node having_clause;
  Node[] window_clause;
  Node[] values_lists;
  Node[] sort_clause;
  Node limit_offset;
  Node limit_count;
  LimitOption limit_option;
  Node[] locking_clause;
  WithClause with_clause;
  SetOperation op;
  bool all;
  SelectStmt larg;
  SelectStmt rarg;
}

struct AlterTableStmt
{
  RangeVar relation;
  Node[] cmds;
  ObjectType relkind;
  bool missing_ok;
}

struct AlterTableCmd
{
  AlterTableType subtype;
  string name;
  int32 num;
  RoleSpec newowner;
  Node def;
  DropBehavior behavior;
  bool missing_ok;
}

struct AlterDomainStmt
{
  string subtype;
  Node[] type_name;
  string name;
  Node def;
  DropBehavior behavior;
  bool missing_ok;
}

struct SetOperationStmt
{
  SetOperation op;
  bool all;
  Node larg;
  Node rarg;
  Node[] col_types;
  Node[] col_typmods;
  Node[] col_collations;
  Node[] group_clauses;
}

struct GrantStmt
{
  bool is_grant;
  GrantTargetType targtype;
  ObjectType objtype;
  Node[] objects;
  Node[] privileges;
  Node[] grantees;
  bool grant_option;
  DropBehavior behavior;
}

struct GrantRoleStmt
{
  Node[] granted_roles;
  Node[] grantee_roles;
  bool is_grant;
  bool admin_opt;
  RoleSpec grantor;
  DropBehavior behavior;
}

struct AlterDefaultPrivilegesStmt
{
  Node[] options;
  GrantStmt action;
}

struct ClosePortalStmt
{
  string portalname;
}

struct ClusterStmt
{
  RangeVar relation;
  string indexname;
  int32 options;
}

struct CopyStmt
{
  RangeVar relation;
  Node query;
  Node[] attlist;
  bool is_from;
  bool is_program;
  string filename;
  Node[] options;
  Node where_clause;
}

struct CreateStmt
{
  RangeVar relation;
  Node[] table_elts;
  Node[] inh_relations;
  PartitionBoundSpec partbound;
  PartitionSpec partspec;
  TypeName of_typename;
  Node[] constraints;
  Node[] options;
  OnCommitAction oncommit;
  string tablespacename;
  string access_method;
  bool if_not_exists;
}

struct DefineStmt
{
  ObjectType kind;
  bool oldstyle;
  Node[] defnames;
  Node[] args;
  Node[] definition;
  bool if_not_exists;
  bool replace;
}

struct DropStmt
{
  Node[] objects;
  ObjectType remove_type;
  DropBehavior behavior;
  bool missing_ok;
  bool concurrent;
}

struct TruncateStmt
{
  Node[] relations;
  bool restart_seqs;
  DropBehavior behavior;
}

struct CommentStmt
{
  ObjectType objtype;
  Node object;
  string comment;
}

struct FetchStmt
{
  FetchDirection direction;
  int64 how_many;
  string portalname;
  bool ismove;
}

struct IndexStmt
{
  string idxname;
  RangeVar relation;
  string access_method;
  string table_space;
  Node[] index_params;
  Node[] index_including_params;
  Node[] options;
  Node where_clause;
  Node[] exclude_op_names;
  string idxcomment;
  uint32 index_oid;
  uint32 old_node;
  uint32 old_create_subid;
  uint32 old_first_relfilenode_subid;
  bool unique;
  bool primary;
  bool isconstraint;
  bool deferrable;
  bool initdeferred;
  bool transformed;
  bool concurrent;
  bool if_not_exists;
  bool reset_default_tblspc;
}

struct CreateFunctionStmt
{
  bool is_procedure;
  bool replace;
  Node[] funcname;
  Node[] parameters;
  TypeName return_type;
  Node[] options;
}

struct AlterFunctionStmt
{
  ObjectType objtype;
  ObjectWithArgs func;
  Node[] actions;
}

struct DoStmt
{
  Node[] args;
}

struct RenameStmt
{
  ObjectType rename_type;
  ObjectType relation_type;
  RangeVar relation;
  Node object;
  string subname;
  string newname;
  DropBehavior behavior;
  bool missing_ok;
}

struct RuleStmt
{
  RangeVar relation;
  string rulename;
  Node where_clause;
  CmdType event;
  bool instead;
  Node[] actions;
  bool replace;
}

struct NotifyStmt
{
  string conditionname;
  string payload;
}

struct ListenStmt
{
  string conditionname;
}

struct UnlistenStmt
{
  string conditionname;
}

struct TransactionStmt
{
  TransactionStmtKind kind;
  Node[] options;
  string savepoint_name;
  string gid;
  bool chain;
}

struct ViewStmt
{
  RangeVar view;
  Node[] aliases;
  Node query;
  bool replace;
  Node[] options;
  ViewCheckOption with_check_option;
}

struct LoadStmt
{
  string filename;
}

struct CreateDomainStmt
{
  Node[] domainname;
  TypeName type_name;
  CollateClause coll_clause;
  Node[] constraints;
}

struct CreatedbStmt
{
  string dbname;
  Node[] options;
}

struct DropdbStmt
{
  string dbname;
  bool missing_ok;
  Node[] options;
}

struct VacuumStmt
{
  Node[] options;
  Node[] rels;
  bool is_vacuumcmd;
}

struct ExplainStmt
{
  Node query;
  Node[] options;
}

struct CreateTableAsStmt
{
  Node query;
  IntoClause into;
  ObjectType relkind;
  bool is_select_into;
  bool if_not_exists;
}

struct CreateSeqStmt
{
  RangeVar sequence;
  Node[] options;
  uint32 owner_id;
  bool for_identity;
  bool if_not_exists;
}

struct AlterSeqStmt
{
  RangeVar sequence;
  Node[] options;
  bool for_identity;
  bool missing_ok;
}

struct VariableSetStmt
{
  VariableSetKind kind;
  string name;
  Node[] args;
  bool is_local;
}

struct VariableShowStmt
{
  string name;
}

struct DiscardStmt
{
  DiscardMode target;
}

struct CreateTrigStmt
{
  string trigname;
  RangeVar relation;
  Node[] funcname;
  Node[] args;
  bool row;
  int32 timing;
  int32 events;
  Node[] columns;
  Node when_clause;
  bool isconstraint;
  Node[] transition_rels;
  bool deferrable;
  bool initdeferred;
  RangeVar constrrel;
}

struct CreatePLangStmt
{
  bool replace;
  string plname;
  Node[] plhandler;
  Node[] plinline;
  Node[] plvalidator;
  bool pltrusted;
}

struct CreateRoleStmt
{
  RoleStmtType stmt_type;
  string role;
  Node[] options;
}

struct AlterRoleStmt
{
  RoleSpec role;
  Node[] options;
  int32 action;
}

struct DropRoleStmt
{
  Node[] roles;
  bool missing_ok;
}

struct LockStmt
{
  Node[] relations;
  int32 mode;
  bool nowait;
}

struct ConstraintsSetStmt
{
  Node[] constraints;
  bool deferred;
}

struct ReindexStmt
{
  ReindexObjectType kind;
  RangeVar relation;
  string name;
  int32 options;
  bool concurrent;
}

struct CheckPointStmt
{
}

struct CreateSchemaStmt
{
  string schemaname;
  RoleSpec authrole;
  Node[] schema_elts;
  bool if_not_exists;
}

struct AlterDatabaseStmt
{
  string dbname;
  Node[] options;
}

struct AlterDatabaseSetStmt
{
  string dbname;
  VariableSetStmt setstmt;
}

struct AlterRoleSetStmt
{
  RoleSpec role;
  string database;
  VariableSetStmt setstmt;
}

struct CreateConversionStmt
{
  Node[] conversion_name;
  string for_encoding_name;
  string to_encoding_name;
  Node[] func_name;
  bool def;
}

struct CreateCastStmt
{
  TypeName sourcetype;
  TypeName targettype;
  ObjectWithArgs func;
  CoercionContext context;
  bool inout;
}

struct CreateOpClassStmt
{
  Node[] opclassname;
  Node[] opfamilyname;
  string amname;
  TypeName datatype;
  Node[] items;
  bool is_default;
}

struct CreateOpFamilyStmt
{
  Node[] opfamilyname;
  string amname;
}

struct AlterOpFamilyStmt
{
  Node[] opfamilyname;
  string amname;
  bool is_drop;
  Node[] items;
}

struct PrepareStmt
{
  string name;
  Node[] argtypes;
  Node query;
}

struct ExecuteStmt
{
  string name;
  Node[] params;
}

struct DeallocateStmt
{
  string name;
}

struct DeclareCursorStmt
{
  string portalname;
  int32 options;
  Node query;
}

struct CreateTableSpaceStmt
{
  string tablespacename;
  RoleSpec owner;
  string location;
  Node[] options;
}

struct DropTableSpaceStmt
{
  string tablespacename;
  bool missing_ok;
}

struct AlterObjectDependsStmt
{
  ObjectType object_type;
  RangeVar relation;
  Node object;
  Node extname;
  bool remove;
}

struct AlterObjectSchemaStmt
{
  ObjectType object_type;
  RangeVar relation;
  Node object;
  string newschema;
  bool missing_ok;
}

struct AlterOwnerStmt
{
  ObjectType object_type;
  RangeVar relation;
  Node object;
  RoleSpec newowner;
}

struct AlterOperatorStmt
{
  ObjectWithArgs opername;
  Node[] options;
}

struct AlterTypeStmt
{
  Node[] type_name;
  Node[] options;
}

struct DropOwnedStmt
{
  Node[] roles;
  DropBehavior behavior;
}

struct ReassignOwnedStmt
{
  Node[] roles;
  RoleSpec newrole;
}

struct CompositeTypeStmt
{
  RangeVar typevar;
  Node[] coldeflist;
}

struct CreateEnumStmt
{
  Node[] type_name;
  Node[] vals;
}

struct CreateRangeStmt
{
  Node[] type_name;
  Node[] params;
}

struct AlterEnumStmt
{
  Node[] type_name;
  string old_val;
  string new_val;
  string new_val_neighbor;
  bool new_val_is_after;
  bool skip_if_new_val_exists;
}

struct AlterTSDictionaryStmt
{
  Node[] dictname;
  Node[] options;
}

struct AlterTSConfigurationStmt
{
  AlterTSConfigType kind;
  Node[] cfgname;
  Node[] tokentype;
  Node[] dicts;
  bool override;
  bool replace;
  bool missing_ok;
}

struct CreateFdwStmt
{
  string fdwname;
  Node[] func_options;
  Node[] options;
}

struct AlterFdwStmt
{
  string fdwname;
  Node[] func_options;
  Node[] options;
}

struct CreateForeignServerStmt
{
  string servername;
  string servertype;
  string version;
  string fdwname;
  bool if_not_exists;
  Node[] options;
}

struct AlterForeignServerStmt
{
  string servername;
  string version;
  Node[] options;
  bool has_version;
}

struct CreateUserMappingStmt
{
  RoleSpec user;
  string servername;
  bool if_not_exists;
  Node[] options;
}

struct AlterUserMappingStmt
{
  RoleSpec user;
  string servername;
  Node[] options;
}

struct DropUserMappingStmt
{
  RoleSpec user;
  string servername;
  bool missing_ok;
}

struct AlterTableSpaceOptionsStmt
{
  string tablespacename;
  Node[] options;
  bool is_reset;
}

struct AlterTableMoveAllStmt
{
  string orig_tablespacename;
  ObjectType objtype;
  Node[] roles;
  string new_tablespacename;
  bool nowait;
}

struct SecLabelStmt
{
  ObjectType objtype;
  Node object;
  string provider;
  string label;
}

struct CreateForeignTableStmt
{
  CreateStmt base_stmt;
  string servername;
  Node[] options;
}

struct ImportForeignSchemaStmt
{
  string server_name;
  string remote_schema;
  string local_schema;
  ImportForeignSchemaType list_type;
  Node[] table_list;
  Node[] options;
}

struct CreateExtensionStmt
{
  string extname;
  bool if_not_exists;
  Node[] options;
}

struct AlterExtensionStmt
{
  string extname;
  Node[] options;
}

struct AlterExtensionContentsStmt
{
  string extname;
  int32 action;
  ObjectType objtype;
  Node object;
}

struct CreateEventTrigStmt
{
  string trigname;
  string eventname;
  Node[] whenclause;
  Node[] funcname;
}

struct AlterEventTrigStmt
{
  string trigname;
  string tgenabled;
}

struct RefreshMatViewStmt
{
  bool concurrent;
  bool skip_data;
  RangeVar relation;
}

struct ReplicaIdentityStmt
{
  string identity_type;
  string name;
}

struct AlterSystemStmt
{
  VariableSetStmt setstmt;
}

struct CreatePolicyStmt
{
  string policy_name;
  RangeVar table;
  string cmd_name;
  bool permissive;
  Node[] roles;
  Node qual;
  Node with_check;
}

struct AlterPolicyStmt
{
  string policy_name;
  RangeVar table;
  Node[] roles;
  Node qual;
  Node with_check;
}

struct CreateTransformStmt
{
  bool replace;
  TypeName type_name;
  string lang;
  ObjectWithArgs fromsql;
  ObjectWithArgs tosql;
}

struct CreateAmStmt
{
  string amname;
  Node[] handler_name;
  string amtype;
}

struct CreatePublicationStmt
{
  string pubname;
  Node[] options;
  Node[] tables;
  bool for_all_tables;
}

struct AlterPublicationStmt
{
  string pubname;
  Node[] options;
  Node[] tables;
  bool for_all_tables;
  DefElemAction table_action;
}

struct CreateSubscriptionStmt
{
  string subname;
  string conninfo;
  Node[] publication;
  Node[] options;
}

struct AlterSubscriptionStmt
{
  AlterSubscriptionType kind;
  string subname;
  string conninfo;
  Node[] publication;
  Node[] options;
}

struct DropSubscriptionStmt
{
  string subname;
  bool missing_ok;
  DropBehavior behavior;
}

struct CreateStatsStmt
{
  Node[] defnames;
  Node[] stat_types;
  Node[] exprs;
  Node[] relations;
  string stxcomment;
  bool if_not_exists;
}

struct AlterCollationStmt
{
  Node[] collname;
}

struct CallStmt
{
  FuncCall funccall;
  FuncExpr funcexpr;
}

struct AlterStatsStmt
{
  Node[] defnames;
  int32 stxstattarget;
  bool missing_ok;
}

struct A_Expr
{
  A_Expr_Kind kind;
  Node[] name;
  Node lexpr;
  Node rexpr;
  int32 location;
}

struct ColumnRef
{
  Node[] fields;
  int32 location;
}

struct ParamRef
{
  int32 number;
  int32 location;
}

struct A_Const
{
  Node val;
  int32 location;
}

struct FuncCall
{
  Node[] funcname;
  Node[] args;
  Node[] agg_order;
  Node agg_filter;
  bool agg_within_group;
  bool agg_star;
  bool agg_distinct;
  bool func_variadic;
  WindowDef over;
  int32 location;
}

struct A_Star
{
}

struct A_Indices
{
  bool is_slice;
  Node lidx;
  Node uidx;
}

struct A_Indirection
{
  Node arg;
  Node[] indirection;
}

struct A_ArrayExpr
{
  Node[] elements;
  int32 location;
}

struct ResTarget
{
  string name;
  Node[] indirection;
  Node val;
  int32 location;
}

struct MultiAssignRef
{
  Node source;
  int32 colno;
  int32 ncolumns;
}

struct TypeCast
{
  Node arg;
  TypeName type_name;
  int32 location;
}

struct CollateClause
{
  Node arg;
  Node[] collname;
  int32 location;
}

struct SortBy
{
  Node node;
  SortByDir sortby_dir;
  SortByNulls sortby_nulls;
  Node[] use_op;
  int32 location;
}

struct WindowDef
{
  string name;
  string refname;
  Node[] partition_clause;
  Node[] order_clause;
  int32 frame_options;
  Node start_offset;
  Node end_offset;
  int32 location;
}

struct RangeSubselect
{
  bool lateral;
  Node subquery;
  Alias alias;
}

struct RangeFunction
{
  bool lateral;
  bool ordinality;
  bool is_rowsfrom;
  Node[] functions;
  Alias alias;
  Node[] coldeflist;
}

struct RangeTableSample
{
  Node relation;
  Node[] method;
  Node[] args;
  Node repeatable;
  int32 location;
}

struct RangeTableFunc
{
  bool lateral;
  Node docexpr;
  Node rowexpr;
  Node[] namespaces;
  Node[] columns;
  Alias alias;
  int32 location;
}

struct RangeTableFuncCol
{
  string colname;
  TypeName type_name;
  bool for_ordinality;
  bool is_not_null;
  Node colexpr;
  Node coldefexpr;
  int32 location;
}

struct TypeName
{
  Node[] names;
  uint32 type_oid;
  bool setof;
  bool pct_type;
  Node[] typmods;
  int32 typemod;
  Node[] array_bounds;
  int32 location;
}

struct ColumnDef
{
  string colname;
  TypeName type_name;
  int32 inhcount;
  bool is_local;
  bool is_not_null;
  bool is_from_type;
  string storage;
  Node raw_default;
  Node cooked_default;
  string identity;
  RangeVar identity_sequence;
  string generated;
  CollateClause coll_clause;
  uint32 coll_oid;
  Node[] constraints;
  Node[] fdwoptions;
  int32 location;
}

struct IndexElem
{
  string name;
  Node expr;
  string indexcolname;
  Node[] collation;
  Node[] opclass;
  Node[] opclassopts;
  SortByDir ordering;
  SortByNulls nulls_ordering;
}

struct Constraint
{
  ConstrType contype;
  string conname;
  bool deferrable;
  bool initdeferred;
  int32 location;
  bool is_no_inherit;
  Node raw_expr;
  string cooked_expr;
  string generated_when;
  Node[] keys;
  Node[] including;
  Node[] exclusions;
  Node[] options;
  string indexname;
  string indexspace;
  bool reset_default_tblspc;
  string access_method;
  Node where_clause;
  RangeVar pktable;
  Node[] fk_attrs;
  Node[] pk_attrs;
  string fk_matchtype;
  string fk_upd_action;
  string fk_del_action;
  Node[] old_conpfeqop;
  uint32 old_pktable_oid;
  bool skip_validation;
  bool initially_valid;
}

struct DefElem
{
  string defnamespace;
  string defname;
  Node arg;
  DefElemAction defaction;
  int32 location;
}

struct RangeTblEntry
{
  RTEKind rtekind;
  uint32 relid;
  string relkind;
  int32 rellockmode;
  TableSampleClause tablesample;
  Query subquery;
  bool security_barrier;
  JoinType jointype;
  int32 joinmergedcols;
  Node[] joinaliasvars;
  Node[] joinleftcols;
  Node[] joinrightcols;
  Node[] functions;
  bool funcordinality;
  TableFunc tablefunc;
  Node[] values_lists;
  string ctename;
  uint32 ctelevelsup;
  bool self_reference;
  Node[] coltypes;
  Node[] coltypmods;
  Node[] colcollations;
  string enrname;
  double enrtuples;
  Alias alias;
  Alias eref;
  bool lateral;
  bool inh;
  bool in_from_cl;
  uint32 required_perms;
  uint32 check_as_user;
  uint64[] selected_cols;
  uint64[] inserted_cols;
  uint64[] updated_cols;
  uint64[] extra_updated_cols;
  Node[] security_quals;
}

struct RangeTblFunction
{
  Node funcexpr;
  int32 funccolcount;
  Node[] funccolnames;
  Node[] funccoltypes;
  Node[] funccoltypmods;
  Node[] funccolcollations;
  uint64[] funcparams;
}

struct TableSampleClause
{
  uint32 tsmhandler;
  Node[] args;
  Node repeatable;
}

struct WithCheckOption
{
  WCOKind kind;
  string relname;
  string polname;
  Node qual;
  bool cascaded;
}

struct SortGroupClause
{
  uint32 tle_sort_group_ref;
  uint32 eqop;
  uint32 sortop;
  bool nulls_first;
  bool hashable;
}

struct GroupingSet
{
  GroupingSetKind kind;
  Node[] content;
  int32 location;
}

struct WindowClause
{
  string name;
  string refname;
  Node[] partition_clause;
  Node[] order_clause;
  int32 frame_options;
  Node start_offset;
  Node end_offset;
  uint32 start_in_range_func;
  uint32 end_in_range_func;
  uint32 in_range_coll;
  bool in_range_asc;
  bool in_range_nulls_first;
  uint32 winref;
  bool copied_order;
}

struct ObjectWithArgs
{
  Node[] objname;
  Node[] objargs;
  bool args_unspecified;
}

struct AccessPriv
{
  string priv_name;
  Node[] cols;
}

struct CreateOpClassItem
{
  int32 itemtype;
  ObjectWithArgs name;
  int32 number;
  Node[] order_family;
  Node[] class_args;
  TypeName storedtype;
}

struct TableLikeClause
{
  RangeVar relation;
  uint32 options;
  uint32 relation_oid;
}

struct FunctionParameter
{
  string name;
  TypeName arg_type;
  FunctionParameterMode mode;
  Node defexpr;
}

struct LockingClause
{
  Node[] locked_rels;
  LockClauseStrength strength;
  LockWaitPolicy wait_policy;
}

struct RowMarkClause
{
  uint32 rti;
  LockClauseStrength strength;
  LockWaitPolicy wait_policy;
  bool pushed_down;
}

struct XmlSerialize
{
  XmlOptionType xmloption;
  Node expr;
  TypeName type_name;
  int32 location;
}

struct WithClause
{
  Node[] ctes;
  bool recursive;
  int32 location;
}

struct InferClause
{
  Node[] index_elems;
  Node where_clause;
  string conname;
  int32 location;
}

struct OnConflictClause
{
  OnConflictAction action;
  InferClause infer;
  Node[] target_list;
  Node where_clause;
  int32 location;
}

struct CommonTableExpr
{
  string ctename;
  Node[] aliascolnames;
  CTEMaterialize ctematerialized;
  Node ctequery;
  int32 location;
  bool cterecursive;
  int32 cterefcount;
  Node[] ctecolnames;
  Node[] ctecoltypes;
  Node[] ctecoltypmods;
  Node[] ctecolcollations;
}

struct RoleSpec
{
  RoleSpecType roletype;
  string rolename;
  int32 location;
}

struct TriggerTransition
{
  string name;
  bool is_new;
  bool is_table;
}

struct PartitionElem
{
  string name;
  Node expr;
  Node[] collation;
  Node[] opclass;
  int32 location;
}

struct PartitionSpec
{
  string strategy;
  Node[] part_params;
  int32 location;
}

struct PartitionBoundSpec
{
  string strategy;
  bool is_default;
  int32 modulus;
  int32 remainder;
  Node[] listdatums;
  Node[] lowerdatums;
  Node[] upperdatums;
  int32 location;
}

struct PartitionRangeDatum
{
  PartitionRangeDatumKind kind;
  Node value;
  int32 location;
}

struct PartitionCmd
{
  RangeVar name;
  PartitionBoundSpec bound;
}

struct VacuumRelation
{
  RangeVar relation;
  uint32 oid;
  Node[] va_cols;
}

struct InlineCodeBlock
{
  string source_text;
  uint32 lang_oid;
  bool lang_is_trusted;
  bool atomic;
}

struct CallContext
{
  bool atomic;
}

enum OverridingKind
{
  OVERRIDING_KIND_UNDEFINED = 0;
  OVERRIDING_NOT_SET = 1;
  OVERRIDING_USER_VALUE = 2;
  OVERRIDING_SYSTEM_VALUE = 3;
}

enum QuerySource
{
  QUERY_SOURCE_UNDEFINED = 0;
  QSRC_ORIGINAL = 1;
  QSRC_PARSER = 2;
  QSRC_INSTEAD_RULE = 3;
  QSRC_QUAL_INSTEAD_RULE = 4;
  QSRC_NON_INSTEAD_RULE = 5;
}

enum SortByDir
{
  SORT_BY_DIR_UNDEFINED = 0;
  SORTBY_DEFAULT = 1;
  SORTBY_ASC = 2;
  SORTBY_DESC = 3;
  SORTBY_USING = 4;
}

enum SortByNulls
{
  SORT_BY_NULLS_UNDEFINED = 0;
  SORTBY_NULLS_DEFAULT = 1;
  SORTBY_NULLS_FIRST = 2;
  SORTBY_NULLS_LAST = 3;
}

enum A_Expr_Kind
{
  A_EXPR_KIND_UNDEFINED = 0;
  AEXPR_OP = 1;
  AEXPR_OP_ANY = 2;
  AEXPR_OP_ALL = 3;
  AEXPR_DISTINCT = 4;
  AEXPR_NOT_DISTINCT = 5;
  AEXPR_NULLIF = 6;
  AEXPR_OF = 7;
  AEXPR_IN = 8;
  AEXPR_LIKE = 9;
  AEXPR_ILIKE = 10;
  AEXPR_SIMILAR = 11;
  AEXPR_BETWEEN = 12;
  AEXPR_NOT_BETWEEN = 13;
  AEXPR_BETWEEN_SYM = 14;
  AEXPR_NOT_BETWEEN_SYM = 15;
  AEXPR_PAREN = 16;
}

enum RoleSpecType
{
  ROLE_SPEC_TYPE_UNDEFINED = 0;
  ROLESPEC_CSTRING = 1;
  ROLESPEC_CURRENT_USER = 2;
  ROLESPEC_SESSION_USER = 3;
  ROLESPEC_PUBLIC = 4;
}

enum TableLikeOption
{
  TABLE_LIKE_OPTION_UNDEFINED = 0;
  CREATE_TABLE_LIKE_COMMENTS = 1;
  CREATE_TABLE_LIKE_CONSTRAINTS = 2;
  CREATE_TABLE_LIKE_DEFAULTS = 3;
  CREATE_TABLE_LIKE_GENERATED = 4;
  CREATE_TABLE_LIKE_IDENTITY = 5;
  CREATE_TABLE_LIKE_INDEXES = 6;
  CREATE_TABLE_LIKE_STATISTICS = 7;
  CREATE_TABLE_LIKE_STORAGE = 8;
  CREATE_TABLE_LIKE_ALL = 9;
}

enum DefElemAction
{
  DEF_ELEM_ACTION_UNDEFINED = 0;
  DEFELEM_UNSPEC = 1;
  DEFELEM_SET = 2;
  DEFELEM_ADD = 3;
  DEFELEM_DROP = 4;
}

enum PartitionRangeDatumKind
{
  PARTITION_RANGE_DATUM_KIND_UNDEFINED = 0;
  PARTITION_RANGE_DATUM_MINVALUE = 1;
  PARTITION_RANGE_DATUM_VALUE = 2;
  PARTITION_RANGE_DATUM_MAXVALUE = 3;
}

enum RTEKind
{
  RTEKIND_UNDEFINED = 0;
  RTE_RELATION = 1;
  RTE_SUBQUERY = 2;
  RTE_JOIN = 3;
  RTE_FUNCTION = 4;
  RTE_TABLEFUNC = 5;
  RTE_VALUES = 6;
  RTE_CTE = 7;
  RTE_NAMEDTUPLESTORE = 8;
  RTE_RESULT = 9;
}

enum WCOKind
{
  WCOKIND_UNDEFINED = 0;
  WCO_VIEW_CHECK = 1;
  WCO_RLS_INSERT_CHECK = 2;
  WCO_RLS_UPDATE_CHECK = 3;
  WCO_RLS_CONFLICT_CHECK = 4;
}

enum GroupingSetKind
{
  GROUPING_SET_KIND_UNDEFINED = 0;
  GROUPING_SET_EMPTY = 1;
  GROUPING_SET_SIMPLE = 2;
  GROUPING_SET_ROLLUP = 3;
  GROUPING_SET_CUBE = 4;
  GROUPING_SET_SETS = 5;
}

enum CTEMaterialize
{
  CTEMATERIALIZE_UNDEFINED = 0;
  CTEMaterializeDefault = 1;
  CTEMaterializeAlways = 2;
  CTEMaterializeNever = 3;
}

enum SetOperation
{
  SET_OPERATION_UNDEFINED = 0;
  SETOP_NONE = 1;
  SETOP_UNION = 2;
  SETOP_INTERSECT = 3;
  SETOP_EXCEPT = 4;
}

enum ObjectType
{
  OBJECT_TYPE_UNDEFINED = 0;
  OBJECT_ACCESS_METHOD = 1;
  OBJECT_AGGREGATE = 2;
  OBJECT_AMOP = 3;
  OBJECT_AMPROC = 4;
  OBJECT_ATTRIBUTE = 5;
  OBJECT_CAST = 6;
  OBJECT_COLUMN = 7;
  OBJECT_COLLATION = 8;
  OBJECT_CONVERSION = 9;
  OBJECT_DATABASE = 10;
  OBJECT_DEFAULT = 11;
  OBJECT_DEFACL = 12;
  OBJECT_DOMAIN = 13;
  OBJECT_DOMCONSTRAINT = 14;
  OBJECT_EVENT_TRIGGER = 15;
  OBJECT_EXTENSION = 16;
  OBJECT_FDW = 17;
  OBJECT_FOREIGN_SERVER = 18;
  OBJECT_FOREIGN_TABLE = 19;
  OBJECT_FUNCTION = 20;
  OBJECT_INDEX = 21;
  OBJECT_LANGUAGE = 22;
  OBJECT_LARGEOBJECT = 23;
  OBJECT_MATVIEW = 24;
  OBJECT_OPCLASS = 25;
  OBJECT_OPERATOR = 26;
  OBJECT_OPFAMILY = 27;
  OBJECT_POLICY = 28;
  OBJECT_PROCEDURE = 29;
  OBJECT_PUBLICATION = 30;
  OBJECT_PUBLICATION_REL = 31;
  OBJECT_ROLE = 32;
  OBJECT_ROUTINE = 33;
  OBJECT_RULE = 34;
  OBJECT_SCHEMA = 35;
  OBJECT_SEQUENCE = 36;
  OBJECT_SUBSCRIPTION = 37;
  OBJECT_STATISTIC_EXT = 38;
  OBJECT_TABCONSTRAINT = 39;
  OBJECT_TABLE = 40;
  OBJECT_TABLESPACE = 41;
  OBJECT_TRANSFORM = 42;
  OBJECT_TRIGGER = 43;
  OBJECT_TSCONFIGURATION = 44;
  OBJECT_TSDICTIONARY = 45;
  OBJECT_TSPARSER = 46;
  OBJECT_TSTEMPLATE = 47;
  OBJECT_TYPE = 48;
  OBJECT_USER_MAPPING = 49;
  OBJECT_VIEW = 50;
}

enum DropBehavior
{
  DROP_BEHAVIOR_UNDEFINED = 0;
  DROP_RESTRICT = 1;
  DROP_CASCADE = 2;
}

enum AlterTableType
{
  ALTER_TABLE_TYPE_UNDEFINED = 0;
  AT_AddColumn = 1;
  AT_AddColumnRecurse = 2;
  AT_AddColumnToView = 3;
  AT_ColumnDefault = 4;
  AT_CookedColumnDefault = 5;
  AT_DropNotNull = 6;
  AT_SetNotNull = 7;
  AT_DropExpression = 8;
  AT_CheckNotNull = 9;
  AT_SetStatistics = 10;
  AT_SetOptions = 11;
  AT_ResetOptions = 12;
  AT_SetStorage = 13;
  AT_DropColumn = 14;
  AT_DropColumnRecurse = 15;
  AT_AddIndex = 16;
  AT_ReAddIndex = 17;
  AT_AddConstraint = 18;
  AT_AddConstraintRecurse = 19;
  AT_ReAddConstraint = 20;
  AT_ReAddDomainConstraint = 21;
  AT_AlterConstraint = 22;
  AT_ValidateConstraint = 23;
  AT_ValidateConstraintRecurse = 24;
  AT_AddIndexConstraint = 25;
  AT_DropConstraint = 26;
  AT_DropConstraintRecurse = 27;
  AT_ReAddComment = 28;
  AT_AlterColumnType = 29;
  AT_AlterColumnGenericOptions = 30;
  AT_ChangeOwner = 31;
  AT_ClusterOn = 32;
  AT_DropCluster = 33;
  AT_SetLogged = 34;
  AT_SetUnLogged = 35;
  AT_DropOids = 36;
  AT_SetTableSpace = 37;
  AT_SetRelOptions = 38;
  AT_ResetRelOptions = 39;
  AT_ReplaceRelOptions = 40;
  AT_EnableTrig = 41;
  AT_EnableAlwaysTrig = 42;
  AT_EnableReplicaTrig = 43;
  AT_DisableTrig = 44;
  AT_EnableTrigAll = 45;
  AT_DisableTrigAll = 46;
  AT_EnableTrigUser = 47;
  AT_DisableTrigUser = 48;
  AT_EnableRule = 49;
  AT_EnableAlwaysRule = 50;
  AT_EnableReplicaRule = 51;
  AT_DisableRule = 52;
  AT_AddInherit = 53;
  AT_DropInherit = 54;
  AT_AddOf = 55;
  AT_DropOf = 56;
  AT_ReplicaIdentity = 57;
  AT_EnableRowSecurity = 58;
  AT_DisableRowSecurity = 59;
  AT_ForceRowSecurity = 60;
  AT_NoForceRowSecurity = 61;
  AT_GenericOptions = 62;
  AT_AttachPartition = 63;
  AT_DetachPartition = 64;
  AT_AddIdentity = 65;
  AT_SetIdentity = 66;
  AT_DropIdentity = 67;
}

enum GrantTargetType
{
  GRANT_TARGET_TYPE_UNDEFINED = 0;
  ACL_TARGET_OBJECT = 1;
  ACL_TARGET_ALL_IN_SCHEMA = 2;
  ACL_TARGET_DEFAULTS = 3;
}

enum VariableSetKind
{
  VARIABLE_SET_KIND_UNDEFINED = 0;
  VAR_SET_VALUE = 1;
  VAR_SET_DEFAULT = 2;
  VAR_SET_CURRENT = 3;
  VAR_SET_MULTI = 4;
  VAR_RESET = 5;
  VAR_RESET_ALL = 6;
}

enum ConstrType
{
  CONSTR_TYPE_UNDEFINED = 0;
  CONSTR_NULL = 1;
  CONSTR_NOTNULL = 2;
  CONSTR_DEFAULT = 3;
  CONSTR_IDENTITY = 4;
  CONSTR_GENERATED = 5;
  CONSTR_CHECK = 6;
  CONSTR_PRIMARY = 7;
  CONSTR_UNIQUE = 8;
  CONSTR_EXCLUSION = 9;
  CONSTR_FOREIGN = 10;
  CONSTR_ATTR_DEFERRABLE = 11;
  CONSTR_ATTR_NOT_DEFERRABLE = 12;
  CONSTR_ATTR_DEFERRED = 13;
  CONSTR_ATTR_IMMEDIATE = 14;
}

enum ImportForeignSchemaType
{
  IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED = 0;
  FDW_IMPORT_SCHEMA_ALL = 1;
  FDW_IMPORT_SCHEMA_LIMIT_TO = 2;
  FDW_IMPORT_SCHEMA_EXCEPT = 3;
}

enum RoleStmtType
{
  ROLE_STMT_TYPE_UNDEFINED = 0;
  ROLESTMT_ROLE = 1;
  ROLESTMT_USER = 2;
  ROLESTMT_GROUP = 3;
}

enum FetchDirection
{
  FETCH_DIRECTION_UNDEFINED = 0;
  FETCH_FORWARD = 1;
  FETCH_BACKWARD = 2;
  FETCH_ABSOLUTE = 3;
  FETCH_RELATIVE = 4;
}

enum FunctionParameterMode
{
  FUNCTION_PARAMETER_MODE_UNDEFINED = 0;
  FUNC_PARAM_IN = 1;
  FUNC_PARAM_OUT = 2;
  FUNC_PARAM_INOUT = 3;
  FUNC_PARAM_VARIADIC = 4;
  FUNC_PARAM_TABLE = 5;
}

enum TransactionStmtKind
{
  TRANSACTION_STMT_KIND_UNDEFINED = 0;
  TRANS_STMT_BEGIN = 1;
  TRANS_STMT_START = 2;
  TRANS_STMT_COMMIT = 3;
  TRANS_STMT_ROLLBACK = 4;
  TRANS_STMT_SAVEPOINT = 5;
  TRANS_STMT_RELEASE = 6;
  TRANS_STMT_ROLLBACK_TO = 7;
  TRANS_STMT_PREPARE = 8;
  TRANS_STMT_COMMIT_PREPARED = 9;
  TRANS_STMT_ROLLBACK_PREPARED = 10;
}

enum ViewCheckOption
{
  VIEW_CHECK_OPTION_UNDEFINED = 0;
  NO_CHECK_OPTION = 1;
  LOCAL_CHECK_OPTION = 2;
  CASCADED_CHECK_OPTION = 3;
}

enum ClusterOption
{
  CLUSTER_OPTION_UNDEFINED = 0;
  CLUOPT_RECHECK = 1;
  CLUOPT_VERBOSE = 2;
}

enum DiscardMode
{
  DISCARD_MODE_UNDEFINED = 0;
  DISCARD_ALL = 1;
  DISCARD_PLANS = 2;
  DISCARD_SEQUENCES = 3;
  DISCARD_TEMP = 4;
}

enum ReindexObjectType
{
  REINDEX_OBJECT_TYPE_UNDEFINED = 0;
  REINDEX_OBJECT_INDEX = 1;
  REINDEX_OBJECT_TABLE = 2;
  REINDEX_OBJECT_SCHEMA = 3;
  REINDEX_OBJECT_SYSTEM = 4;
  REINDEX_OBJECT_DATABASE = 5;
}

enum AlterTSConfigType
{
  ALTER_TSCONFIG_TYPE_UNDEFINED = 0;
  ALTER_TSCONFIG_ADD_MAPPING = 1;
  ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN = 2;
  ALTER_TSCONFIG_REPLACE_DICT = 3;
  ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN = 4;
  ALTER_TSCONFIG_DROP_MAPPING = 5;
}

enum AlterSubscriptionType
{
  ALTER_SUBSCRIPTION_TYPE_UNDEFINED = 0;
  ALTER_SUBSCRIPTION_OPTIONS = 1;
  ALTER_SUBSCRIPTION_CONNECTION = 2;
  ALTER_SUBSCRIPTION_PUBLICATION = 3;
  ALTER_SUBSCRIPTION_REFRESH = 4;
  ALTER_SUBSCRIPTION_ENABLED = 5;
}

enum OnCommitAction
{
  ON_COMMIT_ACTION_UNDEFINED = 0;
  ONCOMMIT_NOOP = 1;
  ONCOMMIT_PRESERVE_ROWS = 2;
  ONCOMMIT_DELETE_ROWS = 3;
  ONCOMMIT_DROP = 4;
}

enum ParamKind
{
  PARAM_KIND_UNDEFINED = 0;
  PARAM_EXTERN = 1;
  PARAM_EXEC = 2;
  PARAM_SUBLINK = 3;
  PARAM_MULTIEXPR = 4;
}

enum CoercionContext
{
  COERCION_CONTEXT_UNDEFINED = 0;
  COERCION_IMPLICIT = 1;
  COERCION_ASSIGNMENT = 2;
  COERCION_EXPLICIT = 3;
}

enum CoercionForm
{
  COERCION_FORM_UNDEFINED = 0;
  COERCE_EXPLICIT_CALL = 1;
  COERCE_EXPLICIT_CAST = 2;
  COERCE_IMPLICIT_CAST = 3;
}

enum BoolExprType
{
  BOOL_EXPR_TYPE_UNDEFINED = 0;
  AND_EXPR = 1;
  OR_EXPR = 2;
  NOT_EXPR = 3;
}

enum SubLinkType
{
  SUB_LINK_TYPE_UNDEFINED = 0;
  EXISTS_SUBLINK = 1;
  ALL_SUBLINK = 2;
  ANY_SUBLINK = 3;
  ROWCOMPARE_SUBLINK = 4;
  EXPR_SUBLINK = 5;
  MULTIEXPR_SUBLINK = 6;
  ARRAY_SUBLINK = 7;
  CTE_SUBLINK = 8;
}

enum RowCompareType
{
  ROW_COMPARE_TYPE_UNDEFINED = 0;
  ROWCOMPARE_LT = 1;
  ROWCOMPARE_LE = 2;
  ROWCOMPARE_EQ = 3;
  ROWCOMPARE_GE = 4;
  ROWCOMPARE_GT = 5;
  ROWCOMPARE_NE = 6;
}

enum MinMaxOp
{
  MIN_MAX_OP_UNDEFINED = 0;
  IS_GREATEST = 1;
  IS_LEAST = 2;
}

enum SQLValueFunctionOp
{
  SQLVALUE_FUNCTION_OP_UNDEFINED = 0;
  SVFOP_CURRENT_DATE = 1;
  SVFOP_CURRENT_TIME = 2;
  SVFOP_CURRENT_TIME_N = 3;
  SVFOP_CURRENT_TIMESTAMP = 4;
  SVFOP_CURRENT_TIMESTAMP_N = 5;
  SVFOP_LOCALTIME = 6;
  SVFOP_LOCALTIME_N = 7;
  SVFOP_LOCALTIMESTAMP = 8;
  SVFOP_LOCALTIMESTAMP_N = 9;
  SVFOP_CURRENT_ROLE = 10;
  SVFOP_CURRENT_USER = 11;
  SVFOP_USER = 12;
  SVFOP_SESSION_USER = 13;
  SVFOP_CURRENT_CATALOG = 14;
  SVFOP_CURRENT_SCHEMA = 15;
}

enum XmlExprOp
{
  XML_EXPR_OP_UNDEFINED = 0;
  IS_XMLCONCAT = 1;
  IS_XMLELEMENT = 2;
  IS_XMLFOREST = 3;
  IS_XMLPARSE = 4;
  IS_XMLPI = 5;
  IS_XMLROOT = 6;
  IS_XMLSERIALIZE = 7;
  IS_DOCUMENT = 8;
}

enum XmlOptionType
{
  XML_OPTION_TYPE_UNDEFINED = 0;
  XMLOPTION_DOCUMENT = 1;
  XMLOPTION_CONTENT = 2;
}

enum NullTestType
{
  NULL_TEST_TYPE_UNDEFINED = 0;
  IS_NULL = 1;
  IS_NOT_NULL = 2;
}

enum BoolTestType
{
  BOOL_TEST_TYPE_UNDEFINED = 0;
  IS_TRUE = 1;
  IS_NOT_TRUE = 2;
  IS_FALSE = 3;
  IS_NOT_FALSE = 4;
  IS_UNKNOWN = 5;
  IS_NOT_UNKNOWN = 6;
}

enum CmdType
{
  CMD_TYPE_UNDEFINED = 0;
  CMD_UNKNOWN = 1;
  CMD_SELECT = 2;
  CMD_UPDATE = 3;
  CMD_INSERT = 4;
  CMD_DELETE = 5;
  CMD_UTILITY = 6;
  CMD_NOTHING = 7;
}

enum JoinType
{
  JOIN_TYPE_UNDEFINED = 0;
  JOIN_INNER = 1;
  JOIN_LEFT = 2;
  JOIN_FULL = 3;
  JOIN_RIGHT = 4;
  JOIN_SEMI = 5;
  JOIN_ANTI = 6;
  JOIN_UNIQUE_OUTER = 7;
  JOIN_UNIQUE_INNER = 8;
}

enum AggStrategy
{
  AGG_STRATEGY_UNDEFINED = 0;
  AGG_PLAIN = 1;
  AGG_SORTED = 2;
  AGG_HASHED = 3;
  AGG_MIXED = 4;
}

enum AggSplit
{
  AGG_SPLIT_UNDEFINED = 0;
  AGGSPLIT_SIMPLE = 1;
  AGGSPLIT_INITIAL_SERIAL = 2;
  AGGSPLIT_FINAL_DESERIAL = 3;
}

enum SetOpCmd
{
  SET_OP_CMD_UNDEFINED = 0;
  SETOPCMD_INTERSECT = 1;
  SETOPCMD_INTERSECT_ALL = 2;
  SETOPCMD_EXCEPT = 3;
  SETOPCMD_EXCEPT_ALL = 4;
}

enum SetOpStrategy
{
  SET_OP_STRATEGY_UNDEFINED = 0;
  SETOP_SORTED = 1;
  SETOP_HASHED = 2;
}

enum OnConflictAction
{
  ON_CONFLICT_ACTION_UNDEFINED = 0;
  ONCONFLICT_NONE = 1;
  ONCONFLICT_NOTHING = 2;
  ONCONFLICT_UPDATE = 3;
}

enum LimitOption
{
  LIMIT_OPTION_UNDEFINED = 0;
  LIMIT_OPTION_DEFAULT = 1;
  LIMIT_OPTION_COUNT = 2;
  LIMIT_OPTION_WITH_TIES = 3;
}

enum LockClauseStrength
{
  LOCK_CLAUSE_STRENGTH_UNDEFINED = 0;
  LCS_NONE = 1;
  LCS_FORKEYSHARE = 2;
  LCS_FORSHARE = 3;
  LCS_FORNOKEYUPDATE = 4;
  LCS_FORUPDATE = 5;
}

enum LockWaitPolicy
{
  LOCK_WAIT_POLICY_UNDEFINED = 0;
  LockWaitBlock = 1;
  LockWaitSkip = 2;
  LockWaitError = 3;
}

enum LockTupleMode
{
  LOCK_TUPLE_MODE_UNDEFINED = 0;
  LockTupleKeyShare = 1;
  LockTupleShare = 2;
  LockTupleNoKeyExclusive = 3;
  LockTupleExclusive = 4;
}

struct ScanToken {
  int32 start;
  int32 end;
  Token token;
  KeywordKind keyword_kind;
}

enum KeywordKind {
  NO_KEYWORD = 0;
  UNRESERVED_KEYWORD = 1;
  COL_NAME_KEYWORD = 2;
  TYPE_FUNC_NAME_KEYWORD = 3;
  RESERVED_KEYWORD = 4;
}

enum Token {
  NUL = 0;
  // Single-character tokens that are returned 1:1 (identical with "self" list in scan.l)
  // Either supporting syntax, or single-character operators (some can be both)
  // Also see https://www.postgresql.org/docs/12/sql-syntax-lexical.html#SQL-SYNTAX-SPECIAL-CHARS
  ASCII_37 = 37; // "%"
  ASCII_40 = 40; // "("
  ASCII_41 = 41; // ")"
  ASCII_42 = 42; // "*"
  ASCII_43 = 43; // "+"
  ASCII_44 = 44; // ","
  ASCII_45 = 45; // "-"
  ASCII_46 = 46; // "."
  ASCII_47 = 47; // "/"
  ASCII_58 = 58; // ":"
  ASCII_59 = 59; // ";"
  ASCII_60 = 60; // "<"
  ASCII_61 = 61; // "="
  ASCII_62 = 62; // ">"
  ASCII_63 = 63; // "?"
  ASCII_91 = 91; // "["
  ASCII_92 = 92; // "\"
  ASCII_93 = 93; // "]"
  ASCII_94 = 94; // "^"
  // Named tokens in scan.l
  IDENT = 258;
  UIDENT = 259;
  FCONST = 260;
  SCONST = 261;
  USCONST = 262;
  BCONST = 263;
  XCONST = 264;
  Op = 265;
  ICONST = 266;
  PARAM = 267;
  TYPECAST = 268;
  DOT_DOT = 269;
  COLON_EQUALS = 270;
  EQUALS_GREATER = 271;
  LESS_EQUALS = 272;
  GREATER_EQUALS = 273;
  NOT_EQUALS = 274;
  SQL_COMMENT = 275;
  C_COMMENT = 276;
  ABORT_P = 277;
  ABSOLUTE_P = 278;
  ACCESS = 279;
  ACTION = 280;
  ADD_P = 281;
  ADMIN = 282;
  AFTER = 283;
  AGGREGATE = 284;
  ALL = 285;
  ALSO = 286;
  ALTER = 287;
  ALWAYS = 288;
  ANALYSE = 289;
  ANALYZE = 290;
  AND = 291;
  ANY = 292;
  ARRAY = 293;
  AS = 294;
  ASC = 295;
  ASSERTION = 296;
  ASSIGNMENT = 297;
  ASYMMETRIC = 298;
  AT = 299;
  ATTACH = 300;
  ATTRIBUTE = 301;
  AUTHORIZATION = 302;
  BACKWARD = 303;
  BEFORE = 304;
  BEGIN_P = 305;
  BETWEEN = 306;
  BIGINT = 307;
  BINARY = 308;
  BIT = 309;
  BOOLEAN_P = 310;
  BOTH = 311;
  BY = 312;
  CACHE = 313;
  CALL = 314;
  CALLED = 315;
  CASCADE = 316;
  CASCADED = 317;
  CASE = 318;
  CAST = 319;
  CATALOG_P = 320;
  CHAIN = 321;
  CHAR_P = 322;
  CHARACTER = 323;
  CHARACTERISTICS = 324;
  CHECK = 325;
  CHECKPOINT = 326;
  CLASS = 327;
  CLOSE = 328;
  CLUSTER = 329;
  COALESCE = 330;
  COLLATE = 331;
  COLLATION = 332;
  COLUMN = 333;
  COLUMNS = 334;
  COMMENT = 335;
  COMMENTS = 336;
  COMMIT = 337;
  COMMITTED = 338;
  CONCURRENTLY = 339;
  CONFIGURATION = 340;
  CONFLICT = 341;
  CONNECTION = 342;
  CONSTRAINT = 343;
  CONSTRAINTS = 344;
  CONTENT_P = 345;
  CONTINUE_P = 346;
  CONVERSION_P = 347;
  COPY = 348;
  COST = 349;
  CREATE = 350;
  CROSS = 351;
  CSV = 352;
  CUBE = 353;
  CURRENT_P = 354;
  CURRENT_CATALOG = 355;
  CURRENT_DATE = 356;
  CURRENT_ROLE = 357;
  CURRENT_SCHEMA = 358;
  CURRENT_TIME = 359;
  CURRENT_TIMESTAMP = 360;
  CURRENT_USER = 361;
  CURSOR = 362;
  CYCLE = 363;
  DATA_P = 364;
  DATABASE = 365;
  DAY_P = 366;
  DEALLOCATE = 367;
  DEC = 368;
  DECIMAL_P = 369;
  DECLARE = 370;
  DEFAULT = 371;
  DEFAULTS = 372;
  DEFERRABLE = 373;
  DEFERRED = 374;
  DEFINER = 375;
  DELETE_P = 376;
  DELIMITER = 377;
  DELIMITERS = 378;
  DEPENDS = 379;
  DESC = 380;
  DETACH = 381;
  DICTIONARY = 382;
  DISABLE_P = 383;
  DISCARD = 384;
  DISTINCT = 385;
  DO = 386;
  DOCUMENT_P = 387;
  DOMAIN_P = 388;
  DOUBLE_P = 389;
  DROP = 390;
  EACH = 391;
  ELSE = 392;
  ENABLE_P = 393;
  ENCODING = 394;
  ENCRYPTED = 395;
  END_P = 396;
  ENUM_P = 397;
  ESCAPE = 398;
  EVENT = 399;
  EXCEPT = 400;
  EXCLUDE = 401;
  EXCLUDING = 402;
  EXCLUSIVE = 403;
  EXECUTE = 404;
  EXISTS = 405;
  EXPLAIN = 406;
  EXPRESSION = 407;
  EXTENSION = 408;
  EXTERNAL = 409;
  EXTRACT = 410;
  FALSE_P = 411;
  FAMILY = 412;
  FETCH = 413;
  FILTER = 414;
  FIRST_P = 415;
  FLOAT_P = 416;
  FOLLOWING = 417;
  FOR = 418;
  FORCE = 419;
  FOREIGN = 420;
  FORWARD = 421;
  FREEZE = 422;
  FROM = 423;
  FULL = 424;
  FUNCTION = 425;
  FUNCTIONS = 426;
  GENERATED = 427;
  GLOBAL = 428;
  GRANT = 429;
  GRANTED = 430;
  GREATEST = 431;
  GROUP_P = 432;
  GROUPING = 433;
  GROUPS = 434;
  HANDLER = 435;
  HAVING = 436;
  HEADER_P = 437;
  HOLD = 438;
  HOUR_P = 439;
  IDENTITY_P = 440;
  IF_P = 441;
  ILIKE = 442;
  IMMEDIATE = 443;
  IMMUTABLE = 444;
  IMPLICIT_P = 445;
  IMPORT_P = 446;
  IN_P = 447;
  INCLUDE = 448;
  INCLUDING = 449;
  INCREMENT = 450;
  INDEX = 451;
  INDEXES = 452;
  INHERIT = 453;
  INHERITS = 454;
  INITIALLY = 455;
  INLINE_P = 456;
  INNER_P = 457;
  INOUT = 458;
  INPUT_P = 459;
  INSENSITIVE = 460;
  INSERT = 461;
  INSTEAD = 462;
  INT_P = 463;
  INTEGER = 464;
  INTERSECT = 465;
  INTERVAL = 466;
  INTO = 467;
  INVOKER = 468;
  IS = 469;
  ISNULL = 470;
  ISOLATION = 471;
  JOIN = 472;
  KEY = 473;
  LABEL = 474;
  LANGUAGE = 475;
  LARGE_P = 476;
  LAST_P = 477;
  LATERAL_P = 478;
  LEADING = 479;
  LEAKPROOF = 480;
  LEAST = 481;
  LEFT = 482;
  LEVEL = 483;
  LIKE = 484;
  LIMIT = 485;
  LISTEN = 486;
  LOAD = 487;
  LOCAL = 488;
  LOCALTIME = 489;
  LOCALTIMESTAMP = 490;
  LOCATION = 491;
  LOCK_P = 492;
  LOCKED = 493;
  LOGGED = 494;
  MAPPING = 495;
  MATCH = 496;
  MATERIALIZED = 497;
  MAXVALUE = 498;
  METHOD = 499;
  MINUTE_P = 500;
  MINVALUE = 501;
  MODE = 502;
  MONTH_P = 503;
  MOVE = 504;
  NAME_P = 505;
  NAMES = 506;
  NATIONAL = 507;
  NATURAL = 508;
  NCHAR = 509;
  NEW = 510;
  NEXT = 511;
  NFC = 512;
  NFD = 513;
  NFKC = 514;
  NFKD = 515;
  NO = 516;
  NONE = 517;
  NORMALIZE = 518;
  NORMALIZED = 519;
  NOT = 520;
  NOTHING = 521;
  NOTIFY = 522;
  NOTNULL = 523;
  NOWAIT = 524;
  NULL_P = 525;
  NULLIF = 526;
  NULLS_P = 527;
  NUMERIC = 528;
  OBJECT_P = 529;
  OF = 530;
  OFF = 531;
  OFFSET = 532;
  OIDS = 533;
  OLD = 534;
  ON = 535;
  ONLY = 536;
  OPERATOR = 537;
  OPTION = 538;
  OPTIONS = 539;
  OR = 540;
  ORDER = 541;
  ORDINALITY = 542;
  OTHERS = 543;
  OUT_P = 544;
  OUTER_P = 545;
  OVER = 546;
  OVERLAPS = 547;
  OVERLAY = 548;
  OVERRIDING = 549;
  OWNED = 550;
  OWNER = 551;
  PARALLEL = 552;
  PARSER = 553;
  PARTIAL = 554;
  PARTITION = 555;
  PASSING = 556;
  PASSWORD = 557;
  PLACING = 558;
  PLANS = 559;
  POLICY = 560;
  POSITION = 561;
  PRECEDING = 562;
  PRECISION = 563;
  PRESERVE = 564;
  PREPARE = 565;
  PREPARED = 566;
  PRIMARY = 567;
  PRIOR = 568;
  PRIVILEGES = 569;
  PROCEDURAL = 570;
  PROCEDURE = 571;
  PROCEDURES = 572;
  PROGRAM = 573;
  PUBLICATION = 574;
  QUOTE = 575;
  RANGE = 576;
  READ = 577;
  REAL = 578;
  REASSIGN = 579;
  RECHECK = 580;
  RECURSIVE = 581;
  REF = 582;
  REFERENCES = 583;
  REFERENCING = 584;
  REFRESH = 585;
  REINDEX = 586;
  RELATIVE_P = 587;
  RELEASE = 588;
  RENAME = 589;
  REPEATABLE = 590;
  REPLACE = 591;
  REPLICA = 592;
  RESET = 593;
  RESTART = 594;
  RESTRICT = 595;
  RETURNING = 596;
  RETURNS = 597;
  REVOKE = 598;
  RIGHT = 599;
  ROLE = 600;
  ROLLBACK = 601;
  ROLLUP = 602;
  ROUTINE = 603;
  ROUTINES = 604;
  ROW = 605;
  ROWS = 606;
  RULE = 607;
  SAVEPOINT = 608;
  SCHEMA = 609;
  SCHEMAS = 610;
  SCROLL = 611;
  SEARCH = 612;
  SECOND_P = 613;
  SECURITY = 614;
  SELECT = 615;
  SEQUENCE = 616;
  SEQUENCES = 617;
  SERIALIZABLE = 618;
  SERVER = 619;
  SESSION = 620;
  SESSION_USER = 621;
  SET = 622;
  SETS = 623;
  SETOF = 624;
  SHARE = 625;
  SHOW = 626;
  SIMILAR = 627;
  SIMPLE = 628;
  SKIP = 629;
  SMALLINT = 630;
  SNAPSHOT = 631;
  SOME = 632;
  SQL_P = 633;
  STABLE = 634;
  STANDALONE_P = 635;
  START = 636;
  STATEMENT = 637;
  STATISTICS = 638;
  STDIN = 639;
  STDOUT = 640;
  STORAGE = 641;
  STORED = 642;
  STRICT_P = 643;
  STRIP_P = 644;
  SUBSCRIPTION = 645;
  SUBSTRING = 646;
  SUPPORT = 647;
  SYMMETRIC = 648;
  SYSID = 649;
  SYSTEM_P = 650;
  TABLE = 651;
  TABLES = 652;
  TABLESAMPLE = 653;
  TABLESPACE = 654;
  TEMP = 655;
  TEMPLATE = 656;
  TEMPORARY = 657;
  TEXT_P = 658;
  THEN = 659;
  TIES = 660;
  TIME = 661;
  TIMESTAMP = 662;
  TO = 663;
  TRAILING = 664;
  TRANSACTION = 665;
  TRANSFORM = 666;
  TREAT = 667;
  TRIGGER = 668;
  TRIM = 669;
  TRUE_P = 670;
  TRUNCATE = 671;
  TRUSTED = 672;
  TYPE_P = 673;
  TYPES_P = 674;
  UESCAPE = 675;
  UNBOUNDED = 676;
  UNCOMMITTED = 677;
  UNENCRYPTED = 678;
  UNION = 679;
  UNIQUE = 680;
  UNKNOWN = 681;
  UNLISTEN = 682;
  UNLOGGED = 683;
  UNTIL = 684;
  UPDATE = 685;
  USER = 686;
  USING = 687;
  VACUUM = 688;
  VALID = 689;
  VALIDATE = 690;
  VALIDATOR = 691;
  VALUE_P = 692;
  VALUES = 693;
  VARCHAR = 694;
  VARIADIC = 695;
  VARYING = 696;
  VERBOSE = 697;
  VERSION_P = 698;
  VIEW = 699;
  VIEWS = 700;
  VOLATILE = 701;
  WHEN = 702;
  WHERE = 703;
  WHITESPACE_P = 704;
  WINDOW = 705;
  WITH = 706;
  WITHIN = 707;
  WITHOUT = 708;
  WORK = 709;
  WRAPPER = 710;
  WRITE = 711;
  XML_P = 712;
  XMLATTRIBUTES = 713;
  XMLCONCAT = 714;
  XMLELEMENT = 715;
  XMLEXISTS = 716;
  XMLFOREST = 717;
  XMLNAMESPACES = 718;
  XMLPARSE = 719;
  XMLPI = 720;
  XMLROOT = 721;
  XMLSERIALIZE = 722;
  XMLTABLE = 723;
  YEAR_P = 724;
  YES_P = 725;
  ZONE = 726;
  NOT_LA = 727;
  NULLS_LA = 728;
  WITH_LA = 729;
  POSTFIXOP = 730;
  UMINUS = 731;
}
